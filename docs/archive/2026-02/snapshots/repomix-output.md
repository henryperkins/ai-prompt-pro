This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.

# File Summary

## Purpose
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  a. A header with the file path (## File: path/to/file)
  b. The full contents of the file in a code block

## Usage Guidelines
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

## Notes
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: src/**, supabase/functions/**, agent_service/**, index.html, vite.config.ts, vitest.config.ts, tsconfig*.json, tailwind.config.ts, postcss.config.js, eslint.config.js, components.json, package.json
- Files matching these patterns are excluded: node_modules/**, dist/**, .venv/**, __pycache__/**, *.pyc, bun.lockb, package-lock.json, src/components/base/primitives/**, *.log, *.local, .env*, !.env.example, clip*.md, product-spec.md, repomix-output.md, src/test/**, **/*.test.ts, **/*.test.tsx, **/*.spec.ts, **/*.spec.tsx
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Long base64 data strings (e.g., data:image/png;base64,...) have been truncated to reduce token count
- Files are sorted by Git change count (files with more changes are at the bottom)

# Directory Structure
```
agent_service/
  codex_service.mjs
  codex-config.mjs
  enhancement-pipeline.mjs
  README.md
  thread-options.mjs
src/
  components/
    application/
      activity-feeds/
        activity-feeds.tsx
      code-snippet/
        code-snippet.tsx
      lists/
        feed-list.tsx
      progress-steps/
        progress-steps.tsx
      tables/
        team-members-table.tsx
    base/
      avatar/
        base-components/
          avatar-add-button.tsx
          avatar-company-icon.tsx
          avatar-online-indicator.tsx
          index.tsx
          verified-tick.tsx
        avatar-label-group.tsx
        avatar-profile-photo.tsx
        avatar.tsx
        utils.ts
      badges/
        badge-groups.tsx
        badge-types.ts
        badges.stories.tsx
        badges.tsx
      button-group/
        button-group.tsx
      buttons/
        button-utility.tsx
        button.stories.tsx
        button.tsx
      checkbox/
        checkbox.tsx
      form/
        form.tsx
      input/
        hint-text.tsx
        input-group.tsx
        input-payment.tsx
        input.stories.tsx
        input.tsx
        label.tsx
      progress-indicators/
        progress-circles.tsx
        progress-indicators.tsx
      select/
        combobox.tsx
        multi-select.tsx
        popover.tsx
        select-item.tsx
        select-native.tsx
        select.tsx
      tags/
        base-components/
          tag-close-x.tsx
      textarea/
        textarea.tsx
      tooltip/
        tooltip.tsx
      dialog.tsx
      drawer.tsx
      label.tsx
      tabs.tsx
      textarea.tsx
    community/
      CommunityComments.tsx
      CommunityFeed.tsx
      CommunityPostCard.tsx
      CommunityPostDetail.tsx
      CommunityReportDialog.tsx
      ProfileHero.tsx
      PromptPreviewPanel.tsx
    fantasy/
      PFBuilderLayout.tsx
      PFButton.tsx
      PFHeroNavbar.tsx
      PFPanel.tsx
      PFQualityGauge.tsx
      PFTemplateCard.tsx
    foundations/
      logo/
        untitledui-logo-minimal.tsx
        untitledui-logo.tsx
      payment-icons/
        amex-icon.tsx
        apple-pay-icon.tsx
        discover-icon.tsx
        index.tsx
        mastercard-icon.tsx
        paypal-icon.tsx
        stripe-icon.tsx
        union-pay-icon.tsx
        visa-icon.tsx
      dot-icon.tsx
    icons/
      oauth-icons.tsx
    marketing/
      contact/
        contact-simple-form.tsx
      footers/
        footer-large-04.tsx
      header-section/
        header-centered-brand.tsx
    AuthDialog.tsx
    BottomNav.tsx
    BuilderAdjustDetails.tsx
    BuilderHeroInput.tsx
    BuilderSourcesAdvanced.tsx
    BuilderTabs.tsx
    ContextIntegrations.tsx
    ContextInterview.tsx
    ContextPanel.tsx
    ContextQualityMeter.tsx
    ContextSourceChips.tsx
    Header.tsx
    NavLink.tsx
    NotificationPanel.tsx
    OutputPanel.tsx
    PageShell.tsx
    ProjectNotes.tsx
    PromptInput.tsx
    PromptLibrary.tsx
    QualityScore.tsx
    route-fallbacks.tsx
    StructuredContextForm.tsx
    ToneControls.tsx
    VersionHistory.tsx
  hooks/
    use-breakpoint.ts
    use-clipboard.ts
    use-mobile.tsx
    use-resize-observer.ts
    use-toast.ts
    useAuth.tsx
    useCommunityMobileTelemetry.ts
    useContextConfig.ts
    useDraftPersistence.ts
    useIntersectionAutoLoad.ts
    useNewPostsIndicator.ts
    useNotifications.ts
    usePromptBuilder.ts
    usePromptBuilderContext.ts
    useTheme.tsx
  integrations/
    neon/
      client.ts
      types.ts
  lib/
    utils/
      countries.tsx
      cx.ts
      icon-slot.tsx
      is-react-component.ts
    ai-client.ts
    backend-config.ts
    brand-copy.ts
    breakpoints.ts
    builder-inference.ts
    builder-tabs.ts
    clipboard.ts
    codex-export.ts
    community-errors.ts
    community-moderation.ts
    community-rarity.ts
    community-share.ts
    community-telemetry.ts
    community-utils.ts
    community.ts
    contact-support.ts
    content-moderation.ts
    context-types.ts
    feature-flags.ts
    gravatar.ts
    history-restore.ts
    launch-experiments.ts
    launch-utm.ts
    library-pages.ts
    navigation.ts
    notifications.ts
    output-panel-validation.ts
    persistence.ts
    profile.ts
    prompt-builder-cache.ts
    prompt-builder-remix.ts
    prompt-builder.ts
    prompt-categories.ts
    prompt-config-adapters.ts
    saved-prompt-shared.ts
    section-health.ts
    telemetry.ts
    template-store.ts
    templates.ts
    text-diff.ts
    ui-density.ts
    ui-status.ts
    url-utils.ts
    user-preferences.ts
    utils.ts
  pages/
    Community.tsx
    CommunityPost.tsx
    ComponentsShowcase.tsx
    Contact.tsx
    Feed.tsx
    History.tsx
    Index.tsx
    Library.tsx
    LibraryBulkEdit.tsx
    NotFound.tsx
    Presets.tsx
    Privacy.tsx
    Profile.tsx
    SupportInbox.tsx
    Terms.tsx
  styles/
    globals.css
    promptforge-fantasy.css
    theme.css
    typography.css
    untitled-compat.css
  utils/
    cx.ts
    is-react-component.ts
  App.tsx
  index.css
  main.tsx
  vite-env.d.ts
components.json
eslint.config.js
index.html
package.json
postcss.config.js
tailwind.config.ts
tsconfig.app.json
tsconfig.json
tsconfig.node.json
vite.config.ts
vitest.config.ts
```

# Files

## File: src/components/NavLink.tsx
````typescript
import { NavLink as RouterNavLink, NavLinkProps } from "react-router-dom";
import { forwardRef } from "react";
import { cn } from "@/lib/utils";

interface NavLinkCompatProps extends Omit<NavLinkProps, "className"> {
  className?: string;
  activeClassName?: string;
  pendingClassName?: string;
}

const NavLink = forwardRef<HTMLAnchorElement, NavLinkCompatProps>(
  ({ className, activeClassName, pendingClassName, to, ...props }, ref) => {
    return (
      <RouterNavLink
        ref={ref}
        to={to}
        className={({ isActive, isPending }) =>
          cn(className, isActive && activeClassName, isPending && pendingClassName)
        }
        {...props}
      />
    );
  },
);

NavLink.displayName = "NavLink";

export { NavLink };
````

## File: src/hooks/useContextConfig.ts
````typescript
import { useCallback } from "react";
import type { Dispatch, SetStateAction } from "react";
import type { PromptConfig } from "@/lib/prompt-builder";
import type {
  ContextSource,
  StructuredContext,
  InterviewAnswer,
  DatabaseConnection,
  RagParameters,
} from "@/lib/context-types";

/**
 * Extracted context-config updaters from usePromptBuilder (P2-2).
 * Each callback merges a partial update into config.contextConfig and marks the draft dirty.
 */
export function useContextConfig(
  setConfig: Dispatch<SetStateAction<PromptConfig>>,
  markDraftDirty: () => void,
) {
  const updateContextSources = useCallback(
    (sources: ContextSource[]) => {
      setConfig((prev) => ({
        ...prev,
        contextConfig: { ...prev.contextConfig, sources },
      }));
      markDraftDirty();
    },
    [setConfig, markDraftDirty],
  );

  const updateDatabaseConnections = useCallback(
    (databaseConnections: DatabaseConnection[]) => {
      setConfig((prev) => ({
        ...prev,
        contextConfig: { ...prev.contextConfig, databaseConnections },
      }));
      markDraftDirty();
    },
    [setConfig, markDraftDirty],
  );

  const updateRagParameters = useCallback(
    (ragUpdates: Partial<RagParameters>) => {
      setConfig((prev) => ({
        ...prev,
        contextConfig: {
          ...prev.contextConfig,
          rag: { ...prev.contextConfig.rag, ...ragUpdates },
        },
      }));
      markDraftDirty();
    },
    [setConfig, markDraftDirty],
  );

  const updateContextStructured = useCallback(
    (updates: Partial<StructuredContext>) => {
      setConfig((prev) => ({
        ...prev,
        contextConfig: {
          ...prev.contextConfig,
          structured: { ...prev.contextConfig.structured, ...updates },
        },
      }));
      markDraftDirty();
    },
    [setConfig, markDraftDirty],
  );

  const updateContextInterview = useCallback(
    (answers: InterviewAnswer[]) => {
      setConfig((prev) => ({
        ...prev,
        contextConfig: { ...prev.contextConfig, interviewAnswers: answers },
      }));
      markDraftDirty();
    },
    [setConfig, markDraftDirty],
  );

  const updateProjectNotes = useCallback(
    (notes: string) => {
      setConfig((prev) => ({
        ...prev,
        contextConfig: { ...prev.contextConfig, projectNotes: notes },
      }));
      markDraftDirty();
    },
    [setConfig, markDraftDirty],
  );

  const toggleDelimiters = useCallback(
    (value: boolean) => {
      setConfig((prev) => ({
        ...prev,
        contextConfig: { ...prev.contextConfig, useDelimiters: value },
      }));
      markDraftDirty();
    },
    [setConfig, markDraftDirty],
  );

  return {
    updateContextSources,
    updateDatabaseConnections,
    updateRagParameters,
    updateContextStructured,
    updateContextInterview,
    updateProjectNotes,
    toggleDelimiters,
  };
}
````

## File: src/hooks/useDraftPersistence.ts
````typescript
import { useState, useCallback, useEffect, useRef } from "react";
import type { PromptConfig } from "@/lib/prompt-builder";
import * as persistence from "@/lib/persistence";

const DRAFT_AUTOSAVE_DELAY_MS = 700;

export interface DraftPersistenceOptions {
  userId: string | null;
  config: PromptConfig;
  isCloudHydrated: boolean;
  toast: (opts: { title: string; description: string; variant?: string }) => void;
}

/**
 * Extracted draft-persistence logic from usePromptBuilder (P2-2).
 * Manages dirty state, debounced autosave, and error deduplication.
 */
export function useDraftPersistence({
  userId,
  config,
  isCloudHydrated,
  toast,
}: DraftPersistenceOptions) {
  const [isDraftDirty, setIsDraftDirty] = useState(false);
  const draftSaveError = useRef<string | null>(null);
  const autosaveToken = useRef(0);
  const editsSinceAuthChange = useRef(false);

  const markDraftDirty = useCallback(() => {
    editsSinceAuthChange.current = true;
    setIsDraftDirty(true);
  }, []);

  const resetDraftState = useCallback(() => {
    draftSaveError.current = null;
    editsSinceAuthChange.current = false;
    setIsDraftDirty(false);
  }, []);

  const clearDirtyIfClean = useCallback(() => {
    if (!editsSinceAuthChange.current) {
      setIsDraftDirty(false);
    }
  }, []);

  const saveDraftSafely = useCallback(
    async (nextConfig: PromptConfig, saveToken: number) => {
      try {
        await persistence.saveDraft(userId, nextConfig);
        draftSaveError.current = null;
        if (saveToken === autosaveToken.current) {
          setIsDraftDirty(false);
        }
      } catch (error) {
        const message = persistence.getPersistenceErrorMessage(error, "Failed to save draft.");
        if (draftSaveError.current !== message) {
          draftSaveError.current = message;
          toast({
            title: "Draft auto-save failed",
            description: message,
            variant: "destructive",
          });
        }
      }
    },
    [userId, toast],
  );

  // Debounced autosave effect
  useEffect(() => {
    if (!isDraftDirty) return;
    if (userId && !isCloudHydrated) return;

    const saveToken = ++autosaveToken.current;
    const timeout = setTimeout(() => {
      void saveDraftSafely(config, saveToken);
    }, DRAFT_AUTOSAVE_DELAY_MS);

    return () => clearTimeout(timeout);
  }, [config, isDraftDirty, userId, isCloudHydrated, saveDraftSafely]);

  return {
    isDraftDirty,
    markDraftDirty,
    resetDraftState,
    clearDirtyIfClean,
    editsSinceAuthChange,
  };
}
````

## File: src/hooks/usePromptBuilderContext.ts
````typescript
import { useCallback } from "react";
import type { Dispatch, SetStateAction } from "react";
import type {
  ContextSource,
  StructuredContext,
  InterviewAnswer,
  DatabaseConnection,
  RagParameters,
} from "@/lib/context-types";
import type { PromptConfig } from "@/lib/prompt-builder";

interface UsePromptBuilderContextInput {
  setConfig: Dispatch<SetStateAction<PromptConfig>>;
  markDraftDirty: () => void;
}

export function usePromptBuilderContext({ setConfig, markDraftDirty }: UsePromptBuilderContextInput) {
  const updateContextSources = useCallback(
    (sources: ContextSource[]) => {
      setConfig((prev) => ({
        ...prev,
        contextConfig: { ...prev.contextConfig, sources },
      }));
      markDraftDirty();
    },
    [markDraftDirty, setConfig],
  );

  const updateDatabaseConnections = useCallback(
    (databaseConnections: DatabaseConnection[]) => {
      setConfig((prev) => ({
        ...prev,
        contextConfig: { ...prev.contextConfig, databaseConnections },
      }));
      markDraftDirty();
    },
    [markDraftDirty, setConfig],
  );

  const updateRagParameters = useCallback(
    (ragUpdates: Partial<RagParameters>) => {
      setConfig((prev) => ({
        ...prev,
        contextConfig: {
          ...prev.contextConfig,
          rag: { ...prev.contextConfig.rag, ...ragUpdates },
        },
      }));
      markDraftDirty();
    },
    [markDraftDirty, setConfig],
  );

  const updateContextStructured = useCallback(
    (updates: Partial<StructuredContext>) => {
      setConfig((prev) => ({
        ...prev,
        contextConfig: {
          ...prev.contextConfig,
          structured: { ...prev.contextConfig.structured, ...updates },
        },
      }));
      markDraftDirty();
    },
    [markDraftDirty, setConfig],
  );

  const updateContextInterview = useCallback(
    (answers: InterviewAnswer[]) => {
      setConfig((prev) => ({
        ...prev,
        contextConfig: { ...prev.contextConfig, interviewAnswers: answers },
      }));
      markDraftDirty();
    },
    [markDraftDirty, setConfig],
  );

  const updateProjectNotes = useCallback(
    (notes: string) => {
      setConfig((prev) => ({
        ...prev,
        contextConfig: { ...prev.contextConfig, projectNotes: notes },
      }));
      markDraftDirty();
    },
    [markDraftDirty, setConfig],
  );

  const toggleDelimiters = useCallback(
    (value: boolean) => {
      setConfig((prev) => ({
        ...prev,
        contextConfig: { ...prev.contextConfig, useDelimiters: value },
      }));
      markDraftDirty();
    },
    [markDraftDirty, setConfig],
  );

  return {
    updateContextSources,
    updateDatabaseConnections,
    updateRagParameters,
    updateContextStructured,
    updateContextInterview,
    updateProjectNotes,
    toggleDelimiters,
  };
}
````

## File: src/lib/builder-inference.ts
````typescript
import { defaultConfig, type PromptConfig } from "@/lib/prompt-builder";
import {
  chooseConstraints,
  chooseFormat,
  chooseLengthPreference,
  chooseRole,
  chooseTone,
  INFERENCE_FIELD_CONFIDENCE,
  INFERENCE_FIELD_LABELS,
  type InferenceField,
} from "../../shared/builder-inference-heuristics";

export type BuilderFieldOwnership = "ai" | "user" | "empty";
export type BuilderInferenceField = InferenceField;

export type BuilderFieldOwnershipMap = Record<BuilderInferenceField, BuilderFieldOwnership>;

export interface BuilderSuggestionChip {
  id: string;
  label: string;
  description: string;
  action:
    | {
        type: "set_fields";
        updates: Partial<PromptConfig>;
        fields: BuilderInferenceField[];
      }
    | {
        type: "append_prompt";
        text: string;
      };
}

export interface BuilderInferenceResult {
  inferredUpdates: Partial<PromptConfig>;
  inferredFields: BuilderInferenceField[];
  suggestionChips: BuilderSuggestionChip[];
  confidence?: Partial<Record<BuilderInferenceField, number>>;
}

function hasText(value: string | undefined): boolean {
  return typeof value === "string" && value.trim().length > 0;
}

function hasRole(config: PromptConfig): boolean {
  return hasText(config.customRole) || hasText(config.role);
}

function hasFormat(config: PromptConfig): boolean {
  return config.format.length > 0 || hasText(config.customFormat);
}

function hasConstraints(config: PromptConfig): boolean {
  return config.constraints.length > 0 || hasText(config.customConstraint);
}

export function createFieldOwnershipFromConfig(config: PromptConfig): BuilderFieldOwnershipMap {
  return {
    role: hasRole(config) ? "user" : "empty",
    tone: config.tone !== defaultConfig.tone ? "user" : "empty",
    lengthPreference: config.lengthPreference !== defaultConfig.lengthPreference ? "user" : "empty",
    format: hasFormat(config) ? "user" : "empty",
    constraints: hasConstraints(config) ? "user" : "empty",
  };
}

export function listInferenceFieldsFromUpdates(updates: Partial<PromptConfig>): BuilderInferenceField[] {
  const fields = new Set<BuilderInferenceField>();

  if ("role" in updates || "customRole" in updates) fields.add("role");
  if ("tone" in updates) fields.add("tone");
  if ("lengthPreference" in updates) fields.add("lengthPreference");
  if ("format" in updates || "customFormat" in updates) fields.add("format");
  if ("constraints" in updates || "customConstraint" in updates) fields.add("constraints");

  return Array.from(fields);
}

export function markOwnershipFields(
  current: BuilderFieldOwnershipMap,
  fields: BuilderInferenceField[],
  value: BuilderFieldOwnership,
): BuilderFieldOwnershipMap {
  if (fields.length === 0) return current;
  const next = { ...current };
  for (const field of fields) {
    next[field] = value;
  }
  return next;
}

function isFieldEmpty(config: PromptConfig, field: BuilderInferenceField): boolean {
  if (field === "role") return !hasRole(config);
  if (field === "tone") return config.tone === defaultConfig.tone;
  if (field === "lengthPreference") return config.lengthPreference === defaultConfig.lengthPreference;
  if (field === "format") return !hasFormat(config);
  return !hasConstraints(config);
}

export function applyInferenceUpdates(
  config: PromptConfig,
  ownership: BuilderFieldOwnershipMap,
  inference: BuilderInferenceResult,
): {
  updates: Partial<PromptConfig>;
  appliedFields: BuilderInferenceField[];
} {
  const updates: Partial<PromptConfig> = {};
  const appliedFields: BuilderInferenceField[] = [];
  const candidateFields =
    inference.inferredFields.length > 0
      ? inference.inferredFields
      : listInferenceFieldsFromUpdates(inference.inferredUpdates);

  for (const field of candidateFields) {
    if (ownership[field] === "user") continue;
    if (!isFieldEmpty(config, field) && ownership[field] !== "ai") continue;

    if (field === "role" && hasText(inference.inferredUpdates.role)) {
      updates.role = inference.inferredUpdates.role;
      updates.customRole = "";
      appliedFields.push(field);
      continue;
    }
    if (field === "tone" && hasText(inference.inferredUpdates.tone)) {
      updates.tone = inference.inferredUpdates.tone;
      appliedFields.push(field);
      continue;
    }
    if (field === "lengthPreference" && hasText(inference.inferredUpdates.lengthPreference)) {
      updates.lengthPreference = inference.inferredUpdates.lengthPreference;
      appliedFields.push(field);
      continue;
    }
    if (field === "format" && Array.isArray(inference.inferredUpdates.format)) {
      updates.format = inference.inferredUpdates.format;
      updates.customFormat = "";
      appliedFields.push(field);
      continue;
    }
    if (field === "constraints" && Array.isArray(inference.inferredUpdates.constraints)) {
      updates.constraints = inference.inferredUpdates.constraints;
      updates.customConstraint = "";
      appliedFields.push(field);
    }
  }

  return { updates, appliedFields };
}

export function clearAiOwnedFields(
  ownership: BuilderFieldOwnershipMap,
): {
  updates: Partial<PromptConfig>;
  clearedFields: BuilderInferenceField[];
  nextOwnership: BuilderFieldOwnershipMap;
} {
  const nextOwnership = { ...ownership };
  const updates: Partial<PromptConfig> = {};
  const clearedFields: BuilderInferenceField[] = [];

  if (ownership.role === "ai") {
    updates.role = "";
    updates.customRole = "";
    nextOwnership.role = "empty";
    clearedFields.push("role");
  }
  if (ownership.tone === "ai") {
    updates.tone = defaultConfig.tone;
    nextOwnership.tone = "empty";
    clearedFields.push("tone");
  }
  if (ownership.lengthPreference === "ai") {
    updates.lengthPreference = defaultConfig.lengthPreference;
    nextOwnership.lengthPreference = "empty";
    clearedFields.push("lengthPreference");
  }
  if (ownership.format === "ai") {
    updates.format = [];
    updates.customFormat = "";
    nextOwnership.format = "empty";
    clearedFields.push("format");
  }
  if (ownership.constraints === "ai") {
    updates.constraints = [];
    updates.customConstraint = "";
    nextOwnership.constraints = "empty";
    clearedFields.push("constraints");
  }

  return { updates, clearedFields, nextOwnership };
}

function toChipLabel(field: BuilderInferenceField): string {
  return INFERENCE_FIELD_LABELS[field];
}

function toChipDescription(field: BuilderInferenceField, updates: Partial<PromptConfig>): string {
  if (field === "role") return `Use role: ${updates.role}`;
  if (field === "tone") return `Use tone: ${updates.tone}`;
  if (field === "lengthPreference") return `Use length: ${updates.lengthPreference}`;
  if (field === "format") return `Use format: ${updates.format?.join(", ")}`;
  return `Use constraints: ${updates.constraints?.join(", ")}`;
}

function buildSetFieldChip(
  field: BuilderInferenceField,
  updates: Partial<PromptConfig>,
): BuilderSuggestionChip {
  return {
    id: `set-${field}`,
    label: toChipLabel(field),
    description: toChipDescription(field, updates),
    action: {
      type: "set_fields",
      updates,
      fields: [field],
    },
  };
}

function applySuggestionRelevance(
  prompt: string,
  config: PromptConfig,
  chips: BuilderSuggestionChip[],
): BuilderSuggestionChip[] {
  const normalizedPrompt = prompt.trim().toLowerCase();
  if (!normalizedPrompt) return [];

  const hasAnyDetails = hasRole(config) || hasFormat(config) || hasConstraints(config);
  if (chips.length > 0) return chips.slice(0, 4);

  if (!hasAnyDetails && normalizedPrompt.length > 20) {
    return [
      {
        id: "append-audience",
        label: "Add audience details",
        description: "Append audience + outcome hints to your prompt.",
        action: {
          type: "append_prompt",
          text: "\nAudience: [who this is for]\nDesired outcome: [what success looks like]",
        },
      },
    ];
  }

  return [];
}

export function inferBuilderFieldsLocally(prompt: string, config: PromptConfig): BuilderInferenceResult {
  const normalizedPrompt = prompt.trim().toLowerCase();
  if (!normalizedPrompt) {
    return {
      inferredUpdates: {},
      inferredFields: [],
      suggestionChips: [],
    };
  }

  const inferredUpdates: Partial<PromptConfig> = {};
  const inferredFields: BuilderInferenceField[] = [];
  const chips: BuilderSuggestionChip[] = [];
  const confidence: Partial<Record<BuilderInferenceField, number>> = {};

  const inferredRole = chooseRole(normalizedPrompt);
  if (inferredRole) {
    inferredUpdates.role = inferredRole;
    inferredFields.push("role");
    chips.push(
      buildSetFieldChip("role", {
        role: inferredRole,
        customRole: "",
      }),
    );
    confidence.role = INFERENCE_FIELD_CONFIDENCE.role;
  }

  const inferredTone = chooseTone(normalizedPrompt);
  if (inferredTone) {
    inferredUpdates.tone = inferredTone;
    inferredFields.push("tone");
    chips.push(buildSetFieldChip("tone", { tone: inferredTone }));
    confidence.tone = INFERENCE_FIELD_CONFIDENCE.tone;
  }

  const inferredLength = chooseLengthPreference(normalizedPrompt);
  if (inferredLength) {
    inferredUpdates.lengthPreference = inferredLength;
    inferredFields.push("lengthPreference");
    chips.push(buildSetFieldChip("lengthPreference", { lengthPreference: inferredLength }));
    confidence.lengthPreference = INFERENCE_FIELD_CONFIDENCE.lengthPreference;
  }

  const inferredFormat = chooseFormat(normalizedPrompt);
  if (inferredFormat.length > 0) {
    inferredUpdates.format = inferredFormat;
    inferredUpdates.customFormat = "";
    inferredFields.push("format");
    chips.push(buildSetFieldChip("format", { format: inferredFormat, customFormat: "" }));
    confidence.format = INFERENCE_FIELD_CONFIDENCE.format;
  }

  const inferredConstraints = chooseConstraints(normalizedPrompt);
  if (inferredConstraints.length > 0) {
    inferredUpdates.constraints = inferredConstraints;
    inferredUpdates.customConstraint = "";
    inferredFields.push("constraints");
    chips.push(
      buildSetFieldChip("constraints", {
        constraints: inferredConstraints,
        customConstraint: "",
      }),
    );
    confidence.constraints = INFERENCE_FIELD_CONFIDENCE.constraints;
  }

  return {
    inferredUpdates,
    inferredFields,
    suggestionChips: applySuggestionRelevance(normalizedPrompt, config, chips),
    confidence,
  };
}
````

## File: src/lib/builder-tabs.ts
````typescript
export function toConstraintInputId(constraint: string): string {
  const slug = constraint
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, "-")
    .replace(/^-+|-+$/g, "");
  return `builder-constraint-${slug || "option"}`;
}
````

## File: src/lib/codex-export.ts
````typescript
/**
 * Codex export helpers.
 *
 * Generates:
 * - AGENTS.md / AGENTS.override.md content (size-capped to Codex's default project_doc_max_bytes)
 * - Bash snippets for:
 *   - `codex "<PROMPT>"` (launch TUI with a pre-filled prompt)
 *   - `codex exec -` (non-interactive; reads prompt from stdin)
 *   - `codex debug app-server send-message-v2 "<PROMPT>"` (debug client)
 */

export const CODEX_DEFAULT_PROJECT_DOC_MAX_BYTES = 32 * 1024;
export const CODEX_DEFAULT_SKILL_NAME = "promptforge-export";
export const CODEX_DEFAULT_SKILL_DESCRIPTION =
  "PromptForge-exported workflow for Codex. Use when you want Codex to execute this exact workflow.";

const encoder = new TextEncoder();
const fatalDecoder = new TextDecoder("utf-8", { fatal: true });

export function utf8ByteLength(text: string): number {
  return encoder.encode(text).length;
}

function safeDecodeUtf8(bytes: Uint8Array): string {
  // Avoid returning text that ends on an incomplete UTF-8 sequence.
  for (let end = bytes.length; end >= 0; end -= 1) {
    try {
      return fatalDecoder.decode(bytes.slice(0, end));
    } catch {
      // Keep trimming until decode succeeds.
    }
  }

  return "";
}

export function truncateToUtf8Bytes(
  text: string,
  maxBytes: number,
  suffix: string = "\n\n...\n",
): string {
  if (maxBytes <= 0) return "";

  const bytes = encoder.encode(text);
  if (bytes.length <= maxBytes) return text;

  const suffixBytes = encoder.encode(suffix);
  if (suffixBytes.length >= maxBytes) {
    return safeDecodeUtf8(bytes.slice(0, maxBytes));
  }

  const targetBytes = maxBytes - suffixBytes.length;
  return safeDecodeUtf8(bytes.slice(0, targetBytes)) + suffix;
}

function normalizeNewlines(text: string): string {
  return (text ?? "").replace(/\r\n/g, "\n");
}

function escapeRegExp(value: string): string {
  return value.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}

function yamlDoubleQuoted(value: string): string {
  return JSON.stringify(value ?? "");
}

function shellSingleQuoted(value: string): string {
  return `'${(value ?? "").replace(/'/g, "'\"'\"'")}'`;
}

function trimHyphens(value: string): string {
  return value.replace(/^-+/, "").replace(/-+$/, "");
}

function clampText(value: string, maxChars: number): string {
  if (value.length <= maxChars) return value;
  if (maxChars <= 3) return value.slice(0, maxChars);
  return `${value.slice(0, maxChars - 3).trimEnd()}...`;
}

function firstNonEmptyLine(text: string): string {
  return text
    .split("\n")
    .map((line) => line.trim())
    .find(Boolean) ?? "";
}

export function sanitizeSkillName(name: string, fallback: string = CODEX_DEFAULT_SKILL_NAME): string {
  const normalized = (name ?? "")
    .toLowerCase()
    .replace(/[^a-z0-9-]+/g, "-")
    .replace(/-+/g, "-");
  const trimmed = trimHyphens(normalized);
  const sliced = trimHyphens(trimmed.slice(0, 64));
  if (sliced) return sliced;

  const fallbackNormalized = (fallback ?? CODEX_DEFAULT_SKILL_NAME)
    .toLowerCase()
    .replace(/[^a-z0-9-]+/g, "-")
    .replace(/-+/g, "-");
  return trimHyphens(fallbackNormalized) || CODEX_DEFAULT_SKILL_NAME;
}

export function generateSkillDescriptionFromPrompt(prompt: string): string {
  const normalized = normalizeNewlines(prompt ?? "");
  const firstLine = firstNonEmptyLine(normalized).replace(/\s+/g, " ").trim();
  if (!firstLine) return CODEX_DEFAULT_SKILL_DESCRIPTION;

  const prefix = "PromptForge-exported workflow. Use when the task matches this prompt: ";
  return clampText(`${prefix}${firstLine}`, 1024);
}

/**
 * Choose a heredoc delimiter that does not appear as a full line in the prompt.
 */
export function chooseHereDocDelimiter(prompt: string, base: string = "PROMPTFORGE_PROMPT"): string {
  const text = normalizeNewlines(prompt ?? "");
  let delimiter = base;
  let suffix = 0;

  while (new RegExp(`^${escapeRegExp(delimiter)}$`, "m").test(text)) {
    suffix += 1;
    delimiter = `${base}_${suffix}`;
  }

  return delimiter;
}

/**
 * Returns a bash command substitution that yields the prompt via heredoc.
 */
export function buildBashHereDocSubstitution(
  prompt: string,
  delimiterBase: string = "PROMPTFORGE_PROMPT",
): string {
  const normalized = normalizeNewlines(prompt ?? "");
  const delimiter = chooseHereDocDelimiter(normalized, delimiterBase);
  return `$(cat <<'${delimiter}'\n${normalized}\n${delimiter}\n)`;
}

export function generateCodexTuiCommandBash(
  prompt: string,
  options?: { codexBin?: string; flags?: string[] | string },
): string {
  const codexBin = options?.codexBin ?? "codex";
  const normalized = normalizeNewlines(prompt ?? "");
  const flags = Array.isArray(options?.flags) ? options.flags.join(" ") : (options?.flags ?? "");
  const flagsPart = flags.trim() ? ` ${flags.trim()}` : "";
  const substitution = buildBashHereDocSubstitution(normalized);
  return `${codexBin}${flagsPart} "${substitution}"`;
}

export function generateCodexExecCommandBash(
  prompt: string,
  options?: { codexBin?: string; flags?: string[] | string },
): string {
  const codexBin = options?.codexBin ?? "codex";
  const normalized = normalizeNewlines(prompt ?? "");
  const flags = Array.isArray(options?.flags) ? options.flags.join(" ") : (options?.flags ?? "");
  const flagsPart = flags.trim() ? ` ${flags.trim()}` : "";
  const delimiter = chooseHereDocDelimiter(normalized, "PROMPTFORGE_PROMPT");

  return `cat <<'${delimiter}' | ${codexBin} exec${flagsPart} -\n${normalized}\n${delimiter}`;
}

export function generateCodexAppServerSendMessageV2CommandBash(
  prompt: string,
  options?: { codexBin?: string },
): string {
  const codexBin = options?.codexBin ?? "codex";
  const normalized = normalizeNewlines(prompt ?? "");
  const substitution = buildBashHereDocSubstitution(normalized);
  return `${codexBin} debug app-server send-message-v2 "${substitution}"`;
}

export function generateSkillMdFromPrompt(
  prompt: string,
  options?: { skillName?: string; description?: string },
): string {
  const normalized = normalizeNewlines(prompt ?? "").trim();
  if (!normalized) return "";

  const name = sanitizeSkillName(options?.skillName ?? CODEX_DEFAULT_SKILL_NAME);
  const description = clampText(
    (options?.description ?? generateSkillDescriptionFromPrompt(normalized)).trim() ||
      CODEX_DEFAULT_SKILL_DESCRIPTION,
    1024,
  );

  return `---\nname: ${name}\ndescription: ${yamlDoubleQuoted(description)}\n---\n\n${normalized}\n`;
}

export function generateCodexSkillScaffoldCommandBash(
  prompt: string,
  options?: { skillName?: string; description?: string; skillRoot?: string },
): string {
  const skillName = sanitizeSkillName(options?.skillName ?? CODEX_DEFAULT_SKILL_NAME);
  const skillRoot = (options?.skillRoot ?? ".agents/skills").replace(/\/+$/, "");
  const skillDir = `${skillRoot}/${skillName}`;
  const skillFilePath = `${skillDir}/SKILL.md`;
  const skillContent = generateSkillMdFromPrompt(prompt, {
    skillName,
    description: options?.description,
  });
  const delimiter = chooseHereDocDelimiter(skillContent, "PROMPTFORGE_SKILL");

  return `mkdir -p ${shellSingleQuoted(skillDir)}\ncat <<'${delimiter}' > ${shellSingleQuoted(skillFilePath)}\n${skillContent}${delimiter}`;
}

export function generateAgentsMdFromPrompt(prompt: string, options?: { maxBytes?: number }): string {
  const maxBytes = options?.maxBytes ?? CODEX_DEFAULT_PROJECT_DOC_MAX_BYTES;
  const normalized = normalizeNewlines(prompt ?? "").trim();
  if (!normalized) return "";

  const body = `${normalized}\n`;
  if (utf8ByteLength(body) <= maxBytes) return body;
  return truncateToUtf8Bytes(body, maxBytes);
}

export function generateAgentsOverrideMdFromPrompt(prompt: string, options?: { maxBytes?: number }): string {
  return generateAgentsMdFromPrompt(prompt, options);
}
````

## File: src/lib/community-telemetry.ts
````typescript
export const COMMUNITY_TELEMETRY_EVENT_NAME = "promptforge:community-telemetry";

export type CommunityTelemetryEvent =
  | "community_mobile_first_meaningful_action"
  | "community_mobile_interaction";

export type CommunityTelemetryValue = string | number | boolean | null;

export interface CommunityTelemetryPayload {
  [key: string]: CommunityTelemetryValue;
}

export interface CommunityTelemetryEnvelope {
  event: CommunityTelemetryEvent;
  payload: CommunityTelemetryPayload;
  timestamp: number;
}

export function trackCommunityEvent(
  event: CommunityTelemetryEvent,
  payload: CommunityTelemetryPayload = {},
): void {
  if (typeof window === "undefined") return;

  const detail: CommunityTelemetryEnvelope = {
    event,
    payload,
    timestamp: Date.now(),
  };

  window.dispatchEvent(
    new CustomEvent<CommunityTelemetryEnvelope>(COMMUNITY_TELEMETRY_EVENT_NAME, {
      detail,
    }),
  );
}
````

## File: src/lib/context-types.ts
````typescript
export type ContextSourceType = "text" | "url" | "file" | "database" | "rag";
export type SourceValidationStatus = "unknown" | "valid" | "stale" | "invalid";

export interface ContextReference {
  kind: "url" | "file" | "database" | "rag";
  refId: string;
  locator: string;
  permissionScope?: string;
}

export interface SourceValidation {
  status: SourceValidationStatus;
  checkedAt?: number;
  message?: string;
}

export interface ContextSource {
  id: string;
  type: ContextSourceType;
  title: string;
  rawContent: string;
  summary: string;
  addedAt: number;
  reference?: ContextReference;
  validation?: SourceValidation;
}

export interface DatabaseConnection {
  id: string;
  label: string;
  provider: "postgres" | "mysql" | "sqlite" | "mongodb" | "other";
  connectionRef: string;
  database: string;
  schema?: string;
  tables: string[];
  readOnly: boolean;
  lastValidatedAt?: number;
}

export interface RagParameters {
  enabled: boolean;
  vectorStoreRef: string;
  namespace: string;
  topK: number;
  minScore: number;
  retrievalStrategy: "semantic" | "hybrid" | "keyword";
  documentRefs: string[];
  chunkWindow: number;
}

export interface StructuredContext {
  audience: string;
  product: string;
  offer: string;
  mustInclude: string;
  excludedTopics: string;
}

export interface InterviewAnswer {
  questionId: string;
  question: string;
  answer: string;
}

export interface ContextConfig {
  sources: ContextSource[];
  databaseConnections: DatabaseConnection[];
  rag: RagParameters;
  structured: StructuredContext;
  interviewAnswers: InterviewAnswer[];
  useDelimiters: boolean;
  projectNotes: string;
}

export const defaultContextConfig: ContextConfig = {
  sources: [],
  databaseConnections: [],
  rag: {
    enabled: false,
    vectorStoreRef: "",
    namespace: "",
    topK: 5,
    minScore: 0.2,
    retrievalStrategy: "hybrid",
    documentRefs: [],
    chunkWindow: 3,
  },
  structured: {
    audience: "",
    product: "",
    offer: "",
    mustInclude: "",
    excludedTopics: "",
  },
  interviewAnswers: [],
  useDelimiters: true,
  projectNotes: "",
};

export const structuredFieldsMeta: {
  key: keyof StructuredContext;
  label: string;
  placeholder: string;
  examples: string[];
}[] = [
  {
    key: "audience",
    label: "Audience",
    placeholder: "Who is this for?",
    examples: [
      "Marketing managers at B2B SaaS companies",
      "First-year university students studying biology",
      "Non-technical startup founders",
    ],
  },
  {
    key: "product",
    label: "Product / Subject",
    placeholder: "What product, topic, or subject is this about?",
    examples: [
      "A project management tool for remote teams",
      "The French Revolution (1789–1799)",
      "React Server Components",
    ],
  },
  {
    key: "offer",
    label: "Goal / Offer",
    placeholder: "What are you offering or trying to achieve?",
    examples: [
      "Free 14-day trial with no credit card required",
      "A comprehensive summary for exam prep",
      "A persuasive pitch deck for Series A investors",
    ],
  },
  {
    key: "mustInclude",
    label: "Must-include facts",
    placeholder: "Key facts, data, or points that must appear",
    examples: [
      "Revenue grew 200% YoY; 10k active users",
      "Must mention GDPR compliance and SOC 2",
      "Include the 3 main causes and 5 consequences",
    ],
  },
  {
    key: "excludedTopics",
    label: "Excluded topics",
    placeholder: "What should the model NOT cover?",
    examples: [
      "Don't mention competitor pricing",
      "Avoid medical advice or diagnoses",
      "Skip implementation details; focus on concepts",
    ],
  },
];

export const interviewQuestions = [
  {
    id: "goal",
    question: "Which of these best describes your goal?",
    options: [
      "Create new content from scratch",
      "Rewrite or improve existing content",
      "Analyze or summarize information",
      "Generate structured data or code",
      "Brainstorm or explore ideas",
    ],
  },
  {
    id: "success",
    question: "What does a successful output look like? (one sentence)",
    options: null, // free text
  },
  {
    id: "inputs",
    question: "What inputs do you have available?",
    options: [
      "Raw notes or bullet points",
      "Existing document(s) to reference",
      "URLs or web sources",
      "Data in spreadsheet/CSV/JSON",
      "Nothing yet — starting from scratch",
    ],
  },
  {
    id: "constraints",
    question: "What should the model NOT do?",
    options: [
      "Don't invent facts or statistics",
      "Don't use overly technical language",
      "Don't exceed a specific word count",
      "Don't include opinions — facts only",
      "No specific constraints",
    ],
  },
  {
    id: "audience_level",
    question: "How much does your audience already know about this topic?",
    options: [
      "Complete beginners",
      "Some familiarity",
      "Intermediate practitioners",
      "Advanced experts",
    ],
  },
];

function splitIntoSentences(content: string): string[] {
  const normalized = content.replace(/\n+/g, " ").trim();
  if (!normalized) return [];
  const sentences: string[] = [];
  let start = 0;

  for (let i = 0; i < normalized.length; i += 1) {
    const char = normalized[i];
    if (char !== "." && char !== "!" && char !== "?") continue;

    const next = normalized[i + 1];
    if (next !== " " && next !== undefined) continue;

    const sentence = normalized.slice(start, i + 1).trim();
    if (sentence) sentences.push(sentence);

    let j = i + 1;
    while (normalized[j] === " ") j += 1;
    start = j;
    i = j - 1;
  }

  const tail = normalized.slice(start).trim();
  if (tail) sentences.push(tail);
  return sentences;
}

export function summarizeSource(content: string): string {
  const sentences = splitIntoSentences(content).filter((s) => s.trim().length > 10);

  if (sentences.length <= 5) {
    return sentences.map((s) => `• ${s.trim()}`).join("\n");
  }

  // Pick the first 3 and last 2 sentences as a heuristic summary.
  const picked = [...sentences.slice(0, 3), ...sentences.slice(-2)];
  return picked.map((s) => `• ${s.trim()}`).join("\n");
}

export function buildContextBlock(ctx: ContextConfig, useDelimiters: boolean): string {
  const sections: string[] = [];

  // Structured fields
  const structuredParts: string[] = [];
  const { structured } = ctx;
  if (structured.audience) structuredParts.push(`Audience: ${structured.audience}`);
  if (structured.product) structuredParts.push(`Subject: ${structured.product}`);
  if (structured.offer) structuredParts.push(`Goal: ${structured.offer}`);
  if (structured.mustInclude) structuredParts.push(`Must include: ${structured.mustInclude}`);
  if (structured.excludedTopics) structuredParts.push(`Excluded: ${structured.excludedTopics}`);

  if (structuredParts.length > 0) {
    if (useDelimiters) {
      sections.push(`<background>\n${structuredParts.join("\n")}\n</background>`);
    } else {
      sections.push(`**Background:**\n${structuredParts.join("\n")}`);
    }
  }

  // Sources
  if (ctx.sources.length > 0) {
    const sourceLines = ctx.sources.map(
      (s) =>
        `[${s.type.toUpperCase()}: ${s.title}]` +
        (s.reference ? ` [ref=${s.reference.refId}]` : "") +
        `\n${s.summary}`
    );
    if (useDelimiters) {
      sections.push(`<sources>\n${sourceLines.join("\n\n")}\n</sources>`);
    } else {
      sections.push(`**Sources:**\n${sourceLines.join("\n\n")}`);
    }
  }

  // Database connections
  if (ctx.databaseConnections.length > 0) {
    const dbLines = ctx.databaseConnections.map((db) => {
      const tableSegment = db.tables.length > 0 ? ` tables=${db.tables.join(",")}` : "";
      const schemaSegment = db.schema ? ` schema=${db.schema}` : "";
      return `[DB: ${db.label}] ref=${db.connectionRef} db=${db.database}${schemaSegment}${tableSegment} readOnly=${db.readOnly}`;
    });
    if (useDelimiters) {
      sections.push(`<database-connections>\n${dbLines.join("\n")}\n</database-connections>`);
    } else {
      sections.push(`**Database Connections:**\n${dbLines.join("\n")}`);
    }
  }

  // RAG parameters
  if (ctx.rag.enabled && ctx.rag.vectorStoreRef.trim()) {
    const ragLines = [
      `vectorStoreRef: ${ctx.rag.vectorStoreRef}`,
      `namespace: ${ctx.rag.namespace || "default"}`,
      `retrievalStrategy: ${ctx.rag.retrievalStrategy}`,
      `topK: ${ctx.rag.topK}`,
      `minScore: ${ctx.rag.minScore}`,
      `chunkWindow: ${ctx.rag.chunkWindow}`,
      ctx.rag.documentRefs.length > 0 ? `documentRefs: ${ctx.rag.documentRefs.join(", ")}` : "",
    ].filter(Boolean);

    if (useDelimiters) {
      sections.push(`<rag-parameters>\n${ragLines.join("\n")}\n</rag-parameters>`);
    } else {
      sections.push(`**RAG Parameters:**\n${ragLines.join("\n")}`);
    }
  }

  // Project notes
  if (ctx.projectNotes.trim()) {
    if (useDelimiters) {
      sections.push(`<project-notes>\n${ctx.projectNotes.trim()}\n</project-notes>`);
    } else {
      sections.push(`**Project Notes:**\n${ctx.projectNotes.trim()}`);
    }
  }

  // Interview answers
  const answeredQ = ctx.interviewAnswers.filter((a) => a.answer.trim());
  if (answeredQ.length > 0) {
    const qaLines = answeredQ.map((a) => `Q: ${a.question}\nA: ${a.answer}`);
    if (useDelimiters) {
      sections.push(`<context-interview>\n${qaLines.join("\n\n")}\n</context-interview>`);
    } else {
      sections.push(`**Context Interview:**\n${qaLines.join("\n\n")}`);
    }
  }

  return sections.join("\n\n");
}

export function scoreContext(ctx: ContextConfig): {
  score: number;
  checks: { label: string; met: boolean; tip: string }[];
} {
  const checks: { label: string; met: boolean; tip: string }[] = [];

  const hasObjective =
    ctx.structured.offer.trim().length > 0 ||
    ctx.interviewAnswers.some((a) => a.questionId === "goal" && a.answer.trim());
  checks.push({
    label: "Clear objective",
    met: hasObjective,
    tip: "Fill in the Goal/Offer field or complete the context interview.",
  });

  const hasBackground =
    ctx.structured.audience.trim().length > 0 ||
    ctx.structured.product.trim().length > 0 ||
    ctx.sources.length > 0;
  checks.push({
    label: "Enough background",
    met: hasBackground,
    tip: "Add audience, subject info, or attach source material.",
  });

  const hasConstraints =
    ctx.structured.excludedTopics.trim().length > 0 ||
    ctx.interviewAnswers.some((a) => a.questionId === "constraints" && a.answer.trim());
  checks.push({
    label: "Defined constraints",
    met: hasConstraints,
    tip: "Specify excluded topics or constraints so the model knows boundaries.",
  });

  const hasExample =
    ctx.structured.mustInclude.trim().length > 0 || ctx.sources.length > 0;
  checks.push({
    label: "Supporting evidence",
    met: hasExample,
    tip: "Add must-include facts or attach a source for grounded output.",
  });

  const metCount = checks.filter((c) => c.met).length;
  const score = Math.round((metCount / checks.length) * 100);

  return { score, checks };
}
````

## File: src/lib/gravatar.ts
````typescript
/**
 * Gravatar avatar URL helper.
 * Uses SHA-256 hash of the normalized email per Gravatar API v3.
 * See: https://docs.gravatar.com/llms.txt
 */

const GRAVATAR_BASE = "https://0.gravatar.com/avatar/";

async function sha256Hex(input: string): Promise<string> {
  const encoded = new TextEncoder().encode(input);
  const hashBuffer = await crypto.subtle.digest("SHA-256", encoded);
  return Array.from(new Uint8Array(hashBuffer))
    .map((b) => b.toString(16).padStart(2, "0"))
    .join("");
}

/**
 * Build a Gravatar avatar URL for the given email.
 * Returns `null` if no email is provided.
 *
 * @param email - User email address
 * @param size  - Image size in pixels (default 80)
 * @param fallback - Gravatar default image style when no avatar exists
 *                   (e.g. "mp" for mystery person, "identicon", "retro")
 */
export async function getGravatarUrl(
  email: string | null | undefined,
  size = 80,
  fallback = "mp",
): Promise<string | null> {
  if (!email) return null;
  const hash = await sha256Hex(email.trim().toLowerCase());
  return `${GRAVATAR_BASE}${hash}?s=${size}&d=${fallback}`;
}
````

## File: src/lib/history-restore.ts
````typescript
const RESTORE_PROMPT_KEY = "promptforge-restore-enhanced-prompt";

export function queueRestoredVersionPrompt(prompt: string): boolean {
  if (!prompt) return false;
  try {
    localStorage.setItem(RESTORE_PROMPT_KEY, prompt);
    return true;
  } catch {
    return false;
  }
}

export function consumeRestoredVersionPrompt(): string | null {
  try {
    const value = localStorage.getItem(RESTORE_PROMPT_KEY);
    if (value === null) return null;
    localStorage.removeItem(RESTORE_PROMPT_KEY);
    return value;
  } catch {
    return null;
  }
}
````

## File: src/lib/output-panel-validation.ts
````typescript
export interface SavePromptValidationErrors {
  name?: string;
}

export interface SaveAndSharePromptValidationErrors extends SavePromptValidationErrors {
  useCase?: string;
  confirmedSafe?: string;
}

export interface SaveDialogValidationInput {
  name: string;
  shareEnabled: boolean;
  useCase?: string;
  confirmedSafe?: boolean;
}

export function validateSavePromptInput(name: string): SavePromptValidationErrors {
  if (!name.trim()) {
    return { name: "Prompt title is required." };
  }
  return {};
}

export function validateSaveAndSharePromptInput(input: {
  name: string;
  useCase: string;
  confirmedSafe: boolean;
}): SaveAndSharePromptValidationErrors {
  const errors: SaveAndSharePromptValidationErrors = {};
  if (!input.name.trim()) {
    errors.name = "Prompt title is required.";
  }
  if (!input.useCase.trim()) {
    errors.useCase = "Use case is required.";
  }
  if (!input.confirmedSafe) {
    errors.confirmedSafe = "Confirm that the prompt contains no private or secret data.";
  }
  return errors;
}

export function validateSaveDialogInput(
  input: SaveDialogValidationInput,
): SaveAndSharePromptValidationErrors {
  const baseErrors = validateSavePromptInput(input.name);
  if (!input.shareEnabled) {
    return baseErrors;
  }

  const shareErrors = validateSaveAndSharePromptInput({
    name: input.name,
    useCase: input.useCase ?? "",
    confirmedSafe: input.confirmedSafe === true,
  });
  return { ...baseErrors, ...shareErrors };
}
````

## File: src/lib/profile.ts
````typescript
export const DISPLAY_NAME_MAX_LENGTH = 32;
const DISPLAY_NAME_PATTERN = /^[A-Za-z0-9]+$/;

export function validateDisplayName(value: string): string | null {
  const normalized = value.trim();

  if (!normalized) {
    return "Display name is required.";
  }

  if (normalized.length > DISPLAY_NAME_MAX_LENGTH) {
    return `Display name must be ${DISPLAY_NAME_MAX_LENGTH} characters or fewer.`;
  }

  if (!DISPLAY_NAME_PATTERN.test(normalized)) {
    return "Display name can only include letters and numbers.";
  }

  return null;
}
````

## File: src/lib/prompt-builder-cache.ts
````typescript
import { defaultConfig, type PromptConfig } from "@/lib/prompt-builder";
import { hydrateConfigV1ToWorkingState } from "@/lib/prompt-config-adapters";
import type { PromptSummary, PromptVersion } from "@/lib/persistence";
import type { TemplateSummary } from "@/lib/template-store";

const STORAGE_KEY = "promptforge-draft";
const LOCAL_VERSIONS_KEY = "promptforge-local-versions";
const CLOUD_VERSIONS_KEY_PREFIX = "promptforge-cloud-versions";

export const MAX_LOCAL_VERSIONS = 50;

function isPromptVersion(value: unknown): value is PromptVersion {
  if (!value || typeof value !== "object") return false;
  const candidate = value as Record<string, unknown>;
  return (
    typeof candidate.id === "string" &&
    typeof candidate.name === "string" &&
    typeof candidate.prompt === "string" &&
    typeof candidate.timestamp === "number"
  );
}

function cloudVersionsKey(userId: string): string {
  return `${CLOUD_VERSIONS_KEY_PREFIX}:${userId}`;
}

export function hydrateConfig(raw: unknown): PromptConfig {
  return hydrateConfigV1ToWorkingState(raw);
}

export function loadLocalDraft(): PromptConfig {
  try {
    const saved = localStorage.getItem(STORAGE_KEY);
    return saved ? hydrateConfig(JSON.parse(saved)) : defaultConfig;
  } catch {
    return defaultConfig;
  }
}

export function loadLocalVersions(): PromptVersion[] {
  try {
    const saved = localStorage.getItem(LOCAL_VERSIONS_KEY);
    if (!saved) return [];
    const parsed = JSON.parse(saved);
    if (!Array.isArray(parsed)) return [];
    return parsed.filter(isPromptVersion).sort((a, b) => b.timestamp - a.timestamp).slice(0, MAX_LOCAL_VERSIONS);
  } catch {
    return [];
  }
}

export function saveLocalVersions(versions: PromptVersion[]): void {
  try {
    localStorage.setItem(LOCAL_VERSIONS_KEY, JSON.stringify(versions.slice(0, MAX_LOCAL_VERSIONS)));
  } catch {
    // quota errors are intentionally ignored to keep the UI responsive
  }
}

export function clearLocalVersions(): void {
  try {
    localStorage.removeItem(LOCAL_VERSIONS_KEY);
  } catch {
    // ignore
  }
}

export function createVersionId(prefix: string): string {
  if (typeof crypto !== "undefined" && "randomUUID" in crypto) {
    return `${prefix}-${crypto.randomUUID()}`;
  }
  return `${prefix}-${Date.now()}-${Math.random().toString(16).slice(2)}`;
}

export function loadCachedCloudVersions(userId: string | null): PromptVersion[] {
  if (!userId) return [];
  try {
    const saved = sessionStorage.getItem(cloudVersionsKey(userId));
    if (!saved) return [];
    const parsed = JSON.parse(saved);
    if (!Array.isArray(parsed)) return [];
    return parsed.filter(isPromptVersion).sort((a, b) => b.timestamp - a.timestamp).slice(0, MAX_LOCAL_VERSIONS);
  } catch {
    return [];
  }
}

export function saveCachedCloudVersions(userId: string | null, versions: PromptVersion[]): void {
  if (!userId) return;
  try {
    sessionStorage.setItem(cloudVersionsKey(userId), JSON.stringify(versions.slice(0, MAX_LOCAL_VERSIONS)));
  } catch {
    // ignore
  }
}

export function clearCachedCloudVersions(userId: string | null): void {
  if (!userId) return;
  try {
    sessionStorage.removeItem(cloudVersionsKey(userId));
  } catch {
    // ignore
  }
}

export function toPromptSummary(template: TemplateSummary): PromptSummary {
  return {
    ...template,
    category: "general",
    isShared: false,
    communityPostId: null,
    targetModel: "",
    useCase: "",
    remixedFrom: null,
    builtPrompt: "",
    enhancedPrompt: "",
    upvoteCount: 0,
    verifiedCount: 0,
    remixCount: 0,
    commentCount: 0,
  };
}
````

## File: src/lib/prompt-builder-remix.ts
````typescript
import { computeRemixDiff } from "@/lib/community";
import type { PromptConfig } from "@/lib/prompt-builder";

export interface PromptBuilderRemixContext {
  postId: string;
  parentTitle: string;
  parentAuthor: string;
  parentConfig: PromptConfig;
  parentTags: string[];
  parentCategory: string;
}

interface RemixInput {
  tags?: string[];
  category?: string;
  remixNote?: string;
}

export function buildRemixPayload(
  remixContext: PromptBuilderRemixContext | null,
  childConfig: PromptConfig,
  input: RemixInput,
) {
  if (!remixContext) return {};

  return {
    remixedFrom: remixContext.postId,
    remixNote: input.remixNote,
    remixDiff: computeRemixDiff(remixContext.parentConfig, childConfig, {
      parentTags: remixContext.parentTags,
      childTags: input.tags,
      parentCategory: remixContext.parentCategory,
      childCategory: input.category,
    }),
  };
}
````

## File: src/lib/prompt-builder.ts
````typescript
import type { ContextConfig } from "@/lib/context-types";
import { defaultContextConfig, buildContextBlock } from "@/lib/context-types";

export interface PromptConfig {
  originalPrompt: string;
  role: string;
  customRole: string;
  task: string;
  context: string;
  contextConfig: ContextConfig;
  format: string[];
  customFormat: string;
  lengthPreference: string;
  examples: string;
  constraints: string[];
  customConstraint: string;
  tone: string;
  complexity: string;
}

export const defaultConfig: PromptConfig = {
  originalPrompt: "",
  role: "",
  customRole: "",
  task: "",
  context: "",
  contextConfig: defaultContextConfig,
  format: [],
  customFormat: "",
  lengthPreference: "standard",
  examples: "",
  constraints: [],
  customConstraint: "",
  tone: "Professional",
  complexity: "Moderate",
};

const hasText = (value: string): boolean => value.trim().length > 0;

function getPrimaryTaskInput(config: PromptConfig): string {
  const originalPrompt = config.originalPrompt.trim();
  if (originalPrompt) return originalPrompt;
  return config.task.trim();
}

export function hasPromptInput(config: PromptConfig): boolean {
  const hasStructuredContext = Object.values(config.contextConfig.structured).some(
    (value) => typeof value === "string" && hasText(value),
  );
  const hasInterviewAnswers = config.contextConfig.interviewAnswers.some((answer) => hasText(answer.answer));
  const hasRagDocumentRefs = config.contextConfig.rag.documentRefs.some((reference) => hasText(reference));
  const hasRagSignal =
    config.contextConfig.rag.enabled ||
    hasText(config.contextConfig.rag.vectorStoreRef) ||
    hasRagDocumentRefs;

  return (
    hasText(config.originalPrompt) ||
    hasText(config.task) ||
    hasText(config.role) ||
    hasText(config.customRole) ||
    hasText(config.context) ||
    config.contextConfig.sources.length > 0 ||
    config.contextConfig.databaseConnections.length > 0 ||
    hasRagSignal ||
    hasStructuredContext ||
    hasInterviewAnswers ||
    hasText(config.contextConfig.projectNotes) ||
    config.format.length > 0 ||
    hasText(config.customFormat) ||
    config.lengthPreference !== defaultConfig.lengthPreference ||
    hasText(config.examples) ||
    config.constraints.length > 0 ||
    hasText(config.customConstraint) ||
    config.tone !== defaultConfig.tone ||
    config.complexity !== defaultConfig.complexity
  );
}

export const roles = [
  "Expert Copywriter",
  "Data Analyst",
  "Software Developer",
  "Teacher",
  "Business Consultant",
  "Creative Director",
  "Marketing Specialist",
  "UX Designer",
  "Financial Advisor",
  "Research Scientist",
  "Product Manager",
  "Legal Advisor",
  "Medical Professional",
  "Journalist",
  "Technical Writer",
];

export const formatOptions = [
  "Bullet points",
  "Numbered list",
  "Paragraph form",
  "Table",
  "JSON",
  "Markdown",
  "Code block",
];

export const constraintOptions = [
  "Avoid jargon",
  "Use formal tone",
  "Be conversational",
  "Include citations",
  "Think step-by-step",
];

export const toneOptions = ["Professional", "Casual", "Technical", "Creative", "Academic"];
export const complexityOptions = ["Simple", "Moderate", "Advanced"];
export const lengthOptions = [
  { value: "brief", label: "Brief (~100 words)" },
  { value: "standard", label: "Standard (~300 words)" },
  { value: "detailed", label: "Detailed (500+ words)" },
];

export function buildPrompt(config: PromptConfig): string {
  const parts: string[] = [];

  const actualRole = config.customRole || config.role;
  if (actualRole) {
    parts.push(`**Role:** Act as a ${actualRole}.`);
  }

  const primaryTaskInput = getPrimaryTaskInput(config);
  if (primaryTaskInput) {
    parts.push(`**Task:** ${primaryTaskInput}`);
  }

  // Rich context from ContextPanel
  const contextBlock = buildContextBlock(config.contextConfig, config.contextConfig.useDelimiters);
  if (contextBlock) {
    parts.push(contextBlock);
  }

  // Legacy context field (for backward compat / simple usage)
  if (config.context && !contextBlock) {
    parts.push(`**Context:** ${config.context}`);
  }

  const formats = [...config.format];
  if (config.customFormat) formats.push(config.customFormat);
  if (formats.length > 0) {
    const lengthLabel =
      config.lengthPreference === "brief"
        ? "Keep it brief (~100 words)"
        : config.lengthPreference === "detailed"
          ? "Be detailed (500+ words)"
          : "Standard length (~300 words)";
    parts.push(`**Format:** Present the response as ${formats.join(", ")}. ${lengthLabel}.`);
  }

  if (config.examples) {
    parts.push(`**Examples:**\n${config.examples}`);
  }

  const allConstraints = [...config.constraints];
  if (config.customConstraint) allConstraints.push(config.customConstraint);
  if (config.tone && config.tone !== defaultConfig.tone) {
    allConstraints.push(`Use a ${config.tone.toLowerCase()} tone`);
  }
  if (config.complexity && config.complexity !== defaultConfig.complexity) {
    allConstraints.push(`Target ${config.complexity.toLowerCase()} complexity level`);
  }

  if (allConstraints.length > 0) {
    parts.push(`**Constraints:**\n${allConstraints.map((c) => `- ${c}`).join("\n")}`);
  }

  return parts.join("\n\n");
}

export function scorePrompt(config: PromptConfig): {
  total: number;
  clarity: number;
  context: number;
  specificity: number;
  structure: number;
  tips: string[];
} {
  let clarity = 0;
  let context = 0;
  let specificity = 0;
  let structure = 0;
  const tips: string[] = [];

  // Clarity (0-25)
  const primaryTaskInput = getPrimaryTaskInput(config);
  if (primaryTaskInput) {
    const taskLen = primaryTaskInput.length;
    clarity = Math.min(25, Math.round((taskLen / 100) * 25));
  }
  if (clarity < 15) tips.push("Make your task description more specific and detailed.");

  // Context (0-25) — now includes structured context
  if (config.context) {
    context = Math.min(15, Math.round((config.context.length / 150) * 15));
  }
  const ctx = config.contextConfig;
  if (ctx.sources.length > 0) context += 5;
  if (ctx.databaseConnections.length > 0) context += 3;
  if (ctx.rag.enabled && ctx.rag.vectorStoreRef.trim()) context += 3;
  if (ctx.structured.audience || ctx.structured.product) context += 4;
  if (ctx.structured.offer) context += 3;
  if (ctx.interviewAnswers.filter((a) => a.answer.trim()).length > 0) context += 3;
  if (ctx.projectNotes.trim()) context += 2;
  if (config.role || config.customRole) context = Math.min(25, context + 5);
  context = Math.min(25, context);
  if (context < 15) tips.push("Use the Context & Sources panel to add structured background info.");

  // Specificity (0-25)
  if (config.format.length > 0) specificity += 8;
  if (config.lengthPreference) specificity += 5;
  if (config.examples) specificity += 7;
  if (config.constraints.length > 0) specificity += 5;
  specificity = Math.min(25, specificity);
  if (specificity < 15) tips.push("Specify output format, length, or provide examples for better results.");

  // Structure (0-25)
  if (config.role || config.customRole) structure += 7;
  if (config.tone) structure += 5;
  if (config.complexity) structure += 5;
  if (config.constraints.length >= 2) structure += 4;
  if (config.format.length > 0) structure += 4;
  structure = Math.min(25, structure);
  if (structure < 15) tips.push("Select a role, tone, and constraints to improve prompt structure.");

  if (tips.length === 0) tips.push("Great prompt! You've covered all the essentials.");

  return {
    total: clarity + context + specificity + structure,
    clarity,
    context,
    specificity,
    structure,
  tips,
  };
}
````

## File: src/lib/prompt-categories.ts
````typescript
export const PROMPT_CATEGORIES = [
  "general",
  "frontend",
  "backend",
  "fullstack",
  "devops",
  "data",
  "ml-ai",
  "security",
  "testing",
  "api",
  "automation",
  "docs",
  "content",
  "analysis",
  "creative",
  "business",
  "education",
] as const;

export type PromptCategory = (typeof PROMPT_CATEGORIES)[number];

export const PROMPT_CATEGORY_LABELS: Record<PromptCategory, string> = {
  general: "General",
  frontend: "Frontend",
  backend: "Backend",
  fullstack: "Fullstack",
  devops: "DevOps",
  data: "Data",
  "ml-ai": "ML / AI",
  security: "Security",
  testing: "Testing",
  api: "API",
  automation: "Automation",
  docs: "Docs",
  content: "Content",
  analysis: "Analysis",
  creative: "Creative",
  business: "Business",
  education: "Education",
};

export const PROMPT_CATEGORY_OPTIONS: ReadonlyArray<{ value: PromptCategory; label: string }> = PROMPT_CATEGORIES.map(
  (value) => ({
    value,
    label: PROMPT_CATEGORY_LABELS[value],
  }),
);

const PROMPT_CATEGORY_SET = new Set<string>(PROMPT_CATEGORIES);

export function isPromptCategory(value: string): value is PromptCategory {
  return PROMPT_CATEGORY_SET.has(value);
}

export function normalizePromptCategory(category?: string): PromptCategory | undefined {
  if (category === undefined) return undefined;
  const normalized = category.trim().toLowerCase();
  if (!normalized) return "general";
  return isPromptCategory(normalized) ? normalized : "general";
}
````

## File: src/lib/section-health.ts
````typescript
import type { PromptConfig } from "@/lib/prompt-builder";

export type SectionHealthState = "empty" | "in_progress" | "complete";

export interface SectionHealth {
  builder: SectionHealthState;
  context: SectionHealthState;
  tone: SectionHealthState;
  quality: SectionHealthState;
}

function resolveState(
  signalCount: number,
  thresholds: { inProgress: number; complete: number },
): SectionHealthState {
  if (signalCount >= thresholds.complete) return "complete";
  if (signalCount >= thresholds.inProgress) return "in_progress";
  return "empty";
}

export function getSectionHealth(config: PromptConfig, qualityTotal: number): SectionHealth {
  const hasValue = (value: string, minLength = 1) => value.trim().length >= minLength;

  const contextStructuredCount = Object.values(config.contextConfig.structured).filter(
    (value) => typeof value === "string" && hasValue(value, 2),
  ).length;
  const contextInterviewCount = config.contextConfig.interviewAnswers.filter(
    (answer) => hasValue(answer.answer, 2),
  ).length;
  const hasRag =
    config.contextConfig.rag.enabled && hasValue(config.contextConfig.rag.vectorStoreRef, 2);
  const hasIntegrations = config.contextConfig.databaseConnections.length > 0 || hasRag;

  const builderSignalCount =
    (config.role || hasValue(config.customRole, 2) ? 1 : 0) +
    (hasValue(config.task, 8) ? 1 : 0) +
    (config.format.length > 0 || hasValue(config.customFormat, 2) || config.lengthPreference !== "standard"
      ? 1
      : 0) +
    (hasValue(config.examples, 12) ? 1 : 0) +
    (config.constraints.length > 0 || hasValue(config.customConstraint, 2) ? 1 : 0);

  const contextSignalCount =
    (config.contextConfig.sources.length > 0 ? 1 : 0) +
    (contextStructuredCount >= 4 ? 2 : contextStructuredCount >= 1 ? 1 : 0) +
    (contextInterviewCount >= 2 ? 1 : contextInterviewCount === 1 ? 0.5 : 0) +
    (hasIntegrations ? 1 : 0) +
    (hasValue(config.contextConfig.projectNotes, 30) ? 1 : 0);

  const toneSignalCount = [
    config.tone !== "Professional",
    config.complexity !== "Moderate",
  ].filter(Boolean).length;

  return {
    builder: resolveState(builderSignalCount, { inProgress: 1, complete: 4 }),
    context: resolveState(contextSignalCount, { inProgress: 1, complete: 3 }),
    tone: resolveState(toneSignalCount, { inProgress: 1, complete: 2 }),
    quality:
      qualityTotal >= 75 ? "complete" : qualityTotal >= 50 ? "in_progress" : "empty",
  };
}
````

## File: src/lib/telemetry.ts
````typescript
export const BUILDER_TELEMETRY_EVENT_NAME = "promptforge:builder-telemetry";

export type BuilderTelemetryEvent =
  | "builder_loaded"
  | "builder_first_input"
  | "builder_zone2_opened"
  | "builder_zone3_opened"
  | "builder_enhance_clicked"
  | "builder_enhance_completed"
  | "builder_inference_applied"
  | "builder_field_manual_override"
  | "builder_save_clicked"
  | "builder_share_toggled"
  | "builder_dev_export_used";

export type BuilderTelemetryValue = string | number | boolean | null;

export interface BuilderTelemetryPayload {
  [key: string]: BuilderTelemetryValue;
}

export interface BuilderTelemetryEnvelope {
  event: BuilderTelemetryEvent;
  payload: BuilderTelemetryPayload;
  timestamp: number;
}

export function trackBuilderEvent(
  event: BuilderTelemetryEvent,
  payload: BuilderTelemetryPayload = {},
): void {
  if (typeof window === "undefined") return;

  const detail: BuilderTelemetryEnvelope = {
    event,
    payload,
    timestamp: Date.now(),
  };

  window.dispatchEvent(
    new CustomEvent<BuilderTelemetryEnvelope>(BUILDER_TELEMETRY_EVENT_NAME, {
      detail,
    }),
  );
}
````

## File: src/lib/text-diff.ts
````typescript
export type DiffLineType = "context" | "add" | "remove";

export interface DiffLine {
  type: DiffLineType;
  value: string;
}

export interface LineDiffResult {
  lines: DiffLine[];
  added: number;
  removed: number;
}

function splitLines(input: string): string[] {
  if (!input) return [];
  return input.replace(/\r\n/g, "\n").split("\n");
}

export function buildLineDiff(before: string, after: string): LineDiffResult {
  const beforeLines = splitLines(before);
  const afterLines = splitLines(after);
  const beforeLen = beforeLines.length;
  const afterLen = afterLines.length;

  const lcs: number[][] = Array.from({ length: beforeLen + 1 }, () =>
    Array.from({ length: afterLen + 1 }, () => 0)
  );

  for (let i = beforeLen - 1; i >= 0; i -= 1) {
    for (let j = afterLen - 1; j >= 0; j -= 1) {
      if (beforeLines[i] === afterLines[j]) {
        lcs[i][j] = lcs[i + 1][j + 1] + 1;
      } else {
        lcs[i][j] = Math.max(lcs[i + 1][j], lcs[i][j + 1]);
      }
    }
  }

  const lines: DiffLine[] = [];
  let added = 0;
  let removed = 0;
  let i = 0;
  let j = 0;

  while (i < beforeLen && j < afterLen) {
    if (beforeLines[i] === afterLines[j]) {
      lines.push({ type: "context", value: beforeLines[i] });
      i += 1;
      j += 1;
      continue;
    }

    if (lcs[i + 1][j] >= lcs[i][j + 1]) {
      lines.push({ type: "remove", value: beforeLines[i] });
      removed += 1;
      i += 1;
    } else {
      lines.push({ type: "add", value: afterLines[j] });
      added += 1;
      j += 1;
    }
  }

  while (i < beforeLen) {
    lines.push({ type: "remove", value: beforeLines[i] });
    removed += 1;
    i += 1;
  }

  while (j < afterLen) {
    lines.push({ type: "add", value: afterLines[j] });
    added += 1;
    j += 1;
  }

  return { lines, added, removed };
}
````

## File: src/lib/url-utils.ts
````typescript
export function normalizeHttpUrl(value: string): string | null {
  const trimmed = value.trim();
  if (!trimmed) return null;

  // Reject explicit non-http(s) schemes (javascript:, data:, mailto:, etc.).
  if (/^[a-z][a-z\d+\-.]*:/i.test(trimmed) && !/^https?:/i.test(trimmed)) {
    return null;
  }

  const candidate = /^https?:\/\//i.test(trimmed) ? trimmed : `https://${trimmed}`;
  try {
    const parsed = new URL(candidate);
    if (parsed.protocol !== "http:" && parsed.protocol !== "https:") return null;
    return parsed.href;
  } catch {
    return null;
  }
}
````

## File: src/lib/utils.ts
````typescript
import { clsx, type ClassValue } from "clsx";
import { twMerge } from "tailwind-merge";

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}
````

## File: eslint.config.js
````javascript
import js from "@eslint/js";
import globals from "globals";
import reactHooks from "eslint-plugin-react-hooks";
import reactRefresh from "eslint-plugin-react-refresh";
import tseslint from "typescript-eslint";

export default tseslint.config(
  { ignores: ["dist"] },
  {
    extends: [js.configs.recommended, ...tseslint.configs.recommended],
    files: ["**/*.{ts,tsx}"],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
    plugins: {
      "react-hooks": reactHooks,
      "react-refresh": reactRefresh,
    },
    rules: {
      ...reactHooks.configs.recommended.rules,
      "react-refresh/only-export-components": ["warn", { allowConstantExport: true }],
      "@typescript-eslint/no-unused-vars": "off",
    },
  },
);
````

## File: tsconfig.app.json
````json
{
  "compilerOptions": {
    "types": ["vitest/globals"],
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": false,
    "noUnusedLocals": false,
    "noUnusedParameters": false,
    "noImplicitAny": false,
    "noFallthroughCasesInSwitch": false,

    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["src"]
}
````

## File: tsconfig.json
````json
{
  "files": [],
  "references": [{ "path": "./tsconfig.app.json" }, { "path": "./tsconfig.node.json" }],
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    },
    "noImplicitAny": false,
    "noUnusedParameters": false,
    "skipLibCheck": true,
    "allowJs": true,
    "noUnusedLocals": false,
    "strictNullChecks": false
  }
}
````

## File: tsconfig.node.json
````json
{
  "compilerOptions": {
    "target": "ES2022",
    "lib": ["ES2023"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": false,
    "noUnusedParameters": false,
    "noFallthroughCasesInSwitch": true
  },
  "include": ["vite.config.ts"]
}
````

## File: vitest.config.ts
````typescript
import { defineConfig } from "vitest/config";
import react from "@vitejs/plugin-react-swc";
import path from "path";

export default defineConfig({
  plugins: [react()],
  test: {
    environment: "jsdom",
    globals: true,
    setupFiles: ["./src/test/setup.ts"],
    include: ["src/**/*.{test,spec}.{ts,tsx}"],
  },
  resolve: {
    alias: { "@": path.resolve(__dirname, "./src") },
  },
});
````

## File: agent_service/enhancement-pipeline.mjs
````javascript
const BUILDER_MODES = new Set(["quick", "guided", "advanced"]);

const INTENT_PATTERNS = {
  creative: /\b(write|create|generate|story|poem|design|draft|compose|brainstorm)\b/i,
  analytical: /\b(analyze|analyse|compare|evaluate|assess|review|benchmark)\b/i,
  instructional: /\b(how to|steps?|guide|tutorial|explain|walkthrough)\b/i,
  conversational: /\b(chat|talk|discuss|roleplay|act as)\b/i,
  extraction: /\b(extract|summari[sz]e|list|find|identify|pull out)\b/i,
  coding: /\b(code|function|script|debug|implement|build|refactor|api)\b/i,
  reasoning: /\b(why|reason|logic|argue|prove|think)\b/i,
};

const DOMAIN_PATTERNS = {
  technical: /\b(api|database|server|deploy|algorithm|code|infra|architecture)\b/i,
  business: /\b(revenue|strategy|market|customer|kpi|roi|sales|gtm)\b/i,
  academic: /\b(research|thesis|study|hypothesis|literature|paper)\b/i,
  creative: /\b(story|character|plot|design|art|music|novel)\b/i,
  health: /\b(medical|health|fitness|nutrition|therapy|wellness)\b/i,
  legal: /\b(law|regulation|compliance|contract|liability|statute)\b/i,
  education: /\b(teach|learn|curriculum|student|lesson|pedagogy)\b/i,
};

const MODE_ADDONS = {
  quick: [
    "## MODE: QUICK",
    "- Keep the enhanced prompt under 200 words.",
    "- Focus primarily on Role, Task, and Output format.",
    "- Skip examples unless critical for task correctness.",
    "- Prioritize clarity over comprehensiveness.",
  ].join("\n"),
  guided: [
    "## MODE: GUIDED",
    "- Use all 6 parts with concise, practical detail.",
    "- Include one example when useful.",
    "- Target 200-500 words for the enhanced prompt.",
    "- Balance structure and readability.",
  ].join("\n"),
  advanced: [
    "## MODE: ADVANCED",
    "- Use all 6 parts with full detail.",
    "- Include 1-2 examples where useful.",
    "- Add explicit edge-case handling instructions.",
    "- Target 400-800 words for the enhanced prompt.",
    "- Include a short pre-answer checklist for reasoning-heavy tasks.",
  ].join("\n"),
};

const INTENT_ADDONS = {
  coding: [
    "## CODING-SPECIFIC ENHANCEMENTS",
    "- Specify language, framework, and relevant versions.",
    "- Request robust error handling and validation.",
    "- Ask for concise comments only where needed.",
    "- Include tests or usage examples.",
    "- Include edge cases and failure handling expectations.",
  ].join("\n"),
  creative: [
    "## CREATIVE-SPECIFIC ENHANCEMENTS",
    "- Define tone, mood, and voice clearly.",
    "- Specify audience and desired emotional impact.",
    "- Set creative boundaries and avoid-list topics if needed.",
    "- Prioritize originality and sensory specificity.",
  ].join("\n"),
  analytical: [
    "## ANALYSIS-SPECIFIC ENHANCEMENTS",
    "- Request a clear analysis framework (for example: pros/cons, SWOT, matrix).",
    "- Require evidence-backed conclusions and explicit assumptions.",
    "- Call out limitations, uncertainty, and missing data.",
  ].join("\n"),
  reasoning: [
    "## REASONING-SPECIFIC ENHANCEMENTS",
    "- Ask for a concise, explicit step-by-step rationale.",
    "- Include competing perspectives and counterarguments when relevant.",
    "- Require clear separation between assumptions and conclusions.",
  ].join("\n"),
};

const REQUIRED_PARTS = ["role", "context", "task", "output_format", "guardrails"];
const BUILDER_FIELD_KEYS = ["role", "context", "task", "output_format", "examples", "guardrails"];
const DEFAULT_PARTS = {
  role: "",
  context: "",
  task: "",
  output_format: "",
  examples: null,
  guardrails: "",
};

const MASTER_META_PROMPT = [
  "You are PromptArchitect, an expert prompt engineer specializing in high-quality prompts for Large Language Models.",
  "",
  "## YOUR TASK",
  "Transform the user's raw input into an enhanced, production-ready prompt using the 6-Part Builder Framework.",
  "",
  "## USER'S RAW INPUT",
  "\"\"\"",
  "{{USER_INPUT}}",
  "\"\"\"",
  "",
  "## DETECTED CONTEXT",
  "- Intent Type: {{INTENT_TYPE}}",
  "- Domain: {{DOMAIN}}",
  "- Complexity Level: {{COMPLEXITY}} / 5",
  "- Builder Mode: {{BUILDER_MODE}}",
  "- Input Language: {{INPUT_LANGUAGE}}",
  "- Prompt Structure Present: {{PRESENT_SECTIONS}}",
  "- Prompt Structure Missing: {{MISSING_SECTIONS}}",
  "",
  "## BUILDER FIELD SNAPSHOT",
  "These are direct UI fields and may be empty. Use them as first-priority signals before inferring.",
  "{{BUILDER_FIELDS}}",
  "",
  "## 6-PART BUILDER FRAMEWORK",
  "Use all parts. If details are missing, infer minimal practical defaults.",
  "",
  "### Part 1: ROLE & PERSONA",
  "- Define who the AI should be.",
  "- Include domain-relevant expertise and communication style.",
  "",
  "### Part 2: CONTEXT & BACKGROUND",
  "- Clarify the user situation and task boundaries.",
  "- Include constraints and assumptions.",
  "",
  "### Part 3: TASK & INSTRUCTIONS",
  "- State the exact task with action verbs.",
  "- Break complex tasks into numbered steps.",
  "",
  "### Part 4: OUTPUT FORMAT & STRUCTURE",
  "- Define response structure, format, and target length.",
  "",
  "### Part 5: EXAMPLES & REFERENCE",
  "- Include 1-2 examples when beneficial.",
  "- If examples do not fit, provide a concise quality reference.",
  "",
  "### Part 6: GUARDRAILS & CONSTRAINTS",
  "- Define what to do and what to avoid.",
  "- Include fallback behavior for uncertainty.",
  "",
  "## ENHANCEMENT RULES",
  "1. Replace vague language with specific, actionable wording.",
  "2. Preserve user intent; improve quality without changing objective.",
  "3. Match terminology and rigor to domain: {{DOMAIN}}.",
  "4. Match detail level to complexity: {{COMPLEXITY}}.",
  "5. Keep the enhanced prompt in the same language as the input unless the user asked otherwise.",
  "6. If web search was used, include a trailing sources block in enhanced_prompt:",
  "   blank line + --- + Sources: + one '- [Title](URL)' per line.",
  "",
  "## EDGE CASE DIRECTIVES",
  "{{EDGE_CASE_NOTES}}",
  "",
  "## OUTPUT FORMAT",
  "Return ONLY valid JSON (no prose, no markdown fences) with this exact schema:",
  "{",
  "  \"enhanced_prompt\": \"string\",",
  "  \"parts_breakdown\": {",
  "    \"role\": \"string\",",
  "    \"context\": \"string\",",
  "    \"task\": \"string\",",
  "    \"output_format\": \"string\",",
  "    \"examples\": \"string|null\",",
  "    \"guardrails\": \"string\"",
  "  },",
  "  \"enhancements_made\": [\"string\"],",
  "  \"quality_score\": {",
  "    \"clarity\": 0,",
  "    \"specificity\": 0,",
  "    \"completeness\": 0,",
  "    \"actionability\": 0,",
  "    \"overall\": 0",
  "  },",
  "  \"suggestions\": [\"string\"],",
  "  \"alternative_versions\": {",
  "    \"shorter\": \"string\",",
  "    \"more_detailed\": \"string\"",
  "  }",
  "}",
].join("\n");

const CORE_SECTIONS = ["Role", "Task", "Context", "Format", "Constraints"];

function asWords(input) {
  if (typeof input !== "string") return [];
  return input.trim().split(/\s+/).filter(Boolean);
}

function clampNumber(value, min, max) {
  const parsed = Number(value);
  if (!Number.isFinite(parsed)) return min;
  return Math.max(min, Math.min(max, parsed));
}

function normalizeStringList(value) {
  if (!Array.isArray(value)) return [];
  return value
    .map((entry) => (typeof entry === "string" ? entry.trim() : ""))
    .filter(Boolean);
}

function normalizeBuilderMode(rawMode) {
  if (typeof rawMode !== "string") return "guided";
  const normalized = rawMode.trim().toLowerCase();
  return BUILDER_MODES.has(normalized) ? normalized : "guided";
}

function normalizeFieldValue(value) {
  if (typeof value !== "string") return "";
  return value.trim();
}

export function normalizeBuilderFields(input) {
  const source = input && typeof input === "object" && !Array.isArray(input) ? input : {};
  return {
    role: normalizeFieldValue(source.role),
    context: normalizeFieldValue(source.context),
    task: normalizeFieldValue(source.task),
    output_format: normalizeFieldValue(source.output_format ?? source.outputFormat),
    examples: normalizeFieldValue(source.examples),
    guardrails: normalizeFieldValue(source.guardrails),
  };
}

function detectInputLanguage(input) {
  const value = typeof input === "string" ? input : "";
  if (!value) return "unknown";
  if (/[\u4E00-\u9FFF\u3040-\u30FF]/.test(value)) return "cjk";
  if (/[\u0400-\u04FF]/.test(value)) return "cyrillic";
  if (/[\u0600-\u06FF]/.test(value)) return "arabic";
  if (/[\u0900-\u097F]/.test(value)) return "devanagari";
  return "english-or-latin";
}

function hasContradictoryLengthSignals(input) {
  const normalized = input.toLowerCase();
  const asksShort = /\b(short|brief|concise|tl;dr)\b/.test(normalized);
  const asksLong = /\b(detailed|comprehensive|thorough|deep dive|exhaustive)\b/.test(normalized);
  return asksShort && asksLong;
}

function hasMultipleTaskSignals(input) {
  const normalized = input.toLowerCase();
  return (
    /\b(and|also|then|plus|as well as)\b/.test(normalized)
    || /\b(first|second|third|next|after that)\b/.test(normalized)
    || /\bmultiple|several\b/.test(normalized)
  );
}

export function classifyIntent(input) {
  return Object.entries(INTENT_PATTERNS)
    .filter(([, regex]) => regex.test(input))
    .map(([intent]) => intent);
}

export function detectDomain(input) {
  return Object.entries(DOMAIN_PATTERNS)
    .filter(([, regex]) => regex.test(input))
    .map(([domain]) => domain);
}

export function scoreComplexity(input) {
  let score = 1;
  if (input.length > 100) score += 1;
  if (input.length > 300) score += 1;
  if (/\b(and|also|then|plus)\b/i.test(input)) score += 1;
  if (/\b(multiple|several|complex|detailed|comprehensive|end-to-end)\b/i.test(input)) score += 1;
  return clampNumber(score, 1, 5);
}

export function inspectPromptStructure(prompt) {
  const normalized = prompt.toLowerCase();
  function hasSection(name) {
    const token = name.toLowerCase();
    return [
      `${token}:`,
      `${token} -`,
      `## ${token}`,
      `### ${token}`,
      `[${token}]`,
    ].some((pattern) => normalized.includes(pattern));
  }
  const presentSections = CORE_SECTIONS.filter(hasSection);
  const missingSections = CORE_SECTIONS.filter((section) => !presentSections.includes(section));
  return {
    presentSections,
    missingSections,
    charCount: prompt.length,
  };
}

export function detectEnhancementContext(input, options = {}) {
  const prompt = typeof input === "string" ? input.trim() : "";
  const words = asWords(prompt);
  const intent = classifyIntent(prompt);
  const domain = detectDomain(prompt);
  const complexity = scoreComplexity(prompt);
  const structure = inspectPromptStructure(prompt);
  const builderMode = normalizeBuilderMode(options.builderMode);
  const inputLanguage = detectInputLanguage(prompt);
  const builderFields = normalizeBuilderFields(options.builderFields);

  return {
    intent,
    domain,
    complexity,
    builderMode,
    inputLanguage,
    wordCount: words.length,
    hasMultipleTasks: hasMultipleTaskSignals(prompt),
    hasContradiction: hasContradictoryLengthSignals(prompt),
    isTooVague: words.length > 0 && words.length < 5,
    structure,
    builderFields,
  };
}

function joinOrDefault(values, fallback) {
  return values.length > 0 ? values.join(", ") : fallback;
}

function buildEdgeCaseNotes(context) {
  const notes = [];
  if (context.isTooVague) {
    notes.push("- Input is very brief. Add practical assumptions and include a short suggestion to add context.");
  }
  if (context.hasMultipleTasks) {
    notes.push("- Multiple tasks are likely. Separate primary and secondary tasks in the enhanced prompt.");
  }
  if (context.hasContradiction) {
    notes.push("- Contradictory detail-level signals detected. Resolve with a practical balance and note the tradeoff.");
  }
  if (notes.length === 0) {
    notes.push("- No special edge-case constraints detected. Apply standard quality improvements.");
  }
  return notes.join("\n");
}

export function buildEnhancementMetaPrompt(userInput, context) {
  const modeAddon = MODE_ADDONS[context.builderMode] || MODE_ADDONS.guided;
  const intentAddons = context.intent
    .map((intent) => INTENT_ADDONS[intent])
    .filter((value) => typeof value === "string" && value.length > 0);

  const edgeCaseNotes = buildEdgeCaseNotes(context);
  const builderFieldLines = BUILDER_FIELD_KEYS.map((key) => {
    const value = context.builderFields?.[key] ?? "";
    return `- ${key}: ${value || "(empty)"}`;
  }).join("\n");
  const template = MASTER_META_PROMPT
    .replace("{{USER_INPUT}}", userInput)
    .replace("{{INTENT_TYPE}}", joinOrDefault(context.intent, "general"))
    .replace("{{DOMAIN}}", joinOrDefault(context.domain, "general"))
    .replace("{{COMPLEXITY}}", String(context.complexity))
    .replace("{{BUILDER_MODE}}", context.builderMode)
    .replace("{{INPUT_LANGUAGE}}", context.inputLanguage)
    .replace(
      "{{PRESENT_SECTIONS}}",
      joinOrDefault(context.structure.presentSections, "none"),
    )
    .replace(
      "{{MISSING_SECTIONS}}",
      joinOrDefault(context.structure.missingSections, "none"),
    )
    .replace("{{BUILDER_FIELDS}}", builderFieldLines)
    .replace("{{EDGE_CASE_NOTES}}", edgeCaseNotes);

  return [template, modeAddon, ...intentAddons].join("\n\n");
}

function stripCodeFence(text) {
  const fenced = text.match(/```(?:json)?\s*([\s\S]*?)```/i);
  if (!fenced) return text;
  return fenced[1].trim();
}

function extractJsonCandidate(text) {
  const normalized = stripCodeFence(text).trim();
  if (!normalized) return null;
  if (normalized.startsWith("{") && normalized.endsWith("}")) return normalized;
  const start = normalized.indexOf("{");
  const end = normalized.lastIndexOf("}");
  if (start === -1 || end <= start) return null;
  return normalized.slice(start, end + 1);
}

export function parseEnhancementJsonResponse(rawText) {
  if (typeof rawText !== "string") return null;
  const candidate = extractJsonCandidate(rawText);
  if (!candidate) return null;
  try {
    const parsed = JSON.parse(candidate);
    if (!parsed || typeof parsed !== "object" || Array.isArray(parsed)) return null;
    return parsed;
  } catch {
    return null;
  }
}

function normalizePartsBreakdown(value, enhancedPrompt) {
  const source = value && typeof value === "object" && !Array.isArray(value) ? value : {};
  const output = { ...DEFAULT_PARTS };
  for (const key of Object.keys(DEFAULT_PARTS)) {
    const raw = source[key];
    if (key === "examples") {
      output.examples = typeof raw === "string" ? raw.trim() : null;
    } else if (typeof raw === "string") {
      output[key] = raw.trim();
    }
  }

  if (!output.role) output.role = "Role inferred from user objective and domain.";
  if (!output.context) output.context = "Context inferred from the source prompt and constraints.";
  if (!output.task) output.task = "Task clarified and broken into executable instructions.";
  if (!output.output_format) output.output_format = "Explicit output structure and length guidance.";
  if (!output.guardrails) output.guardrails = "Safety, quality, and uncertainty handling requirements.";
  if (!output.examples && enhancedPrompt.length > 0) {
    output.examples = null;
  }
  return output;
}

function normalizeQualityScore(value, fallbackOverall) {
  const source = value && typeof value === "object" && !Array.isArray(value) ? value : {};
  const clarity = clampNumber(source.clarity, 0, 10);
  const specificity = clampNumber(source.specificity, 0, 10);
  const completeness = clampNumber(source.completeness, 0, 10);
  const actionability = clampNumber(source.actionability, 0, 10);

  const average = Number(
    ((clarity + specificity + completeness + actionability) / 4).toFixed(1),
  );
  const overall = clampNumber(source.overall, 0, 10);

  if (overall > 0) {
    return { clarity, specificity, completeness, actionability, overall };
  }
  return { clarity, specificity, completeness, actionability, overall: fallbackOverall || average };
}

function normalizeAlternatives(value) {
  const source = value && typeof value === "object" && !Array.isArray(value) ? value : {};
  return {
    shorter: typeof source.shorter === "string" ? source.shorter.trim() : "",
    more_detailed: typeof source.more_detailed === "string" ? source.more_detailed.trim() : "",
  };
}

function countWords(text) {
  return asWords(text).length;
}

export function scorePromptQuality(input) {
  let score = 2;
  const words = countWords(input);
  if (words > 20) score += 1;
  if (words > 50) score += 1;
  if (/\b(you are|act as|role)\b/i.test(input)) score += 1;
  if (/\b(step|first|then|next)\b/i.test(input)) score += 1;
  if (/\b(format|structure|output)\b/i.test(input)) score += 1;
  if (/\b(don't|avoid|must not|do not)\b/i.test(input)) score += 1;
  if (/\b(example|e\.g\.|such as)\b/i.test(input)) score += 1;
  if (/\d+/.test(input)) score += 0.5;
  return clampNumber(Math.round(score), 0, 10);
}

export function postProcessEnhancementResponse({
  llmResponseText,
  userInput,
  context,
}) {
  const originalPrompt = typeof userInput === "string" ? userInput.trim() : "";
  const rawResponse = typeof llmResponseText === "string" ? llmResponseText.trim() : "";
  const parsed = parseEnhancementJsonResponse(rawResponse);
  const originalScore = scorePromptQuality(originalPrompt);

  const fallbackEnhancedPrompt = rawResponse;
  const normalizedEnhancedPrompt = parsed && typeof parsed.enhanced_prompt === "string"
    ? parsed.enhanced_prompt.trim()
    : fallbackEnhancedPrompt;

  const parsedParts = parsed?.parts_breakdown && typeof parsed.parts_breakdown === "object"
    && !Array.isArray(parsed.parts_breakdown)
    ? parsed.parts_breakdown
    : {};
  const inferredEnhancedScore = Math.max(scorePromptQuality(normalizedEnhancedPrompt), originalScore);
  const partsBreakdown = normalizePartsBreakdown(parsed?.parts_breakdown, normalizedEnhancedPrompt);
  const qualityScore = normalizeQualityScore(parsed?.quality_score, inferredEnhancedScore);
  const missingParts = REQUIRED_PARTS.filter((part) => {
    const value = parsedParts[part];
    return !(typeof value === "string" && value.trim().length > 0);
  });
  const enhancementDelta = Number((qualityScore.overall - originalScore).toFixed(1));
  const safeEnhancements = normalizeStringList(parsed?.enhancements_made);
  const safeSuggestions = normalizeStringList(parsed?.suggestions);
  const alternatives = normalizeAlternatives(parsed?.alternative_versions);

  return {
    enhanced_prompt: normalizedEnhancedPrompt,
    parts_breakdown: partsBreakdown,
    enhancements_made: safeEnhancements,
    quality_score: qualityScore,
    suggestions: safeSuggestions,
    alternative_versions: alternatives,
    improvement_delta: enhancementDelta,
    missing_parts: missingParts,
    word_count: {
      original: countWords(originalPrompt),
      enhanced: countWords(normalizedEnhancedPrompt),
    },
    timestamp: new Date().toISOString(),
    detected_context: {
      intent: context.intent,
      domain: context.domain,
      complexity: context.complexity,
      mode: context.builderMode,
      input_language: context.inputLanguage,
    },
    builder_fields: context.builderFields,
    parse_status: parsed ? "json" : "fallback",
  };
}

export function pickPrimaryAgentMessageText(messagesByItemId, itemOrder) {
  const ordered = Array.isArray(itemOrder) ? itemOrder : [];
  const messageMap = messagesByItemId instanceof Map ? messagesByItemId : new Map();
  for (let i = ordered.length - 1; i >= 0; i -= 1) {
    const itemId = ordered[i];
    const candidate = messageMap.get(itemId);
    if (typeof candidate === "string" && candidate.trim()) {
      return candidate.trim();
    }
  }

  let longest = "";
  for (const value of messageMap.values()) {
    if (typeof value === "string" && value.trim().length > longest.length) {
      longest = value.trim();
    }
  }
  return longest;
}

export function parseEnhancementRequestMode(body) {
  if (!body || typeof body !== "object") return "guided";
  const directMode = typeof body.builder_mode === "string" ? body.builder_mode : body.builderMode;
  return normalizeBuilderMode(directMode);
}

export function parseEnhancementRequestBuilderFields(body) {
  if (!body || typeof body !== "object") {
    return normalizeBuilderFields({});
  }
  const raw = body.builder_fields ?? body.builderFields;
  return normalizeBuilderFields(raw);
}
````

## File: agent_service/thread-options.mjs
````javascript
const REASONING_EFFORTS = new Set(["minimal", "low", "medium", "high", "xhigh"]);

export function sanitizeEnhanceThreadOptions(input) {
  if (input === undefined) {
    return { ok: true, value: undefined };
  }

  if (!input || typeof input !== "object" || Array.isArray(input)) {
    return { ok: false, error: "thread_options must be an object when provided." };
  }

  const source = input;
  const sanitized = {};

  if (typeof source.modelReasoningEffort === "string") {
    const normalizedEffort = source.modelReasoningEffort.trim().toLowerCase();
    if (REASONING_EFFORTS.has(normalizedEffort)) {
      sanitized.modelReasoningEffort = normalizedEffort;
    }
  }

  if (typeof source.webSearchEnabled === "boolean") {
    sanitized.webSearchEnabled = source.webSearchEnabled;
  }

  return {
    ok: true,
    value: Object.keys(sanitized).length > 0 ? sanitized : undefined,
  };
}

export function extractThreadOptions(input) {
  const result = sanitizeEnhanceThreadOptions(input);
  if (!result.ok || !result.value) {
    return {};
  }
  return result.value;
}
````

## File: src/components/base/avatar/base-components/avatar-company-icon.tsx
````typescript
import { cx } from "@/lib/utils/cx";

const sizes = {
    xs: "size-2",
    sm: "size-3",
    md: "size-3.5",
    lg: "size-4",
    xl: "size-4.5",
    "2xl": "size-5 ring-[1.67px]",
};

interface AvatarCompanyIconProps {
    size: "xs" | "sm" | "md" | "lg" | "xl" | "2xl";
    src: string;
    alt?: string;
}

export const AvatarCompanyIcon = ({ size, src, alt }: AvatarCompanyIconProps) => (
    <img
        src={src}
        alt={alt}
        className={cx("bg-primary-25 absolute -right-0.5 -bottom-0.5 rounded-full object-cover ring-[1.5px] ring-bg-primary", sizes[size])}
    />
);
````

## File: src/components/base/avatar/base-components/avatar-online-indicator.tsx
````typescript
import { cx } from "@/lib/utils/cx";

const sizes = {
    xs: "size-1.5",
    sm: "size-2",
    md: "size-2.5",
    lg: "size-3",
    xl: "size-3.5",
    "2xl": "size-4",
    "3xl": "size-4.5",
    "4xl": "size-5",
};

interface AvatarOnlineIndicatorProps {
    size: "xs" | "sm" | "md" | "lg" | "xl" | "2xl" | "3xl" | "4xl";
    status: "online" | "offline";
    className?: string;
}

export const AvatarOnlineIndicator = ({ size, status, className }: AvatarOnlineIndicatorProps) => (
    <span
        className={cx(
            "absolute right-0 bottom-0 rounded-full ring-[1.5px] ring-bg-primary",
            status === "online" ? "bg-fg-success-secondary" : "bg-fg-disabled_subtle",
            sizes[size],
            className,
        )}
    />
);
````

## File: src/components/base/avatar/base-components/index.tsx
````typescript
export * from "./avatar-add-button";
export * from "./avatar-company-icon";
export * from "./avatar-online-indicator";
export * from "./verified-tick";
````

## File: src/components/base/avatar/base-components/verified-tick.tsx
````typescript
import { cx } from "@/lib/utils/cx";

const sizes = {
    xs: { root: "size-2.5", tick: "size-[4.38px" },
    sm: { root: "size-3", tick: "size-[5.25px]" },
    md: { root: "size-3.5", tick: "size-[6.13px]" },
    lg: { root: "size-4", tick: "size-[7px]" },
    xl: { root: "size-4.5", tick: "size-[7.88px]" },
    "2xl": { root: "size-5", tick: "size-[8.75px]" },
    "3xl": { root: "size-6", tick: "size-[10.5px]" },
    "4xl": { root: "size-8", tick: "size-[14px]" },
};

interface VerifiedTickProps {
    size: "xs" | "sm" | "md" | "lg" | "xl" | "2xl" | "3xl" | "4xl";
    className?: string;
}

export const VerifiedTick = ({ size, className }: VerifiedTickProps) => (
    <svg data-verified className={cx("z-10 text-utility-blue-500", sizes[size].root, className)} viewBox="0 0 10 10" fill="none">
        <path
            d="M7.72237 1.77098C7.81734 2.00068 7.99965 2.18326 8.2292 2.27858L9.03413 2.61199C9.26384 2.70714 9.44635 2.88965 9.5415 3.11936C9.63665 3.34908 9.63665 3.60718 9.5415 3.83689L9.20833 4.64125C9.11313 4.87106 9.113 5.12943 9.20863 5.35913L9.54122 6.16325C9.58839 6.27702 9.61268 6.39897 9.6127 6.52214C9.61272 6.6453 9.58847 6.76726 9.54134 6.88105C9.4942 6.99484 9.42511 7.09823 9.33801 7.18531C9.2509 7.27238 9.14749 7.34144 9.03369 7.38854L8.22934 7.72171C7.99964 7.81669 7.81706 7.99899 7.72174 8.22855L7.38833 9.03348C7.29318 9.26319 7.11067 9.4457 6.88096 9.54085C6.65124 9.636 6.39314 9.636 6.16343 9.54085L5.35907 9.20767C5.12935 9.11276 4.87134 9.11295 4.64177 9.20821L3.83684 9.54115C3.60725 9.63608 3.34937 9.636 3.11984 9.54092C2.89032 9.44585 2.70791 9.26356 2.6127 9.03409L2.27918 8.22892C2.18421 7.99923 2.0019 7.81665 1.77235 7.72133L0.967421 7.38792C0.737807 7.29281 0.555355 7.11041 0.460169 6.88083C0.364983 6.65125 0.364854 6.39327 0.45981 6.16359L0.792984 5.35924C0.8879 5.12952 0.887707 4.87151 0.792445 4.64193L0.459749 3.83642C0.41258 3.72265 0.388291 3.60069 0.388272 3.47753C0.388252 3.35436 0.412501 3.2324 0.459634 3.11861C0.506767 3.00482 0.57586 2.90144 0.662965 2.81436C0.75007 2.72728 0.853479 2.65822 0.967283 2.61113L1.77164 2.27795C2.00113 2.18306 2.1836 2.00099 2.27899 1.7717L2.6124 0.966768C2.70755 0.737054 2.89006 0.554547 3.11978 0.459397C3.34949 0.364246 3.60759 0.364246 3.83731 0.459397L4.64166 0.792571C4.87138 0.887487 5.12939 0.887293 5.35897 0.792031L6.16424 0.459913C6.39392 0.364816 6.65197 0.364836 6.88164 0.459968C7.11131 0.555099 7.29379 0.737554 7.38895 0.967208L7.72247 1.77238L7.72237 1.77098Z"
            className="fill-current"
        />
        <path
            fillRule="evenodd"
            clipRule="evenodd"
            d="M6.95829 3.68932C7.02509 3.58439 7.04747 3.45723 7.02051 3.3358C6.99356 3.21437 6.91946 3.10862 6.81454 3.04182C6.70961 2.97502 6.58245 2.95264 6.46102 2.97959C6.33959 3.00655 6.23384 3.08064 6.16704 3.18557L4.33141 6.06995L3.49141 5.01995C3.41375 4.92281 3.30069 4.8605 3.17709 4.84673C3.05349 4.83296 2.92949 4.86885 2.83235 4.94651C2.73522 5.02417 2.67291 5.13723 2.65914 5.26083C2.64536 5.38443 2.68125 5.50843 2.75891 5.60557L4.00891 7.16807C4.0555 7.22638 4.11533 7.27271 4.18344 7.30323C4.25154 7.33375 4.32595 7.34757 4.40047 7.34353C4.47499 7.3395 4.54747 7.31773 4.61188 7.28004C4.67629 7.24234 4.73077 7.18981 4.77079 7.12682L6.95829 3.68932Z"
            fill="white"
        />
    </svg>
);
````

## File: src/components/base/avatar/avatar-label-group.tsx
````typescript
import { type ReactNode } from "react";
import { cx } from "@/lib/utils/cx";
import { Avatar, type AvatarProps } from "./avatar";

const styles = {
    sm: { root: "gap-2", title: "text-sm font-semibold", subtitle: "text-xs" },
    md: { root: "gap-2", title: "text-sm font-semibold", subtitle: "text-sm" },
    lg: { root: "gap-3", title: "text-md font-semibold", subtitle: "text-md" },
    xl: { root: "gap-4", title: "text-lg font-semibold", subtitle: "text-md" },
};

interface AvatarLabelGroupProps extends AvatarProps {
    size: "sm" | "md" | "lg" | "xl";
    title: string | ReactNode;
    subtitle: string | ReactNode;
}

export const AvatarLabelGroup = ({ title, subtitle, className, ...props }: AvatarLabelGroupProps) => {
    return (
        <figure className={cx("group flex min-w-0 flex-1 items-center", styles[props.size].root, className)}>
            <Avatar {...props} />
            <figcaption className="min-w-0 flex-1">
                <p className={cx("text-primary", styles[props.size].title)}>{title}</p>
                <p className={cx("truncate text-tertiary", styles[props.size].subtitle)}>{subtitle}</p>
            </figcaption>
        </figure>
    );
};
````

## File: src/components/base/avatar/utils.ts
````typescript
/**
 * Extracts the initials from a full name.
 *
 * @param name - The full name from which to extract initials.
 * @returns The initials of the provided name. If the name contains only one word,
 *          it returns the first character of that word. If the name contains two words,
 *          it returns the first character of each word.
 */
export const getInitials = (name: string) => {
    const [firstName, lastName] = name.split(" ");
    return firstName.charAt(0) + (lastName ? lastName.charAt(0) : "");
};
````

## File: src/components/base/checkbox/checkbox.tsx
````typescript
import type { ReactNode, Ref } from "react";
import { Checkbox as AriaCheckbox, type CheckboxProps as AriaCheckboxProps } from "react-aria-components";
import { cx } from "@/lib/utils/cx";

export interface CheckboxBaseProps {
    size?: "sm" | "md";
    className?: string;
    isFocusVisible?: boolean;
    isSelected?: boolean;
    isDisabled?: boolean;
    isIndeterminate?: boolean;
}

export const CheckboxBase = ({ className, isSelected, isDisabled, isIndeterminate, size = "sm", isFocusVisible = false }: CheckboxBaseProps) => {
    return (
        <div
            className={cx(
                "relative flex size-4 shrink-0 cursor-pointer appearance-none items-center justify-center rounded bg-primary ring-1 ring-primary ring-inset",
                size === "md" && "size-5 rounded-md",
                (isSelected || isIndeterminate) && "bg-brand-solid ring-bg-brand-solid",
                isDisabled && "cursor-not-allowed bg-disabled_subtle ring-disabled",
                isFocusVisible && "outline-2 outline-offset-2 outline-focus-ring",
                className,
            )}
        >
            <svg
                aria-hidden="true"
                viewBox="0 0 14 14"
                fill="none"
                className={cx(
                    "pointer-events-none absolute h-3 w-2.5 text-fg-white opacity-0 transition-inherit-all",
                    size === "md" && "size-3.5",
                    isIndeterminate && "opacity-100",
                    isDisabled && "text-fg-disabled_subtle",
                )}
            >
                <path d="M2.91675 7H11.0834" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" />
            </svg>

            <svg
                aria-hidden="true"
                viewBox="0 0 14 14"
                fill="none"
                className={cx(
                    "pointer-events-none absolute size-3 text-fg-white opacity-0 transition-inherit-all",
                    size === "md" && "size-3.5",
                    isSelected && !isIndeterminate && "opacity-100",
                    isDisabled && "text-fg-disabled_subtle",
                )}
            >
                <path d="M11.6666 3.5L5.24992 9.91667L2.33325 7" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" />
            </svg>
        </div>
    );
};
CheckboxBase.displayName = "CheckboxBase";

interface CheckboxProps extends AriaCheckboxProps {
    ref?: Ref<HTMLLabelElement>;
    size?: "sm" | "md";
    label?: ReactNode;
    hint?: ReactNode;
}

export const Checkbox = ({ label, hint, size = "sm", className, ...ariaCheckboxProps }: CheckboxProps) => {
    const sizes = {
        sm: {
            root: "gap-2",
            textWrapper: "",
            label: "text-sm font-medium",
            hint: "text-sm",
        },
        md: {
            root: "gap-3",
            textWrapper: "gap-0.5",
            label: "text-md font-medium",
            hint: "text-md",
        },
    };

    return (
        <AriaCheckbox
            {...ariaCheckboxProps}
            className={(state) =>
                cx(
                    "flex items-start",
                    state.isDisabled && "cursor-not-allowed",
                    sizes[size].root,
                    typeof className === "function" ? className(state) : className,
                )
            }
        >
            {({ isSelected, isIndeterminate, isDisabled, isFocusVisible }) => (
                <>
                    <CheckboxBase
                        size={size}
                        isSelected={isSelected}
                        isIndeterminate={isIndeterminate}
                        isDisabled={isDisabled}
                        isFocusVisible={isFocusVisible}
                        className={label || hint ? "mt-0.5" : ""}
                    />
                    {(label || hint) && (
                        <div className={cx("inline-flex flex-col", sizes[size].textWrapper)}>
                            {label && <p className={cx("text-secondary select-none", sizes[size].label)}>{label}</p>}
                            {hint && (
                                <span className={cx("text-tertiary", sizes[size].hint)} onClick={(event) => event.stopPropagation()}>
                                    {hint}
                                </span>
                            )}
                        </div>
                    )}
                </>
            )}
        </AriaCheckbox>
    );
};
Checkbox.displayName = "Checkbox";
````

## File: src/components/base/form/form.tsx
````typescript
import type { ComponentPropsWithRef } from "react";
import { Form as AriaForm } from "react-aria-components";

export const Form = (props: ComponentPropsWithRef<typeof AriaForm>) => {
    return <AriaForm {...props} />;
};

Form.displayName = "Form";
````

## File: src/components/base/input/hint-text.tsx
````typescript
import type { ReactNode, Ref } from "react";
import type { TextProps as AriaTextProps } from "react-aria-components";
import { Text as AriaText } from "react-aria-components";
import { cx } from "@/lib/utils/cx";

interface HintTextProps extends AriaTextProps {
    /** Indicates that the hint text is an error message. */
    isInvalid?: boolean;
    ref?: Ref<HTMLElement>;
    children: ReactNode;
}

export const HintText = ({ isInvalid, className, ...props }: HintTextProps) => {
    return (
        <AriaText
            {...props}
            slot={isInvalid ? "errorMessage" : "description"}
            className={cx(
                "text-sm text-tertiary",

                // Invalid state
                isInvalid && "text-error-primary",
                "group-invalid:text-error-primary",

                className,
            )}
        />
    );
};

HintText.displayName = "HintText";
````

## File: src/components/base/progress-indicators/progress-circles.tsx
````typescript
import { cn } from "@/lib/utils";

interface ProgressBarProps {
  value: number;
  min?: number;
  max?: number;
  size: "xxs" | "xs" | "sm" | "md" | "lg";
  label?: string;
  valueFormatter?: (value: number, valueInPercentage: number) => string | number;
}

const sizes = {
  xxs: {
    strokeWidth: 6,
    radius: 28,
    valueClass: "text-sm font-semibold text-foreground",
    labelClass: "text-xs font-medium text-muted-foreground",
    halfCircleTextPosition: "absolute bottom-0 text-center",
  },
  xs: {
    strokeWidth: 10,
    radius: 48,
    valueClass: "text-xl font-semibold text-foreground",
    labelClass: "text-xs font-medium text-muted-foreground",
    halfCircleTextPosition: "absolute bottom-0 text-center",
  },
  sm: {
    strokeWidth: 12,
    radius: 60,
    valueClass: "text-2xl font-semibold text-foreground",
    labelClass: "text-xs font-medium text-muted-foreground",
    halfCircleTextPosition: "absolute bottom-0 text-center",
  },
  md: {
    strokeWidth: 14,
    radius: 72,
    valueClass: "text-3xl font-semibold text-foreground",
    labelClass: "text-sm font-medium text-muted-foreground",
    halfCircleTextPosition: "absolute bottom-0 text-center",
  },
  lg: {
    strokeWidth: 16,
    radius: 84,
    valueClass: "text-4xl font-semibold text-foreground",
    labelClass: "text-sm font-medium text-muted-foreground",
    halfCircleTextPosition: "absolute bottom-0 text-center",
  },
} as const;

function getPercentage(value: number, min: number, max: number) {
  const range = max - min || 1;
  const raw = ((value - min) * 100) / range;
  return Math.min(100, Math.max(0, Math.round(raw)));
}

export const ProgressBarCircle = ({ value, min = 0, max = 100, size, label, valueFormatter }: ProgressBarProps) => {
  const percentage = getPercentage(value, min, max);
  const sizeConfig = sizes[size];
  const { strokeWidth, radius, valueClass, labelClass } = sizeConfig;

  const diameter = 2 * (radius + strokeWidth / 2);
  const cx = diameter / 2;
  const cy = diameter / 2;
  const valueText = valueFormatter ? valueFormatter(value, percentage) : `${percentage}%`;
  const strokeDashoffset = 100 - percentage;

  return (
    <div className="flex flex-col items-center gap-1">
      <div role="progressbar" aria-valuenow={value} aria-valuemin={min} aria-valuemax={max} className="relative flex w-max items-center justify-center">
        <svg className="-rotate-90" width={diameter} height={diameter} viewBox={`0 0 ${diameter} ${diameter}`}>
          <circle
            className="stroke-muted"
            cx={cx}
            cy={cy}
            r={radius}
            fill="none"
            strokeWidth={strokeWidth}
            pathLength="100"
            strokeDasharray="100"
            strokeLinecap="round"
          />
          <circle
            className="stroke-primary"
            cx={cx}
            cy={cy}
            r={radius}
            fill="none"
            strokeWidth={strokeWidth}
            pathLength="100"
            strokeDasharray="100"
            strokeLinecap="round"
            strokeDashoffset={strokeDashoffset}
          />
        </svg>

        {label && size !== "xxs" ? (
          <div className="absolute text-center">
            <div className={labelClass}>{label}</div>
            <div className={valueClass}>{valueText}</div>
          </div>
        ) : (
          <span className={cn("absolute text-center", valueClass)}>{valueText}</span>
        )}
      </div>

      {label && size === "xxs" && <div className={labelClass}>{label}</div>}
    </div>
  );
};

export const ProgressBarHalfCircle = ({ value, min = 0, max = 100, size, label, valueFormatter }: ProgressBarProps) => {
  const percentage = getPercentage(value, min, max);
  const sizeConfig = sizes[size];
  const { strokeWidth, radius, valueClass, labelClass, halfCircleTextPosition } = sizeConfig;

  const width = 2 * (radius + strokeWidth / 2);
  const height = radius + strokeWidth;
  const valueText = valueFormatter ? valueFormatter(value, percentage) : `${percentage}%`;
  const strokeDashoffset = -50 - (100 - percentage) / 2;

  return (
    <div className="flex flex-col items-center gap-1">
      <div role="progressbar" aria-valuenow={value} aria-valuemin={min} aria-valuemax={max} className="relative flex w-max items-center justify-center">
        <svg width={width} height={height} viewBox={`0 0 ${width} ${height}`}>
          <circle
            className="stroke-muted"
            cx="50%"
            cy={radius + strokeWidth / 2}
            r={radius}
            fill="none"
            strokeWidth={strokeWidth}
            pathLength="100"
            strokeDasharray="100"
            strokeDashoffset="-50"
            strokeLinecap="round"
          />
          <circle
            className="origin-center -scale-x-100 stroke-primary"
            cx="50%"
            cy={radius + strokeWidth / 2}
            r={radius}
            fill="none"
            strokeWidth={strokeWidth}
            pathLength="100"
            strokeDasharray="100"
            strokeDashoffset={strokeDashoffset}
            strokeLinecap="round"
          />
        </svg>

        {label && size !== "xxs" ? (
          <div className={halfCircleTextPosition}>
            <div className={labelClass}>{label}</div>
            <div className={valueClass}>{valueText}</div>
          </div>
        ) : (
          <span className={cn(halfCircleTextPosition, valueClass)}>{valueText}</span>
        )}
      </div>

      {label && size === "xxs" && <div className={labelClass}>{label}</div>}
    </div>
  );
};
````

## File: src/components/base/progress-indicators/progress-indicators.tsx
````typescript
import { cn } from "@/lib/utils";

export interface ProgressBarProps {
  value: number;
  min?: number;
  max?: number;
  className?: string;
  progressClassName?: string;
  valueFormatter?: (value: number, valueInPercentage: number) => string | number;
}

type ProgressBarLabelPosition = "right" | "bottom" | "top-floating" | "bottom-floating";

export interface ProgressIndicatorWithTextProps extends ProgressBarProps {
  labelPosition?: ProgressBarLabelPosition;
}

function getProgressPercentage(value: number, min: number, max: number) {
  const range = max - min || 1;
  const raw = ((value - min) * 100) / range;
  return Math.min(100, Math.max(0, raw));
}

export const ProgressBarBase = ({ value, min = 0, max = 100, className, progressClassName }: ProgressBarProps) => {
  const percentage = getProgressPercentage(value, min, max);

  return (
    <div
      role="progressbar"
      aria-valuenow={value}
      aria-valuemin={min}
      aria-valuemax={max}
      className={cn("h-2 w-full overflow-hidden rounded-full bg-muted", className)}
    >
      <div
        style={{ transform: `translateX(-${100 - percentage}%)` }}
        className={cn("h-full w-full rounded-full bg-primary transition-transform duration-150 ease-linear", progressClassName)}
      />
    </div>
  );
};

export const ProgressBar = ({
  value,
  min = 0,
  max = 100,
  valueFormatter,
  labelPosition,
  className,
  progressClassName,
}: ProgressIndicatorWithTextProps) => {
  const percentage = getProgressPercentage(value, min, max);
  const formattedValue = valueFormatter ? valueFormatter(value, percentage) : `${percentage.toFixed(0)}%`;
  const label = <span className="shrink-0 text-sm font-medium text-muted-foreground tabular-nums">{formattedValue}</span>;
  const bar = <ProgressBarBase min={min} max={max} value={value} className={className} progressClassName={progressClassName} />;

  if (labelPosition === "right") {
    return (
      <div className="flex items-center gap-3">
        {bar}
        {label}
      </div>
    );
  }

  if (labelPosition === "bottom") {
    return (
      <div className="flex flex-col gap-2">
        {bar}
        <div className="flex justify-end">{label}</div>
      </div>
    );
  }

  if (labelPosition === "top-floating" || labelPosition === "bottom-floating") {
    return (
      <div className="relative">
        {bar}
        <div
          style={{ left: `${percentage}%` }}
          className={cn(
            "absolute -translate-x-1/2 rounded-md border border-border bg-card px-2 py-1 text-xs font-medium text-foreground shadow-sm tabular-nums",
            labelPosition === "top-floating" ? "-top-2 -translate-y-full" : "-bottom-2 translate-y-full",
          )}
        >
          {formattedValue}
        </div>
      </div>
    );
  }

  return bar;
};
````

## File: src/components/base/dialog.tsx
````typescript
export {
  Dialog,
  DialogPortal,
  DialogOverlay,
  DialogClose,
  DialogTrigger,
  DialogContent,
  DialogHeader,
  DialogFooter,
  DialogTitle,
  DialogDescription,
} from "@/components/base/primitives/dialog";
````

## File: src/components/base/drawer.tsx
````typescript
export {
  Drawer,
  DrawerPortal,
  DrawerOverlay,
  DrawerTrigger,
  DrawerClose,
  DrawerContent,
  DrawerHeader,
  DrawerFooter,
  DrawerTitle,
  DrawerDescription,
} from "@/components/base/primitives/drawer";
````

## File: src/components/base/label.tsx
````typescript
export { Label } from "@/components/base/primitives/label";
````

## File: src/components/base/tabs.tsx
````typescript
export { Tabs, TabsList, TabsTrigger, TabsContent } from "@/components/base/primitives/tabs";
````

## File: src/components/base/textarea.tsx
````typescript
export { Textarea } from "@/components/base/primitives/textarea";
````

## File: src/components/fantasy/PFBuilderLayout.tsx
````typescript
import { PFButton } from "@/components/fantasy/PFButton";
import { PFPanel } from "@/components/fantasy/PFPanel";
import { PFQualityGauge } from "@/components/fantasy/PFQualityGauge";

export function PFBuilderLayout() {
    return (
        <div className="grid gap-6 lg:grid-cols-[320px_1fr]">
            <aside className="space-y-4">
                <PFPanel className="p-4">
                    <h3 className="pf-text-display text-lg text-[rgba(230,225,213,.96)]">Forge Settings</h3>
                    <p className="mt-1 text-xs text-[rgba(230,225,213,.68)]">Tune your artifact before final smithing.</p>

                    <div className="mt-4 space-y-3">
                        <label className="block text-xs font-semibold text-[rgba(230,225,213,.75)]">Role</label>
                        <input className="pf-input h-11 w-full px-3 text-sm" placeholder="e.g., Senior Technical PM" />

                        <label className="block text-xs font-semibold text-[rgba(230,225,213,.75)]">Constraints</label>
                        <textarea
                            className="pf-input min-h-24 w-full resize-y px-3 py-2 text-sm"
                            placeholder="Include acceptance criteria, edge cases, and non-goals"
                        />
                    </div>
                </PFPanel>

                <PFPanel className="p-4">
                    <h4 className="text-sm font-bold text-[rgba(230,225,213,.95)]">Quality Signal</h4>
                    <p className="mt-1 text-xs text-[rgba(230,225,213,.7)]">Rarity unlocks as structure and clarity improve.</p>
                    <div className="mt-3">
                        <PFQualityGauge value={78} size={112} />
                    </div>
                </PFPanel>
            </aside>

            <main>
                <PFPanel gilded className="p-4 md:p-5">
                    <div className="flex flex-wrap items-center justify-between gap-3">
                        <h2 className="pf-text-display text-2xl text-[rgba(230,225,213,.95)]">Prompt Builder</h2>
                        <div className="flex items-center gap-2">
                            <PFButton variant="secondary">Preview</PFButton>
                            <PFButton variant="primary">Enhance</PFButton>
                        </div>
                    </div>

                    <div className="mt-3 pf-divider" />

                    <div className="mt-4 grid gap-3">
                        <textarea
                            className="pf-input min-h-52.5 w-full resize-y px-4 py-3 text-sm leading-relaxed"
                            placeholder="Paste or draft your rough prompt here..."
                        />

                        <div className="grid gap-3 sm:grid-cols-3">
                            <input className="pf-input h-11 px-3 text-sm" placeholder="Tone" />
                            <input className="pf-input h-11 px-3 text-sm" placeholder="Format" />
                            <input className="pf-input h-11 px-3 text-sm" placeholder="Audience" />
                        </div>
                    </div>

                    <div className="mt-5 flex flex-wrap items-center gap-2">
                        <PFButton variant="ghost">Arcane</PFButton>
                        <PFButton variant="ghost">Rare</PFButton>
                        <PFButton variant="ghost">Ember</PFButton>
                    </div>
                </PFPanel>
            </main>
        </div>
    );
}
````

## File: src/components/fantasy/PFButton.tsx
````typescript
import type { ButtonHTMLAttributes } from "react";
import { cx } from "@/lib/utils/cx";

export type PFButtonVariant = "primary" | "secondary" | "ghost";

export type PFButtonProps = ButtonHTMLAttributes<HTMLButtonElement> & {
  variant?: PFButtonVariant;
};

export function PFButton({ variant = "primary", className, ...props }: PFButtonProps) {
  const variantClass =
    variant === "primary"
      ? "pf-button-primary"
      : variant === "secondary"
        ? "pf-button-secondary"
        : "pf-button-ghost";

  return <button {...props} className={cx("pf-button", variantClass, className)} />;
}
````

## File: src/components/fantasy/PFPanel.tsx
````typescript
import type { HTMLAttributes } from "react";
import { cx } from "@/lib/utils/cx";

export type PFPanelProps = HTMLAttributes<HTMLDivElement> & {
  gilded?: boolean;
};

export function PFPanel({ gilded = false, className, ...props }: PFPanelProps) {
  return <div {...props} className={cx(gilded ? "pf-gilded-frame" : "pf-panel", className)} />;
}
````

## File: src/components/fantasy/PFQualityGauge.tsx
````typescript
import { useId } from "react";

export type PFQualityGaugeProps = {
  value: number;
  size?: number;
  showLabel?: boolean;
};

type Tier = "Common" | "Rare" | "Epic" | "Legendary";

function clamp(value: number, min: number, max: number): number {
  return Math.max(min, Math.min(max, value));
}

function getTier(value: number): Tier {
  if (value >= 90) return "Legendary";
  if (value >= 70) return "Epic";
  if (value >= 40) return "Rare";
  return "Common";
}

function getTierStroke(tier: Tier): { stroke: string; glow: string } {
  switch (tier) {
    case "Legendary":
      return {
        stroke: "rgb(var(--pf-gold-rgb))",
        glow: "drop-shadow(0 0 18px rgba(214,166,64,.35))",
      };
    case "Epic":
      return {
        stroke: "rgb(var(--pf-ember-rgb))",
        glow: "drop-shadow(0 0 18px rgba(255,122,24,.28))",
      };
    case "Rare":
      return {
        stroke: "rgb(var(--pf-arcane-rgb))",
        glow: "drop-shadow(0 0 18px rgba(18,200,181,.28))",
      };
    default:
      return {
        stroke: "rgb(var(--pf-slate-rgb))",
        glow: "none",
      };
  }
}

export function PFQualityGauge({ value, size = 128, showLabel = true }: PFQualityGaugeProps) {
  const normalizedValue = clamp(value, 0, 100);
  const tier = getTier(normalizedValue);
  const { stroke, glow } = getTierStroke(tier);

  const strokeWidth = Math.max(10, Math.round(size * 0.09));
  const radius = (size - strokeWidth) / 2;
  const circumference = 2 * Math.PI * radius;
  const strokeOffset = circumference * (1 - normalizedValue / 100);

  const gradientId = useId();

  return (
    <div className="flex items-center gap-4">
      <svg width={size} height={size} viewBox={`0 0 ${size} ${size}`} style={{ filter: glow }}>
        <defs>
          <linearGradient id={gradientId} x1="0" y1="0" x2="1" y2="1">
            <stop offset="0%" stopColor="rgba(255,255,255,0.35)" />
            <stop offset="40%" stopColor={stroke} />
            <stop offset="100%" stopColor="rgba(0,0,0,0.35)" />
          </linearGradient>
        </defs>

        <circle
          cx={size / 2}
          cy={size / 2}
          r={radius}
          fill="transparent"
          stroke="rgba(46,58,70,0.65)"
          strokeWidth={strokeWidth}
        />

        <circle
          cx={size / 2}
          cy={size / 2}
          r={radius}
          fill="transparent"
          stroke={`url(#${gradientId})`}
          strokeWidth={strokeWidth}
          strokeLinecap="round"
          strokeDasharray={circumference}
          strokeDashoffset={strokeOffset}
          transform={`rotate(-90 ${size / 2} ${size / 2})`}
        />

        <circle
          cx={size / 2}
          cy={size / 2}
          r={Math.max(18, radius - strokeWidth * 0.75)}
          fill="rgba(11,15,20,0.88)"
          stroke="rgba(214,166,64,0.25)"
        />

        <text
          x="50%"
          y="49%"
          dominantBaseline="middle"
          textAnchor="middle"
          fontSize={Math.round(size * 0.18)}
          fill="rgba(230,225,213,0.95)"
          fontWeight="800"
        >
          {Math.round(normalizedValue)}
        </text>
        <text
          x="50%"
          y="64%"
          dominantBaseline="middle"
          textAnchor="middle"
          fontSize={Math.round(size * 0.085)}
          fill="rgba(230,225,213,0.70)"
          fontWeight="700"
        >
          / 100
        </text>
      </svg>

      {showLabel && (
        <div>
          <div className="text-xs text-[rgba(230,225,213,.65)]">Quality tier</div>
          <div className="mt-1 text-lg font-extrabold text-[rgba(230,225,213,.95)]">{tier}</div>
        </div>
      )}
    </div>
  );
}
````

## File: src/components/fantasy/PFTemplateCard.tsx
````typescript
import { cx } from "@/lib/utils/cx";

export type PFRarity = "common" | "rare" | "epic" | "legendary";

export type PFTemplateCardProps = {
  title: string;
  description: string;
  rarity: PFRarity;
  author?: string;
  tags?: string[];
  footerLeft?: string;
  footerRight?: string;
  onClick?: () => void;
};

const rarityLabel: Record<PFRarity, string> = {
  common: "Common",
  rare: "Rare",
  epic: "Epic",
  legendary: "Legendary",
};

const rarityClass: Record<PFRarity, string> = {
  common: "pf-rarity-common",
  rare: "pf-rarity-rare",
  epic: "pf-rarity-epic",
  legendary: "pf-rarity-legendary",
};

export function PFTemplateCard({
  title,
  description,
  rarity,
  author = "Community",
  tags = [],
  footerLeft = "Recently forged",
  footerRight = "Ready",
  onClick,
}: PFTemplateCardProps) {
  const CardTag = onClick ? "button" : "div";

  return (
    <CardTag
      onClick={onClick}
      className={cx("pf-card w-full p-5 text-left", rarityClass[rarity], onClick && "cursor-pointer")}
    >
      <div className="flex items-start justify-between gap-3">
        <div>
          <div className="text-xs text-[rgba(230,225,213,.65)]">{author}</div>
          <div className="mt-1 text-lg font-extrabold text-[rgba(230,225,213,.96)]">{title}</div>
        </div>

        <span
          className={cx(
            "rounded-full border px-3 py-1 text-xs font-extrabold",
            rarity === "legendary"
              ? "border-[rgba(214,166,64,.65)] bg-[rgba(214,166,64,.08)] text-[rgba(214,166,64,.95)]"
              : rarity === "epic"
                ? "border-[rgba(255,122,24,.55)] bg-[rgba(255,122,24,.08)] text-[rgba(255,170,120,.95)]"
                : rarity === "rare"
                  ? "border-[rgba(18,200,181,.55)] bg-[rgba(18,200,181,.08)] text-[rgba(160,255,242,.95)]"
                  : "border-white/15 bg-white/5 text-[rgba(230,225,213,.78)]",
          )}
        >
          {rarityLabel[rarity]}
        </span>
      </div>

      <p className="mt-3 line-clamp-3 text-sm leading-relaxed text-[rgba(230,225,213,.75)]">
        {description}
      </p>

      {tags.length > 0 && (
        <div className="mt-4 flex flex-wrap gap-2">
          {tags.slice(0, 4).map((tag) => (
            <span
              key={tag}
              className="rounded-full border border-white/10 bg-black/25 px-3 py-1 text-xs font-semibold text-[rgba(230,225,213,.70)]"
            >
              #{tag}
            </span>
          ))}
        </div>
      )}

      <div className="mt-5 pf-divider" />

      <div className="mt-3 flex items-center justify-between text-xs text-[rgba(230,225,213,.6)]">
        <span>{footerLeft}</span>
        <span>{footerRight}</span>
      </div>
    </CardTag>
  );
}
````

## File: src/components/foundations/logo/untitledui-logo-minimal.tsx
````typescript
import type { SVGProps } from "react";
import { useId } from "react";
import { cx } from "@/lib/utils/cx";

export const UntitledLogoMinimal = (props: SVGProps<SVGSVGElement>) => {
    const id = useId();

    return (
        <svg viewBox="0 0 38 38" fill="none" {...props} className={cx("size-8 origin-center scale-[1.2]", props.className)}>
            <g filter={`url(#filter0-${id}`}>
                <g clipPath={`url(#clip0-${id}`}>
                    <path
                        d="M3 14.8C3 10.3196 3 8.07937 3.87195 6.36808C4.63893 4.86278 5.86278 3.63893 7.36808 2.87195C9.07937 2 11.3196 2 15.8 2H22.2C26.6804 2 28.9206 2 30.6319 2.87195C32.1372 3.63893 33.3611 4.86278 34.1281 6.36808C35 8.07937 35 10.3196 35 14.8V21.2C35 25.6804 35 27.9206 34.1281 29.6319C33.3611 31.1372 32.1372 32.3611 30.6319 33.1281C28.9206 34 26.6804 34 22.2 34H15.8C11.3196 34 9.07937 34 7.36808 33.1281C5.86278 32.3611 4.63893 31.1372 3.87195 29.6319C3 27.9206 3 25.6804 3 21.2V14.8Z"
                        fill="white"
                    />
                    <path
                        d="M3 14.8C3 10.3196 3 8.07937 3.87195 6.36808C4.63893 4.86278 5.86278 3.63893 7.36808 2.87195C9.07937 2 11.3196 2 15.8 2H22.2C26.6804 2 28.9206 2 30.6319 2.87195C32.1372 3.63893 33.3611 4.86278 34.1281 6.36808C35 8.07937 35 10.3196 35 14.8V21.2C35 25.6804 35 27.9206 34.1281 29.6319C33.3611 31.1372 32.1372 32.3611 30.6319 33.1281C28.9206 34 26.6804 34 22.2 34H15.8C11.3196 34 9.07937 34 7.36808 33.1281C5.86278 32.3611 4.63893 31.1372 3.87195 29.6319C3 27.9206 3 25.6804 3 21.2V14.8Z"
                        fill={`url(#paint0_linear-${id}`}
                        fillOpacity="0.2"
                    />
                    <g opacity="0.14" clipPath={`url(#clip1-${id}`}>
                        <path
                            fillRule="evenodd"
                            clipRule="evenodd"
                            d="M18.9612 2H19.0388V3.96123C20.8929 3.96625 22.6625 4.33069 24.2816 4.98855V2H24.3592V5.02038C25.7339 5.58859 26.9986 6.36882 28.1126 7.32031H29.602V2H29.6796V7.32031H35V7.39798H29.6796V8.88728C30.6311 10.0013 31.4113 11.266 31.9796 12.6406H35V12.7183H32.0114C32.6693 14.3373 33.0337 16.1069 33.0388 17.9609H35V18.0386H33.0388C33.0338 19.8927 32.6694 21.6622 32.0116 23.2812H35V23.3589H31.9798C31.4115 24.7337 30.6312 25.9986 29.6796 27.1128V28.6016H35V28.6792H29.6796V34H29.602V28.6792H28.1132C26.999 29.6309 25.7341 30.4113 24.3592 30.9797V34H24.2816V31.0115C22.6625 31.6693 20.8929 32.0338 19.0388 32.0388V34H18.9612V32.0388C17.1071 32.0338 15.3375 31.6693 13.7184 31.0115V34H13.6408V30.9797C12.2659 30.4113 11.001 29.6309 9.88678 28.6792H8.39804V34H8.32037V28.6792H3V28.6016H8.32037V27.1128C7.36877 25.9986 6.58847 24.7337 6.02023 23.3589H3V23.2812H5.9884C5.3306 21.6622 4.96621 19.8927 4.96122 18.0386H3V17.9609H4.96122C4.96627 16.1069 5.33073 14.3373 5.9886 12.7183H3V12.6406H6.02044C6.58866 11.266 7.36889 10.0013 8.32037 8.88728V7.39798H3V7.32031H8.32037V2H8.39804V7.32031H9.88736C11.0014 6.36882 12.2661 5.58859 13.6408 5.02038V2H13.7184V4.98855C15.3375 4.33069 17.1071 3.96626 18.9612 3.96123V2ZM18.9612 4.0389C17.1062 4.04396 15.3364 4.41075 13.7184 5.07245V7.32031H18.9612V4.0389ZM13.6408 5.10449C12.3137 5.65662 11.0902 6.40763 10.0074 7.32031H13.6408V5.10449ZM9.79719 7.39798H8.39804V8.79711C8.8311 8.29865 9.29872 7.83103 9.79719 7.39798ZM8.39804 8.91598C8.86452 8.37206 9.37213 7.86446 9.91606 7.39798H13.6408V12.6406H8.39804V8.91598ZM8.32037 9.00733C7.4077 10.0901 6.65669 11.3136 6.10454 12.6406H8.32037V9.00733ZM6.0725 12.7183C5.41078 14.3362 5.04397 16.106 5.03889 17.9609H8.32037V12.7183H6.0725ZM5.03889 18.0386C5.04391 19.8935 5.41065 21.6633 6.0723 23.2812H8.32037V18.0386H5.03889ZM6.10434 23.3589C6.6565 24.6861 7.40759 25.9098 8.32037 26.9927V23.3589H6.10434ZM8.39804 27.2029V28.6016H9.79662C9.29837 28.1686 8.83093 27.7012 8.39804 27.2029ZM9.91548 28.6016C9.37178 28.1352 8.86436 27.6278 8.39804 27.0841V23.3589H13.6408V28.6016H9.91548ZM10.0068 28.6792C11.0898 29.5921 12.3135 30.3433 13.6408 30.8955V28.6792H10.0068ZM13.7184 30.9276C15.3364 31.5893 17.1062 31.9561 18.9612 31.9611V28.6792H13.7184V30.9276ZM19.0388 31.9611C20.8937 31.9561 22.6636 31.5893 24.2816 30.9276V28.6792H19.0388V31.9611ZM24.3592 30.8955C25.6865 30.3433 26.9102 29.5921 27.9932 28.6792H24.3592V30.8955ZM28.2034 28.6016H29.602V27.2029C29.1691 27.7012 28.7016 28.1686 28.2034 28.6016ZM29.602 27.0841C29.1356 27.6278 28.6282 28.1352 28.0845 28.6016H24.3592V23.3589H29.602V27.0841ZM29.6796 26.9927C30.5924 25.9098 31.3435 24.6861 31.8957 23.3589H29.6796V26.9927ZM31.9277 23.2812C32.5894 21.6633 32.9561 19.8935 32.9611 18.0386H29.6796V23.2812H31.9277ZM32.9611 17.9609C32.956 16.1061 32.5892 14.3362 31.9275 12.7183H29.6796V17.9609H32.9611ZM31.8955 12.6406C31.3433 11.3136 30.5923 10.0901 29.6796 9.00733V12.6406H31.8955ZM29.602 8.79711V7.39798H28.2028C28.7013 7.83103 29.1689 8.29865 29.602 8.79711ZM28.0839 7.39798C28.6279 7.86446 29.1355 8.37206 29.602 8.91598V12.6406H24.3592V7.39798H28.0839ZM27.9926 7.32031C26.9098 6.40763 25.6863 5.65662 24.3592 5.10449V7.32031H27.9926ZM24.2816 5.07245C22.6636 4.41074 20.8937 4.04395 19.0388 4.0389V7.32031H24.2816V5.07245ZM13.7184 7.39798H18.9612V12.6406H13.7184V7.39798ZM24.2816 7.39798H19.0388V12.6406H24.2816V7.39798ZM13.6408 23.2812H8.39804V18.0386H13.6408V23.2812ZM13.7184 23.3589V28.6016H18.9612V23.3589H13.7184ZM18.9612 23.2812H13.7184V18.0386H18.9612V23.2812ZM19.0388 23.3589V28.6016H24.2816V23.3589H19.0388ZM24.2816 23.2812H19.0388V18.0386H24.2816V23.2812ZM29.602 23.2812H24.3592V18.0386H29.602V23.2812ZM13.7184 12.7183H18.9612V17.9609H13.7184V12.7183ZM8.39804 12.7183L13.6408 12.7183V17.9609H8.39804V12.7183ZM24.2816 12.7183H19.0388V17.9609H24.2816V12.7183ZM24.3592 17.9609V12.7183L29.602 12.7183V17.9609H24.3592Z"
                            fill="#0A0D12"
                        />
                    </g>
                    <g filter={`url(#filter1_dd-${id}`}>
                        <rect x="11" y="10" width="16" height="16" rx="8" fill={`url(#paint1_linear-${id}`} />
                        <rect x="11" y="10" width="16" height="16" rx="8" fill={`url(#paint2_radial-${id}`} fillOpacity="0.08" />
                        <rect x="11" y="10" width="16" height="16" rx="8" fill={`url(#paint3_radial-${id}`} fillOpacity="0.18" />
                        <rect x="11" y="10" width="16" height="16" rx="8" fill={`url(#paint4_radial-${id}`} fillOpacity="0.05" />
                        <path
                            d="M23.8 14.0414C23.8 15.3898 21.651 14.5297 19 14.5297C16.349 14.5297 14.2 15.3898 14.2 14.0414C14.2 12.693 16.349 11.6 19 11.6C21.651 11.6 23.8 12.693 23.8 14.0414Z"
                            fill={`url(#paint5_linear-${id}`}
                            fillOpacity="0.4"
                        />
                    </g>
                </g>
                <path
                    d="M3.1 14.8C3.1 12.5581 3.10008 10.8828 3.20866 9.55376C3.31715 8.22593 3.53345 7.25268 3.96105 6.41348C4.71845 4.92699 5.92699 3.71845 7.41348 2.96105C8.25268 2.53345 9.22593 2.31715 10.5538 2.20866C11.8828 2.10008 13.5581 2.1 15.8 2.1H22.2C24.4419 2.1 26.1172 2.10008 27.4462 2.20866C28.7741 2.31715 29.7473 2.53345 30.5865 2.96105C32.073 3.71845 33.2816 4.92699 34.039 6.41348C34.4665 7.25268 34.6828 8.22593 34.7913 9.55376C34.8999 10.8828 34.9 12.5581 34.9 14.8V21.2C34.9 23.4419 34.8999 25.1172 34.7913 26.4462C34.6828 27.7741 34.4665 28.7473 34.039 29.5865C33.2816 31.073 32.073 32.2816 30.5865 33.039C29.7473 33.4665 28.7741 33.6828 27.4462 33.7913C26.1172 33.8999 24.4419 33.9 22.2 33.9H15.8C13.5581 33.9 11.8828 33.8999 10.5538 33.7913C9.22593 33.6828 8.25268 33.4665 7.41348 33.039C5.92699 32.2816 4.71845 31.073 3.96105 29.5865C3.53345 28.7473 3.31715 27.7741 3.20866 26.4462C3.10008 25.1172 3.1 23.4419 3.1 21.2V14.8Z"
                    stroke="#0A0D12"
                    strokeOpacity="0.12"
                    strokeWidth="0.2"
                />
            </g>
            <image
                href="data:image/webp;base64,UklGRoYHAABXRUJQVlA4WAoAAAAQAAAA..."
                x="0"
                y="19"
                width="38"
                height="19"
                transform="scale(0.84) translate(0, -1.5)"
                className="origin-center"
                preserveAspectRatio="xMidYMax slice"
                clipPath={`url(#imageClip-${id})`}
            />

            <defs>
                <clipPath id={`imageClip-${id}`}>
                    <path d="M 0 19 L 38 19 L 38 28.88  A 9.12 9.12 0 0 1 28.88 38 L 9.12 38 A 9.12 9.12 0 0 1 0 28.88 Z" />
                </clipPath>
                <filter id={`filter0-${id}`} x="0" y="0" width="38" height="38" filterUnits="userSpaceOnUse" colorInterpolationFilters="sRGB">
                    <feFlood floodOpacity="0" result="BackgroundImageFix" />
                    <feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha" />
                    <feOffset dy="1" />
                    <feGaussianBlur stdDeviation="1" />
                    <feColorMatrix type="matrix" values="0 0 0 0 0.0392157 0 0 0 0 0.0509804 0 0 0 0 0.0705882 0 0 0 0.06 0" />
                    <feBlend mode="normal" in2="BackgroundImageFix" result="effect1_dropShadow" />
                    <feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha" />
                    <feOffset dy="1" />
                    <feGaussianBlur stdDeviation="1.5" />
                    <feColorMatrix type="matrix" values="0 0 0 0 0.0392157 0 0 0 0 0.0509804 0 0 0 0 0.0705882 0 0 0 0.1 0" />
                    <feBlend mode="normal" in2="effect1_dropShadow" result="effect2_dropShadow" />
                    <feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha" />
                    <feMorphology radius="0.5" operator="erode" in="SourceAlpha" result="effect3_dropShadow" />
                    <feOffset dy="1" />
                    <feGaussianBlur stdDeviation="0.5" />
                    <feComposite in2="hardAlpha" operator="out" />
                    <feColorMatrix type="matrix" values="0 0 0 0 0.0392157 0 0 0 0 0.0509804 0 0 0 0 0.0705882 0 0 0 0.13 0" />
                    <feBlend mode="normal" in2="effect2_dropShadow" result="effect3_dropShadow" />
                    <feBlend mode="normal" in="SourceGraphic" in2="effect3_dropShadow" result="shape" />
                    <feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha" />
                    <feOffset dy="-0.5" />
                    <feGaussianBlur stdDeviation="0.25" />
                    <feComposite in2="hardAlpha" operator="arithmetic" k2="-1" k3="1" />
                    <feColorMatrix type="matrix" values="0 0 0 0 0.0392157 0 0 0 0 0.0509804 0 0 0 0 0.0705882 0 0 0 0.1 0" />
                    <feBlend mode="normal" in2="shape" result="effect4_innerShadow" />
                </filter>
                <filter id={`filter1_dd-${id}`} x="8" y="8" width="22" height="22" filterUnits="userSpaceOnUse" colorInterpolationFilters="sRGB">
                    <feFlood floodOpacity="0" result="BackgroundImageFix" />
                    <feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha" />
                    <feOffset dy="1" />
                    <feGaussianBlur stdDeviation="1" />
                    <feColorMatrix type="matrix" values="0 0 0 0 0.0392157 0 0 0 0 0.0509804 0 0 0 0 0.0705882 0 0 0 0.06 0" />
                    <feBlend mode="normal" in2="BackgroundImageFix" result="effect1_dropShadow" />
                    <feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha" />
                    <feOffset dy="1" />
                    <feGaussianBlur stdDeviation="1.5" />
                    <feColorMatrix type="matrix" values="0 0 0 0 0.0392157 0 0 0 0 0.0509804 0 0 0 0 0.0705882 0 0 0 0.1 0" />
                    <feBlend mode="normal" in2="effect1_dropShadow" result="effect2_dropShadow" />
                    <feBlend mode="normal" in="SourceGraphic" in2="effect2_dropShadow" result="shape" />
                </filter>
                <filter id={`filter2_b-${id}`} x="-2" y="13" width="42" height="26" filterUnits="userSpaceOnUse" colorInterpolationFilters="sRGB">
                    <feFlood floodOpacity="0" result="BackgroundImageFix" />
                    <feGaussianBlur in="BackgroundImageFix" stdDeviation="2.5" />
                    <feComposite in2="SourceAlpha" operator="in" result="effect1_backgroundBlur" />
                    <feBlend mode="normal" in="SourceGraphic" in2="effect1_backgroundBlur" result="shape" />
                </filter>
                <linearGradient id={`paint0_linear-${id}`} x1="19" y1="2" x2="19" y2="34" gradientUnits="userSpaceOnUse">
                    <stop stopColor="white" />
                    <stop offset="1" stopColor="#0A0D12" />
                </linearGradient>
                <linearGradient id={`paint1_linear-${id}`} x1="15" y1="26" x2="23" y2="10" gradientUnits="userSpaceOnUse">
                    <stop stopColor="#53389E" />
                    <stop offset="1" stopColor="#6941C6" />
                </linearGradient>
                <radialGradient
                    id={`paint2_radial-${id}`}
                    cx="0"
                    cy="0"
                    r="1"
                    gradientUnits="userSpaceOnUse"
                    gradientTransform="translate(19 10) rotate(90) scale(12)"
                >
                    <stop stopColor="white" stopOpacity="0" />
                    <stop offset="0.5" stopColor="white" stopOpacity="0" />
                    <stop offset="0.99" stopColor="white" />
                    <stop offset="1" stopColor="white" stopOpacity="0" />
                </radialGradient>
                <radialGradient
                    id={`paint3_radial-${id}`}
                    cx="0"
                    cy="0"
                    r="1"
                    gradientUnits="userSpaceOnUse"
                    gradientTransform="translate(19 18) rotate(90) scale(8)"
                >
                    <stop offset="0.746599" stopColor="white" stopOpacity="0" />
                    <stop offset="1" stopColor="white" />
                </radialGradient>
                <radialGradient
                    id={`paint4_radial-${id}`}
                    cx="0"
                    cy="0"
                    r="1"
                    gradientUnits="userSpaceOnUse"
                    gradientTransform="translate(19 14.6) rotate(90) scale(7)"
                >
                    <stop stopColor="white" />
                    <stop offset="1" stopColor="white" stopOpacity="0" />
                </radialGradient>
                <linearGradient id={`paint5_linear-${id}`} x1="19" y1="11.6" x2="19" y2="14.8" gradientUnits="userSpaceOnUse">
                    <stop stopColor="white" />
                    <stop offset="1" stopColor="white" stopOpacity="0.1" />
                </linearGradient>
                <clipPath id={`clip0-${id}`}>
                    <path
                        d="M3 14.8C3 10.3196 3 8.07937 3.87195 6.36808C4.63893 4.86278 5.86278 3.63893 7.36808 2.87195C9.07937 2 11.3196 2 15.8 2H22.2C26.6804 2 28.9206 2 30.6319 2.87195C32.1372 3.63893 33.3611 4.86278 34.1281 6.36808C35 8.07937 35 10.3196 35 14.8V21.2C35 25.6804 35 27.9206 34.1281 29.6319C33.3611 31.1372 32.1372 32.3611 30.6319 33.1281C28.9206 34 26.6804 34 22.2 34H15.8C11.3196 34 9.07937 34 7.36808 33.1281C5.86278 32.3611 4.63893 31.1372 3.87195 29.6319C3 27.9206 3 25.6804 3 21.2V14.8Z"
                        fill="white"
                    />
                </clipPath>
                <clipPath id={`clip1-${id}`}>
                    <rect width="32" height="32" fill="white" transform="translate(3 2)" />
                </clipPath>
            </defs>
        </svg>
    );
};
````

## File: src/components/foundations/logo/untitledui-logo.tsx
````typescript
import type { HTMLAttributes } from "react";
import { cx } from "@/lib/utils/cx";
import { UntitledLogoMinimal } from "./untitledui-logo-minimal";

export const UntitledLogo = (props: HTMLAttributes<HTMLOrSVGElement>) => {
    return (
        <div {...props} className={cx("flex h-8 w-max items-center justify-start overflow-visible", props.className)}>
            {/* Minimal logo */}
            <UntitledLogoMinimal className="aspect-square h-full w-auto shrink-0" />

            {/* Gap that adjusts to the height of the container */}
            <div className="aspect-[0.3] h-full" />

            {/* Logomark */}
            <svg viewBox="0 0 97 32" fill="none" className="aspect-[3] h-full shrink-0">
                <path
                    d="M33.9101 10.2372C34.2321 10.5355 34.6179 10.6847 35.0678 10.6847C35.5176 10.6847 35.9011 10.5355 36.2183 10.2372C36.5403 9.9342 36.7013 9.57199 36.7013 9.15058C36.7013 8.73392 36.5403 8.37644 36.2183 8.07814C35.9011 7.77511 35.5176 7.6236 35.0678 7.6236C34.6179 7.6236 34.2321 7.77511 33.9101 8.07814C33.5928 8.37644 33.4342 8.73392 33.4342 9.15058C33.4342 9.57199 33.5928 9.9342 33.9101 10.2372Z"
                    className="fill-fg-primary"
                />
                <path
                    d="M11.2997 20.6847C11.8063 19.8892 12.0597 18.9612 12.0597 17.9006V8.45456H8.98438V17.6378C8.98438 18.1918 8.86127 18.6842 8.61506 19.1151C8.37358 19.5459 8.0303 19.8845 7.58523 20.1307C7.14489 20.3769 6.62642 20.5 6.02983 20.5C5.43797 20.5 4.91951 20.3769 4.47443 20.1307C4.02936 19.8845 3.68371 19.5459 3.4375 19.1151C3.19602 18.6842 3.07528 18.1918 3.07528 17.6378V8.45456H0V17.9006C0 18.9612 0.250947 19.8892 0.752841 20.6847C1.25473 21.4801 1.95786 22.1004 2.86222 22.5455C3.76657 22.9858 4.82244 23.206 6.02983 23.206C7.23248 23.206 8.28599 22.9858 9.19034 22.5455C10.0947 22.1004 10.7978 21.4801 11.2997 20.6847Z"
                    className="fill-fg-primary"
                />
                <path
                    d="M18.3589 12.51C17.7907 12.8793 17.3859 13.3812 17.1444 14.0156H17.0165V12.0909H14.133V23H17.1586V16.6932C17.1633 16.2244 17.2509 15.8244 17.4214 15.4929C17.5966 15.1567 17.838 14.9011 18.1458 14.7259C18.4583 14.5507 18.8182 14.4631 19.2254 14.4631C19.8314 14.4631 20.3073 14.6525 20.6529 15.0313C20.9986 15.4053 21.169 15.9262 21.1643 16.5938V23H24.1898V16.054C24.1898 15.2065 24.0336 14.4773 23.7211 13.8665C23.4086 13.251 22.9706 12.7775 22.4072 12.446C21.8437 12.1146 21.1832 11.9489 20.4256 11.9489C19.616 11.9489 18.9271 12.1359 18.3589 12.51Z"
                    className="fill-fg-primary"
                />
                <path
                    d="M27.3463 21.821C27.0433 21.3523 26.8941 20.7604 26.8989 20.0455V14.3637H25.4074V12.0909H26.8989V9.47729H29.9244V12.0909H31.977V14.3637H29.9244V19.6477C29.9244 19.9271 29.967 20.1449 30.0523 20.3012C30.1375 20.4527 30.2559 20.5592 30.4074 20.6208C30.5636 20.6823 30.7436 20.7131 30.9472 20.7131C31.0892 20.7131 31.2313 20.7012 31.3733 20.6776C31.5153 20.6492 31.6242 20.6279 31.7 20.6137L32.1759 22.8651C32.0243 22.9124 31.8113 22.9669 31.5366 23.0284C31.262 23.0947 30.9282 23.135 30.5352 23.1492C29.8061 23.1776 29.1669 23.0805 28.6176 22.858C28.0731 22.6354 27.6493 22.2898 27.3463 21.821Z"
                    className="fill-fg-primary"
                />
                <path
                    d="M39.769 21.821C39.4659 21.3523 39.3168 20.7604 39.3215 20.0455V14.3637H37.83V12.0909H39.3215V9.47729H42.3471V12.0909H44.3996V14.3637H42.3471V19.6477C42.3471 19.9271 42.3897 20.1449 42.4749 20.3012C42.5602 20.4527 42.6785 20.5592 42.83 20.6208C42.9863 20.6823 43.1662 20.7131 43.3698 20.7131C43.5119 20.7131 43.6539 20.7012 43.796 20.6776C43.938 20.6492 44.0469 20.6279 44.1227 20.6137L44.5985 22.8651C44.447 22.9124 44.2339 22.9669 43.9593 23.0284C43.6847 23.0947 43.3509 23.135 42.9579 23.1492C42.2287 23.1776 41.5895 23.0805 41.0403 22.858C40.4958 22.6354 40.072 22.2898 39.769 21.821Z"
                    className="fill-fg-primary"
                />
                <path
                    fillRule="evenodd"
                    clipRule="evenodd"
                    d="M56.2257 23.2131C55.1035 23.2131 54.1376 22.9858 53.328 22.5313C52.5231 22.072 51.9028 21.4233 51.4672 20.5852C51.0316 19.7424 50.8138 18.7458 50.8138 17.5952C50.8138 16.473 51.0316 15.4882 51.4672 14.6406C51.9028 13.7931 52.516 13.1326 53.3067 12.6591C54.1021 12.1856 55.0349 11.9489 56.105 11.9489C56.8247 11.9489 57.4946 12.0649 58.1149 12.2969C58.7399 12.5242 59.2844 12.8674 59.7484 13.3267C60.2172 13.786 60.5818 14.3637 60.8422 15.0597C61.1026 15.751 61.2328 16.5606 61.2328 17.4887V18.3196H53.8038V18.3267C53.8038 18.8665 53.9033 19.3329 54.1021 19.7259C54.3057 20.1189 54.5922 20.4219 54.9615 20.635C55.3308 20.848 55.7688 20.9546 56.2754 20.9546C56.6116 20.9546 56.9194 20.9072 57.1987 20.8125C57.4781 20.7178 57.7172 20.5758 57.916 20.3864C58.1149 20.197 58.2664 19.965 58.3706 19.6904L61.1689 19.875C61.0268 20.5474 60.7357 21.1345 60.2953 21.6364C59.8597 22.1335 59.2963 22.5218 58.605 22.8012C57.9184 23.0758 57.1253 23.2131 56.2257 23.2131ZM54.1092 15.3722C53.9258 15.6954 53.8249 16.0529 53.8067 16.4446H58.3848C58.3848 16.009 58.2901 15.6231 58.1007 15.2869C57.9113 14.9508 57.6485 14.688 57.3124 14.4986C56.9809 14.3045 56.595 14.2074 56.1547 14.2074C55.6954 14.2074 55.2882 14.3139 54.9331 14.527C54.5827 14.7353 54.3081 15.0171 54.1092 15.3722Z"
                    className="fill-fg-primary"
                />
                <path
                    fillRule="evenodd"
                    clipRule="evenodd"
                    d="M64.5757 22.5384C65.2481 22.9645 65.9985 23.1776 66.8271 23.1776C67.4143 23.1776 67.9114 23.0805 68.3186 22.8864C68.7305 22.6923 69.0643 22.4484 69.32 22.1548C69.5804 21.8566 69.7817 21.5559 69.9237 21.2529H70.0516V23H73.0345V8.45456H70.0161V13.9233H69.9237C69.7911 13.6298 69.597 13.3315 69.3413 13.0284C69.0904 12.7207 68.7589 12.465 68.347 12.2614C67.9398 12.053 67.4308 11.9489 66.82 11.9489C66.0198 11.9489 65.2836 12.1572 64.6112 12.5739C63.9436 12.9858 63.4086 13.6084 63.0061 14.4418C62.6036 15.2704 62.4024 16.3097 62.4024 17.5597C62.4024 18.7765 62.5965 19.804 62.9848 20.6421C63.3778 21.4754 63.9081 22.1075 64.5757 22.5384ZM69.0217 20.3722C68.6856 20.6373 68.2736 20.7699 67.7859 20.7699C67.2888 20.7699 66.8698 20.635 66.5288 20.3651C66.1927 20.0905 65.9346 19.7117 65.7547 19.2287C65.5795 18.741 65.4919 18.1799 65.4919 17.5455C65.4919 16.9157 65.5795 16.3618 65.7547 15.8835C65.9299 15.4053 66.1879 15.0313 66.5288 14.7614C66.8698 14.4915 67.2888 14.3566 67.7859 14.3566C68.2736 14.3566 68.6879 14.4868 69.0288 14.7472C69.3698 15.0076 69.6302 15.3769 69.8101 15.8551C69.99 16.3334 70.08 16.8968 70.08 17.5455C70.08 18.1941 69.9876 18.76 69.803 19.2429C69.6231 19.7259 69.3626 20.1023 69.0217 20.3722Z"
                    className="fill-fg-primary"
                />
                <path
                    d="M88.0229 19.1151C88.2691 18.6842 88.3922 18.1918 88.3922 17.6378V8.45456H91.4675V17.9006C91.4675 18.9612 91.2142 19.8892 90.7075 20.6847C90.2056 21.4801 89.5025 22.1004 88.5982 22.5455C87.6938 22.9858 86.6403 23.206 85.4376 23.206C84.2303 23.206 83.1744 22.9858 82.27 22.5455C81.3657 22.1004 80.6625 21.4801 80.1607 20.6847C79.6588 19.8892 79.4078 18.9612 79.4078 17.9006V8.45456H82.4831V17.6378C82.4831 18.1918 82.6038 18.6842 82.8453 19.1151C83.0915 19.5459 83.4372 19.8845 83.8822 20.1307C84.3273 20.3769 84.8458 20.5 85.4376 20.5C86.0342 20.5 86.5527 20.3769 86.993 20.1307C87.4381 19.8845 87.7814 19.5459 88.0229 19.1151Z"
                    className="fill-fg-primary"
                />
                <path d="M33.5479 12.0909V23H36.5734V12.0909H33.5479Z" className="fill-fg-primary" />
                <path d="M49.2305 23V8.45456H46.2049V23H49.2305Z" className="fill-fg-primary" />
                <path d="M96.6729 23V8.45456H93.5977V23H96.6729Z" className="fill-fg-primary" />
            </svg>
        </div>
    );
};
````

## File: src/components/foundations/payment-icons/amex-icon.tsx
````typescript
import type { SVGProps } from "react";

const AmexIcon = (props: SVGProps<SVGSVGElement>) => {
    return (
        <svg width="34" height="24" viewBox="0 0 34 24" fill="none" {...props}>
            <path d="M0 4C0 1.79086 1.79086 0 4 0H30C32.2091 0 34 1.79086 34 4V20C34 22.2091 32.2091 24 30 24H4C1.79086 24 0 22.2091 0 20V4Z" fill="#1F72CD" />
            <path
                fillRule="evenodd"
                clipRule="evenodd"
                d="M6.09517 8.5L2.91406 15.7467H6.7223L7.19441 14.5913H8.27355L8.74566 15.7467H12.9375V14.8649L13.311 15.7467H15.4793L15.8528 14.8462V15.7467H24.5706L25.6307 14.6213L26.6232 15.7467L31.1009 15.7561L27.9097 12.1436L31.1009 8.5H26.6927L25.6608 9.60463L24.6995 8.5H15.2156L14.4013 10.3704L13.5678 8.5H9.7675V9.35186L9.34474 8.5H6.09517ZM6.83205 9.52905H8.68836L10.7984 14.4431V9.52905H12.8319L14.4617 13.0524L15.9637 9.52905H17.987V14.7291H16.7559L16.7458 10.6544L14.9509 14.7291H13.8495L12.0446 10.6544V14.7291H9.51179L9.03162 13.5633H6.43745L5.95827 14.728H4.60123L6.83205 9.52905ZM24.1196 9.52905H19.1134V14.726H24.0421L25.6307 13.0036L27.1618 14.726H28.7624L26.436 12.1426L28.7624 9.52905H27.2313L25.6507 11.2316L24.1196 9.52905ZM7.73508 10.4089L6.8804 12.4856H8.58876L7.73508 10.4089ZM20.3497 11.555V10.6057V10.6048H23.4734L24.8364 12.1229L23.413 13.6493H20.3497V12.613H23.0808V11.555H20.3497Z"
                fill="white"
            />
        </svg>
    );
};

export default AmexIcon;
````

## File: src/components/foundations/payment-icons/apple-pay-icon.tsx
````typescript
import type { SVGProps } from "react";

const ApplePayIcon = (props: SVGProps<SVGSVGElement>) => {
    return (
        <svg width="34" height="24" viewBox="0 0 34 24" fill="none" {...props}>
            <path
                d="M0.5 4C0.5 2.067 2.067 0.5 4 0.5H30C31.933 0.5 33.5 2.067 33.5 4V20C33.5 21.933 31.933 23.5 30 23.5H4C2.067 23.5 0.5 21.933 0.5 20V4Z"
                fill="white"
            />
            <path
                d="M0.5 4C0.5 2.067 2.067 0.5 4 0.5H30C31.933 0.5 33.5 2.067 33.5 4V20C33.5 21.933 31.933 23.5 30 23.5H4C2.067 23.5 0.5 21.933 0.5 20V4Z"
                className="stroke-border-secondary"
                strokeWidth="0.75"
            />
            <path
                fillRule="evenodd"
                clipRule="evenodd"
                d="M9.44921 8.34316C9.16382 8.69506 8.70721 8.97261 8.2506 8.93296C8.19353 8.45715 8.41707 7.95161 8.67867 7.63936C8.96406 7.27755 9.46348 7.01983 9.86777 7C9.91533 7.49563 9.72983 7.98135 9.44921 8.34316ZM9.86297 9.02712C9.46071 9.003 9.09366 9.15319 8.79718 9.2745C8.60639 9.35256 8.44483 9.41867 8.32191 9.41867C8.18397 9.41867 8.01574 9.34903 7.82685 9.27084L7.82685 9.27084C7.57935 9.16838 7.29638 9.05124 6.99964 9.05686C6.31948 9.06677 5.68688 9.46823 5.33967 10.1076C4.62621 11.3863 5.15417 13.2796 5.84384 14.3205C6.18155 14.8359 6.58584 15.4009 7.11855 15.3811C7.35291 15.3719 7.5215 15.2973 7.69597 15.2202C7.89683 15.1314 8.10549 15.0391 8.43131 15.0391C8.74582 15.0391 8.94536 15.129 9.1369 15.2152C9.31903 15.2973 9.49393 15.376 9.75358 15.3712C10.3053 15.3613 10.6525 14.8557 10.9902 14.3403C11.3547 13.7871 11.5148 13.2471 11.5391 13.1652L11.542 13.1557C11.5414 13.1551 11.5369 13.153 11.5289 13.1492C11.4071 13.0911 10.476 12.6469 10.467 11.4557C10.4581 10.4559 11.2056 9.94935 11.3233 9.86961L11.3233 9.8696C11.3304 9.86476 11.3353 9.86149 11.3374 9.85978C10.8618 9.12625 10.1198 9.04695 9.86297 9.02712ZM13.6824 15.3167V7.5898H16.4649C17.9013 7.5898 18.9049 8.62071 18.9049 10.1274C18.9049 11.6341 17.8822 12.675 16.4268 12.675H14.8334V15.3167H13.6824ZM14.8333 8.60088H16.1603C17.1592 8.60088 17.7299 9.15599 17.7299 10.1324C17.7299 11.1088 17.1592 11.6688 16.1556 11.6688H14.8333V8.60088ZM22.7053 14.3898C22.4009 14.9945 21.7302 15.3761 21.0072 15.3761C19.9371 15.3761 19.1903 14.712 19.1903 13.7108C19.1903 12.7196 19.9133 12.1496 21.2498 12.0653L22.6862 11.9761V11.5499C22.6862 10.9204 22.2915 10.5784 21.5875 10.5784C21.0072 10.5784 20.5839 10.8907 20.4983 11.3665H19.4614C19.4947 10.3653 20.3984 9.63675 21.6208 9.63675C22.9383 9.63675 23.7945 10.3554 23.7945 11.4706V15.3167H22.729V14.3898H22.7053ZM21.3163 14.4592C20.7027 14.4592 20.3127 14.1519 20.3127 13.6811C20.3127 13.1954 20.6885 12.9129 21.4067 12.8683L22.6861 12.784V13.2202C22.6861 13.9438 22.0964 14.4592 21.3163 14.4592ZM27.3284 15.619C26.867 16.9721 26.3391 17.4181 25.2166 17.4181C25.131 17.4181 24.8456 17.4082 24.779 17.3884V16.4616C24.8503 16.4715 25.0263 16.4814 25.1167 16.4814C25.6256 16.4814 25.911 16.2584 26.087 15.6785L26.1916 15.3365L24.2415 9.7111H25.4449L26.8004 14.2759H26.8242L28.1798 9.7111H29.3499L27.3284 15.619Z"
                fill="black"
            />
        </svg>
    );
};

export default ApplePayIcon;
````

## File: src/components/foundations/payment-icons/discover-icon.tsx
````typescript
import type { SVGProps } from "react";

const DiscoverIcon = (props: SVGProps<SVGSVGElement>) => {
    return (
        <svg width="34" height="24" viewBox="0 0 34 24" fill="none" {...props}>
            <path
                d="M0.5 4C0.5 2.067 2.067 0.5 4 0.5H30C31.933 0.5 33.5 2.067 33.5 4V20C33.5 21.933 31.933 23.5 30 23.5H4C2.067 23.5 0.5 21.933 0.5 20V4Z"
                fill="white"
            />
            <path
                d="M0.5 4C0.5 2.067 2.067 0.5 4 0.5H30C31.933 0.5 33.5 2.067 33.5 4V20C33.5 21.933 31.933 23.5 30 23.5H4C2.067 23.5 0.5 21.933 0.5 20V4Z"
                className="stroke-border-secondary"
                strokeWidth="0.75"
            />
            <path d="M14 23L33 17.25V20C33 21.6569 31.6569 23 30 23H14Z" fill="#FD6020" />
            <path
                fillRule="evenodd"
                clipRule="evenodd"
                d="M29.3937 9.11084C30.439 9.11084 31.0139 9.59438 31.0139 10.5077C31.0662 11.2062 30.5958 11.7972 29.9686 11.9046L31.3797 13.8925H30.2822L29.0801 11.9584H28.9756V13.8925H28.0871V9.11084H29.3937ZM28.9756 11.3137H29.2369C29.8118 11.3137 30.0731 11.045 30.0731 10.5615C30.0731 10.1317 29.8118 9.86304 29.2369 9.86304H28.9756V11.3137ZM25.0034 13.8925H27.5122V13.0866H25.8919V11.7972H27.4599V10.9913H25.8919V9.91674H27.5122V9.11084H25.0034V13.8925ZM22.3902 12.3345L21.1881 9.11084H20.2474L22.1812 14H22.6515L24.5853 9.11084H23.6446L22.3902 12.3345ZM11.7805 11.5286C11.7805 12.8717 12.8258 14 14.1324 14C14.5505 14 14.9164 13.8925 15.2822 13.7314V12.6568C15.0209 12.9792 14.655 13.1941 14.2369 13.1941C13.4007 13.1941 12.7212 12.5494 12.7212 11.6897V11.5823C12.669 10.7227 13.3484 9.97048 14.1847 9.91675C14.6028 9.91675 15.0209 10.1317 15.2822 10.454V9.37948C14.9686 9.16458 14.5505 9.11085 14.1847 9.11085C12.8258 9.0034 11.7805 10.1317 11.7805 11.5286ZM10.1603 10.9376C9.63762 10.7227 9.48082 10.6152 9.48082 10.3466C9.53309 10.0242 9.79441 9.75557 10.108 9.8093C10.3693 9.8093 10.6306 9.97048 10.8397 10.1854L11.3101 9.54066C10.9442 9.2183 10.4739 9.00339 10.0035 9.00339C9.27176 8.94967 8.64459 9.54066 8.59232 10.2928V10.3466C8.59232 10.9913 8.85365 11.3674 9.68988 11.636C9.89894 11.6897 10.108 11.7972 10.3171 11.9046C10.4739 12.0121 10.5784 12.1733 10.5784 12.3882C10.5784 12.7643 10.2648 13.0866 9.95121 13.0866H9.89894C9.48082 13.0866 9.11497 12.818 8.95818 12.4419L8.38326 13.0329C8.69685 13.6239 9.32403 13.9463 9.95121 13.9463C10.7874 14 11.4669 13.3553 11.5191 12.4956V12.3345C11.4669 11.6897 11.2056 11.3674 10.1603 10.9376ZM7.12892 13.8925H8.01742V9.11084H7.12892V13.8925ZM3 9.11086H4.30662H4.56794C5.8223 9.16458 6.81532 10.2391 6.76306 11.5286C6.76306 12.227 6.44947 12.8717 5.92682 13.3553C5.45644 13.7314 4.88153 13.9463 4.30662 13.8926H3V9.11086ZM4.14983 13.0866C4.56794 13.1404 5.03833 12.9792 5.35191 12.7105C5.6655 12.3882 5.8223 11.9584 5.8223 11.4748C5.8223 11.045 5.6655 10.6152 5.35191 10.2928C5.03833 10.0242 4.56794 9.86302 4.14983 9.91674H3.8885V13.0866H4.14983Z"
                fill="black"
            />
            <path
                fillRule="evenodd"
                clipRule="evenodd"
                d="M17.9481 9C16.6415 9 15.5439 10.0745 15.5439 11.4714C15.5439 12.8146 16.5892 13.9429 17.9481 13.9966C19.307 14.0503 20.3523 12.9221 20.4046 11.5252C20.3523 10.1283 19.307 9 17.9481 9V9Z"
                fill="#FD6020"
            />
        </svg>
    );
};

export default DiscoverIcon;
````

## File: src/components/foundations/payment-icons/index.tsx
````typescript
export { default as AmexIcon } from "./amex-icon";
export { default as ApplePayIcon } from "./apple-pay-icon";
export { default as DiscoverIcon } from "./discover-icon";
export { default as MastercardIcon } from "./mastercard-icon";
export { default as VisaIcon } from "./visa-icon";
export { default as PayPalIcon } from "./paypal-icon";
export { default as StripeIcon } from "./stripe-icon";
export { default as UnionPayIcon } from "./union-pay-icon";
````

## File: src/components/foundations/payment-icons/mastercard-icon.tsx
````typescript
import type { SVGProps } from "react";

const MastercardIcon = (props: SVGProps<SVGSVGElement>) => {
    return (
        <svg width="34" height="24" viewBox="0 0 34 24" fill="none" {...props}>
            <path
                d="M0.5 4C0.5 2.067 2.067 0.5 4 0.5H30C31.933 0.5 33.5 2.067 33.5 4V20C33.5 21.933 31.933 23.5 30 23.5H4C2.067 23.5 0.5 21.933 0.5 20V4Z"
                fill="white"
            />
            <path
                d="M0.5 4C0.5 2.067 2.067 0.5 4 0.5H30C31.933 0.5 33.5 2.067 33.5 4V20C33.5 21.933 31.933 23.5 30 23.5H4C2.067 23.5 0.5 21.933 0.5 20V4Z"
                className="stroke-border-secondary"
                strokeWidth="0.75"
            />
            <path
                fillRule="evenodd"
                clipRule="evenodd"
                d="M17.179 16.8294C15.9949 17.8275 14.459 18.43 12.7807 18.43C9.03582 18.43 6 15.4303 6 11.73C6 8.02966 9.03582 5.02997 12.7807 5.02997C14.459 5.02997 15.9949 5.63247 17.179 6.63051C18.363 5.63247 19.8989 5.02997 21.5773 5.02997C25.3221 5.02997 28.358 8.02966 28.358 11.73C28.358 15.4303 25.3221 18.43 21.5773 18.43C19.8989 18.43 18.363 17.8275 17.179 16.8294Z"
                fill="#ED0006"
            />
            <path
                fillRule="evenodd"
                clipRule="evenodd"
                d="M17.1787 16.8294C18.6366 15.6005 19.5611 13.7719 19.5611 11.73C19.5611 9.68801 18.6366 7.85941 17.1787 6.63051C18.3628 5.63247 19.8987 5.02997 21.577 5.02997C25.3219 5.02997 28.3577 8.02966 28.3577 11.73C28.3577 15.4303 25.3219 18.43 21.577 18.43C19.8987 18.43 18.3628 17.8275 17.1787 16.8294Z"
                fill="#F9A000"
            />
            <path
                fillRule="evenodd"
                clipRule="evenodd"
                d="M17.1793 16.8294C18.6372 15.6005 19.5616 13.7719 19.5616 11.73C19.5616 9.68805 18.6372 7.85946 17.1793 6.63055C15.7213 7.85946 14.7969 9.68805 14.7969 11.73C14.7969 13.7719 15.7213 15.6005 17.1793 16.8294Z"
                fill="#FF5E00"
            />
        </svg>
    );
};

export default MastercardIcon;
````

## File: src/components/foundations/payment-icons/paypal-icon.tsx
````typescript
import type { SVGProps } from "react";

const PayPalIcon = (props: SVGProps<SVGSVGElement>) => {
    return (
        <svg width="34" height="24" viewBox="0 0 34 24" fill="none" {...props}>
            <path
                d="M0.5 4C0.5 2.067 2.067 0.5 4 0.5H30C31.933 0.5 33.5 2.067 33.5 4V20C33.5 21.933 31.933 23.5 30 23.5H4C2.067 23.5 0.5 21.933 0.5 20V4Z"
                fill="white"
            />
            <path
                d="M0.5 4C0.5 2.067 2.067 0.5 4 0.5H30C31.933 0.5 33.5 2.067 33.5 4V20C33.5 21.933 31.933 23.5 30 23.5H4C2.067 23.5 0.5 21.933 0.5 20V4Z"
                className="stroke-border-secondary"
                strokeWidth="0.75"
            />
            <path
                fillRule="evenodd"
                clipRule="evenodd"
                d="M14.614 18.4483L14.8347 16.9992L14.3431 16.9873H11.9951L13.6268 6.2937C13.6319 6.26132 13.6484 6.23126 13.6724 6.20987C13.6965 6.18849 13.7272 6.17676 13.7594 6.17676H17.7184C19.0328 6.17676 19.9398 6.45939 20.4133 7.01734C20.6353 7.27908 20.7767 7.55267 20.8452 7.85364C20.9169 8.16951 20.9181 8.54685 20.8481 9.00715L20.843 9.04063V9.33561L21.0651 9.46563C21.252 9.56815 21.4006 9.68546 21.5145 9.81975C21.7044 10.0436 21.8272 10.3281 21.8791 10.6652C21.9328 11.012 21.9151 11.4248 21.8272 11.892C21.7259 12.4295 21.5622 12.8976 21.341 13.2805C21.1376 13.6334 20.8785 13.9262 20.5708 14.153C20.277 14.3686 19.928 14.5322 19.5333 14.6369C19.1509 14.7398 18.7149 14.7917 18.2367 14.7917H17.9286C17.7083 14.7917 17.4943 14.8737 17.3263 15.0207C17.1579 15.1708 17.0465 15.3758 17.0123 15.6L16.989 15.7305L16.599 18.2848L16.5814 18.3785C16.5767 18.4082 16.5686 18.423 16.5568 18.433C16.5463 18.4422 16.5311 18.4483 16.5164 18.4483H14.614Z"
                fill="#28356A"
            />
            <path
                fillRule="evenodd"
                clipRule="evenodd"
                d="M21.2761 9.07458C21.2644 9.15267 21.2508 9.23246 21.2356 9.31445C20.7136 12.0851 18.9273 13.0422 16.646 13.0422H15.4845C15.2055 13.0422 14.9703 13.2516 14.9269 13.536L14.1638 18.5393C14.1356 18.7261 14.2748 18.8944 14.4571 18.8944H16.5173C16.7612 18.8944 16.9684 18.7112 17.0069 18.4626L17.0271 18.3544L17.415 15.8102L17.4399 15.6707C17.4779 15.4211 17.6856 15.2378 17.9295 15.2378H18.2376C20.2336 15.2378 21.7961 14.4003 22.2528 11.9765C22.4435 10.964 22.3448 10.1185 21.84 9.52389C21.6873 9.34464 21.4977 9.1958 21.2761 9.07458Z"
                fill="#298FC2"
            />
            <path
                fillRule="evenodd"
                clipRule="evenodd"
                d="M20.7298 8.84956C20.65 8.82549 20.5677 8.80374 20.4833 8.78407C20.3984 8.76488 20.3115 8.7479 20.222 8.73299C19.9089 8.68069 19.5656 8.65588 19.1981 8.65588H16.0951C16.0186 8.65588 15.946 8.67372 15.8811 8.70598C15.7379 8.7771 15.6316 8.91714 15.6058 9.08857L14.9457 13.4101L14.9268 13.5361C14.9701 13.2516 15.2053 13.0423 15.4843 13.0423H16.6459C18.9271 13.0423 20.7134 12.0847 21.2354 9.31451C21.2511 9.23252 21.2642 9.15273 21.2759 9.07464C21.1438 9.00218 21.0008 8.94023 20.8467 8.88744C20.8087 8.87437 20.7694 8.86178 20.7298 8.84956Z"
                fill="#22284F"
            />
            <path
                fillRule="evenodd"
                clipRule="evenodd"
                d="M15.6056 9.08862C15.6314 8.91718 15.7377 8.77715 15.8809 8.70652C15.9462 8.67414 16.0184 8.6563 16.0948 8.6563H19.1979C19.5654 8.6563 19.9086 8.68123 20.2218 8.73353C20.3113 8.74831 20.3982 8.76542 20.4831 8.7846C20.5675 8.80415 20.6498 8.82603 20.7296 8.84998C20.7692 8.8622 20.8085 8.8749 20.8469 8.88749C21.0009 8.94028 21.1441 9.00272 21.2761 9.07469C21.4315 8.05082 21.2748 7.3537 20.7393 6.72245C20.1488 6.0274 19.0831 5.72998 17.7194 5.72998H13.7603C13.4817 5.72998 13.2441 5.9393 13.2011 6.22426L11.5521 17.0279C11.5196 17.2416 11.679 17.4344 11.8876 17.4344H14.3318L15.6056 9.08862Z"
                fill="#28356A"
            />
        </svg>
    );
};

export default PayPalIcon;
````

## File: src/components/foundations/payment-icons/stripe-icon.tsx
````typescript
import type { SVGProps } from "react";

const StripeIcon = (props: SVGProps<SVGSVGElement>) => {
    return (
        <svg width="34" height="24" viewBox="0 0 34 24" fill="none" {...props}>
            <path
                d="M0.5 4C0.5 2.067 2.067 0.5 4 0.5H30C31.933 0.5 33.5 2.067 33.5 4V20C33.5 21.933 31.933 23.5 30 23.5H4C2.067 23.5 0.5 21.933 0.5 20V4Z"
                fill="white"
            />
            <path
                d="M0.5 4C0.5 2.067 2.067 0.5 4 0.5H30C31.933 0.5 33.5 2.067 33.5 4V20C33.5 21.933 31.933 23.5 30 23.5H4C2.067 23.5 0.5 21.933 0.5 20V4Z"
                className="stroke-border-secondary"
                strokeWidth="0.75"
            />
            <path
                fillRule="evenodd"
                clipRule="evenodd"
                d="M18.2684 8.14192L16.5413 8.52349V7.08202L18.2684 6.70752V8.14192ZM21.8602 8.94038C21.1858 8.94038 20.7523 9.26542 20.5115 9.49153L20.422 9.05344H18.9082V17.2924L20.6285 16.9179L20.6354 14.9183C20.8831 15.102 21.2478 15.3634 21.8533 15.3634C23.085 15.3634 24.2066 14.3459 24.2066 12.106C24.1997 10.0568 23.0643 8.94038 21.8602 8.94038ZM21.4473 13.8089C21.0413 13.8089 20.8005 13.6605 20.6353 13.4768L20.6285 10.8553C20.8074 10.6504 21.0551 10.509 21.4473 10.509C22.0735 10.509 22.507 11.2298 22.507 12.1554C22.507 13.1023 22.0803 13.8089 21.4473 13.8089ZM29.6289 12.1766C29.6289 10.3677 28.7756 8.94038 27.1448 8.94038C25.5072 8.94038 24.5163 10.3677 24.5163 12.1625C24.5163 14.2894 25.6861 15.3634 27.365 15.3634C28.1839 15.3634 28.8031 15.1726 29.271 14.9041V13.4909C28.8031 13.7312 28.2664 13.8795 27.5852 13.8795C26.9178 13.8795 26.326 13.6393 26.2503 12.8055H29.6151C29.6151 12.7666 29.6176 12.6782 29.6204 12.5763L29.6204 12.5761C29.6243 12.4377 29.6289 12.2743 29.6289 12.1766ZM26.2296 11.5054C26.2296 10.7069 26.7044 10.3748 27.1379 10.3748C27.5576 10.3748 28.0049 10.7069 28.0049 11.5054H26.2296ZM16.5412 9.06052H18.2683V15.2433H16.5412V9.06052ZM14.5803 9.06051L14.6904 9.5834C15.0963 8.82026 15.9014 8.97572 16.1216 9.06051V10.6857C15.9083 10.608 15.2202 10.509 14.8142 11.0531V15.2433H13.094V9.06051H14.5803ZM11.2498 7.52717L9.57081 7.8946L9.56392 13.5545C9.56392 14.6003 10.3277 15.3705 11.3461 15.3705C11.9103 15.3705 12.3232 15.2645 12.5503 15.1373V13.7029C12.3301 13.7947 11.2429 14.1198 11.2429 13.074V10.5656H12.5503V9.0605H11.2429L11.2498 7.52717ZM7.1832 10.4737C6.8185 10.4737 6.59831 10.5797 6.59831 10.8553C6.59831 11.1562 6.97726 11.2885 7.4474 11.4527C8.21383 11.7204 9.22258 12.0728 9.22685 13.3779C9.22685 14.6427 8.24287 15.3705 6.81162 15.3705C6.21986 15.3705 5.57304 15.2504 4.93311 14.9677V13.286C5.51112 13.611 6.2405 13.8513 6.81162 13.8513C7.19696 13.8513 7.4722 13.7453 7.4722 13.4203C7.4722 13.087 7.0614 12.9346 6.56547 12.7507C5.81018 12.4706 4.85742 12.1173 4.85742 10.9401C4.85742 9.6894 5.78636 8.9404 7.1832 8.9404C7.75432 8.9404 8.31856 9.03225 8.88968 9.26543V10.926C8.36673 10.6362 7.70615 10.4737 7.1832 10.4737Z"
                fill="#6461FC"
            />
        </svg>
    );
};

export default StripeIcon;
````

## File: src/components/foundations/payment-icons/union-pay-icon.tsx
````typescript
import type { SVGProps } from "react";

const UnionPayIcon = (props: SVGProps<SVGSVGElement>) => {
    return (
        <svg width="34" height="24" viewBox="0 0 34 24" fill="none" {...props}>
            <path
                d="M0.5 4C0.5 2.067 2.067 0.5 4 0.5H30C31.933 0.5 33.5 2.067 33.5 4V20C33.5 21.933 31.933 23.5 30 23.5H4C2.067 23.5 0.5 21.933 0.5 20V4Z"
                fill="white"
            />
            <path
                d="M0.5 4C0.5 2.067 2.067 0.5 4 0.5H30C31.933 0.5 33.5 2.067 33.5 4V20C33.5 21.933 31.933 23.5 30 23.5H4C2.067 23.5 0.5 21.933 0.5 20V4Z"
                className="stroke-border-secondary"
                strokeWidth="0.75"
            />
            <path
                d="M10.5185 5.00073H15.8767C16.6247 5.00073 17.0899 5.62831 16.9154 6.40082L14.4208 17.4262C14.2447 18.196 13.4959 18.8241 12.7474 18.8241H7.38973C6.64282 18.8241 6.17657 18.196 6.35106 17.4262L8.84672 6.40082C9.0212 5.62831 9.76968 5.00073 10.5185 5.00073Z"
                fill="#E21836"
            />
            <path
                d="M15.4303 5H21.5921C22.3399 5 22.0027 5.62758 21.8268 6.40009L19.3326 17.4255C19.1576 18.1953 19.2121 18.8234 18.4628 18.8234H12.301C11.5516 18.8234 11.0878 18.1953 11.2639 17.4255L13.758 6.40009C13.9351 5.62758 14.682 5 15.4303 5Z"
                fill="#00447C"
            />
            <path
                d="M21.348 5H26.7062C27.4552 5 27.9204 5.62758 27.7445 6.40009L25.2503 17.4255C25.0742 18.1953 24.3248 18.8234 23.576 18.8234H18.2203C17.4709 18.8234 17.0061 18.1953 17.1816 17.4255L19.6762 6.40009C19.8507 5.62758 20.5986 5 21.348 5Z"
                fill="#007B84"
            />
            <path
                d="M11.9181 8.53326C11.3671 8.53904 11.2043 8.53326 11.1524 8.52062C11.1324 8.61836 10.7605 10.384 10.7595 10.3855C10.6794 10.7427 10.6212 10.9973 10.4233 11.1617C10.311 11.2573 10.1799 11.3035 10.0279 11.3035C9.78352 11.3035 9.64116 11.1786 9.61726 10.9417L9.61269 10.8603C9.61269 10.8603 9.68714 10.3818 9.68714 10.3792C9.68714 10.3792 10.0774 8.77015 10.1472 8.55746C10.1509 8.54536 10.1519 8.53904 10.1529 8.53326C9.39328 8.54012 9.25863 8.53326 9.24936 8.52062C9.24427 8.53797 9.22546 8.63772 9.22546 8.63772L8.82699 10.4512L8.79278 10.605L8.72656 11.1081C8.72656 11.2573 8.75503 11.3791 8.81171 11.4821C8.99325 11.8087 9.51108 11.8576 9.80402 11.8576C10.1815 11.8576 10.5355 11.7751 10.7748 11.6244C11.1901 11.3717 11.2988 10.9769 11.3957 10.626L11.4406 10.446C11.4406 10.446 11.8426 8.77485 11.9109 8.55746C11.9135 8.54536 11.9145 8.53904 11.9181 8.53326ZM13.2858 9.88137C13.1889 9.88137 13.0118 9.90557 12.8527 9.98583C12.795 10.0164 12.7404 10.0516 12.6828 10.0867L12.7348 9.89347L12.7063 9.86094C12.369 9.93125 12.2935 9.94066 11.9819 9.98583L11.9558 10.0037C11.9196 10.3125 11.8875 10.5447 11.7533 11.1517C11.7023 11.3754 11.6493 11.6013 11.5961 11.8245L11.6105 11.8528C11.9298 11.8355 12.0267 11.8355 12.3042 11.8402L12.3267 11.8151C12.3619 11.6291 12.3665 11.5856 12.4446 11.209C12.4813 11.0305 12.5578 10.6381 12.5956 10.4985C12.6649 10.4654 12.7334 10.4329 12.7987 10.4329C12.9542 10.4329 12.9353 10.5725 12.9293 10.6282C12.9226 10.7216 12.8659 11.0268 12.8078 11.2888L12.769 11.458C12.742 11.5829 12.7123 11.7043 12.6853 11.8281L12.6971 11.8528C13.0118 11.8355 13.1078 11.8355 13.3766 11.8402L13.4082 11.8151C13.4568 11.5247 13.471 11.447 13.5572 11.0241L13.6006 10.8299C13.6848 10.4497 13.7271 10.2569 13.6634 10.0998C13.596 9.92385 13.4343 9.88137 13.2858 9.88137ZM14.8137 10.2794C14.6464 10.3125 14.5397 10.3346 14.4337 10.3488C14.3286 10.3662 14.226 10.3819 14.0644 10.405L14.0516 10.417L14.0398 10.4265C14.023 10.5505 14.0112 10.6576 13.9889 10.7836C13.9699 10.9139 13.9408 11.0619 13.8934 11.2746C13.8567 11.4374 13.8378 11.4941 13.8169 11.5514C13.7965 11.6087 13.774 11.6643 13.7328 11.8245L13.7424 11.8392L13.7505 11.8528C13.9016 11.8454 14.0005 11.8402 14.1021 11.8392C14.2036 11.8355 14.3087 11.8392 14.4714 11.8402L14.4857 11.8282L14.501 11.815C14.5245 11.6707 14.528 11.6318 14.5424 11.5614C14.5566 11.4858 14.5811 11.3812 14.6414 11.1018C14.6698 10.9706 14.7016 10.8398 14.7311 10.7059C14.7618 10.5725 14.7939 10.4412 14.8245 10.31L14.8199 10.2941L14.8137 10.2794ZM14.8173 9.74272C14.6653 9.65036 14.3985 9.67967 14.2189 9.80725C14.0398 9.93228 14.0195 10.1097 14.171 10.2033C14.3204 10.2931 14.5882 10.2664 14.7662 10.1377C14.9449 10.01 14.9672 9.83414 14.8173 9.74272ZM15.7367 11.8818C16.0442 11.8818 16.3595 11.7945 16.5968 11.5356C16.7794 11.3256 16.8631 11.0131 16.8921 10.8845C16.9865 10.458 16.913 10.2589 16.8207 10.1376C16.6804 9.95279 16.4325 9.8935 16.1754 9.8935C16.0207 9.8935 15.6524 9.90923 15.3647 10.1823C15.1581 10.3792 15.0626 10.6465 15.0051 10.9028C14.9469 11.1638 14.8801 11.6339 15.3 11.8088C15.4295 11.866 15.6163 11.8818 15.7367 11.8818ZM15.7127 10.9223C15.7836 10.5993 15.8673 10.3283 16.0809 10.3283C16.2484 10.3283 16.2605 10.5299 16.1861 10.854C16.1728 10.9259 16.1116 11.1933 16.029 11.3072C15.9712 11.3912 15.9029 11.4421 15.8275 11.4421C15.805 11.4421 15.6714 11.4421 15.6693 11.2379C15.6682 11.1371 15.6882 11.0341 15.7127 10.9223ZM17.661 11.8402L17.685 11.8151C17.7191 11.6292 17.7247 11.5855 17.8002 11.209C17.8379 11.0305 17.916 10.6382 17.9527 10.4985C18.0222 10.4653 18.0895 10.4328 18.1569 10.4328C18.3114 10.4328 18.2926 10.5724 18.2864 10.6281C18.2808 10.7217 18.2241 11.0267 18.165 11.2888L18.1283 11.4579C18.1002 11.5829 18.0696 11.7042 18.0426 11.8281L18.0543 11.8529C18.3701 11.8355 18.4625 11.8355 18.7328 11.8402L18.7655 11.8151C18.8129 11.5246 18.8257 11.4469 18.9145 11.0242L18.9568 10.8298C19.0414 10.4496 19.0843 10.2569 19.0216 10.0999C18.9522 9.92389 18.7895 9.88141 18.6431 9.88141C18.546 9.88141 18.368 9.90548 18.2099 9.98587C18.1533 10.0164 18.0967 10.0515 18.041 10.0867L18.0895 9.89351L18.0635 9.86084C17.7263 9.93129 17.6492 9.9407 17.338 9.98587L17.3141 10.0038C17.2763 10.3126 17.2457 10.5446 17.1115 11.1518C17.0605 11.3755 17.0074 11.6013 16.9544 11.8245L16.9686 11.8529C17.2885 11.8355 17.384 11.8355 17.661 11.8402ZM19.9812 11.8528C20.001 11.7531 20.1189 11.1618 20.12 11.1618C20.12 11.1618 20.2204 10.7279 20.2266 10.7122C20.2266 10.7122 20.2582 10.667 20.2898 10.6491H20.3363C20.775 10.6491 21.2703 10.6491 21.6586 10.3551C21.9228 10.1535 22.1034 9.85567 22.184 9.49375C22.2049 9.40501 22.2203 9.29948 22.2203 9.19394C22.2203 9.05533 22.1933 8.9182 22.1152 8.81105C21.9172 8.52589 21.5229 8.52065 21.0678 8.5185C21.0663 8.5185 20.8434 8.52065 20.8434 8.52065C20.2608 8.52804 20.0271 8.52589 19.9311 8.51379C19.923 8.55749 19.9078 8.6352 19.9078 8.6352C19.9078 8.6352 19.6991 9.63088 19.6991 9.63249C19.6991 9.63249 19.1996 11.7494 19.1761 11.8492C19.6848 11.8429 19.8934 11.8429 19.9812 11.8528ZM20.3679 10.0841C20.3679 10.0841 20.5898 9.09042 20.5887 9.09418L20.5959 9.04323L20.599 9.00437L20.6877 9.01379C20.6877 9.01379 21.1453 9.05425 21.1561 9.05533C21.3367 9.12726 21.4111 9.31265 21.3591 9.55465C21.3117 9.77581 21.1724 9.96174 20.9933 10.0515C20.8459 10.1276 20.6653 10.134 20.4791 10.134H20.3587L20.3679 10.0841ZM21.7494 10.9407C21.6908 11.198 21.6234 11.668 22.0412 11.8355C22.1744 11.8939 22.2938 11.9112 22.4151 11.9049C22.5432 11.8978 22.6619 11.8316 22.7719 11.7364C22.762 11.7755 22.7521 11.8147 22.7421 11.8539L22.7611 11.8791C23.0616 11.866 23.1548 11.866 23.4804 11.8686L23.5099 11.8455C23.5575 11.5577 23.6023 11.2784 23.7258 10.728C23.786 10.4643 23.8461 10.2032 23.9079 9.94067L23.8982 9.91177C23.562 9.9759 23.4722 9.98961 23.1488 10.0368L23.1243 10.0574C23.121 10.0841 23.1176 10.1098 23.1145 10.1355C23.0642 10.0519 22.9913 9.98047 22.8789 9.93597C22.7351 9.87775 22.3973 9.95277 22.107 10.2249C21.903 10.4192 21.8051 10.6854 21.7494 10.9407ZM22.4555 10.9564C22.5274 10.6392 22.6101 10.3709 22.8243 10.3709C22.9597 10.3709 23.031 10.4996 23.0165 10.719C23.005 10.7737 22.9926 10.8314 22.9779 10.8966C22.9564 10.9908 22.9332 11.0842 22.9106 11.1778C22.8876 11.2418 22.8608 11.3022 22.8315 11.3424C22.7763 11.4228 22.6452 11.4726 22.5697 11.4726C22.5483 11.4726 22.4161 11.4726 22.4116 11.2721C22.4105 11.1722 22.4305 11.0693 22.4555 10.9564ZM26.1424 9.9092L26.1164 9.87868C25.7838 9.94805 25.7236 9.95908 25.418 10.0016L25.3955 10.0247C25.3944 10.0285 25.3935 10.0342 25.392 10.0395L25.3909 10.0342C25.1634 10.5746 25.1701 10.458 24.9849 10.8834C24.9838 10.864 24.9838 10.8519 24.9828 10.8313L24.9364 9.9092L24.9073 9.87868C24.5589 9.94805 24.5506 9.95908 24.2288 10.0016L24.2038 10.0247C24.2002 10.0357 24.2002 10.0478 24.1981 10.061L24.2002 10.0657C24.2405 10.2773 24.2308 10.2301 24.2711 10.5641C24.2899 10.728 24.315 10.8928 24.3338 11.0547C24.3656 11.3256 24.3833 11.4589 24.4221 11.8723C24.2048 12.2415 24.1533 12.3812 23.9441 12.7052L23.9456 12.7084L23.7982 12.9483C23.7814 12.9735 23.7661 12.9909 23.7447 12.9983C23.7212 13.0103 23.6906 13.0124 23.6482 13.0124H23.5665L23.4452 13.4278L23.8614 13.4352C24.1058 13.4342 24.2594 13.3165 24.3421 13.1584L24.6038 12.6967H24.5996L24.6272 12.6642C24.8032 12.274 26.1424 9.9092 26.1424 9.9092ZM21.7494 15.3652H21.5728L22.2264 13.1401H22.4432L22.512 12.9108L22.5187 13.1657C22.5106 13.3233 22.631 13.463 22.9473 13.4399H23.3131L23.439 13.0114H23.3013C23.2222 13.0114 23.1855 12.9908 23.1901 12.9467L23.1834 12.6874H22.506V12.6887C22.287 12.6934 21.6329 12.7104 21.5005 12.7467C21.3402 12.7892 21.1714 12.9142 21.1714 12.9142L21.2377 12.6847H20.604L20.472 13.1401L19.8097 15.3992H19.6812L19.5552 15.8246H20.8173L20.775 15.9664H21.3969L21.4382 15.8246H21.6127L21.7494 15.3652ZM21.2316 13.5922C21.1301 13.6211 20.9413 13.7087 20.9413 13.7087L21.1092 13.1401H21.6127L21.4912 13.5544C21.4912 13.5544 21.3357 13.5638 21.2316 13.5922ZM21.2412 14.4046C21.2412 14.4046 21.0831 14.4251 20.979 14.4493C20.8765 14.4813 20.6842 14.5821 20.6842 14.5821L20.8577 13.9903H21.3637L21.2412 14.4046ZM20.9591 15.3705H20.4541L20.6005 14.871H21.104L20.9591 15.3705ZM22.1754 13.9903H22.9034L22.7987 14.339H22.0611L21.9504 14.7203H22.5958L22.1071 15.4287C22.0729 15.4807 22.0422 15.4991 22.0081 15.5138C21.9739 15.5317 21.9289 15.5526 21.877 15.5526H21.6979L21.5749 15.9702H22.0432C22.2867 15.9702 22.4304 15.8562 22.5366 15.7066L22.8717 15.2344L22.9437 15.7138C22.959 15.8036 23.0217 15.8562 23.0641 15.8766C23.111 15.9008 23.1595 15.9424 23.2279 15.9486C23.3013 15.9518 23.3543 15.9543 23.3896 15.9543H23.6197L23.7579 15.487H23.6671C23.615 15.487 23.5253 15.478 23.51 15.4612C23.4947 15.4408 23.4947 15.4093 23.4865 15.3615L23.4135 14.881H23.1145L23.2457 14.7203H23.9819L24.0951 14.339H23.4135L23.5197 13.9903H24.1992L24.3252 13.5602H22.2993L22.1754 13.9903ZM16.0269 15.4676L16.1968 14.8857H16.8951L17.0227 14.4529H16.3238L16.4305 14.0948H17.1135L17.2401 13.6757H15.531L15.4071 14.0948H15.7953L15.6918 14.4529H15.3025L15.1734 14.8931H15.5616L15.3351 15.6629C15.3045 15.7648 15.3495 15.8037 15.3779 15.851C15.4071 15.8971 15.4366 15.9276 15.5029 15.945C15.5714 15.9607 15.6183 15.9701 15.682 15.9701H16.4693L16.6095 15.4907L16.2606 15.54C16.1932 15.54 16.0065 15.5317 16.0269 15.4676ZM16.107 12.6821L15.93 13.0113C15.8922 13.0833 15.8581 13.1279 15.8274 13.1485C15.8004 13.1658 15.7468 13.1731 15.6692 13.1731H15.5769L15.4535 13.5943H15.7601C15.9076 13.5943 16.0208 13.5386 16.0749 13.5108C16.133 13.4788 16.1483 13.4971 16.1932 13.4524L16.2968 13.3601H17.2543L17.3814 12.9215H16.6805L16.8028 12.6821H16.107ZM17.5207 15.476C17.5044 15.4518 17.5161 15.4092 17.5411 15.3205L17.8028 14.4287H18.7338C18.8695 14.4267 18.9675 14.4251 19.0312 14.4204C19.0997 14.413 19.1741 14.3878 19.2552 14.3427C19.3389 14.2953 19.3818 14.2455 19.4179 14.1882C19.4583 14.1311 19.5231 14.006 19.5787 13.8132L19.9077 12.6847L18.9415 12.6905C18.9415 12.6905 18.644 12.7357 18.513 12.7856C18.3808 12.8412 18.192 12.9966 18.192 12.9966L18.2792 12.6873H17.6824L16.8468 15.54C16.8171 15.6508 16.7973 15.7312 16.7927 15.7795C16.7911 15.8315 16.8564 15.883 16.8988 15.9218C16.9488 15.9607 17.0227 15.9544 17.0936 15.9607C17.1682 15.9665 17.2742 15.9701 17.4206 15.9701H17.8793L18.0201 15.4807L17.6095 15.5207C17.5656 15.5207 17.5339 15.4965 17.5207 15.476ZM17.9717 13.8264H18.9496L18.8874 14.027C18.8787 14.0317 18.8578 14.0171 18.7583 14.0292H17.9114L17.9717 13.8264ZM18.1676 13.1537H19.1537L19.0828 13.3953C19.0828 13.3953 18.618 13.3906 18.5436 13.4047C18.216 13.463 18.0247 13.6432 18.0247 13.6432L18.1676 13.1537ZM18.9093 14.6987C18.9012 14.7287 18.8884 14.747 18.8705 14.7607C18.8507 14.7739 18.8185 14.7786 18.7706 14.7786H18.6313L18.6395 14.5343H18.0599L18.0364 15.7285C18.0355 15.8147 18.0436 15.8646 18.1048 15.9045C18.1661 15.9544 18.3548 15.9607 18.6088 15.9607H18.972L19.1031 15.5137L18.7869 15.5316L18.6818 15.5379C18.6674 15.5316 18.6537 15.5258 18.6384 15.5101C18.6251 15.4965 18.6027 15.5048 18.6063 15.4187L18.6088 15.1125L18.9404 15.0984C19.1195 15.0984 19.196 15.0385 19.2613 14.9813C19.3236 14.9266 19.344 14.8637 19.3675 14.7786L19.4231 14.5075H18.9674L18.9093 14.6987Z"
                fill="#FEFEFE"
            />
        </svg>
    );
};

export default UnionPayIcon;
````

## File: src/components/foundations/payment-icons/visa-icon.tsx
````typescript
import type { SVGProps } from "react";

const VisaIcon = (props: SVGProps<SVGSVGElement>) => {
    return (
        <svg width="34" height="24" viewBox="0 0 34 24" fill="none" {...props}>
            <path
                d="M0.5 4C0.5 2.067 2.067 0.5 4 0.5H30C31.933 0.5 33.5 2.067 33.5 4V20C33.5 21.933 31.933 23.5 30 23.5H4C2.067 23.5 0.5 21.933 0.5 20V4Z"
                fill="white"
            />
            <path
                d="M0.5 4C0.5 2.067 2.067 0.5 4 0.5H30C31.933 0.5 33.5 2.067 33.5 4V20C33.5 21.933 31.933 23.5 30 23.5H4C2.067 23.5 0.5 21.933 0.5 20V4Z"
                className="stroke-border-secondary"
                strokeWidth="0.75"
            />
            <path
                fillRule="evenodd"
                clipRule="evenodd"
                d="M10.7501 15.8582H8.69031L7.14576 9.79235C7.07245 9.51332 6.91679 9.26664 6.68782 9.15038C6.11639 8.85821 5.48672 8.62568 4.7998 8.50841V8.27487H8.11789C8.57583 8.27487 8.91929 8.62568 8.97653 9.0331L9.77793 13.4086L11.8367 8.27487H13.8392L10.7501 15.8582ZM14.984 15.8582H13.0388L14.6406 8.27487H16.5858L14.984 15.8582ZM19.1025 10.3757C19.1597 9.96725 19.5032 9.73372 19.9039 9.73372C20.5336 9.67508 21.2195 9.79235 21.7919 10.0835L22.1354 8.45079C21.5629 8.21725 20.9333 8.09998 20.3619 8.09998C18.4738 8.09998 17.1 9.15038 17.1 10.6082C17.1 11.7173 18.0731 12.2996 18.7601 12.6504C19.5032 13.0002 19.7894 13.2337 19.7322 13.5835C19.7322 14.1082 19.1597 14.3418 18.5883 14.3418C17.9014 14.3418 17.2145 14.1669 16.5858 13.8747L16.2424 15.5084C16.9293 15.7996 17.6724 15.9169 18.3594 15.9169C20.4763 15.9745 21.7919 14.9251 21.7919 13.35C21.7919 11.3664 19.1025 11.2502 19.1025 10.3757ZM28.5998 15.8582L27.0553 8.27487H25.3962C25.0528 8.27487 24.7093 8.50841 24.5948 8.85821L21.7347 15.8582H23.7372L24.1369 14.7502H26.5973L26.8263 15.8582H28.5998ZM25.6824 10.3171L26.2539 13.1751H24.6521L25.6824 10.3171Z"
                fill="#172B85"
            />
        </svg>
    );
};

export default VisaIcon;
````

## File: src/components/foundations/dot-icon.tsx
````typescript
import type { HTMLAttributes } from "react";

const sizes = {
    sm: {
        wh: 8,
        c: 4,
        r: 2.5,
    },
    md: {
        wh: 10,
        c: 5,
        r: 4,
    },
};

export const Dot = ({ size = "md", ...props }: HTMLAttributes<HTMLOrSVGElement> & { size?: "sm" | "md" }) => {
    return (
        <svg width={sizes[size].wh} height={sizes[size].wh} viewBox={`0 0 ${sizes[size].wh} ${sizes[size].wh}`} fill="none" {...props}>
            <circle cx={sizes[size].c} cy={sizes[size].c} r={sizes[size].r} fill="currentColor" stroke="currentColor" />
        </svg>
    );
};
````

## File: src/components/icons/oauth-icons.tsx
````typescript
interface OAuthIconProps {
  className?: string;
  "data-icon"?: string;
}

export function AppleOAuthIcon({ className, ...props }: OAuthIconProps) {
  return (
    <svg
      {...props}
      className={className}
      viewBox="0 0 24 24"
      fill="currentColor"
      aria-hidden="true"
    >
      <path d="M16.365 1.43c0 1.14-.41 2.155-1.23 3.045-.82.89-1.81 1.385-2.97 1.335-.02-.14-.03-.285-.03-.435 0-1.09.45-2.12 1.35-3.09.45-.5 1.02-.905 1.71-1.215.69-.31 1.34-.475 1.95-.495.14.285.21.57.21.855zm3.405 16.14c-.34.8-.75 1.55-1.23 2.25-.65.95-1.18 1.61-1.59 1.98-.63.61-1.305.925-2.025.945-.52 0-1.15-.15-1.89-.45-.74-.3-1.42-.45-2.04-.45-.65 0-1.35.15-2.1.45-.75.3-1.355.46-1.815.48-.69.03-1.38-.295-2.07-.975-.44-.39-.995-1.075-1.665-2.055-.72-1.04-1.31-2.245-1.77-3.615-.49-1.48-.735-2.915-.735-4.305 0-1.59.345-2.96 1.035-4.11.54-.92 1.26-1.645 2.16-2.175.9-.53 1.875-.8 2.925-.82.55 0 1.27.17 2.16.51.89.34 1.46.51 1.71.51.19 0 .84-.205 1.95-.615 1.05-.38 1.935-.54 2.655-.48 1.95.16 3.415.925 4.395 2.295-1.75 1.06-2.615 2.545-2.595 4.455.02 1.49.555 2.73 1.605 3.72.48.47 1.015.835 1.605 1.095-.13.37-.27.73-.42 1.08z" />
    </svg>
  );
}

export function GitHubOAuthIcon({ className, ...props }: OAuthIconProps) {
  return (
    <svg
      {...props}
      className={className}
      viewBox="0 0 24 24"
      fill="currentColor"
      aria-hidden="true"
    >
      <path d="M12 0C5.37 0 0 5.37 0 12c0 5.31 3.435 9.795 8.205 11.385.6.105.825-.255.825-.57 0-.285-.015-1.23-.015-2.235-3.015.555-3.795-.735-4.035-1.41-.135-.345-.72-1.41-1.23-1.695-.42-.225-1.02-.78-.015-.795.945-.015 1.62.87 1.845 1.23 1.08 1.815 2.805 1.305 3.495.99.105-.78.42-1.305.765-1.605-2.67-.3-5.46-1.335-5.46-5.925 0-1.305.465-2.385 1.23-3.225-.12-.3-.54-1.53.12-3.18 0 0 1.005-.315 3.3 1.23.96-.27 1.98-.405 3-.405s2.04.135 3 .405c2.295-1.56 3.3-1.23 3.3-1.23.66 1.65.24 2.88.12 3.18.765.84 1.23 1.905 1.23 3.225 0 4.605-2.805 5.625-5.475 5.925.435.375.81 1.095.81 2.22 0 1.605-.015 2.895-.015 3.3 0 .315.225.69.825.57A12.02 12.02 0 0 0 24 12c0-6.63-5.37-12-12-12z" />
    </svg>
  );
}

export function GoogleOAuthIcon({ className, ...props }: OAuthIconProps) {
  return (
    <svg
      {...props}
      className={className}
      viewBox="0 0 24 24"
      aria-hidden="true"
    >
      <path d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92a5.06 5.06 0 0 1-2.2 3.32v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.1z" fill="#4285F4" />
      <path d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z" fill="#34A853" />
      <path d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z" fill="#FBBC05" />
      <path d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z" fill="#EA4335" />
    </svg>
  );
}
````

## File: src/components/marketing/contact/contact-simple-form.tsx
````typescript
import { useState, type FormEvent } from "react";
import { Link } from "react-router-dom";
import { Button } from "@/components/base/buttons/button";
import { Checkbox } from "@/components/base/checkbox/checkbox";
import { Form } from "@/components/base/form/form";
import { Input, InputBase } from "@/components/base/input/input";
import { InputGroup } from "@/components/base/input/input-group";
import { NativeSelect } from "@/components/base/select/select-native";
import { TextArea } from "@/components/base/textarea/textarea";
import { useToast } from "@/hooks/use-toast";
import { submitContactMessage } from "@/lib/contact-support";
import countries, { phoneCodeOptions } from "@/lib/utils/countries";

export const ContactSimpleForm = () => {
    const [selectedCountryPhone, setSelectedCountryPhone] = useState("US");
    const [isSubmitting, setIsSubmitting] = useState(false);
    const { toast } = useToast();

    const handleSubmit = async (event: FormEvent<HTMLFormElement>) => {
        event.preventDefault();
        if (isSubmitting) return;

        const form = event.currentTarget;
        const formData = new FormData(form);
        const firstName = String(formData.get("firstName") || "");
        const lastName = String(formData.get("lastName") || "");
        const email = String(formData.get("email") || "");
        const phoneCountry = String(formData.get("phoneCountry") || selectedCountryPhone || "US");
        const phoneNumber = String(formData.get("phone") || "");
        const message = String(formData.get("message") || "");
        const privacyConsent = formData.get("privacy") !== null;

        setIsSubmitting(true);
        try {
            await submitContactMessage({
                firstName,
                lastName,
                email,
                phoneCountry,
                phoneNumber,
                message,
                privacyConsent,
            });
            toast({
                title: "Message sent",
                description: "Thanks for reaching out. Support will follow up soon.",
            });
            form.reset();
            setSelectedCountryPhone("US");
        } catch (error) {
            toast({
                title: "Could not send message",
                description: error instanceof Error ? error.message : "Please try again.",
                variant: "destructive",
            });
        } finally {
            setIsSubmitting(false);
        }
    };

    return (
        <section className="bg-muted/40 py-16 md:py-24">
            <div className="mx-auto w-full max-w-5xl px-4 md:px-8">
                <div className="mx-auto flex w-full max-w-3xl flex-col items-center text-center">
                    <span className="text-sm font-semibold text-primary md:text-base">Contact us</span>
                    <h2 className="mt-3 text-3xl font-semibold tracking-tight text-foreground md:text-5xl">Get in touch</h2>
                    <p className="mt-4 text-base text-muted-foreground md:mt-6 md:text-lg">We'd love to hear from you. Please fill out this form.</p>
                </div>

                <Form
                    onSubmit={(event) => void handleSubmit(event)}
                    aria-busy={isSubmitting}
                    className="mx-auto mt-12 flex w-full max-w-2xl flex-col gap-8 md:mt-16"
                >
                    <div className="flex flex-col gap-6">
                        <div className="flex flex-col gap-x-8 gap-y-6 md:flex-row">
                            <Input isRequired size="md" name="firstName" label="First name" placeholder="First name" wrapperClassName="flex-1" maxLength={80} />
                            <Input isRequired size="md" name="lastName" label="Last name" placeholder="Last name" wrapperClassName="flex-1" maxLength={80} />
                        </div>
                        <Input isRequired size="md" name="email" label="Email" type="email" placeholder="you@company.com" maxLength={320} />
                        <InputGroup
                            size="md"
                            name="phone"
                            label="Phone number"
                            leadingAddon={
                                <NativeSelect
                                    aria-label="Country code"
                                    name="phoneCountry"
                                    value={selectedCountryPhone}
                                    onChange={(value) => setSelectedCountryPhone(value.currentTarget.value)}
                                    options={phoneCodeOptions.map((item) => ({
                                        label: item.label as string,
                                        value: item.id as string,
                                    }))}
                                />
                            }
                        >
                            <InputBase
                                name="phone"
                                type="tel"
                                placeholder={countries.find((country) => country.code === selectedCountryPhone)?.phoneMask?.replace(/#/g, "0")}
                                maxLength={50}
                            />
                        </InputGroup>
                        <TextArea isRequired name="message" label="Message" placeholder="Leave us a message..." rows={5} maxLength={5000} />
                        <Checkbox
                            name="privacy"
                            size="md"
                            label="I agree to the privacy policy."
                            hint={
                                <>
                                    We only use this information to respond to your request. Review our{" "}
                                    <Link
                                        to="/privacy"
                                        className="rounded-sm underline underline-offset-4 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring"
                                    >
                                        privacy policy
                                    </Link>
                                    .
                                </>
                            }
                        />
                    </div>

                    <Button type="submit" size="xl" isDisabled={isSubmitting} isLoading={isSubmitting}>
                        {isSubmitting ? "Sending..." : "Send message"}
                    </Button>
                </Form>
            </div>
        </section>
    );
};
````

## File: src/components/marketing/footers/footer-large-04.tsx
````typescript
import { Badge } from "@/components/base/badges/badges";
import { Button } from "@/components/base/buttons/button";
import { Form } from "@/components/base/form/form";
import { Input } from "@/components/base/input/input";
import { UntitledLogo } from "@/components/foundations/logo/untitledui-logo";

const footerNavList = [
    {
        label: "Product",
        items: [
            {
                label: "Overview",
                href: "#",
            },
            {
                label: "Features",
                href: "#",
            },
            {
                label: "Solutions",
                href: "#",
                badge: (
                    <Badge size="sm" type="modern" className="ml-1">
                        New
                    </Badge>
                ),
            },
            {
                label: "Tutorials",
                href: "#",
            },
            {
                label: "Pricing",
                href: "#",
            },
            {
                label: "Releases",
                href: "#",
            },
        ],
    },
    {
        label: "Resources",
        items: [
            {
                label: "Blog",
                href: "#",
            },
            {
                label: "Newsletter",
                href: "#",
            },
            {
                label: "Events",
                href: "#",
            },
            {
                label: "Help centre",
                href: "#",
            },
            {
                label: "Tutorials",
                href: "#",
            },
            {
                label: "Support",
                href: "#",
            },
        ],
    },
];

export const FooterLarge04 = () => {
    return (
        <footer className="bg-primary py-12 md:pt-16">
            <div className="mx-auto max-w-container px-4 md:px-8">
                <div className="flex flex-col gap-12 md:gap-16 xl:flex-row">
                    <div className="flex w-full flex-col gap-6 md:max-w-xs md:gap-8">
                        <UntitledLogo className="h-8 w-min shrink-0" />
                        <p className="text-md text-tertiary">Design amazing digital experiences that create more happy in the world.</p>
                    </div>
                    <nav className="flex flex-1 flex-col-reverse gap-12 md:flex-row md:gap-8 xl:justify-end">
                        <ul className="grid w-full grid-cols-2 gap-8 md:max-w-xs">
                            {footerNavList.map((category) => (
                                <li key={category.label}>
                                    <h4 className="text-sm font-semibold text-primary">{category.label}</h4>
                                    <ul className="mt-4 flex flex-col gap-3">
                                        {category.items.map((item) => (
                                            <li key={item.label}>
                                                <Button color="link-color" size="lg" href={item.href} iconTrailing={item.badge} className="gap-1">
                                                    {item.label}
                                                </Button>
                                            </li>
                                        ))}
                                    </ul>
                                </li>
                            ))}
                        </ul>
                        <Form
                            onSubmit={(e) => {
                                e.preventDefault();
                                const data = Object.fromEntries(new FormData(e.currentTarget));
                                console.log("Form data:", data);
                            }}
                            className="flex w-full flex-col gap-4 md:max-w-90"
                        >
                            <label htmlFor="newsletters-email" className="text-sm font-semibold text-primary">
                                Stay up to date
                            </label>
                            <div className="flex flex-col gap-4 sm:flex-row">
                                <Input
                                    isRequired
                                    id="newsletters-email"
                                    name="email"
                                    type="email"
                                    placeholder="Enter your email"
                                    size="md"
                                    wrapperClassName="flex-1"
                                />
                                <Button type="submit" size="lg">
                                    Subscribe
                                </Button>
                            </div>
                        </Form>
                    </nav>
                </div>
                <div className="mt-12 flex flex-col-reverse justify-between gap-4 border-t border-secondary pt-8 md:mt-16 md:flex-row md:gap-6">
                    <p className="text-md text-quaternary">© 2077 Untitled UI. All rights reserved.</p>

                    <ul className="flex gap-4">
                        {[
                            {
                                label: "Terms",
                                href: "#",
                            },
                            {
                                label: "Privacy",
                                href: "#",
                            },
                            {
                                label: "Cookies",
                                href: "#",
                            },
                        ].map(({ label, href }) => (
                            <li key={label}>
                                <a
                                    href={href}
                                    className="rounded-xs text-md text-quaternary outline-focus-ring transition duration-100 ease-linear hover:text-tertiary focus-visible:outline-2 focus-visible:outline-offset-2"
                                >
                                    {label}
                                </a>
                            </li>
                        ))}
                    </ul>
                </div>
            </div>
        </footer>
    );
};
````

## File: src/components/marketing/header-section/header-centered-brand.tsx
````typescript
export const HeaderCenteredBrand = () => {
  return (
    <section className="bg-muted/40 py-16 md:py-24">
      <div className="mx-auto w-full max-w-5xl px-4 md:px-8">
        <div className="mx-auto flex w-full max-w-3xl flex-col items-center text-center">
          <span className="text-sm font-semibold text-primary md:text-base">About us</span>
          <h1 className="mt-3 text-3xl font-semibold tracking-tight text-foreground md:text-5xl">About the company</h1>
          <p className="mt-4 text-base text-muted-foreground md:mt-6 md:text-lg">
            Learn more about the company and the world-class team behind Untitled.
          </p>
        </div>
      </div>
    </section>
  );
};
````

## File: src/components/ContextQualityMeter.tsx
````typescript
import type { ContextConfig } from "@/lib/context-types";
import { scoreContext } from "@/lib/context-types";
import { CheckCircle as CheckCircle2, Circle } from "@phosphor-icons/react";

interface ContextQualityMeterProps {
  contextConfig: ContextConfig;
}

export function ContextQualityMeter({ contextConfig }: ContextQualityMeterProps) {
  const { score, checks } = scoreContext(contextConfig);

  const getScoreColor = () => {
    if (score >= 75) return "text-primary";
    if (score >= 50) return "text-accent-foreground";
    return "text-destructive";
  };

  return (
    <div className="space-y-2">
      <div className="flex items-center justify-between">
        <span className="text-xs font-medium text-foreground">Context completeness</span>
        <span className={`text-xs font-bold ${getScoreColor()}`}>{score}%</span>
      </div>
      <div className="space-y-1.5">
        {checks.map((check) => (
          <div key={check.label} className="flex items-start gap-2">
            {check.met ? (
              <CheckCircle2 className="w-3.5 h-3.5 text-primary shrink-0 mt-0.5" />
            ) : (
              <Circle className="w-3.5 h-3.5 text-muted-foreground shrink-0 mt-0.5" />
            )}
            <div>
              <span className="text-xs text-foreground">{check.label}</span>
              {!check.met && (
                <p className="text-xs text-muted-foreground">{check.tip}</p>
              )}
            </div>
          </div>
        ))}
      </div>
    </div>
  );
}
````

## File: src/hooks/use-breakpoint.ts
````typescript
import { useEffect, useState } from "react";

const screens = {
  sm: "640px",
  md: "768px",
  lg: "1024px",
  xl: "1280px",
  "2xl": "1536px",
};

/**
 * Checks whether a particular Tailwind CSS viewport size applies.
 *
 * @param size The size to check, which must either be included in Tailwind CSS's
 * list of default screen sizes, or added to the Tailwind CSS config file.
 *
 * @returns A boolean indicating whether the viewport size applies.
 */
export const useBreakpoint = (size: "sm" | "md" | "lg" | "xl" | "2xl") => {
  const [matches, setMatches] = useState(
    typeof window !== "undefined" ? window.matchMedia(`(min-width: ${screens[size]})`).matches : true,
  );

  useEffect(() => {
    const breakpoint = window.matchMedia(`(min-width: ${screens[size]})`);

    setMatches(breakpoint.matches);

    const handleChange = (value: MediaQueryListEvent) => setMatches(value.matches);

    breakpoint.addEventListener("change", handleChange);
    return () => breakpoint.removeEventListener("change", handleChange);
  }, [size]);

  return matches;
};
````

## File: src/hooks/use-mobile.tsx
````typescript
import * as React from "react";
import { MOBILE_BREAKPOINT_PX, MOBILE_MAX_WIDTH_PX } from "@/lib/breakpoints";

export function useIsMobile() {
  const [isMobile, setIsMobile] = React.useState<boolean>(() => {
    if (typeof window === "undefined") return false;
    return window.innerWidth < MOBILE_BREAKPOINT_PX;
  });

  React.useEffect(() => {
    const mql = window.matchMedia(`(max-width: ${MOBILE_MAX_WIDTH_PX}px)`);
    const onChange = () => {
      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT_PX);
    };
    mql.addEventListener("change", onChange);
    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT_PX);
    return () => mql.removeEventListener("change", onChange);
  }, []);

  return isMobile;
}
````

## File: src/hooks/use-resize-observer.ts
````typescript
import { useEffect } from "react";
import type { RefObject } from "@react-types/shared";

/**
 * Checks if the ResizeObserver API is supported.
 * @returns True if the ResizeObserver API is supported, false otherwise.
 */
function hasResizeObserver() {
    return typeof window.ResizeObserver !== "undefined";
}

/**
 * The options for the useResizeObserver hook.
 */
type useResizeObserverOptionsType<T> = {
    /**
     * The ref to the element to observe.
     */
    ref: RefObject<T | undefined | null> | undefined;
    /**
     * The box to observe.
     */
    box?: ResizeObserverBoxOptions;
    /**
     * The callback function to call when the size changes.
     */
    onResize: () => void;
};

/**
 * A hook that observes the size of an element and calls a callback function when the size changes.
 * @param options - The options for the hook.
 */
export function useResizeObserver<T extends Element>(options: useResizeObserverOptionsType<T>) {
    const { ref, box, onResize } = options;

    useEffect(() => {
        const element = ref?.current;
        if (!element) {
            return;
        }

        if (!hasResizeObserver()) {
            window.addEventListener("resize", onResize, false);

            return () => {
                window.removeEventListener("resize", onResize, false);
            };
        } else {
            const resizeObserverInstance = new window.ResizeObserver((entries) => {
                if (!entries.length) {
                    return;
                }

                onResize();
            });

            resizeObserverInstance.observe(element, { box });

            return () => {
                if (element) {
                    resizeObserverInstance.unobserve(element);
                }
            };
        }
    }, [onResize, ref, box]);
}
````

## File: src/hooks/use-toast.ts
````typescript
import * as React from "react";

import type { ToastActionElement, ToastProps } from "@/components/base/primitives/toast";

const TOAST_LIMIT = 1;
const TOAST_REMOVE_DELAY = 1000000;

type ToasterToast = ToastProps & {
  id: string;
  title?: React.ReactNode;
  description?: React.ReactNode;
  action?: ToastActionElement;
};

const actionTypes = {
  ADD_TOAST: "ADD_TOAST",
  UPDATE_TOAST: "UPDATE_TOAST",
  DISMISS_TOAST: "DISMISS_TOAST",
  REMOVE_TOAST: "REMOVE_TOAST",
} as const;

let count = 0;

function genId() {
  count = (count + 1) % Number.MAX_SAFE_INTEGER;
  return count.toString();
}

type ActionType = typeof actionTypes;

type Action =
  | {
      type: ActionType["ADD_TOAST"];
      toast: ToasterToast;
    }
  | {
      type: ActionType["UPDATE_TOAST"];
      toast: Partial<ToasterToast>;
    }
  | {
      type: ActionType["DISMISS_TOAST"];
      toastId?: ToasterToast["id"];
    }
  | {
      type: ActionType["REMOVE_TOAST"];
      toastId?: ToasterToast["id"];
    };

interface State {
  toasts: ToasterToast[];
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>();

const addToRemoveQueue = (toastId: string) => {
  if (toastTimeouts.has(toastId)) {
    return;
  }

  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId);
    dispatch({
      type: "REMOVE_TOAST",
      toastId: toastId,
    });
  }, TOAST_REMOVE_DELAY);

  toastTimeouts.set(toastId, timeout);
};

export const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case "ADD_TOAST":
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
      };

    case "UPDATE_TOAST":
      return {
        ...state,
        toasts: state.toasts.map((t) => (t.id === action.toast.id ? { ...t, ...action.toast } : t)),
      };

    case "DISMISS_TOAST": {
      const { toastId } = action;

      // ! Side effects ! - This could be extracted into a dismissToast() action,
      // but I'll keep it here for simplicity
      if (toastId) {
        addToRemoveQueue(toastId);
      } else {
        state.toasts.forEach((toast) => {
          addToRemoveQueue(toast.id);
        });
      }

      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === toastId || toastId === undefined
            ? {
                ...t,
                open: false,
              }
            : t,
        ),
      };
    }
    case "REMOVE_TOAST":
      if (action.toastId === undefined) {
        return {
          ...state,
          toasts: [],
        };
      }
      return {
        ...state,
        toasts: state.toasts.filter((t) => t.id !== action.toastId),
      };
  }
};

const listeners: Array<(state: State) => void> = [];

let memoryState: State = { toasts: [] };

function dispatch(action: Action) {
  memoryState = reducer(memoryState, action);
  listeners.forEach((listener) => {
    listener(memoryState);
  });
}

type Toast = Omit<ToasterToast, "id">;

function toast({ ...props }: Toast) {
  const id = genId();

  const update = (props: ToasterToast) =>
    dispatch({
      type: "UPDATE_TOAST",
      toast: { ...props, id },
    });
  const dismiss = () => dispatch({ type: "DISMISS_TOAST", toastId: id });

  dispatch({
    type: "ADD_TOAST",
    toast: {
      ...props,
      id,
      open: true,
      onOpenChange: (open) => {
        if (!open) dismiss();
      },
    },
  });

  return {
    id: id,
    dismiss,
    update,
  };
}

function useToast() {
  const [state, setState] = React.useState<State>(memoryState);

  React.useEffect(() => {
    listeners.push(setState);
    return () => {
      const index = listeners.indexOf(setState);
      if (index > -1) {
        listeners.splice(index, 1);
      }
    };
  }, []);

  return {
    ...state,
    toast,
    dismiss: (toastId?: string) => dispatch({ type: "DISMISS_TOAST", toastId }),
  };
}

export { useToast, toast };
````

## File: src/hooks/useCommunityMobileTelemetry.ts
````typescript
import { useCallback, useEffect, useRef } from "react";
import {
  trackCommunityEvent,
  type CommunityTelemetryPayload,
} from "@/lib/community-telemetry";

const SESSION_STORAGE_KEY = "promptforge:community-mobile-session-v1";

type CommunityMobileTelemetrySurface = "community_feed" | "community_post";
type CommunityMobileInteractionKind = "comment" | "reaction";

interface StoredMobileSessionState {
  id: string;
  startedAt: number;
  firstActionTracked: boolean;
  commentInteractions: number;
  reactionInteractions: number;
}

interface UseCommunityMobileTelemetryInput {
  enabled: boolean;
  surface: CommunityMobileTelemetrySurface;
}

function createSessionId(): string {
  if (typeof crypto !== "undefined" && typeof crypto.randomUUID === "function") {
    return crypto.randomUUID();
  }
  return `session-${Date.now()}-${Math.random().toString(16).slice(2)}`;
}

function createInitialSession(now: number): StoredMobileSessionState {
  return {
    id: createSessionId(),
    startedAt: now,
    firstActionTracked: false,
    commentInteractions: 0,
    reactionInteractions: 0,
  };
}

function readSession(): StoredMobileSessionState | null {
  if (typeof window === "undefined") return null;
  try {
    const raw = window.sessionStorage.getItem(SESSION_STORAGE_KEY);
    if (!raw) return null;
    const parsed = JSON.parse(raw) as Partial<StoredMobileSessionState>;
    if (
      typeof parsed.id !== "string" ||
      typeof parsed.startedAt !== "number" ||
      typeof parsed.firstActionTracked !== "boolean" ||
      typeof parsed.commentInteractions !== "number" ||
      typeof parsed.reactionInteractions !== "number"
    ) {
      return null;
    }
    return {
      id: parsed.id,
      startedAt: parsed.startedAt,
      firstActionTracked: parsed.firstActionTracked,
      commentInteractions: parsed.commentInteractions,
      reactionInteractions: parsed.reactionInteractions,
    };
  } catch {
    return null;
  }
}

function writeSession(session: StoredMobileSessionState): void {
  if (typeof window === "undefined") return;
  try {
    window.sessionStorage.setItem(SESSION_STORAGE_KEY, JSON.stringify(session));
  } catch {
    // Ignore storage failures (private mode, quota, etc.) and still emit events.
  }
}

export function useCommunityMobileTelemetry({
  enabled,
  surface,
}: UseCommunityMobileTelemetryInput) {
  const sessionRef = useRef<StoredMobileSessionState | null>(null);
  const enabledStartedAtRef = useRef<number | null>(null);

  const ensureSession = useCallback((): StoredMobileSessionState | null => {
    if (!enabled) return null;

    if (sessionRef.current) return sessionRef.current;

    const now = enabledStartedAtRef.current ?? Date.now();
    const existing = readSession();
    const session = existing ?? createInitialSession(now);
    if (!existing) {
      writeSession(session);
    }
    sessionRef.current = session;
    return session;
  }, [enabled]);

  const persist = useCallback((session: StoredMobileSessionState) => {
    sessionRef.current = session;
    writeSession(session);
  }, []);

  useEffect(() => {
    if (enabled) {
      enabledStartedAtRef.current = Date.now();
      return;
    }
    enabledStartedAtRef.current = null;
    sessionRef.current = null;
  }, [enabled]);

  useEffect(() => {
    if (!enabled) return;
    ensureSession();
  }, [enabled, ensureSession]);

  const maybeTrackFirstAction = useCallback(
    (
      session: StoredMobileSessionState,
      action: string,
      payload: CommunityTelemetryPayload,
      now: number,
    ): StoredMobileSessionState => {
      if (session.firstActionTracked) return session;

      const nextSession: StoredMobileSessionState = {
        ...session,
        firstActionTracked: true,
      };
      persist(nextSession);

      trackCommunityEvent("community_mobile_first_meaningful_action", {
        surface,
        action,
        sessionId: nextSession.id,
        firstMeaningfulActionMs: Math.max(0, now - session.startedAt),
        ...payload,
      });

      return nextSession;
    },
    [persist, surface],
  );

  const trackFirstMeaningfulAction = useCallback(
    (action: string, payload: CommunityTelemetryPayload = {}) => {
      const session = ensureSession();
      if (!session) return;

      const now = Date.now();
      maybeTrackFirstAction(session, action, payload, now);
    },
    [ensureSession, maybeTrackFirstAction],
  );

  const trackInteraction = useCallback(
    (
      kind: CommunityMobileInteractionKind,
      action: string,
      payload: CommunityTelemetryPayload = {},
    ) => {
      const session = ensureSession();
      if (!session) return;

      const now = Date.now();
      const sessionWithFirstAction = maybeTrackFirstAction(session, action, payload, now);

      const nextSession: StoredMobileSessionState = {
        ...sessionWithFirstAction,
        commentInteractions:
          kind === "comment"
            ? sessionWithFirstAction.commentInteractions + 1
            : sessionWithFirstAction.commentInteractions,
        reactionInteractions:
          kind === "reaction"
            ? sessionWithFirstAction.reactionInteractions + 1
            : sessionWithFirstAction.reactionInteractions,
      };
      persist(nextSession);

      const interactionCount =
        kind === "comment" ? nextSession.commentInteractions : nextSession.reactionInteractions;

      trackCommunityEvent("community_mobile_interaction", {
        surface,
        kind,
        action,
        sessionId: nextSession.id,
        interactionCount,
        commentInteractions: nextSession.commentInteractions,
        reactionInteractions: nextSession.reactionInteractions,
        ...payload,
      });
    },
    [ensureSession, maybeTrackFirstAction, persist, surface],
  );

  return {
    trackFirstMeaningfulAction,
    trackInteraction,
  };
}
````

## File: src/hooks/useIntersectionAutoLoad.ts
````typescript
import { useEffect, useRef } from "react";

interface UseIntersectionAutoLoadOptions {
  hasMore: boolean;
  isLoading: boolean;
  onLoadMore: () => void;
  rootMargin?: string;
}

export function useIntersectionAutoLoad({
  hasMore,
  isLoading,
  onLoadMore,
  rootMargin = "400px",
}: UseIntersectionAutoLoadOptions) {
  const sentinelRef = useRef<HTMLDivElement | null>(null);
  const onLoadMoreRef = useRef(onLoadMore);
  onLoadMoreRef.current = onLoadMore;

  useEffect(() => {
    const sentinel = sentinelRef.current;
    if (!sentinel || !hasMore || isLoading || typeof IntersectionObserver === "undefined") return;

    const observer = new IntersectionObserver(
      (entries) => {
        if (entries[0]?.isIntersecting) {
          onLoadMoreRef.current();
        }
      },
      { rootMargin },
    );

    observer.observe(sentinel);
    return () => observer.disconnect();
  }, [hasMore, isLoading, rootMargin]);

  return sentinelRef;
}
````

## File: src/hooks/useTheme.tsx
````typescript
import { createContext, useCallback, useContext, useEffect, useState, type ReactNode } from "react";
import { getUserPreferences, setUserPreference } from "@/lib/user-preferences";

interface ThemeContextValue {
  isDark: boolean;
  toggleTheme: () => void;
}

const ThemeContext = createContext<ThemeContextValue | null>(null);

export function ThemeProvider({ children }: { children: ReactNode }) {
  const [isDark, setIsDark] = useState(() => getUserPreferences().theme === "dark");

  useEffect(() => {
    document.documentElement.classList.toggle("dark", isDark);
    setUserPreference("theme", isDark ? "dark" : "light");
  }, [isDark]);

  const toggleTheme = useCallback(() => {
    setIsDark((previous) => !previous);
  }, []);

  return <ThemeContext.Provider value={{ isDark, toggleTheme }}>{children}</ThemeContext.Provider>;
}

export function useTheme() {
  const context = useContext(ThemeContext);
  if (!context) {
    throw new Error("useTheme must be used within ThemeProvider");
  }
  return context;
}
````

## File: src/lib/utils/cx.ts
````typescript
import { extendTailwindMerge } from "tailwind-merge";

const twMerge = extendTailwindMerge({
    extend: {
        theme: {
            text: ["display-xs", "display-sm", "display-md", "display-lg", "display-xl", "display-2xl"],
        },
    },
});

/**
 * This function is a wrapper around the twMerge function.
 * It is used to merge the classes inside style objects.
 */
export const cx = twMerge;

/**
 * This function does nothing besides helping us to be able to
 * sort the classes inside style objects which is not supported
 * by the Tailwind IntelliSense by default.
 */
export function sortCx<T extends Record<string, string | number | Record<string, string | number | Record<string, string | number>>>>(classes: T): T {
    return classes;
}
````

## File: src/lib/utils/icon-slot.tsx
````typescript
import type { ComponentType, ReactNode } from "react";
import { isValidElement } from "react";
import { isReactComponent } from "@/lib/utils/is-react-component";

export type IconComponent<TProps extends object = { className?: string }> = ComponentType<TProps>;
export type IconSlot<TProps extends object = { className?: string }> = IconComponent<TProps> | ReactNode;

export function renderIconSlot<TProps extends object>(icon: IconSlot<TProps> | null | undefined, props: TProps): ReactNode {
  if (isReactComponent(icon)) {
    const Icon = icon as IconComponent<TProps>;
    return <Icon {...props} />;
  }

  if (isValidElement(icon)) {
    return icon;
  }

  return null;
}
````

## File: src/lib/utils/is-react-component.ts
````typescript
/* We cannot use type `unknown` instead of `any` here because it will break the type assertion `isReactComponent` function is providing. */
/* eslint-disable @typescript-eslint/no-explicit-any */
import type React from "react";

type ReactComponent = React.FC<any> | React.ComponentClass<any, any>;

/**
 * Checks if a given value is a function component.
 */
export const isFunctionComponent = (component: any): component is React.FC<any> => {
    return typeof component === "function";
};

/**
 * Checks if a given value is a class component.
 */
export const isClassComponent = (component: any): component is React.ComponentClass<any, any> => {
    return typeof component === "function" && component.prototype && (!!component.prototype.isReactComponent || !!component.prototype.render);
};

/**
 * Checks if a given value is a forward ref component.
 */
export const isForwardRefComponent = (component: any): component is React.ForwardRefExoticComponent<any> => {
    return typeof component === "object" && component !== null && component.$$typeof.toString() === "Symbol(react.forward_ref)";
};

/**
 * Checks if a given value is a valid React component.
 */
export const isReactComponent = (component: any): component is ReactComponent => {
    return isFunctionComponent(component) || isForwardRefComponent(component) || isClassComponent(component);
};
````

## File: src/lib/backend-config.ts
````typescript
function normalizeEnvValue(value?: string): string | undefined {
  if (typeof value !== "string") return undefined;
  const trimmed = value.trim();
  if (!trimmed) return undefined;

  const hasDoubleQuotes = trimmed.startsWith("\"") && trimmed.endsWith("\"");
  const hasSingleQuotes = trimmed.startsWith("'") && trimmed.endsWith("'");
  if (hasDoubleQuotes || hasSingleQuotes) {
    const unquoted = trimmed.slice(1, -1).trim();
    return unquoted || undefined;
  }

  return trimmed;
}

export interface BackendConfigInput {
  dataApiUrl?: string;
  authUrl?: string;
  mode?: string;
  vitest?: boolean;
}

export interface BackendConfigResolution {
  dataApiUrl?: string;
  authUrl?: string;
  hasBackendEnvConfig: boolean;
  isBackendConfigured: boolean;
}

export function resolveBackendConfig(input: BackendConfigInput): BackendConfigResolution {
  const dataApiUrl = normalizeEnvValue(input.dataApiUrl);
  const authUrl = normalizeEnvValue(input.authUrl);
  const isTestEnv = input.mode === "test" || input.vitest === true;
  const hasBackendEnvConfig = Boolean(dataApiUrl && authUrl);

  return {
    dataApiUrl,
    authUrl,
    hasBackendEnvConfig,
    isBackendConfigured: hasBackendEnvConfig || isTestEnv,
  };
}

export const TEST_DATA_API_URL = "https://neon.test/neondb/rest/v1";
export const TEST_AUTH_URL = "https://neon.test/neondb/auth";

const runtimeBackendConfig = resolveBackendConfig({
  dataApiUrl: import.meta.env.VITE_NEON_DATA_API_URL,
  authUrl: import.meta.env.VITE_NEON_AUTH_URL,
  mode: import.meta.env.MODE,
  vitest: import.meta.env.VITEST,
});

export const NEON_DATA_API_URL = runtimeBackendConfig.dataApiUrl;
export const NEON_AUTH_URL = runtimeBackendConfig.authUrl;
export const hasBackendEnvConfig = runtimeBackendConfig.hasBackendEnvConfig;
export const isBackendConfigured = runtimeBackendConfig.isBackendConfigured;

export function getBackendConfigErrorMessage(featureLabel: string): string {
  return `${featureLabel} is unavailable because backend is not configured. Set VITE_NEON_DATA_API_URL and VITE_NEON_AUTH_URL.`;
}

export function assertBackendConfigured(featureLabel: string): void {
  if (!isBackendConfigured) {
    throw new Error(getBackendConfigErrorMessage(featureLabel));
  }
}
````

## File: src/lib/brand-copy.ts
````typescript
export const brandCopy = {
  appName: "PromptForge",
  brandLine: "Quality prompts grounded in context",
  tagline: "Build, score, and remix prompts your team can trust.",
  hero: {
    headline: "Turn rough ideas into quality prompts with context",
    subhead:
      "Draft once, improve with quality checks, and remix proven prompts without losing intent.",
    primaryCta: "Enhance prompt",
  },
  pillars: [
    {
      title: "Quality you can see",
      proof: "Quality Score highlights clarity, constraints, and structure before you run a model.",
    },
    {
      title: "Context that travels",
      proof: "Attach sources, notes, and data references so every prompt stays grounded.",
    },
    {
      title: "Remix with attribution",
      proof: "Community remixes keep lineage visible so teams can iterate without losing intent.",
    },
  ],
} as const;

export type BrandPillar = (typeof brandCopy.pillars)[number];
````

## File: src/lib/breakpoints.ts
````typescript
export const MOBILE_BREAKPOINT_PX = 640;
export const MOBILE_MAX_WIDTH_PX = MOBILE_BREAKPOINT_PX - 1;
````

## File: src/lib/clipboard.ts
````typescript
function fallbackCopyText(text: string): boolean {
  if (typeof document === "undefined" || typeof document.execCommand !== "function") {
    return false;
  }

  const textArea = document.createElement("textarea");
  textArea.value = text;
  textArea.setAttribute("readonly", "");
  textArea.style.position = "fixed";
  textArea.style.top = "0";
  textArea.style.left = "-9999px";
  textArea.style.opacity = "0";
  textArea.style.pointerEvents = "none";

  document.body.appendChild(textArea);

  try {
    textArea.focus();
    textArea.select();
    textArea.setSelectionRange(0, textArea.value.length);
    return document.execCommand("copy");
  } catch {
    return false;
  } finally {
    textArea.remove();
  }
}

export async function copyTextToClipboard(text: string): Promise<void> {
  if (typeof navigator !== "undefined" && navigator.clipboard?.writeText) {
    try {
      await navigator.clipboard.writeText(text);
      return;
    } catch {
      // Fall through to legacy copy path for iOS/webview contexts.
    }
  }

  if (fallbackCopyText(text)) {
    return;
  }

  throw new Error("Clipboard access is blocked.");
}
````

## File: src/lib/community-errors.ts
````typescript
export type CommunityErrorKind =
  | "network"
  | "auth"
  | "not_found"
  | "backend_unconfigured"
  | "unknown";

export interface CommunityErrorState {
  kind: CommunityErrorKind;
  message: string;
}

function toErrorMessage(error: unknown, fallback: string): string {
  if (error instanceof Error && error.message.trim()) {
    return error.message.trim();
  }
  return fallback;
}

function classifyErrorKind(message: string): CommunityErrorKind {
  const normalized = message.toLowerCase();

  if (normalized.includes("backend is not configured")) {
    return "backend_unconfigured";
  }

  if (
    /network|failed to fetch|fetch failed|connection|timeout|offline|load failed/.test(normalized)
  ) {
    return "network";
  }

  if (
    /sign in required|authentication|not authenticated|unauthorized|forbidden|permission|row-level security|jwt/.test(
      normalized,
    )
  ) {
    return "auth";
  }

  if (/not found|unavailable|invalid or expired|no post|404/.test(normalized)) {
    return "not_found";
  }

  return "unknown";
}

export function toCommunityErrorState(error: unknown, fallback: string): CommunityErrorState {
  const message = toErrorMessage(error, fallback);
  return {
    kind: classifyErrorKind(message),
    message,
  };
}
````

## File: src/lib/community-moderation.ts
````typescript
import { neon } from "@/integrations/neon/client";
import type { TablesInsert } from "@/integrations/neon/types";
import { assertBackendConfigured } from "@/lib/backend-config";
import { isPostgrestError, sanitizePostgresText } from "@/lib/saved-prompt-shared";

export type CommunityReportTargetType = "post" | "comment";

export interface CommunityReportInput {
  targetType: CommunityReportTargetType;
  postId?: string | null;
  commentId?: string | null;
  reportedUserId?: string | null;
  reason?: string;
  details?: string;
}

function toError(error: unknown, fallback: string): Error {
  if (error instanceof Error) return error;
  if (isPostgrestError(error)) {
    return new Error(error.message || fallback);
  }
  return new Error(fallback);
}

function normalizeReason(value?: string): string {
  const normalized = sanitizePostgresText(value || "").trim().slice(0, 80);
  return normalized || "other";
}

function normalizeDetails(value?: string): string {
  return sanitizePostgresText(value || "").trim().slice(0, 2000);
}

async function requireUserId(featureName: string): Promise<string> {
  assertBackendConfigured(featureName);
  const { data, error } = await neon.auth.getUser();
  if (error) throw toError(error, "Authentication failed.");
  if (!data.user?.id) throw new Error("Sign in required.");
  return data.user.id;
}

export async function loadBlockedUserIds(): Promise<string[]> {
  assertBackendConfigured("Community moderation");

  const { data: authData, error: authError } = await neon.auth.getUser();
  if (authError) {
    throw toError(authError, "Authentication failed.");
  }
  if (!authData.user?.id) {
    return [];
  }

  try {
    const { data, error } = await neon
      .from("community_user_blocks")
      .select("blocked_user_id")
      .eq("blocker_id", authData.user.id)
      .order("created_at", { ascending: false });

    if (error) throw error;

    return Array.from(new Set((data || []).map((row) => row.blocked_user_id).filter(Boolean)));
  } catch (error) {
    throw toError(error, "Failed to load blocked users.");
  }
}

export async function blockCommunityUser(blockedUserId: string, reason?: string): Promise<boolean> {
  const blockerId = await requireUserId("Community moderation");
  const targetId = blockedUserId.trim();

  if (!targetId) {
    throw new Error("Target user is required.");
  }
  if (targetId === blockerId) {
    throw new Error("You cannot block your own account.");
  }

  const safeReason = sanitizePostgresText(reason || "").trim().slice(0, 500);

  try {
    const { data, error } = await neon
      .from("community_user_blocks")
      .upsert(
        {
          blocker_id: blockerId,
          blocked_user_id: targetId,
          reason: safeReason,
        },
        {
          onConflict: "blocker_id,blocked_user_id",
          ignoreDuplicates: true,
        },
      )
      .select("id")
      .maybeSingle();

    if (error) throw error;
    if (data?.id) return true;

    const { data: existing, error: lookupError } = await neon
      .from("community_user_blocks")
      .select("id")
      .eq("blocker_id", blockerId)
      .eq("blocked_user_id", targetId)
      .maybeSingle();

    if (lookupError) throw lookupError;
    return Boolean(existing?.id);
  } catch (error) {
    throw toError(error, "Failed to block user.");
  }
}

export async function unblockCommunityUser(blockedUserId: string): Promise<boolean> {
  const blockerId = await requireUserId("Community moderation");
  const targetId = blockedUserId.trim();
  if (!targetId) return false;

  try {
    const { data, error } = await neon
      .from("community_user_blocks")
      .delete()
      .eq("blocker_id", blockerId)
      .eq("blocked_user_id", targetId)
      .select("id")
      .maybeSingle();

    if (error) throw error;
    return Boolean(data?.id);
  } catch (error) {
    throw toError(error, "Failed to unblock user.");
  }
}

export async function submitCommunityReport(input: CommunityReportInput): Promise<string> {
  const reporterId = await requireUserId("Community moderation");
  const reason = normalizeReason(input.reason);
  const details = normalizeDetails(input.details);

  if (input.targetType === "post" && !input.postId) {
    throw new Error("Post report is missing a post id.");
  }
  if (input.targetType === "comment" && !input.commentId) {
    throw new Error("Comment report is missing a comment id.");
  }

  const payload: TablesInsert<"community_reports"> = {
    reporter_id: reporterId,
    reported_user_id: input.reportedUserId?.trim() || null,
    target_type: input.targetType,
    reason,
    details,
    post_id: input.postId?.trim() || null,
    comment_id: input.commentId?.trim() || null,
  };

  if (input.targetType === "post") {
    payload.comment_id = null;
  }

  try {
    const { data, error } = await neon
      .from("community_reports")
      .insert(payload)
      .select("id")
      .single();

    if (error) throw error;
    if (!data?.id) {
      throw new Error("Report submission returned no id.");
    }
    return data.id;
  } catch (error) {
    throw toError(error, "Failed to submit report.");
  }
}
````

## File: src/lib/community-rarity.ts
````typescript
import type { CommunityPost } from "@/lib/community";
import type { PromptSummary } from "@/lib/persistence";

export type PromptForgeRarity = "common" | "rare" | "epic" | "legendary";
export type CommunityRarityClass = `pf-rarity-${PromptForgeRarity}`;

type CommunityRarityInput = Pick<CommunityPost, "upvoteCount" | "verifiedCount" | "remixCount" | "ratingAverage">;
type LibraryRarityInput = Pick<PromptSummary, "revision" | "sourceCount" | "databaseCount" | "tags" | "isShared" | "remixedFrom">;

export function getCommunityPostRarity(post: CommunityRarityInput): PromptForgeRarity {
  const signal =
    post.upvoteCount +
    post.verifiedCount * 2 +
    post.remixCount * 2 +
    Math.round(post.ratingAverage ?? 0);

  if (signal >= 22) return "legendary";
  if (signal >= 12) return "epic";
  if (signal >= 6) return "rare";
  return "common";
}

export function getCommunityPostRarityClass(post: CommunityRarityInput, isFeatured = false): CommunityRarityClass {
  if (isFeatured) return "pf-rarity-legendary";
  return `pf-rarity-${getCommunityPostRarity(post)}` as CommunityRarityClass;
}

export function getLibraryPromptRarity(prompt: LibraryRarityInput): PromptForgeRarity {
  const weightedSignal =
    prompt.revision +
    prompt.sourceCount +
    prompt.databaseCount +
    Math.min(prompt.tags.length, 4) +
    (prompt.isShared ? 2 : 0) +
    (prompt.remixedFrom ? 1 : 0);

  if (weightedSignal >= 12) return "legendary";
  if (weightedSignal >= 8) return "epic";
  if (weightedSignal >= 4) return "rare";
  return "common";
}
````

## File: src/lib/community-share.ts
````typescript
import { copyTextToClipboard } from "@/lib/clipboard";

export type ShareResult = "native" | "clipboard" | "failed";

export async function sharePost(
  post: { id: string; title: string },
  origin?: string,
): Promise<ShareResult> {
  const url = `${origin ?? window.location.origin}/community/${post.id}`;

  if (typeof navigator !== "undefined" && navigator.share) {
    try {
      await navigator.share({ title: post.title, url });
      return "native";
    } catch (error) {
      if (error instanceof Error && error.name === "AbortError") {
        return "native";
      }
      // Fall through to clipboard
    }
  }

  try {
    await copyTextToClipboard(url);
    return "clipboard";
  } catch {
    return "failed";
  }
}
````

## File: src/lib/community-utils.ts
````typescript
import type { CommunityPost, CommunityProfile } from "@/lib/community";

export function getInitials(name: string): string {
  const parts = name
    .split(" ")
    .map((part) => part.trim())
    .filter(Boolean);
  if (parts.length === 0) return "?";
  if (parts.length === 1) return parts[0].slice(0, 2).toUpperCase();
  return `${parts[0][0] || ""}${parts[1][0] || ""}`.toUpperCase();
}

export function estimateTokens(text: string): string {
  const words = text
    .split(/\s+/)
    .map((part) => part.trim())
    .filter(Boolean).length;
  const tokens = Math.max(1, Math.round(words * 1.35));
  if (tokens >= 1000) return `${(tokens / 1000).toFixed(1)}k`;
  return String(tokens);
}

export function toProfileMap(profiles: CommunityProfile[]): Record<string, CommunityProfile> {
  return profiles.reduce<Record<string, CommunityProfile>>((map, profile) => {
    map[profile.id] = profile;
    return map;
  }, {});
}

export function toParentTitleMap(posts: CommunityPost[]): Record<string, string> {
  return posts.reduce<Record<string, string>>((map, post) => {
    map[post.id] = post.title;
    return map;
  }, {});
}
````

## File: src/lib/contact-support.ts
````typescript
import { neon } from "@/integrations/neon/client";
import type { TablesInsert } from "@/integrations/neon/types";
import { assertBackendConfigured } from "@/lib/backend-config";
import { isPostgrestError, sanitizePostgresText } from "@/lib/saved-prompt-shared";

const EMAIL_PATTERN = /^[^\s@]+@[^\s@]+\.[^\s@]+$/i;
const MAX_NAME_LENGTH = 80;
const MAX_EMAIL_LENGTH = 320;
const MAX_PHONE_COUNTRY_LENGTH = 8;
const MAX_PHONE_NUMBER_LENGTH = 50;
const MAX_MESSAGE_LENGTH = 5000;
const SUPPORT_INBOX_PAGE_SIZE = 100;

export interface ContactMessageInput {
  firstName: string;
  lastName: string;
  email: string;
  message: string;
  phoneCountry?: string;
  phoneNumber?: string;
  privacyConsent: boolean;
}

export type ContactMessageStatus = "new" | "reviewing" | "resolved";

export interface ContactMessageRecord {
  id: string;
  firstName: string;
  lastName: string;
  email: string;
  phoneCountry: string;
  phoneNumber: string;
  message: string;
  status: ContactMessageStatus;
  requesterUserId: string | null;
  createdAt: string;
  updatedAt: string;
}

function toError(error: unknown, fallback: string): Error {
  if (error instanceof Error) return error;
  if (isPostgrestError(error)) {
    return new Error(error.message || fallback);
  }
  return new Error(fallback);
}

function normalizeRequiredText(value: string, label: string, maxLength: number): string {
  const normalized = sanitizePostgresText(value).trim().slice(0, maxLength);
  if (!normalized) {
    throw new Error(`${label} is required.`);
  }
  return normalized;
}

function normalizeOptionalText(value: string | undefined, maxLength: number): string {
  return sanitizePostgresText(value || "").trim().slice(0, maxLength);
}

function normalizeStatus(value: string): ContactMessageStatus {
  if (value === "reviewing" || value === "resolved") return value;
  return "new";
}

async function requireReviewerUserId(): Promise<string> {
  const { data: authData, error: authError } = await neon.auth.getUser();
  if (authError) {
    throw toError(authError, "Authentication failed.");
  }
  const userId = authData.user?.id;
  if (!userId) {
    throw new Error("Sign in required.");
  }

  const { data: reviewer, error } = await neon
    .from("support_reviewers")
    .select("user_id")
    .eq("user_id", userId)
    .maybeSingle();

  if (error) {
    throw toError(error, "Failed to verify reviewer access.");
  }
  if (!reviewer?.user_id) {
    throw new Error("You do not have support inbox access.");
  }

  return userId;
}

export async function isSupportReviewer(): Promise<boolean> {
  assertBackendConfigured("Contact support");
  const { data: authData, error: authError } = await neon.auth.getUser();
  if (authError) throw toError(authError, "Authentication failed.");

  const userId = authData.user?.id;
  if (!userId) return false;

  const { data, error } = await neon
    .from("support_reviewers")
    .select("user_id")
    .eq("user_id", userId)
    .maybeSingle();

  if (error) {
    throw toError(error, "Failed to verify reviewer access.");
  }

  return Boolean(data?.user_id);
}

export async function submitContactMessage(input: ContactMessageInput): Promise<string> {
  assertBackendConfigured("Contact support");

  const firstName = normalizeRequiredText(input.firstName, "First name", MAX_NAME_LENGTH);
  const lastName = normalizeRequiredText(input.lastName, "Last name", MAX_NAME_LENGTH);
  const email = normalizeRequiredText(input.email, "Email", MAX_EMAIL_LENGTH).toLowerCase();
  const message = normalizeRequiredText(input.message, "Message", MAX_MESSAGE_LENGTH);
  const phoneCountry = normalizeOptionalText(input.phoneCountry, MAX_PHONE_COUNTRY_LENGTH).toUpperCase() || "US";
  const phoneNumber = normalizeOptionalText(input.phoneNumber, MAX_PHONE_NUMBER_LENGTH);

  if (!EMAIL_PATTERN.test(email)) {
    throw new Error("Enter a valid email address.");
  }

  if (!input.privacyConsent) {
    throw new Error("Please accept the privacy policy before sending.");
  }

  const payload: TablesInsert<"contact_messages"> = {
    first_name: firstName,
    last_name: lastName,
    email,
    phone_country: phoneCountry,
    phone_number: phoneNumber,
    message,
    privacy_consent: true,
  };

  try {
    const { data, error } = await neon
      .from("contact_messages")
      .insert(payload)
      .select("id")
      .single();

    if (error) throw error;
    if (!data?.id) {
      throw new Error("Contact message was submitted without an id.");
    }

    return data.id;
  } catch (error) {
    throw toError(error, "Failed to send message.");
  }
}

export async function listContactMessagesForReviewer(limit = SUPPORT_INBOX_PAGE_SIZE): Promise<ContactMessageRecord[]> {
  assertBackendConfigured("Contact support");
  await requireReviewerUserId();

  const pageSize = Math.max(1, Math.min(limit, 500));
  try {
    const { data, error } = await neon
      .from("contact_messages")
      .select("id, first_name, last_name, email, phone_country, phone_number, message, status, requester_user_id, created_at, updated_at")
      .order("created_at", { ascending: false })
      .limit(pageSize);

    if (error) throw error;

    return (data || []).map((row) => ({
      id: row.id,
      firstName: row.first_name,
      lastName: row.last_name,
      email: row.email,
      phoneCountry: row.phone_country,
      phoneNumber: row.phone_number,
      message: row.message,
      status: normalizeStatus(row.status),
      requesterUserId: row.requester_user_id,
      createdAt: row.created_at,
      updatedAt: row.updated_at,
    }));
  } catch (error) {
    throw toError(error, "Failed to load contact messages.");
  }
}

export async function updateContactMessageStatus(
  messageId: string,
  status: ContactMessageStatus,
): Promise<void> {
  assertBackendConfigured("Contact support");
  await requireReviewerUserId();

  const id = sanitizePostgresText(messageId).trim();
  if (!id) {
    throw new Error("Message id is required.");
  }

  try {
    const { error } = await neon
      .from("contact_messages")
      .update({ status })
      .eq("id", id);

    if (error) throw error;
  } catch (error) {
    throw toError(error, "Failed to update contact message status.");
  }
}
````

## File: src/lib/content-moderation.ts
````typescript
interface ModerationRule {
  pattern: RegExp;
  reason: string;
}

const COMMUNITY_MODERATION_RULES: ReadonlyArray<ModerationRule> = [
  {
    pattern: /\bkill yourself\b/i,
    reason: "Content promoting self-harm is not allowed.",
  },
  {
    pattern: /\b(?:i|we)\s+(?:will|am going to)\s+(?:kill|hurt|doxx)\b/i,
    reason: "Threatening language is not allowed.",
  },
  {
    pattern: /\b(?:doxx|doxxing|swat)\b/i,
    reason: "Harassment and targeting language is not allowed.",
  },
  {
    pattern: /\b(?:csam|child sexual abuse)\b/i,
    reason: "Sexual exploitation content is not allowed.",
  },
];

export interface ModerationCheck {
  blocked: boolean;
  reason: string | null;
}

export function checkCommunityText(content: string): ModerationCheck {
  const normalized = content.trim();
  if (!normalized) {
    return { blocked: false, reason: null };
  }

  const match = COMMUNITY_MODERATION_RULES.find((rule) => rule.pattern.test(normalized));
  if (!match) {
    return { blocked: false, reason: null };
  }

  return { blocked: true, reason: match.reason };
}

export function assertCommunityTextAllowed(content: string, fallbackMessage: string): void {
  const result = checkCommunityText(content);
  if (result.blocked) {
    throw new Error(result.reason || fallbackMessage);
  }
}
````

## File: src/lib/feature-flags.ts
````typescript
function parseBooleanFlag(value: string | undefined): boolean {
  if (!value) return false;
  const normalized = value.trim().toLowerCase();
  return normalized === "1" || normalized === "true" || normalized === "yes" || normalized === "on";
}

export interface BuilderRedesignFlags {
  builderRedesignPhase1: boolean;
  builderRedesignPhase2: boolean;
  builderRedesignPhase3: boolean;
  builderRedesignPhase4: boolean;
}

export const builderRedesignFlags: BuilderRedesignFlags = {
  builderRedesignPhase1: parseBooleanFlag(import.meta.env.VITE_BUILDER_REDESIGN_PHASE1),
  builderRedesignPhase2: parseBooleanFlag(import.meta.env.VITE_BUILDER_REDESIGN_PHASE2),
  builderRedesignPhase3: parseBooleanFlag(import.meta.env.VITE_BUILDER_REDESIGN_PHASE3),
  builderRedesignPhase4: parseBooleanFlag(import.meta.env.VITE_BUILDER_REDESIGN_PHASE4),
};

export interface CommunityFeatureFlags {
  communityMobileEnhancements: boolean;
}

export const communityFeatureFlags: CommunityFeatureFlags = {
  communityMobileEnhancements: parseBooleanFlag(import.meta.env.VITE_COMMUNITY_MOBILE_ENHANCEMENTS),
};

export interface LaunchExperimentFlags {
  launchHeroCopyExperiment: boolean;
  launchPrimaryCtaExperiment: boolean;
}

export const launchExperimentFlags: LaunchExperimentFlags = {
  launchHeroCopyExperiment: parseBooleanFlag(import.meta.env.VITE_LAUNCH_EXPERIMENT_HERO_COPY),
  launchPrimaryCtaExperiment: parseBooleanFlag(import.meta.env.VITE_LAUNCH_EXPERIMENT_PRIMARY_CTA),
};
````

## File: src/lib/launch-experiments.ts
````typescript
import { brandCopy } from "@/lib/brand-copy";

export type HeroCopyVariant = "control" | "speed";
export type PrimaryCtaVariant = "control" | "quality_pass";

export interface LaunchExperimentAssignments {
  heroCopy: HeroCopyVariant;
  primaryCta: PrimaryCtaVariant;
}

const HERO_VARIANTS: readonly HeroCopyVariant[] = ["control", "speed"];
const PRIMARY_CTA_VARIANTS: readonly PrimaryCtaVariant[] = ["control", "quality_pass"];
const STORAGE_KEY_HERO_COPY = "promptforge:launch-exp:hero-copy";
const STORAGE_KEY_PRIMARY_CTA = "promptforge:launch-exp:primary-cta";
const QUERY_KEY_HERO_COPY = "exp_hero";
const QUERY_KEY_PRIMARY_CTA = "exp_cta";

const heroCopyQueryMap: Record<string, HeroCopyVariant> = {
  a: "control",
  b: "speed",
  control: "control",
  speed: "speed",
};

const primaryCtaQueryMap: Record<string, PrimaryCtaVariant> = {
  a: "control",
  b: "quality_pass",
  control: "control",
  quality_pass: "quality_pass",
};

function normalizeExperimentToken(value: string | null): string {
  return (value || "").trim().toLowerCase();
}

function pickStoredVariant<T extends string>(
  storageKey: string,
  variants: readonly T[],
  random: () => number,
): T {
  if (typeof window === "undefined") return variants[0];

  const stored = window.sessionStorage.getItem(storageKey);
  if (stored && variants.includes(stored as T)) return stored as T;

  const next = random() < 0.5 ? variants[0] : variants[1];
  window.sessionStorage.setItem(storageKey, next);
  return next;
}

function readQueryValue(search: string | undefined, key: string): string | null {
  if (typeof search === "string") {
    return new URLSearchParams(search).get(key);
  }
  if (typeof window === "undefined") return null;
  return new URLSearchParams(window.location.search).get(key);
}

export function getLaunchExperimentAssignments(options: {
  search?: string;
  random?: () => number;
} = {}): LaunchExperimentAssignments {
  const random = options.random ?? Math.random;

  const heroQuery = normalizeExperimentToken(readQueryValue(options.search, QUERY_KEY_HERO_COPY));
  const heroFromQuery = heroCopyQueryMap[heroQuery];

  const primaryCtaQuery = normalizeExperimentToken(readQueryValue(options.search, QUERY_KEY_PRIMARY_CTA));
  const primaryCtaFromQuery = primaryCtaQueryMap[primaryCtaQuery];

  const heroCopy = heroFromQuery || pickStoredVariant(STORAGE_KEY_HERO_COPY, HERO_VARIANTS, random);
  const primaryCta =
    primaryCtaFromQuery || pickStoredVariant(STORAGE_KEY_PRIMARY_CTA, PRIMARY_CTA_VARIANTS, random);

  if (typeof window !== "undefined") {
    window.sessionStorage.setItem(STORAGE_KEY_HERO_COPY, heroCopy);
    window.sessionStorage.setItem(STORAGE_KEY_PRIMARY_CTA, primaryCta);
  }

  return {
    heroCopy,
    primaryCta,
  };
}

export function getHeroCopyVariant(variant: HeroCopyVariant): { headline: string; subhead: string } {
  if (variant === "speed") {
    return {
      headline: "Ship quality prompts faster with grounded context",
      subhead:
        "Start from rough intent, run a quality pass, and remix proven prompts without rewriting from scratch.",
    };
  }

  return {
    headline: brandCopy.hero.headline,
    subhead: brandCopy.hero.subhead,
  };
}

export function getPrimaryCtaVariantLabel(variant: PrimaryCtaVariant): string {
  if (variant === "quality_pass") return "Run quality pass";
  return brandCopy.hero.primaryCta;
}
````

## File: src/lib/launch-utm.ts
````typescript
import { normalizeHttpUrl } from "@/lib/url-utils";

export type LaunchUtmChannel =
  | "organic_social"
  | "paid_social"
  | "email"
  | "community"
  | "partner";

export interface LaunchUtmOptions {
  campaign: string;
  channel: LaunchUtmChannel;
  content?: string;
  term?: string;
}

const channelDefaults: Record<LaunchUtmChannel, { source: string; medium: string }> = {
  organic_social: { source: "social", medium: "organic" },
  paid_social: { source: "social", medium: "paid" },
  email: { source: "email", medium: "owned" },
  community: { source: "community", medium: "referral" },
  partner: { source: "partner", medium: "referral" },
};

function normalizeCampaignValue(value: string): string {
  return value
    .trim()
    .toLowerCase()
    .replace(/\s+/g, "-")
    .replace(/[^a-z0-9_-]/g, "")
    .slice(0, 80);
}

export function buildLaunchTrackedUrl(baseUrl: string, options: LaunchUtmOptions): string | null {
  const normalizedBase = normalizeHttpUrl(baseUrl);
  if (!normalizedBase) return null;

  const campaign = normalizeCampaignValue(options.campaign);
  if (!campaign) return null;

  const defaults = channelDefaults[options.channel];
  const url = new URL(normalizedBase);
  url.searchParams.set("utm_source", defaults.source);
  url.searchParams.set("utm_medium", defaults.medium);
  url.searchParams.set("utm_campaign", campaign);

  if (options.content?.trim()) {
    url.searchParams.set("utm_content", options.content.trim().toLowerCase().replace(/\s+/g, "_"));
  }

  if (options.term?.trim()) {
    url.searchParams.set("utm_term", options.term.trim().toLowerCase().replace(/\s+/g, "_"));
  }

  return url.toString();
}
````

## File: src/lib/library-pages.ts
````typescript
import type { AuthUser } from "@/hooks/useAuth";

function normalizeIds(ids: string[]): string[] {
  return Array.from(
    new Set(
      ids
        .map((id) => id.trim())
        .filter(Boolean),
    ),
  );
}

export function decodeSelectionIds(searchParams: URLSearchParams): string[] {
  return normalizeIds(searchParams.getAll("id"));
}

export function encodeSelectionIds(ids: string[]): URLSearchParams {
  const next = new URLSearchParams();
  normalizeIds(ids).forEach((id) => next.append("id", id));
  return next;
}

export function getUserDisplayName(user: AuthUser | null): string {
  if (!user) return "Guest";
  const metadata = user.user_metadata as Record<string, unknown> | null | undefined;
  const displayName = typeof metadata?.display_name === "string" ? metadata.display_name : "";
  if (displayName.trim()) return displayName.trim();
  const fullName = typeof metadata?.full_name === "string" ? metadata.full_name : "";
  if (fullName.trim()) return fullName.trim();
  if (user.email) return user.email;
  return "You";
}

export function getUserAvatarUrl(user: AuthUser | null): string | null {
  if (!user) return null;
  const metadata = user.user_metadata as Record<string, unknown> | null | undefined;
  const avatarUrl = typeof metadata?.avatar_url === "string" ? metadata.avatar_url.trim() : "";
  return avatarUrl || null;
}

export function getInitials(value: string): string {
  const parts = value
    .split(" ")
    .map((part) => part.trim())
    .filter(Boolean);
  if (parts.length === 0) return "?";
  if (parts.length === 1) return parts[0].slice(0, 2).toUpperCase();
  return `${parts[0][0] || ""}${parts[1][0] || ""}`.toUpperCase();
}
````

## File: src/lib/prompt-config-adapters.ts
````typescript
import type { ContextSource, DatabaseConnection, RagParameters } from "@/lib/context-types";
import { defaultContextConfig } from "@/lib/context-types";
import { defaultConfig, type PromptConfig } from "@/lib/prompt-builder";
import { normalizeTemplateConfig } from "@/lib/template-store";

type FieldOwnership = "ai" | "user" | "empty";
export const PROMPT_CONFIG_SCHEMA_VERSION_KEY = "__schemaVersion";
export const PROMPT_CONFIG_V2_COMPAT_KEY = "__promptConfigV2";

export interface PromptConfigV2 {
  originalPrompt: string;
  role: string;
  audience: string;
  tone: string;
  format: string[];
  lengthPreference: "brief" | "standard" | "detailed";
  constraints: string[];
  examples: string;
  sources: ContextSource[];
  projectNotes: string;
  advanced: {
    useDelimiters: boolean;
    databaseConnections: DatabaseConnection[];
    rag: RagParameters;
  };
  aiMeta?: {
    fieldOwnership: Record<string, FieldOwnership>;
    inferredAt?: number;
  };
}

interface SerializeWorkingStateToV1Options {
  includeV2Compat?: boolean;
  preserveSourceRawContent?: boolean;
}

function isRecord(value: unknown): value is Record<string, unknown> {
  return !!value && typeof value === "object";
}

function toStringArray(value: unknown): string[] {
  if (!Array.isArray(value)) return [];
  return value.filter((entry): entry is string => typeof entry === "string");
}

function normalizeLengthPreference(value: unknown): "brief" | "standard" | "detailed" {
  return value === "brief" || value === "detailed" ? value : "standard";
}

function toPromptConfig(config: PromptConfig): PromptConfig {
  return {
    originalPrompt: config.originalPrompt,
    role: config.role,
    customRole: config.customRole,
    task: config.task,
    context: config.context,
    contextConfig: config.contextConfig,
    format: config.format,
    customFormat: config.customFormat,
    lengthPreference: config.lengthPreference,
    examples: config.examples,
    constraints: config.constraints,
    customConstraint: config.customConstraint,
    tone: config.tone,
    complexity: config.complexity,
  };
}

function toOriginalPrompt(originalPrompt: string, task: string): string {
  const normalizedOriginal = originalPrompt.trim();
  const normalizedTask = task.trim();

  if (normalizedOriginal && normalizedTask && normalizedOriginal !== normalizedTask) {
    return `${normalizedOriginal}\n\n${normalizedTask}`;
  }

  return normalizedOriginal || normalizedTask;
}

function hasLegacyV1Fields(value: Record<string, unknown>): boolean {
  return (
    "contextConfig" in value ||
    "customRole" in value ||
    "task" in value ||
    "customFormat" in value ||
    "customConstraint" in value ||
    "complexity" in value
  );
}

function isPromptConfigV2Payload(value: unknown): value is PromptConfigV2 {
  if (!isRecord(value)) return false;
  const advanced = value.advanced;
  return (
    typeof value.originalPrompt === "string" &&
    typeof value.role === "string" &&
    typeof value.audience === "string" &&
    typeof value.tone === "string" &&
    Array.isArray(value.format) &&
    Array.isArray(value.constraints) &&
    typeof value.examples === "string" &&
    Array.isArray(value.sources) &&
    typeof value.projectNotes === "string" &&
    isRecord(advanced)
  );
}

function hydrateConfigV2ToWorkingState(payload: PromptConfigV2): PromptConfig {
  const { advanced } = payload;
  const normalized = normalizeTemplateConfig(
    {
      ...defaultConfig,
      originalPrompt: payload.originalPrompt,
      role: payload.role,
      customRole: "",
      tone: payload.tone || defaultConfig.tone,
      format: toStringArray(payload.format),
      customFormat: "",
      lengthPreference: normalizeLengthPreference(payload.lengthPreference),
      constraints: toStringArray(payload.constraints),
      customConstraint: "",
      examples: payload.examples,
      contextConfig: {
        ...defaultContextConfig,
        sources: Array.isArray(payload.sources)
          ? (payload.sources as ContextSource[])
          : [],
        projectNotes: payload.projectNotes,
        useDelimiters: advanced.useDelimiters,
        databaseConnections: advanced.databaseConnections,
        rag: {
          ...defaultContextConfig.rag,
          ...advanced.rag,
          documentRefs: toStringArray(advanced.rag.documentRefs),
        },
        structured: {
          ...defaultContextConfig.structured,
          audience: payload.audience,
        },
        interviewAnswers: [],
      },
    },
    { preserveSourceRawContent: true },
  );

  return toPromptConfig(normalized);
}

export function hydrateConfigV1ToWorkingState(raw: unknown): PromptConfig {
  if (!isRecord(raw)) return defaultConfig;
  const embeddedV2Raw = raw[PROMPT_CONFIG_V2_COMPAT_KEY];
  const embeddedV2: PromptConfigV2 | null = isPromptConfigV2Payload(embeddedV2Raw)
    ? embeddedV2Raw
    : null;

  if (!hasLegacyV1Fields(raw)) {
    if (isPromptConfigV2Payload(raw)) {
      return hydrateConfigV2ToWorkingState(raw);
    }
    if (embeddedV2) {
      return hydrateConfigV2ToWorkingState(embeddedV2);
    }
  }

  const candidate = raw as Partial<PromptConfig>;
  const rawContextConfig = isRecord(candidate.contextConfig)
    ? (candidate.contextConfig as Record<string, unknown>)
    : {};
  const rawRag = isRecord(rawContextConfig.rag)
    ? (rawContextConfig.rag as Record<string, unknown>)
    : {};

  const hydrated: PromptConfig = {
    ...defaultConfig,
    ...candidate,
    format: toStringArray(candidate.format),
    constraints: toStringArray(candidate.constraints),
    contextConfig: {
      ...defaultContextConfig,
      ...(rawContextConfig as Partial<typeof defaultContextConfig>),
      sources: Array.isArray(rawContextConfig.sources)
        ? (rawContextConfig.sources as typeof defaultContextConfig.sources)
        : [],
      databaseConnections: Array.isArray(rawContextConfig.databaseConnections)
        ? (rawContextConfig.databaseConnections as typeof defaultContextConfig.databaseConnections)
        : [],
      rag: {
        ...defaultContextConfig.rag,
        ...(rawRag as Partial<typeof defaultContextConfig.rag>),
        documentRefs: toStringArray(rawRag.documentRefs),
      },
      structured: {
        ...defaultContextConfig.structured,
        ...(isRecord(rawContextConfig.structured)
          ? (rawContextConfig.structured as Partial<typeof defaultContextConfig.structured>)
          : {}),
      },
      interviewAnswers: Array.isArray(rawContextConfig.interviewAnswers)
        ? (rawContextConfig.interviewAnswers as typeof defaultContextConfig.interviewAnswers)
        : [],
    },
  };

  return toPromptConfig(normalizeTemplateConfig(hydrated, { preserveSourceRawContent: true }));
}

export function serializeWorkingStateToV1(
  config: PromptConfig,
  options: SerializeWorkingStateToV1Options = {},
): PromptConfig {
  const normalized = toPromptConfig(
    normalizeTemplateConfig(config, {
      preserveSourceRawContent: options.preserveSourceRawContent === true,
    }),
  );
  if (options.includeV2Compat === false) {
    return normalized;
  }

  const v2 = serializeWorkingStateToV2(normalized);
  return {
    ...normalized,
    [PROMPT_CONFIG_SCHEMA_VERSION_KEY]: 2,
    [PROMPT_CONFIG_V2_COMPAT_KEY]: v2,
  } as PromptConfig;
}

export function serializeWorkingStateToV2(config: PromptConfig): PromptConfigV2 {
  const normalized = normalizeTemplateConfig(config);
  const format = [...normalized.format];
  if (normalized.customFormat.trim()) {
    format.push(normalized.customFormat.trim());
  }

  const constraints = [...normalized.constraints];
  if (normalized.customConstraint.trim()) {
    constraints.push(normalized.customConstraint.trim());
  }

  const lengthPreference: "brief" | "standard" | "detailed" =
    normalized.lengthPreference === "brief" || normalized.lengthPreference === "detailed"
      ? normalized.lengthPreference
      : "standard";

  return {
    originalPrompt: toOriginalPrompt(normalized.originalPrompt, normalized.task),
    role: (normalized.customRole || normalized.role || "").trim(),
    audience: normalized.contextConfig.structured.audience,
    tone: normalized.tone,
    format,
    lengthPreference,
    constraints,
    examples: normalized.examples,
    sources: normalized.contextConfig.sources,
    projectNotes: normalized.contextConfig.projectNotes,
    advanced: {
      useDelimiters: normalized.contextConfig.useDelimiters,
      databaseConnections: normalized.contextConfig.databaseConnections,
      rag: normalized.contextConfig.rag,
    },
  };
}
````

## File: src/lib/saved-prompt-shared.ts
````typescript
import type { Json } from "@/integrations/neon/types";

export interface PostgrestError {
  code: string;
  details: string;
  hint: string;
  message: string;
}

export interface SavedPromptRow {
  id: string;
  user_id: string;
  title: string;
  description: string;
  category: string;
  tags: string[] | null;
  config: Json | null;
  built_prompt: string;
  enhanced_prompt: string;
  fingerprint: string | null;
  revision: number;
  is_shared: boolean;
  target_model: string;
  use_case: string;
  remixed_from: string | null;
  remix_note: string;
  remix_diff: Json | null;
  created_at: string;
  updated_at: string;
}

export type SavedPromptListRow = Omit<
  SavedPromptRow,
  "built_prompt" | "enhanced_prompt" | "remix_note" | "remix_diff"
>;

export function isPostgrestError(value: unknown): value is PostgrestError {
  if (!value || typeof value !== "object") return false;
  const candidate = value as Record<string, unknown>;
  return typeof candidate.message === "string" && typeof candidate.code === "string";
}

function isHighSurrogate(codeUnit: number): boolean {
  return codeUnit >= 0xd800 && codeUnit <= 0xdbff;
}

function isLowSurrogate(codeUnit: number): boolean {
  return codeUnit >= 0xdc00 && codeUnit <= 0xdfff;
}

export function sanitizePostgresText(value: string): string {
  let sanitized = "";
  for (let index = 0; index < value.length; index += 1) {
    const codeUnit = value.charCodeAt(index);
    if (codeUnit === 0) {
      continue;
    }

    if (isHighSurrogate(codeUnit)) {
      const nextCodeUnit = index + 1 < value.length ? value.charCodeAt(index + 1) : 0;
      if (isLowSurrogate(nextCodeUnit)) {
        sanitized += value[index] + value[index + 1];
        index += 1;
      } else {
        sanitized += "\ufffd";
      }
      continue;
    }

    if (isLowSurrogate(codeUnit)) {
      sanitized += "\ufffd";
      continue;
    }

    sanitized += value[index];
  }
  return sanitized;
}

export function sanitizePostgresJson(value: Json): Json {
  if (typeof value === "string") {
    return sanitizePostgresText(value);
  }
  if (Array.isArray(value)) {
    return value.map((entry) => sanitizePostgresJson(entry as Json));
  }
  if (value && typeof value === "object") {
    const sanitizedObject: Record<string, Json> = {};
    for (const [key, entry] of Object.entries(value)) {
      if (entry === undefined) continue;
      sanitizedObject[key] = sanitizePostgresJson(entry as Json);
    }
    return sanitizedObject;
  }
  return value;
}

function normalizeTagsCore(tags: string[]): string[] {
  return Array.from(
    new Set(
      tags
        .map((tag) => sanitizePostgresText(tag).trim().toLowerCase())
        .filter(Boolean)
        .slice(0, 20),
    ),
  );
}

export function normalizePromptTags(tags?: string[]): string[] {
  if (!Array.isArray(tags)) return [];
  return normalizeTagsCore(tags);
}

export function normalizePromptTagsOptional(tags?: string[]): string[] | undefined {
  if (!Array.isArray(tags)) return undefined;
  return normalizeTagsCore(tags);
}

export function escapePostgrestLikePattern(value: string): string {
  return value.replace(/\\/g, "\\\\").replace(/%/g, "\\%").replace(/_/g, "\\_");
}
````

## File: src/lib/template-store.ts
````typescript
import type {
  ContextConfig,
  ContextReference,
  ContextSource,
  ContextSourceType,
  DatabaseConnection,
  RagParameters,
  SourceValidationStatus,
} from "@/lib/context-types";
import { defaultContextConfig } from "@/lib/context-types";
import type { PromptConfig } from "@/lib/prompt-builder";
import { defaultConfig } from "@/lib/prompt-builder";

const STORAGE_KEY = "promptforge-template-snapshots";
const CURRENT_SCHEMA_VERSION = 2;
const STALE_AFTER_MS = 1000 * 60 * 60 * 24 * 14;

type SaveOutcome = "created" | "updated" | "unchanged";

export interface TemplateMetadata {
  id: string;
  name: string;
  description: string;
  tags: string[];
  schemaVersion: number;
  revision: number;
  fingerprint: string;
  createdAt: number;
  updatedAt: number;
}

export interface TemplateExternalReference {
  sourceId: string;
  sourceType: ContextSourceType;
  refId: string;
  locator: string;
  title: string;
  permissionScope?: string;
  status: SourceValidationStatus;
  checkedAt?: number;
}

export interface TemplateState {
  promptConfig: PromptConfig;
  externalReferences: TemplateExternalReference[];
}

export interface TemplateRecord {
  metadata: TemplateMetadata;
  state: TemplateState;
}

export interface TemplateSaveInput {
  name: string;
  description?: string;
  tags?: string[];
  config: PromptConfig;
}

export interface SaveTemplateResult {
  outcome: SaveOutcome;
  record: TemplateRecord;
  warnings: string[];
}

export interface TemplateLoadResult {
  record: TemplateRecord;
  warnings: string[];
}

export interface TemplateSummary {
  id: string;
  name: string;
  description: string;
  tags: string[];
  starterPrompt: string;
  updatedAt: number;
  createdAt: number;
  revision: number;
  schemaVersion: number;
  sourceCount: number;
  databaseCount: number;
  ragEnabled: boolean;
}

interface TemplateEnvelope {
  schemaVersion: number;
  records: unknown[];
}

interface LegacyTemplateRecordV1 {
  name: string;
  role: string;
  task: string;
  context: string;
  id?: string;
  description?: string;
  format?: string[];
  lengthPreference?: string;
  tone?: string;
  complexity?: string;
  constraints?: string[];
  examples?: string;
}

function isLegacyTemplateRecordV1(value: unknown): value is LegacyTemplateRecordV1 {
  if (!isRecord(value)) return false;
  return (
    typeof value.name === "string" &&
    typeof value.role === "string" &&
    typeof value.task === "string" &&
    typeof value.context === "string"
  );
}

export const TEMPLATE_JSON_SCHEMA = {
  $schema: "https://json-schema.org/draft/2020-12/schema",
  title: "PromptTemplateSnapshot",
  type: "object",
  required: ["metadata", "state"],
  properties: {
    metadata: {
      type: "object",
      required: ["id", "name", "schemaVersion", "revision", "fingerprint", "createdAt", "updatedAt"],
      properties: {
        id: { type: "string" },
        name: { type: "string" },
        description: { type: "string" },
        tags: { type: "array", items: { type: "string" } },
        schemaVersion: { type: "integer", minimum: 1 },
        revision: { type: "integer", minimum: 1 },
        fingerprint: { type: "string" },
        createdAt: { type: "integer" },
        updatedAt: { type: "integer" },
      },
      additionalProperties: false,
    },
    state: {
      type: "object",
      required: ["promptConfig", "externalReferences"],
      properties: {
        promptConfig: { type: "object" },
        externalReferences: {
          type: "array",
          items: {
            type: "object",
            required: ["sourceId", "sourceType", "refId", "locator", "title", "status"],
          },
        },
      },
      additionalProperties: false,
    },
  },
  additionalProperties: false,
} as const;

function isRecord(value: unknown): value is Record<string, unknown> {
  return !!value && typeof value === "object";
}

function cloneDeep<T>(value: T): T {
  return JSON.parse(JSON.stringify(value)) as T;
}

function mergeContextConfig(input?: ContextConfig): ContextConfig {
  const raw = input || defaultContextConfig;
  const rag: RagParameters = {
    ...defaultContextConfig.rag,
    ...raw.rag,
    documentRefs: Array.isArray(raw.rag?.documentRefs) ? raw.rag.documentRefs : [],
  };

  const databaseConnections: DatabaseConnection[] = Array.isArray(raw.databaseConnections)
    ? raw.databaseConnections.map((db) => ({
        id: db.id || generateId("db"),
        label: db.label || db.connectionRef || "Database",
        provider: db.provider || "other",
        connectionRef: db.connectionRef || "",
        database: db.database || "",
        schema: db.schema || "",
        tables: Array.isArray(db.tables) ? db.tables : [],
        readOnly: db.readOnly !== false,
        lastValidatedAt: db.lastValidatedAt,
      }))
    : [];

  return {
    ...defaultContextConfig,
    ...raw,
    sources: Array.isArray(raw.sources) ? raw.sources : [],
    databaseConnections,
    rag,
    structured: { ...defaultContextConfig.structured, ...raw.structured },
    interviewAnswers: Array.isArray(raw.interviewAnswers) ? raw.interviewAnswers : [],
  };
}

export function normalizeTemplateConfig(
  config: PromptConfig,
  options?: {
    preserveSourceRawContent?: boolean;
  },
): PromptConfig {
  const merged: PromptConfig = {
    ...defaultConfig,
    ...config,
    contextConfig: mergeContextConfig(config.contextConfig),
    format: Array.isArray(config.format) ? config.format : [],
    constraints: Array.isArray(config.constraints) ? config.constraints : [],
  };

  return {
    ...merged,
    contextConfig: {
      ...merged.contextConfig,
      sources: merged.contextConfig.sources.map((source) =>
        normalizeSource(source, options?.preserveSourceRawContent === true),
      ),
    },
  };
}

export function computeTemplateFingerprint(config: PromptConfig): string {
  const canonical = cloneDeep(config);
  canonical.contextConfig.sources = canonical.contextConfig.sources.map((source) => ({
    ...source,
    addedAt: 0,
    validation: source.validation
      ? {
          ...source.validation,
          checkedAt: 0,
        }
      : source.validation,
  }));
  canonical.contextConfig.databaseConnections = canonical.contextConfig.databaseConnections.map((db) => ({
    ...db,
    lastValidatedAt: 0,
  }));
  return fnv1aHash(stableStringify(canonical));
}

function createReference(source: ContextSource): ContextReference | undefined {
  if (source.type === "text") return source.reference;
  const defaultLocator =
    source.type === "url"
      ? source.rawContent.trim()
      : source.type === "file"
        ? source.title
        : source.title || source.id;
  const fallbackRefId = `${source.type}:${source.id}`;

  if (source.type === "url" || source.type === "file" || source.type === "database" || source.type === "rag") {
    return {
      kind: source.type,
      refId: source.reference?.refId || fallbackRefId,
      locator: source.reference?.locator || defaultLocator,
      permissionScope: source.reference?.permissionScope,
    };
  }

  return source.reference;
}

function normalizeSource(source: ContextSource, preserveRawContent: boolean): ContextSource {
  const normalizedReference = createReference(source);
  const shouldStripRaw =
    source.type === "url" || source.type === "file" || source.type === "database" || source.type === "rag";

  return {
    ...source,
    title: source.title || "Source",
    rawContent: shouldStripRaw && !preserveRawContent ? "" : source.rawContent || "",
    summary: source.summary || "",
    reference: normalizedReference,
    validation: validateSource({ ...source, reference: normalizedReference }),
  };
}

function validateSource(source: ContextSource): ContextSource["validation"] {
  const checkedAt = Date.now();
  if (source.type === "text") {
    return { status: "valid", checkedAt };
  }

  if (!source.reference?.refId || !source.reference.locator) {
    return { status: "invalid", checkedAt, message: "Missing external reference ID or locator." };
  }

  if (source.type === "url") {
    try {
      const url = new URL(source.reference.locator);
      if (url.protocol !== "http:" && url.protocol !== "https:") {
        return { status: "invalid", checkedAt, message: "URL sources must use http(s)." };
      }
    } catch {
      return { status: "invalid", checkedAt, message: "Malformed URL reference." };
    }
  }

  if (source.validation?.checkedAt && checkedAt - source.validation.checkedAt > STALE_AFTER_MS) {
    return { status: "stale", checkedAt: source.validation.checkedAt, message: "Source requires re-validation." };
  }

  return { status: "unknown", checkedAt };
}

function validateDatabaseConnections(databases: DatabaseConnection[]): string[] {
  const warnings: string[] = [];

  databases.forEach((db) => {
    if (!db.connectionRef.trim()) warnings.push(`DB "${db.label}" is missing connectionRef.`);
    if (!db.database.trim()) warnings.push(`DB "${db.label}" is missing database name.`);
    if (!db.readOnly) warnings.push(`DB "${db.label}" should be readOnly for template safety.`);
    if (db.lastValidatedAt && Date.now() - db.lastValidatedAt > STALE_AFTER_MS) {
      warnings.push(`DB "${db.label}" permissions may be stale.`);
    }
  });

  return warnings;
}

function validateRag(rag: RagParameters): string[] {
  if (!rag.enabled) return [];
  const warnings: string[] = [];
  if (!rag.vectorStoreRef.trim()) warnings.push("RAG is enabled but vectorStoreRef is missing.");
  if (rag.topK < 1 || rag.topK > 100) warnings.push("RAG topK must be between 1 and 100.");
  if (rag.minScore < 0 || rag.minScore > 1) warnings.push("RAG minScore must be between 0 and 1.");
  if (rag.chunkWindow < 1 || rag.chunkWindow > 20) warnings.push("RAG chunkWindow must be between 1 and 20.");
  return warnings;
}

export function collectTemplateWarnings(config: PromptConfig): string[] {
  const warnings: string[] = [];
  config.contextConfig.sources.forEach((source) => {
    if (source.validation?.status === "invalid") {
      warnings.push(`${source.title}: ${source.validation.message || "Invalid source reference."}`);
    }
    if (source.validation?.status === "stale") {
      warnings.push(`${source.title}: source reference should be re-validated.`);
    }
  });

  warnings.push(...validateDatabaseConnections(config.contextConfig.databaseConnections));
  warnings.push(...validateRag(config.contextConfig.rag));
  return warnings;
}

export function deriveExternalReferencesFromConfig(config: PromptConfig): TemplateExternalReference[] {
  const sourceRefs: TemplateExternalReference[] = config.contextConfig.sources
    .filter((source) => source.type !== "text")
    .map((source) => ({
      sourceId: source.id,
      sourceType: source.type,
      refId: source.reference?.refId || `${source.type}:${source.id}`,
      locator: source.reference?.locator || source.title,
      title: source.title,
      permissionScope: source.reference?.permissionScope,
      status: source.validation?.status || "unknown",
      checkedAt: source.validation?.checkedAt,
    }));

  const dbRefs: TemplateExternalReference[] = config.contextConfig.databaseConnections.map((db) => ({
    sourceId: db.id,
    sourceType: "database",
    refId: db.connectionRef,
    locator: `${db.database}${db.schema ? `.${db.schema}` : ""}`,
    title: db.label,
    permissionScope: db.readOnly ? "read_only" : "read_write",
    status: db.connectionRef.trim() && db.database.trim() ? "unknown" : "invalid",
    checkedAt: db.lastValidatedAt,
  }));

  const ragRefs: TemplateExternalReference[] =
    config.contextConfig.rag.enabled && config.contextConfig.rag.vectorStoreRef.trim()
      ? [
          {
            sourceId: `rag:${config.contextConfig.rag.vectorStoreRef}`,
            sourceType: "rag",
            refId: config.contextConfig.rag.vectorStoreRef,
            locator: config.contextConfig.rag.namespace || "default",
            title: "Vector Store",
            status: "unknown",
            checkedAt: Date.now(),
          },
          ...config.contextConfig.rag.documentRefs.map((docId) => ({
            sourceId: `rag-doc:${docId}`,
            sourceType: "rag" as const,
            refId: docId,
            locator: config.contextConfig.rag.vectorStoreRef,
            title: `RAG Document ${docId}`,
            status: "unknown" as const,
            checkedAt: Date.now(),
          })),
        ]
      : [];

  return [...sourceRefs, ...dbRefs, ...ragRefs];
}

function stableStringify(value: unknown): string {
  if (value === null || typeof value !== "object") {
    return JSON.stringify(value);
  }
  if (Array.isArray(value)) {
    return `[${value.map((item) => stableStringify(item)).join(",")}]`;
  }
  const entries = Object.entries(value).sort(([a], [b]) => a.localeCompare(b));
  return `{${entries.map(([k, v]) => `${JSON.stringify(k)}:${stableStringify(v)}`).join(",")}}`;
}

function fnv1aHash(input: string): string {
  let hash = 2166136261;
  for (let i = 0; i < input.length; i += 1) {
    hash ^= input.charCodeAt(i);
    hash += (hash << 1) + (hash << 4) + (hash << 7) + (hash << 8) + (hash << 24);
  }
  return `fnv1a-${(hash >>> 0).toString(16)}`;
}

function generateId(prefix: string): string {
  if (typeof crypto !== "undefined" && typeof crypto.randomUUID === "function") {
    return `${prefix}_${crypto.randomUUID()}`;
  }
  return `${prefix}_${Date.now()}_${Math.random().toString(16).slice(2)}`;
}

function parseEnvelope(raw: string | null): TemplateEnvelope {
  if (!raw) return { schemaVersion: CURRENT_SCHEMA_VERSION, records: [] };
  try {
    const parsed = JSON.parse(raw);
    if (Array.isArray(parsed)) {
      return { schemaVersion: 1, records: parsed };
    }
    if (isRecord(parsed) && Array.isArray(parsed.records)) {
      return {
        schemaVersion:
          typeof parsed.schemaVersion === "number" ? parsed.schemaVersion : CURRENT_SCHEMA_VERSION,
        records: parsed.records,
      };
    }
  } catch {
    // fall through
  }
  return { schemaVersion: CURRENT_SCHEMA_VERSION, records: [] };
}

function migrateLegacyV1(legacy: LegacyTemplateRecordV1): TemplateRecord {
  const now = Date.now();
  const config: PromptConfig = normalizeTemplateConfig({
    ...defaultConfig,
    role: legacy.role || "",
    task: legacy.task || "",
    context: legacy.context || "",
    format: Array.isArray(legacy.format) ? legacy.format : [],
    lengthPreference: legacy.lengthPreference || "standard",
    tone: legacy.tone || "Professional",
    complexity: legacy.complexity || "Moderate",
    constraints: Array.isArray(legacy.constraints) ? legacy.constraints : [],
    examples: legacy.examples || "",
  });
  const fingerprint = computeTemplateFingerprint(config);
  return {
    metadata: {
      id: legacy.id || generateId("tpl"),
      name: legacy.name || "Migrated Preset",
      description: legacy.description || "",
      tags: [],
      schemaVersion: CURRENT_SCHEMA_VERSION,
      revision: 1,
      fingerprint,
      createdAt: now,
      updatedAt: now,
    },
    state: {
      promptConfig: config,
      externalReferences: deriveExternalReferencesFromConfig(config),
    },
  };
}

function parseTemplateRecord(raw: unknown): TemplateRecord | null {
  if (!isRecord(raw)) return null;

  if ("metadata" in raw && "state" in raw && isRecord(raw.metadata) && isRecord(raw.state)) {
    const metadata = raw.metadata;
    const state = raw.state;
    if (typeof metadata.name !== "string" || typeof metadata.id !== "string") return null;
    const normalizedConfig = normalizeTemplateConfig((state.promptConfig || defaultConfig) as PromptConfig);
    const externalReferences = Array.isArray(state.externalReferences)
      ? (state.externalReferences as TemplateExternalReference[])
      : deriveExternalReferencesFromConfig(normalizedConfig);

    return {
      metadata: {
        id: metadata.id,
        name: metadata.name,
        description: typeof metadata.description === "string" ? metadata.description : "",
        tags: Array.isArray(metadata.tags) ? metadata.tags.filter((t): t is string => typeof t === "string") : [],
        schemaVersion:
          typeof metadata.schemaVersion === "number" ? metadata.schemaVersion : CURRENT_SCHEMA_VERSION,
        revision: typeof metadata.revision === "number" && metadata.revision > 0 ? metadata.revision : 1,
        fingerprint:
          typeof metadata.fingerprint === "string"
            ? metadata.fingerprint
            : computeTemplateFingerprint(normalizedConfig),
        createdAt: typeof metadata.createdAt === "number" ? metadata.createdAt : Date.now(),
        updatedAt: typeof metadata.updatedAt === "number" ? metadata.updatedAt : Date.now(),
      },
      state: {
        promptConfig: normalizedConfig,
        externalReferences,
      },
    };
  }

  if (isLegacyTemplateRecordV1(raw)) {
    return migrateLegacyV1(raw);
  }
  return null;
}

function readAllRecords(): TemplateRecord[] {
  if (typeof window === "undefined") return [];
  let raw!: string | null;
  try {
    raw = localStorage.getItem(STORAGE_KEY);
  } catch {
    return [];
  }
  const envelope = parseEnvelope(raw);
  const records = envelope.records.map(parseTemplateRecord).filter((r): r is TemplateRecord => !!r);
  return records.sort((a, b) => b.metadata.updatedAt - a.metadata.updatedAt);
}

function writeAllRecords(records: TemplateRecord[]): void {
  if (typeof window === "undefined") return;
  const payload: TemplateEnvelope = {
    schemaVersion: CURRENT_SCHEMA_VERSION,
    records: records.map((record) => cloneDeep(record)),
  };
  try {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));
  } catch {
    // Ignore storage failures to avoid crashing the UI.
  }
}

function toSingleLine(value: string): string {
  return value.replace(/\s+/g, " ").trim();
}

function clipText(value: string, limit: number): string {
  if (value.length <= limit) return value;
  return `${value.slice(0, limit - 3).trimEnd()}...`;
}

export function inferTemplateStarterPrompt(config: PromptConfig): string {
  const candidates = [
    config.originalPrompt,
    config.task,
    config.contextConfig.structured.offer,
    config.contextConfig.structured.product,
  ];
  const first = candidates.map(toSingleLine).find((value) => value.length > 0);
  if (!first) {
    return "Start by stating the goal, audience, and desired output format.";
  }
  return clipText(first, 120);
}

export function listTemplateSummaries(): TemplateSummary[] {
  return readAllRecords().map((record) => ({
    id: record.metadata.id,
    name: record.metadata.name,
    description: record.metadata.description,
    tags: record.metadata.tags,
    starterPrompt: inferTemplateStarterPrompt(record.state.promptConfig),
    updatedAt: record.metadata.updatedAt,
    createdAt: record.metadata.createdAt,
    revision: record.metadata.revision,
    schemaVersion: record.metadata.schemaVersion,
    sourceCount: record.state.promptConfig.contextConfig.sources.length,
    databaseCount: record.state.promptConfig.contextConfig.databaseConnections.length,
    ragEnabled: record.state.promptConfig.contextConfig.rag.enabled,
  }));
}

export function loadTemplateById(id: string): TemplateLoadResult | null {
  const records = readAllRecords();
  const record = records.find((entry) => entry.metadata.id === id);
  if (!record) return null;
  return {
    record: cloneDeep(record),
    warnings: collectTemplateWarnings(record.state.promptConfig),
  };
}

export function saveTemplateSnapshot(input: TemplateSaveInput): SaveTemplateResult {
  const name = input.name.trim();
  if (!name) throw new Error("Preset name is required.");

  const now = Date.now();
  const normalizedConfig = normalizeTemplateConfig(input.config);
  const normalizedDescription = input.description === undefined ? undefined : input.description.trim();
  const fingerprint = computeTemplateFingerprint(normalizedConfig);
  const warnings = collectTemplateWarnings(normalizedConfig);
  const records = readAllRecords();
  const existingIndex = records.findIndex((record) => record.metadata.name.toLowerCase() === name.toLowerCase());

  if (existingIndex >= 0) {
    const existing = records[existingIndex];
    if (existing.metadata.fingerprint === fingerprint) {
      return {
        outcome: "unchanged",
        record: cloneDeep(existing),
        warnings,
      };
    }

    const updated: TemplateRecord = {
      metadata: {
        ...existing.metadata,
        description: normalizedDescription ?? existing.metadata.description,
        tags: Array.isArray(input.tags) ? input.tags.map((tag) => tag.trim()).filter(Boolean) : existing.metadata.tags,
        revision: existing.metadata.revision + 1,
        fingerprint,
        updatedAt: now,
      },
      state: {
        promptConfig: normalizedConfig,
        externalReferences: deriveExternalReferencesFromConfig(normalizedConfig),
      },
    };

    const next = [...records];
    next.splice(existingIndex, 1, updated);
    writeAllRecords(next);
    return { outcome: "updated", record: cloneDeep(updated), warnings };
  }

  const created: TemplateRecord = {
    metadata: {
      id: generateId("tpl"),
      name,
      description: normalizedDescription ?? "",
      tags: Array.isArray(input.tags) ? input.tags.map((tag) => tag.trim()).filter(Boolean) : [],
      schemaVersion: CURRENT_SCHEMA_VERSION,
      revision: 1,
      fingerprint,
      createdAt: now,
      updatedAt: now,
    },
    state: {
      promptConfig: normalizedConfig,
      externalReferences: deriveExternalReferencesFromConfig(normalizedConfig),
    },
  };

  writeAllRecords([created, ...records]);
  return { outcome: "created", record: cloneDeep(created), warnings };
}

export function deleteTemplateById(id: string): boolean {
  const records = readAllRecords();
  const next = records.filter((record) => record.metadata.id !== id);
  if (next.length === records.length) return false;
  writeAllRecords(next);
  return true;
}

export function clearAllTemplatesForTest(): void {
  if (typeof window === "undefined") return;
  try {
    localStorage.removeItem(STORAGE_KEY);
  } catch {
    // Ignore storage failures in constrained environments.
  }
}
````

## File: src/lib/templates.ts
````typescript
export type PromptCategory =
  | "general"
  | "frontend"
  | "backend"
  | "fullstack"
  | "devops"
  | "data"
  | "ml-ai"
  | "security"
  | "testing"
  | "api"
  | "automation"
  | "docs";

export interface PromptTemplate {
  id: string;
  name: string;
  category: PromptCategory;
  description: string;
  starterPrompt: string;
  role: string;
  task: string;
  context: string;
  format: string[];
  lengthPreference: string;
  tone: string;
  complexity: string;
  constraints: string[];
  examples: string;
}

export interface PromptCategorySkin {
  card: string;
  iconWrap: string;
  badge: string;
  action: string;
}

export const templates: PromptTemplate[] = [
  {
    id: "blog-post",
    name: "Blog Post Writer",
    category: "docs",
    description: "Create engaging blog posts on any topic with SEO optimization",
    starterPrompt: "Write a 1,200-word blog post about edge AI for small businesses.",
    role: "Expert Copywriter & SEO Specialist",
    task: "Write a comprehensive, engaging blog post",
    context: "The blog targets a general audience interested in learning new topics. Content should be informative yet accessible.",
    format: ["Markdown"],
    lengthPreference: "detailed",
    tone: "Professional",
    complexity: "Moderate",
    constraints: ["Include citations", "Think step-by-step"],
    examples: "",
  },
  {
    id: "social-media",
    name: "Social Media Post",
    category: "general",
    description: "Craft attention-grabbing social media content",
    starterPrompt: "Create 3 LinkedIn posts announcing our spring product launch.",
    role: "Social Media Marketing Expert",
    task: "Create engaging social media posts that drive engagement",
    context: "Posts should be platform-optimized and include relevant hashtags. Focus on shareability.",
    format: ["Bullet points"],
    lengthPreference: "brief",
    tone: "Casual",
    complexity: "Simple",
    constraints: ["Be conversational"],
    examples: "",
  },
  {
    id: "email-campaign",
    name: "Email Campaign",
    category: "general",
    description: "Write persuasive email sequences",
    starterPrompt: "Draft a 4-email onboarding sequence for new trial users.",
    role: "Email Marketing Strategist",
    task: "Write a compelling email that converts readers",
    context: "Professional email targeting potential customers. Should follow email marketing best practices.",
    format: ["Paragraph form"],
    lengthPreference: "standard",
    tone: "Professional",
    complexity: "Moderate",
    constraints: ["Use formal tone"],
    examples: "",
  },
  {
    id: "data-analysis",
    name: "Data Analysis Report",
    category: "data",
    description: "Analyze datasets and provide actionable insights",
    starterPrompt: "Analyze this churn dataset and summarize the top 5 retention risks.",
    role: "Senior Data Analyst",
    task: "Analyze the provided data and generate a comprehensive report with insights",
    context: "Data-driven analysis targeting business decision makers who need actionable recommendations.",
    format: ["Table", "Bullet points"],
    lengthPreference: "detailed",
    tone: "Technical",
    complexity: "Advanced",
    constraints: ["Include citations", "Think step-by-step", "Avoid jargon"],
    examples: "",
  },
  {
    id: "code-review",
    name: "Code Review",
    category: "testing",
    description: "Thorough code review with improvement suggestions",
    starterPrompt: "Review this TypeScript API handler for bugs, security, and performance.",
    role: "Senior Software Engineer",
    task: "Review the provided code for bugs, performance issues, and best practices",
    context: "Code review for a production application. Focus on security, maintainability, and performance.",
    format: ["Code block", "Bullet points"],
    lengthPreference: "detailed",
    tone: "Technical",
    complexity: "Advanced",
    constraints: ["Think step-by-step"],
    examples: "",
  },
  {
    id: "brainstorm",
    name: "Brainstorming Session",
    category: "general",
    description: "Generate creative ideas and explore possibilities",
    starterPrompt: "Brainstorm 20 campaign ideas for a zero-budget local fitness app launch.",
    role: "Creative Director & Innovation Consultant",
    task: "Generate diverse, creative ideas and explore possibilities",
    context: "Open-ended creative brainstorming session. Push boundaries and think outside the box.",
    format: ["Numbered list"],
    lengthPreference: "detailed",
    tone: "Creative",
    complexity: "Moderate",
    constraints: ["Be conversational"],
    examples: "",
  },
  {
    id: "story-writing",
    name: "Story Writing",
    category: "general",
    description: "Craft compelling narratives and stories",
    starterPrompt: "Write a short sci-fi story about a city powered by memories.",
    role: "Published Fiction Author",
    task: "Write a compelling story with vivid characters and engaging plot",
    context: "Creative fiction writing. Focus on character development, dialogue, and narrative tension.",
    format: ["Paragraph form"],
    lengthPreference: "detailed",
    tone: "Creative",
    complexity: "Advanced",
    constraints: [],
    examples: "",
  },
  {
    id: "business-proposal",
    name: "Business Proposal",
    category: "general",
    description: "Create professional business proposals",
    starterPrompt: "Draft a proposal to redesign a retailer's ecommerce checkout flow.",
    role: "Business Development Consultant",
    task: "Draft a professional business proposal",
    context: "Formal business document targeting potential clients or stakeholders. Should demonstrate value proposition clearly.",
    format: ["Markdown", "Bullet points"],
    lengthPreference: "detailed",
    tone: "Professional",
    complexity: "Advanced",
    constraints: ["Use formal tone", "Include citations"],
    examples: "",
  },
  {
    id: "lesson-plan",
    name: "Lesson Plan",
    category: "docs",
    description: "Design structured educational lesson plans",
    starterPrompt: "Create a 45-minute lesson plan to teach photosynthesis to 8th graders.",
    role: "Experienced Educator & Curriculum Designer",
    task: "Create a structured, engaging lesson plan",
    context: "Educational content designed for effective learning outcomes. Include activities, assessments, and clear objectives.",
    format: ["Numbered list", "Bullet points"],
    lengthPreference: "detailed",
    tone: "Professional",
    complexity: "Moderate",
    constraints: ["Avoid jargon", "Think step-by-step"],
    examples: "",
  },
  {
    id: "explainer",
    name: "Concept Explainer",
    category: "docs",
    description: "Explain complex topics in simple terms",
    starterPrompt: "Explain how neural networks work using simple everyday analogies.",
    role: "Expert Teacher & Science Communicator",
    task: "Explain a complex concept in simple, easy-to-understand terms",
    context: "Educational explanation for beginners. Use analogies and real-world examples.",
    format: ["Paragraph form", "Bullet points"],
    lengthPreference: "standard",
    tone: "Casual",
    complexity: "Simple",
    constraints: ["Avoid jargon", "Be conversational"],
    examples: "",
  },
];

export const categoryLabels: Record<PromptCategory, string> = {
  general: "General",
  frontend: "Frontend",
  backend: "Backend",
  fullstack: "Fullstack",
  devops: "DevOps",
  data: "Data",
  "ml-ai": "ML / AI",
  security: "Security",
  testing: "Testing",
  api: "API",
  automation: "Automation",
  docs: "Docs",
};

export const promptCategorySkins: Record<PromptCategory, PromptCategorySkin> = {
  general: {
    card:
      "border-primary/25 bg-gradient-to-br from-primary/10 via-card to-card hover:border-primary/45",
    iconWrap: "bg-primary/15 text-primary",
    badge: "border-transparent bg-primary/15 text-primary",
    action: "border-primary/30 bg-primary/10 text-primary",
  },
  frontend: {
    card:
      "border-utility-blue-light-200 bg-gradient-to-br from-utility-blue-light-50 via-card to-card hover:border-utility-blue-light-300",
    iconWrap: "bg-utility-blue-light-50 text-utility-blue-light-700",
    badge: "border-transparent bg-utility-blue-light-50 text-utility-blue-light-700",
    action: "border-utility-blue-light-200 bg-utility-blue-light-50 text-utility-blue-light-700",
  },
  backend: {
    card:
      "border-utility-success-200 bg-gradient-to-br from-utility-success-50 via-card to-card hover:border-utility-success-300",
    iconWrap: "bg-utility-success-50 text-utility-success-700",
    badge: "border-transparent bg-utility-success-50 text-utility-success-700",
    action: "border-utility-success-200 bg-utility-success-50 text-utility-success-700",
  },
  fullstack: {
    card:
      "border-utility-purple-200 bg-gradient-to-br from-utility-purple-50 via-card to-card hover:border-utility-purple-300",
    iconWrap: "bg-utility-purple-50 text-utility-purple-700",
    badge: "border-transparent bg-utility-purple-50 text-utility-purple-700",
    action: "border-utility-purple-200 bg-utility-purple-50 text-utility-purple-700",
  },
  devops: {
    card:
      "border-utility-gray-blue-200 bg-gradient-to-br from-utility-gray-blue-50 via-card to-card hover:border-utility-gray-blue-300",
    iconWrap: "bg-utility-gray-blue-50 text-utility-gray-blue-700",
    badge: "border-transparent bg-utility-gray-blue-50 text-utility-gray-blue-700",
    action: "border-utility-gray-blue-200 bg-utility-gray-blue-50 text-utility-gray-blue-700",
  },
  data: {
    card:
      "border-utility-warning-200 bg-gradient-to-br from-utility-warning-50 via-card to-card hover:border-utility-warning-300",
    iconWrap: "bg-utility-warning-50 text-utility-warning-700",
    badge: "border-transparent bg-utility-warning-50 text-utility-warning-700",
    action: "border-utility-warning-200 bg-utility-warning-50 text-utility-warning-700",
  },
  "ml-ai": {
    card:
      "border-utility-pink-200 bg-gradient-to-br from-utility-pink-50 via-card to-card hover:border-utility-pink-300",
    iconWrap: "bg-utility-pink-50 text-utility-pink-700",
    badge: "border-transparent bg-utility-pink-50 text-utility-pink-700",
    action: "border-utility-pink-200 bg-utility-pink-50 text-utility-pink-700",
  },
  security: {
    card:
      "border-utility-error-200 bg-gradient-to-br from-utility-error-50 via-card to-card hover:border-utility-error-300",
    iconWrap: "bg-utility-error-50 text-utility-error-700",
    badge: "border-transparent bg-utility-error-50 text-utility-error-700",
    action: "border-utility-error-200 bg-utility-error-50 text-utility-error-700",
  },
  testing: {
    card:
      "border-utility-blue-200 bg-gradient-to-br from-utility-blue-50 via-card to-card hover:border-utility-blue-300",
    iconWrap: "bg-utility-blue-50 text-utility-blue-700",
    badge: "border-transparent bg-utility-blue-50 text-utility-blue-700",
    action: "border-utility-blue-200 bg-utility-blue-50 text-utility-blue-700",
  },
  api: {
    card:
      "border-utility-indigo-200 bg-gradient-to-br from-utility-indigo-50 via-card to-card hover:border-utility-indigo-300",
    iconWrap: "bg-utility-indigo-50 text-utility-indigo-700",
    badge: "border-transparent bg-utility-indigo-50 text-utility-indigo-700",
    action: "border-utility-indigo-200 bg-utility-indigo-50 text-utility-indigo-700",
  },
  automation: {
    card:
      "border-utility-gray-200 bg-gradient-to-br from-utility-gray-50 via-card to-card hover:border-utility-gray-300",
    iconWrap: "bg-utility-gray-50 text-utility-gray-700",
    badge: "border-transparent bg-utility-gray-50 text-utility-gray-700",
    action: "border-utility-gray-200 bg-utility-gray-50 text-utility-gray-700",
  },
  docs: {
    card:
      "border-utility-orange-200 bg-gradient-to-br from-utility-orange-50 via-card to-card hover:border-utility-orange-300",
    iconWrap: "bg-utility-orange-50 text-utility-orange-700",
    badge: "border-transparent bg-utility-orange-50 text-utility-orange-700",
    action: "border-utility-orange-200 bg-utility-orange-50 text-utility-orange-700",
  },
};

export const categoryColors: Record<PromptCategory, string> = {
  general: promptCategorySkins.general.badge,
  frontend: promptCategorySkins.frontend.badge,
  backend: promptCategorySkins.backend.badge,
  fullstack: promptCategorySkins.fullstack.badge,
  devops: promptCategorySkins.devops.badge,
  data: promptCategorySkins.data.badge,
  "ml-ai": promptCategorySkins["ml-ai"].badge,
  security: promptCategorySkins.security.badge,
  testing: promptCategorySkins.testing.badge,
  api: promptCategorySkins.api.badge,
  automation: promptCategorySkins.automation.badge,
  docs: promptCategorySkins.docs.badge,
};
````

## File: src/lib/ui-density.ts
````typescript
/**
 * Shared density variants used by UI primitives that need consistent sizing
 * across screens (state cards, toolbar actions, and section labels).
 */
export const UI_DENSITY_VARIANTS = ["comfortable", "compact"] as const;

export type UIDensity = (typeof UI_DENSITY_VARIANTS)[number];

export const DEFAULT_UI_DENSITY: UIDensity = "comfortable";
````

## File: src/lib/ui-status.ts
````typescript
export const UI_STATUS_SURFACE_CLASSES = {
  info: "border-primary/30 bg-primary/10 text-primary",
  success: "border-utility-success-200 bg-utility-success-50 text-utility-success-700",
  warning: "border-utility-warning-200 bg-utility-warning-50 text-utility-warning-700",
  danger: "border-utility-error-200 bg-utility-error-50 text-utility-error-700",
} as const;

export const UI_STATUS_TEXT_CLASSES = {
  info: "text-primary",
  success: "text-utility-success-700",
  warning: "text-utility-warning-700",
  danger: "text-utility-error-700",
} as const;

export const UI_STATUS_ROW_CLASSES = {
  success: "bg-utility-success-50 text-utility-success-700",
  warning: "bg-utility-warning-50 text-utility-warning-700",
  danger: "bg-utility-error-50 text-utility-error-700",
} as const;
````

## File: src/lib/user-preferences.ts
````typescript
const STORAGE_KEY = "promptforge-user-prefs";

export interface UserPreferences {
  theme: "light" | "dark";
  webSearchEnabled: boolean;
  showAdvancedControls: boolean;
}

const defaults: UserPreferences = {
  theme: "light",
  webSearchEnabled: false,
  showAdvancedControls: false,
};

function load(): UserPreferences {
  if (typeof window === "undefined") return { ...defaults };
  try {
    const raw = localStorage.getItem(STORAGE_KEY);
    if (!raw) return { ...defaults };
    const parsed = JSON.parse(raw) as Partial<UserPreferences>;
    return {
      theme: parsed.theme === "dark" ? "dark" : "light",
      webSearchEnabled: typeof parsed.webSearchEnabled === "boolean" ? parsed.webSearchEnabled : defaults.webSearchEnabled,
      showAdvancedControls: typeof parsed.showAdvancedControls === "boolean" ? parsed.showAdvancedControls : defaults.showAdvancedControls,
    };
  } catch {
    return { ...defaults };
  }
}

let cached: UserPreferences | null = null;

export function getUserPreferences(): UserPreferences {
  if (!cached) cached = load();
  return cached;
}

export function setUserPreference<K extends keyof UserPreferences>(
  key: K,
  value: UserPreferences[K],
): void {
  const prefs = getUserPreferences();
  prefs[key] = value;
  cached = prefs;
  try {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(prefs));
  } catch {
    // Storage full or unavailable — preference still cached in memory for session.
  }
}

/** Reset the in-memory cache (useful for tests). */
export function resetPreferencesCache(): void {
  cached = null;
}
````

## File: src/utils/cx.ts
````typescript
import { extendTailwindMerge } from "tailwind-merge";

const twMerge = extendTailwindMerge({
  extend: {
    theme: {
      text: ["display-xs", "display-sm", "display-md", "display-lg", "display-xl", "display-2xl"],
    },
  },
});

/**
 * This function is a wrapper around the twMerge function.
 * It is used to merge the classes inside style objects.
 */
export const cx = twMerge;

/**
 * This function does nothing besides helping us to be able to
 * sort the classes inside style objects which is not supported
 * by the Tailwind IntelliSense by default.
 */
type SortableClassMap = Record<
  string,
  string | number | Record<string, string | number | Record<string, string | number>>
>;

export function sortCx<T extends SortableClassMap>(classes: T): T {
  return classes;
}
````

## File: src/main.tsx
````typescript
import { createRoot } from "react-dom/client";
import App from "./App.tsx";
import "./styles/globals.css";

createRoot(document.getElementById("root")!).render(<App />);
````

## File: components.json
````json
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "default",
  "rsc": false,
  "tsx": true,
  "tailwind": {
    "config": "tailwind.config.ts",
    "css": "src/styles/globals.css",
    "baseColor": "slate",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  }
}
````

## File: postcss.config.js
````javascript
export default {
  plugins: {
    "@tailwindcss/postcss": {},
    autoprefixer: {},
  },
};
````

## File: vite.config.ts
````typescript
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react-swc";
import tailwindcss from "@tailwindcss/vite";
import path from "path";
import { componentTagger } from "lovable-tagger";

// https://vitejs.dev/config/
export default defineConfig(({ mode }) => ({
  server: {
    host: "::",
    port: 8080,
    hmr: {
      overlay: false,
    },
  },
  plugins: [react(), tailwindcss(), mode === "development" && componentTagger()].filter(Boolean),
  resolve: {
    alias: {
      "@": path.resolve(__dirname, "./src"),
    },
  },
}));
````

## File: agent_service/codex-config.mjs
````javascript
import { readFile } from "node:fs/promises";
import { homedir } from "node:os";
import { join } from "node:path";
import { parse as parseToml } from "smol-toml";

const CONFIG_PATH = join(homedir(), ".codex", "config.toml");

/**
 * @typedef {Object} ResolvedProviderConfig
 * @property {string} provider - Provider key (e.g. "azure", "openai")
 * @property {string} name - Human-readable provider name
 * @property {string} baseUrl - API base URL
 * @property {string} envKey - Environment variable name for the API key
 * @property {string} wireApi - Wire API format ("responses" | "chat")
 * @property {string} model - Default model from config.toml top-level or profile
 */

/**
 * Load and parse ~/.codex/config.toml, resolving the active model provider.
 *
 * @returns {ResolvedProviderConfig | null} Resolved provider config, or null if
 *   config.toml is missing or doesn't specify a model_provider.
 */
export async function loadCodexConfig() {
  let raw;
  try {
    raw = await readFile(CONFIG_PATH, "utf8");
  } catch {
    return null;
  }

  let config;
  try {
    config = parseToml(raw);
  } catch {
    return null;
  }

  return resolveProviderConfig(config);
}

/**
 * Resolve provider details from a parsed Codex config object.
 *
 * Supports objects from ~/.codex/config.toml and CODEX_CONFIG_JSON.
 *
 * @param {Record<string, unknown> | null | undefined} config
 * @returns {ResolvedProviderConfig | null}
 */
export function resolveProviderConfig(config) {
  if (!config || typeof config !== "object" || Array.isArray(config)) return null;

  const providerKey = typeof config.model_provider === "string"
    ? config.model_provider.trim()
    : "";
  if (!providerKey) return null;

  const model = typeof config.model === "string" ? config.model.trim() : "";

  const providers = config.model_providers;
  if (!providers || typeof providers !== "object") return null;

  const providerSection = providers[providerKey];
  if (!providerSection || typeof providerSection !== "object") return null;

  const name = typeof providerSection.name === "string"
    ? providerSection.name.trim()
    : providerKey;
  const baseUrl = typeof providerSection.base_url === "string"
    ? providerSection.base_url.trim()
    : "";
  const envKey = typeof providerSection.env_key === "string"
    ? providerSection.env_key.trim()
    : "";
  const wireApi = typeof providerSection.wire_api === "string"
    ? providerSection.wire_api.trim()
    : "";

  if (!baseUrl || !envKey) return null;

  return { provider: providerKey, name, baseUrl, envKey, wireApi, model };
}

/**
 * Resolve the API key for a provider config from the environment.
 *
 * @param {ResolvedProviderConfig} providerConfig
 * @returns {string | null}
 */
export function resolveApiKey(providerConfig) {
  if (!providerConfig?.envKey) return null;
  const value = process.env[providerConfig.envKey];
  return typeof value === "string" && value.trim() ? value.trim() : null;
}

/**
 * Check whether the resolved provider is Azure-based.
 *
 * @param {ResolvedProviderConfig | null} providerConfig
 * @returns {boolean}
 */
export function isAzureProvider(providerConfig) {
  if (!providerConfig) return false;
  return providerConfig.provider.toLowerCase().startsWith("azure");
}
````

## File: src/components/application/code-snippet/code-snippet.tsx
````typescript
import { useMemo, useState } from "react";
import { Badge, BadgeWithDot } from "@/components/base/badges/badges";
import { ButtonGroup, ButtonGroupItem } from "@/components/base/button-group/button-group";
import { ButtonUtility } from "@/components/base/buttons/button-utility";
import { cn } from "@/lib/utils";
import { Check, Copy } from "@phosphor-icons/react";

export interface CodeSnippetProps {
  code: string;
  language: string;
  fileName?: string;
  showLineNumbers?: boolean;
  className?: string;
}

export interface CodeSnippetTab {
  id: string;
  label: string;
  code: string;
  language: string;
  fileName?: string;
}

interface CodeSnippetTabsProps {
  tabs: CodeSnippetTab[];
  defaultTabId?: string;
}

export const CodeSnippet = ({
  code,
  language,
  fileName,
  showLineNumbers = true,
  className,
}: CodeSnippetProps) => {
  const [copied, setCopied] = useState(false);

  const lines = useMemo(() => code.replace(/\n$/, "").split("\n"), [code]);

  const handleCopy = async () => {
    try {
      if (typeof navigator !== "undefined" && navigator.clipboard) {
        await navigator.clipboard.writeText(code);
        setCopied(true);
        setTimeout(() => setCopied(false), 1200);
      }
    } catch {
      setCopied(false);
    }
  };

  return (
    <div className={cn("overflow-hidden rounded-xl border border-border bg-card", className)}>
      <div className="flex items-center justify-between gap-3 border-b border-border/80 px-3 py-2 sm:px-4">
        <div className="flex min-w-0 items-center gap-2">
          <BadgeWithDot tone="info" size="sm">
            {language.toUpperCase()}
          </BadgeWithDot>
          {fileName ? (
            <Badge tone="default" size="sm" className="truncate">
              {fileName}
            </Badge>
          ) : null}
        </div>
        <ButtonUtility
          icon={copied ? Check : Copy}
          tooltip={copied ? "Copied" : "Copy code"}
          onClick={handleCopy}
          color="tertiary"
          size="xs"
          aria-label={copied ? "Copied code" : "Copy code"}
        />
      </div>

      <pre className="overflow-x-auto p-3 sm:p-4">
        <code className="block font-mono text-xs text-foreground sm:text-sm">
          {lines.map((line, index) => (
            <span key={`${index}-${line}`} className={cn("grid min-h-[1.5rem]", showLineNumbers ? "grid-cols-[2rem_1fr]" : "grid-cols-1")}>
              {showLineNumbers ? (
                <span className="select-none pr-2 text-right text-muted-foreground tabular-nums">{index + 1}</span>
              ) : null}
              <span className="whitespace-pre break-normal">{line || " "}</span>
            </span>
          ))}
        </code>
      </pre>
    </div>
  );
};

export const CodeSnippetTabs = ({ tabs, defaultTabId }: CodeSnippetTabsProps) => {
  const [activeTab, setActiveTab] = useState(defaultTabId ?? tabs[0]?.id ?? "");
  const active = tabs.find((tab) => tab.id === activeTab) ?? tabs[0];
  const [showLineNumbers, setShowLineNumbers] = useState(true);

  if (!active) {
    return null;
  }

  return (
    <div className="space-y-3">
      <div className="flex flex-wrap items-center justify-between gap-2">
        <ButtonGroup value={active.id} onValueChange={(value) => value && setActiveTab(value)} aria-label="Snippet selection">
          {tabs.map((tab) => (
            <ButtonGroupItem key={tab.id} value={tab.id}>
              {tab.label}
            </ButtonGroupItem>
          ))}
        </ButtonGroup>

        <ButtonGroup
          value={showLineNumbers ? "on" : "off"}
          onValueChange={(value) => setShowLineNumbers(value !== "off")}
          aria-label="Line number mode"
        >
          <ButtonGroupItem value="on">Line Numbers</ButtonGroupItem>
          <ButtonGroupItem value="off">Plain</ButtonGroupItem>
        </ButtonGroup>
      </div>

      <CodeSnippet
        code={active.code}
        language={active.language}
        fileName={active.fileName}
        showLineNumbers={showLineNumbers}
      />
    </div>
  );
};
````

## File: src/components/application/progress-steps/progress-steps.tsx
````typescript
import { cn } from "@/lib/utils";
import { Check } from "@phosphor-icons/react";

export type ProgressStepStatus = "complete" | "current" | "upcoming";

export interface ProgressStepItem {
  id: string;
  title: string;
  description?: string;
  status: ProgressStepStatus;
}

interface ProgressStepsProps {
  steps: ProgressStepItem[];
  showNumbers?: boolean;
  className?: string;
}

function circleStyles(status: ProgressStepStatus) {
  if (status === "complete") {
    return "border-primary bg-primary text-primary-foreground";
  }

  if (status === "current") {
    return "border-primary bg-card text-primary";
  }

  return "border-border bg-card text-muted-foreground";
}

function lineStyles(status: ProgressStepStatus) {
  return status === "complete" ? "bg-primary" : "bg-border";
}

export const ProgressSteps = ({ steps, showNumbers = false, className }: ProgressStepsProps) => {
  return (
    <ol className={cn("w-full", className)}>
      <li className="grid gap-4 sm:grid-cols-[repeat(var(--step-count),minmax(0,1fr))]" style={{ ["--step-count" as string]: String(steps.length) }}>
        {steps.map((step, index) => {
          const isLast = index === steps.length - 1;
          const markerContent =
            step.status === "complete" && !showNumbers ? (
              <Check className="h-3.5 w-3.5" aria-hidden="true" />
            ) : (
              <span className="text-xs font-semibold">{index + 1}</span>
            );

          return (
            <div key={step.id} className="relative">
              {!isLast && (
                <span
                  className={cn("absolute left-8 right-0 top-3 hidden h-0.5 sm:block", lineStyles(step.status))}
                  aria-hidden="true"
                />
              )}
              <div className="relative flex items-start gap-3">
                <span
                  className={cn(
                    "relative z-10 inline-flex h-6 w-6 shrink-0 items-center justify-center rounded-full border",
                    circleStyles(step.status),
                  )}
                  aria-hidden="true"
                >
                  {markerContent}
                </span>
                <span className="flex min-w-0 flex-col">
                  <span
                    className={cn(
                      "text-sm font-medium",
                      step.status === "upcoming" ? "text-muted-foreground" : "text-foreground",
                    )}
                  >
                    {step.title}
                  </span>
                  {step.description ? <span className="text-xs text-muted-foreground">{step.description}</span> : null}
                </span>
              </div>
            </div>
          );
        })}
      </li>
    </ol>
  );
};
````

## File: src/components/base/badges/badge-types.ts
````typescript
export type IconComponentType = React.FunctionComponent<{ className?: string; strokeWidth?: string | number }>;

export type Sizes = "sm" | "md" | "lg";

export type BadgeColors = "gray" | "brand" | "error" | "warning" | "success" | "gray-blue" | "blue-light" | "blue" | "indigo" | "purple" | "pink" | "orange";

export type FlagTypes =
    | "AD"
    | "AE"
    | "AF"
    | "AG"
    | "AI"
    | "AL"
    | "AM"
    | "AO"
    | "AR"
    | "AS"
    | "AT"
    | "AU"
    | "AW"
    | "AX"
    | "AZ"
    | "BA"
    | "BB"
    | "BD"
    | "BE"
    | "BF"
    | "BG"
    | "BH"
    | "BI"
    | "BJ"
    | "BL"
    | "BM"
    | "BN"
    | "BO"
    | "BQ-1"
    | "BQ-2"
    | "BQ"
    | "BR"
    | "BS"
    | "BT"
    | "BW"
    | "BY"
    | "BZ"
    | "CA"
    | "CC"
    | "CD-1"
    | "CD"
    | "CF"
    | "CH"
    | "CK"
    | "CL"
    | "CM"
    | "CN"
    | "CO"
    | "CR"
    | "CU"
    | "CW"
    | "CX"
    | "CY"
    | "CZ"
    | "DE"
    | "DJ"
    | "DK"
    | "DM"
    | "DO"
    | "DS"
    | "DZ"
    | "earth"
    | "EC"
    | "EE"
    | "EG"
    | "EH"
    | "ER"
    | "ES"
    | "ET"
    | "FI"
    | "FJ"
    | "FK"
    | "FM"
    | "FO"
    | "FR"
    | "GA"
    | "GB-2"
    | "GB"
    | "GD"
    | "GE"
    | "GG"
    | "GH"
    | "GI"
    | "GL"
    | "GM"
    | "GN"
    | "GQ"
    | "GR"
    | "GT"
    | "GU"
    | "GW"
    | "GY"
    | "HK"
    | "HN"
    | "HR"
    | "HT"
    | "HU"
    | "ID"
    | "IE"
    | "IL"
    | "IM"
    | "IN"
    | "IO"
    | "IQ"
    | "IR"
    | "IS"
    | "IT"
    | "JE"
    | "JM"
    | "JO"
    | "JP"
    | "KE"
    | "KG"
    | "KH"
    | "KI"
    | "KM"
    | "KN"
    | "KP"
    | "KR"
    | "KW"
    | "KY"
    | "KZ"
    | "LA"
    | "LB"
    | "LC"
    | "LI"
    | "LK"
    | "LR"
    | "LS"
    | "LT"
    | "LU"
    | "LV"
    | "LY"
    | "MA"
    | "MC"
    | "MD"
    | "ME"
    | "MG"
    | "MH"
    | "MK"
    | "ML"
    | "MM"
    | "MN"
    | "MO"
    | "MP"
    | "MQ"
    | "MR"
    | "MS"
    | "MT"
    | "MU"
    | "MV"
    | "MW"
    | "MX"
    | "MY"
    | "MZ"
    | "NA"
    | "NE"
    | "NF"
    | "NG"
    | "NI"
    | "NL"
    | "NO"
    | "NP"
    | "NR"
    | "NU"
    | "NZ"
    | "OM"
    | "PA"
    | "PE"
    | "PF"
    | "PG"
    | "PH"
    | "PK"
    | "PL"
    | "PM"
    | "PN"
    | "PR"
    | "PT"
    | "PW"
    | "PY"
    | "QA"
    | "RE"
    | "RO"
    | "RS"
    | "RU"
    | "RW"
    | "SA"
    | "SB"
    | "SC"
    | "SD"
    | "SE"
    | "SG"
    | "SH"
    | "SI"
    | "SJ"
    | "SK"
    | "SL"
    | "SM"
    | "SN"
    | "SO"
    | "SR"
    | "SS"
    | "ST"
    | "SV"
    | "SX"
    | "SY"
    | "SZ"
    | "TC"
    | "TD"
    | "TF"
    | "TG"
    | "TH"
    | "TJ"
    | "TK"
    | "TL"
    | "TM"
    | "TN"
    | "TO"
    | "TR"
    | "TT"
    | "TV"
    | "TZ"
    | "UA"
    | "UG"
    | "UM"
    | "US"
    | "UY"
    | "UZ"
    | "VA"
    | "VC"
    | "VE"
    | "VG"
    | "VI"
    | "VN"
    | "VU"
    | "WF"
    | "WS"
    | "YE"
    | "YT"
    | "ZA"
    | "ZM"
    | "ZW";

export type ExtractColorKeys<T> = T extends { styles: infer C } ? keyof C : never;
export type ExtractBadgeKeys<T> = keyof T;
export type BadgeTypeToColorMap<T> = {
    [K in ExtractBadgeKeys<T>]: ExtractColorKeys<T[K]>;
};
export type BadgeTypeColors<T> = ExtractColorKeys<T[keyof T]>;

export const badgeTypes = {
    pillColor: "pill-color",
    badgeColor: "color",
    badgeModern: "modern",
} as const;

export type BadgeTypes = (typeof badgeTypes)[keyof typeof badgeTypes];
````

## File: src/components/base/badges/badges.stories.tsx
````typescript
import type { Meta, StoryObj } from "@storybook/react-vite";
import { Badge, BadgeWithDot, BadgeWithIcon } from "./badges";
import { CheckCircle as CheckCircle2 } from "@phosphor-icons/react";

const meta = {
  title: "Design System/Badge",
  component: Badge,
  args: {
    children: "Status",
    size: "md",
    type: "pill-color",
    color: "gray",
  },
  parameters: {
    layout: "centered",
  },
} satisfies Meta<typeof Badge>;

export default meta;
type Story = StoryObj<typeof meta>;

export const Gray: Story = {};

export const Brand: Story = {
  args: {
    color: "brand",
    children: "Featured",
  },
};

export const Error: Story = {
  args: {
    color: "error",
    children: "Blocked",
  },
};

export const WithDot: Story = {
  render: (args) => (
    <BadgeWithDot {...args}>
      Online
    </BadgeWithDot>
  ),
  args: {
    size: "md",
    type: "pill-color",
    color: "success",
  },
};

export const WithIcon: Story = {
  render: (args) => (
    <BadgeWithIcon {...args} iconLeading={CheckCircle2}>
      Verified
    </BadgeWithIcon>
  ),
  args: {
    size: "md",
    type: "pill-color",
    color: "brand",
  },
};
````

## File: src/components/base/buttons/button.stories.tsx
````typescript
import type { Meta, StoryObj } from "@storybook/react-vite";
import { Button } from "./button";
import { ArrowRight } from "@phosphor-icons/react";

const meta = {
  title: "Design System/Button",
  component: Button,
  args: {
    children: "Primary action",
    size: "sm",
    color: "primary",
  },
  parameters: {
    layout: "centered",
  },
} satisfies Meta<typeof Button>;

export default meta;
type Story = StoryObj<typeof meta>;

export const Primary: Story = {};

export const Secondary: Story = {
  args: {
    color: "secondary",
    children: "Secondary action",
  },
};

export const Tertiary: Story = {
  args: {
    color: "tertiary",
    children: "Tertiary action",
  },
};

export const Destructive: Story = {
  args: {
    color: "primary-destructive",
    children: "Delete item",
  },
};

export const Loading: Story = {
  args: {
    isLoading: true,
    children: "Saving",
  },
};

export const IconOnly: Story = {
  args: {
    size: "icon",
    color: "secondary",
    iconTrailing: ArrowRight,
    children: undefined,
    "aria-label": "Continue",
  },
};
````

## File: src/components/base/input/input-group.tsx
````typescript
import { type HTMLAttributes, type ReactNode } from "react";
import { HintText } from "@/components/base/input/hint-text";
import type { InputBaseProps } from "@/components/base/input/input";
import { TextField } from "@/components/base/input/input";
import { Label } from "@/components/base/input/label";
import { cx, sortCx } from "@/lib/utils/cx";

interface InputPrefixProps extends HTMLAttributes<HTMLDivElement> {
    /** The position of the prefix. */
    position?: "leading" | "trailing";
    /** The size of the prefix. */
    size?: "sm" | "md";
    /** Indicates that the prefix is disabled. */
    isDisabled?: boolean;
}

export const InputPrefix = ({ isDisabled, children, ...props }: InputPrefixProps) => (
    <span
        {...props}
        className={cx(
            "flex text-md text-tertiary shadow-xs ring-1 ring-border-primary ring-inset",
            // Styles when the prefix is within an `InputGroup`
            "in-data-input-wrapper:in-data-leading:-mr-px in-data-input-wrapper:in-data-leading:rounded-l-lg",
            "in-data-input-wrapper:in-data-trailing:-ml-px in-data-input-wrapper:in-data-trailing:rounded-r-lg",
            // Size styles based on size when within an `InputGroup`
            "in-data-input-wrapper:in-data-[input-size=md]:py-2.5 in-data-input-wrapper:in-data-[input-size=md]:pr-3 in-data-input-wrapper:in-data-[input-size=md]:pl-3.5 in-data-input-wrapper:in-data-[input-size=sm]:px-3 in-data-input-wrapper:in-data-[input-size=sm]:py-2",
            // Disabled styles
            isDisabled && "border-disabled bg-disabled_subtle text-tertiary",
            "in-data-input-wrapper:group-disabled:bg-disabled_subtle in-data-input-wrapper:group-disabled:text-disabled in-data-input-wrapper:group-disabled:ring-border-disabled",

            props.className,
        )}
    >
        {children}
    </span>
);

// `${string}ClassName` is used to omit any className prop that ends with a `ClassName` suffix
interface InputGroupProps extends Omit<InputBaseProps, "type" | "icon" | "placeholder" | "tooltip" | "shortcut" | `${string}ClassName`> {
    /** A prefix text that is displayed in the same box as the input.*/
    prefix?: string;
    /** A leading addon that is displayed with visual separation from the input. */
    leadingAddon?: ReactNode;
    /** A trailing addon that is displayed with visual separation from the input. */
    trailingAddon?: ReactNode;
    /** The class name to apply to the input group. */
    className?: string;
    /** The children of the input group (i.e `<InputBase />`) */
    children: ReactNode;
}

export const InputGroup = ({ size = "sm", prefix, leadingAddon, trailingAddon, label, hint, children, ...props }: InputGroupProps) => {
    const hasLeading = !!leadingAddon;
    const hasTrailing = !!trailingAddon;

    const paddings = sortCx({
        sm: {
            input: cx(
                // Apply padding styles when select element is passed as a child
                hasLeading && "group-has-[&>select]:px-2.5 group-has-[&>select]:pl-2.5",
                hasTrailing && (prefix ? "group-has-[&>select]:pr-6 group-has-[&>select]:pl-0" : "group-has-[&>select]:pr-6 group-has-[&>select]:pl-3"),
            ),
            leadingText: "pl-3",
        },
        md: {
            input: cx(
                // Apply padding styles when select element is passed as a child
                hasLeading && "group-has-[&>select]:px-3 group-has-[&>select]:pl-3",
                hasTrailing && (prefix ? "group-has-[&>select]:pr-6 group-has-[&>select]:pl-0" : "group-has-[&>select]:pr-6 group-has-[&>select]:pl-3"),
            ),
            leadingText: "pl-3.5",
        },
    });

    return (
        <TextField
            size={size}
            aria-label={label || undefined}
            inputClassName={cx(paddings[size].input)}
            tooltipClassName={cx(hasTrailing && !hasLeading && "group-has-[&>select]:right-0")}
            wrapperClassName={cx(
                "z-10",
                // Apply styles based on the presence of leading or trailing elements
                hasLeading && "rounded-l-none",
                hasTrailing && "rounded-r-none",
                // When select element is passed as a child
                "group-has-[&>select]:bg-transparent group-has-[&>select]:shadow-none group-has-[&>select]:ring-0 group-has-[&>select]:focus-within:ring-0",
                // In `Input` component, there is "group-disabled" class so here we need to use "group-disabled:group-has-[&>select]" to avoid conflict
                "group-disabled:group-has-[&>select]:bg-transparent",
            )}
            {...props}
        >
            {({ isDisabled, isInvalid, isRequired }) => (
                <>
                    {label && <Label isRequired={isRequired}>{label}</Label>}

                    <div
                        data-input-size={size}
                        className={cx(
                            "group relative flex h-max w-full flex-row justify-center rounded-lg bg-background transition-all duration-100 ease-linear",

                            // Only apply focus ring when child is select and input is focused
                            "has-[&>select]:shadow-xs has-[&>select]:ring-1 has-[&>select]:ring-border-primary has-[&>select]:ring-inset has-[&>select]:has-[input:focus]:ring-2 has-[&>select]:has-[input:focus]:ring-border-brand",

                            isDisabled && "cursor-not-allowed has-[&>select]:bg-disabled_subtle has-[&>select]:ring-border-disabled",
                            isInvalid && "has-[&>select]:ring-border-error_subtle has-[&>select]:has-[input:focus]:ring-border-error",
                        )}
                    >
                        {leadingAddon && <section data-leading={hasLeading || undefined}>{leadingAddon}</section>}

                        {prefix && (
                            <span className={cx("my-auto grow pr-2", paddings[size].leadingText)}>
                                <p className={cx("text-md text-tertiary", isDisabled && "text-disabled")}>{prefix}</p>
                            </span>
                        )}

                        {children}

                        {trailingAddon && <section data-trailing={hasTrailing || undefined}>{trailingAddon}</section>}
                    </div>

                    {hint && <HintText isInvalid={isInvalid}>{hint}</HintText>}
                </>
            )}
        </TextField>
    );
};

InputGroup.Prefix = InputPrefix;

InputGroup.displayName = "InputGroup";
````

## File: src/components/base/input/input-payment.tsx
````typescript
import { useControlledState } from "@react-stately/utils";
import { HintText } from "@/components/base/input/hint-text";
import type { InputBaseProps } from "@/components/base/input/input";
import { InputBase, TextField } from "@/components/base/input/input";
import { Label } from "@/components/base/input/label";
import { AmexIcon, DiscoverIcon, MastercardIcon, UnionPayIcon, VisaIcon } from "@/components/foundations/payment-icons";

const cardTypes = [
    {
        name: "Visa",
        pattern: /^4[0-9]{3,}$/, // Visa card numbers start with 4 and are 13 or 16 digits long
        card: "visa",
        icon: VisaIcon,
    },
    {
        name: "MasterCard",
        pattern: /^5[1-5][0-9]{2,}$/, // MasterCard numbers start with 51-55 and are 16 digits long
        card: "mastercard",
        icon: MastercardIcon,
    },
    {
        name: "American Express",
        pattern: /^3[47][0-9]{2,}$/, // American Express numbers start with 34 or 37 and are 15 digits long
        card: "amex",
        icon: AmexIcon,
    },
    {
        name: "Discover",
        pattern: /^6(?:011|5[0-9]{2}|4[4-9][0-9])[0-9]{12}$/, // Discover card numbers start with 6011 or 65 and are 16 digits long
        card: "discover",
        icon: DiscoverIcon,
    },
    {
        name: "UnionPay",
        pattern: /^(62|88)[0-9]{14,17}$/, // UnionPay card numbers start with 62 or 88 and are between 15-19 digits long
        card: "unionpay",
        icon: UnionPayIcon,
    },
    {
        name: "Unknown",
        pattern: /.*/, // Fallback pattern for unknown cards
        card: "unknown",
        icon: MastercardIcon,
    },
];

/**
 * Detect the card type based on the card number.
 * @param number The card number to detect the type for.
 * @returns The matching card type object.
 */
const detectCardType = (number: string) => {
    // Remove all spaces
    const sanitizedNumber = number.replace(/\D/g, "");

    // Find the matching card type
    const card = cardTypes.find((cardType) => cardType.pattern.test(sanitizedNumber));

    return card || cardTypes[cardTypes.length - 1];
};

/**
 * Format the card number in groups of 4 digits (i.e. 1234 5678 9012 3456).
 */
export const formatCardNumber = (number: string) => {
    // Remove non-numeric characters
    const cleaned = number.replace(/\D/g, "");

    // Format the card number in groups of 4 digits
    const match = cleaned.match(/\d{1,4}/g);

    if (match) {
        return match.join(" ");
    }

    return cleaned;
};

type PaymentInputProps = Omit<InputBaseProps, "icon">;

export const PaymentInput = ({ onChange, value, defaultValue, className, maxLength = 19, label, hint, ...props }: PaymentInputProps) => {
    const [cardNumber, setCardNumber] = useControlledState(value, defaultValue || "", (value) => {
        // Remove all non-numeric characters
        value = value.replace(/\D/g, "");

        onChange?.(value || "");
    });

    const card = detectCardType(cardNumber);

    return (
        <TextField
            aria-label={!label ? props?.placeholder : undefined}
            {...props}
            className={className}
            inputMode="numeric"
            maxLength={maxLength}
            value={formatCardNumber(cardNumber)}
            onChange={setCardNumber}
        >
            {({ isDisabled, isInvalid, isRequired }) => (
                <>
                    {label && <Label isRequired={isRequired}>{label}</Label>}

                    <InputBase
                        {...props}
                        isDisabled={isDisabled}
                        isInvalid={isInvalid}
                        icon={card.icon}
                        inputClassName="pl-13"
                        iconClassName="left-2.5 h-6 w-8.5"
                    />

                    {hint && <HintText isInvalid={isInvalid}>{hint}</HintText>}
                </>
            )}
        </TextField>
    );
};

PaymentInput.displayName = "PaymentInput";
````

## File: src/components/base/input/input.stories.tsx
````typescript
import type { Meta, StoryObj } from "@storybook/react-vite";
import { Input } from "./input";
import { MagnifyingGlass as Search } from "@phosphor-icons/react";

const meta = {
  title: "Design System/Input",
  component: Input,
  args: {
    label: "Prompt title",
    placeholder: "Enter a concise title",
    size: "sm",
  },
  parameters: {
    layout: "centered",
  },
  decorators: [
    (Story) => (
      <div className="w-[320px] sm:w-[420px]">
        <Story />
      </div>
    ),
  ],
} satisfies Meta<typeof Input>;

export default meta;
type Story = StoryObj<typeof meta>;

export const Default: Story = {};

export const WithLeadingIcon: Story = {
  args: {
    icon: Search,
    placeholder: "Search prompts",
  },
};

export const Disabled: Story = {
  args: {
    isDisabled: true,
    value: "Read-only value",
  },
};

export const InvalidWithHint: Story = {
  args: {
    isInvalid: true,
    value: "bad@@mail",
    label: "Email",
    hint: "Enter a valid email address.",
  },
};
````

## File: src/components/base/input/label.tsx
````typescript
import type { ReactNode, Ref } from "react";
import type { LabelProps as AriaLabelProps } from "react-aria-components";
import { Label as AriaLabel } from "react-aria-components";
import { Tooltip, TooltipTrigger } from "@/components/base/tooltip/tooltip";
import { cx } from "@/lib/utils/cx";
import { Question as HelpCircle } from "@phosphor-icons/react";

interface LabelProps extends AriaLabelProps {
    children: ReactNode;
    isRequired?: boolean;
    tooltip?: string;
    tooltipDescription?: string;
    ref?: Ref<HTMLLabelElement>;
}

export const Label = ({ isRequired, tooltip, tooltipDescription, className, ...props }: LabelProps) => {
    return (
        <AriaLabel
            // Used for conditionally hiding/showing the label element via CSS:
            // <Input label="Visible only on mobile" className="lg:**:data-label:hidden" />
            // or
            // <Input label="Visible only on mobile" className="lg:label:hidden" />
            data-label="true"
            {...props}
            className={cx("flex cursor-default items-center gap-0.5 text-sm font-medium text-secondary", className)}
        >
            {props.children}

            <span className={cx("hidden text-brand-tertiary", isRequired && "block", typeof isRequired === "undefined" && "group-required:block")}>*</span>

            {tooltip && (
                <Tooltip title={tooltip} description={tooltipDescription} placement="top">
                    <TooltipTrigger
                        // `TooltipTrigger` inherits the disabled state from the parent form field
                        // but we don't that. We want the tooltip be enabled even if the parent
                        // field is disabled.
                        isDisabled={false}
                        className="cursor-pointer text-fg-quaternary transition duration-200 hover:text-fg-quaternary_hover focus:text-fg-quaternary_hover"
                    >
                        <HelpCircle className="size-4" />
                    </TooltipTrigger>
                </Tooltip>
            )}
        </AriaLabel>
    );
};

Label.displayName = "Label";
````

## File: src/components/base/select/popover.tsx
````typescript
import type { RefAttributes } from "react";
import type { PopoverProps as AriaPopoverProps } from "react-aria-components";
import { Popover as AriaPopover } from "react-aria-components";
import { cx } from "@/lib/utils/cx";

interface PopoverProps extends AriaPopoverProps, RefAttributes<HTMLElement> {
    size: "sm" | "md";
}

export const Popover = (props: PopoverProps) => {
    return (
        <AriaPopover
            placement="bottom"
            containerPadding={0}
            offset={4}
            {...props}
            className={(state) =>
                cx(
                    "max-h-64! w-(--trigger-width) origin-(--trigger-anchor-point) overflow-x-hidden overflow-y-auto rounded-lg bg-popover py-1 shadow-lg ring-1 ring-border outline-hidden will-change-transform",

                    state.isEntering &&
                        "duration-150 ease-out animate-in fade-in placement-right:slide-in-from-left-0.5 placement-top:slide-in-from-bottom-0.5 placement-bottom:slide-in-from-top-0.5",
                    state.isExiting &&
                        "duration-100 ease-in animate-out fade-out placement-right:slide-out-to-left-0.5 placement-top:slide-out-to-bottom-0.5 placement-bottom:slide-out-to-top-0.5",
                    props.size === "md" && "max-h-80!",

                    typeof props.className === "function" ? props.className(state) : props.className,
                )
            }
        />
    );
};
````

## File: src/components/base/tags/base-components/tag-close-x.tsx
````typescript
import type { RefAttributes } from "react";
import { Button as AriaButton, type ButtonProps as AriaButtonProps } from "react-aria-components";
import { cx } from "@/lib/utils/cx";
import { X as XClose } from "@phosphor-icons/react";

interface TagCloseXProps extends AriaButtonProps, RefAttributes<HTMLButtonElement> {
    size?: "sm" | "md" | "lg";
    className?: string;
}

const styles = {
    sm: { root: "p-0.5", icon: "size-2.5" },
    md: { root: "p-0.5", icon: "size-3" },
    lg: { root: "p-0.75", icon: "size-3.5" },
};

export const TagCloseX = ({ size = "md", className, ...otherProps }: TagCloseXProps) => {
    return (
        <AriaButton
            slot="remove"
            aria-label="Remove this tag"
            className={cx(
                "flex cursor-pointer rounded-[3px] text-fg-quaternary outline-transparent transition duration-100 ease-linear hover:bg-primary_hover hover:text-fg-quaternary_hover focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-focus-ring disabled:cursor-not-allowed",
                styles[size].root,
                className,
            )}
            {...otherProps}
        >
            <XClose className={cx("transition-inherit-all", styles[size].icon)} strokeWidth="3" />
        </AriaButton>
    );
};
````

## File: src/components/base/textarea/textarea.tsx
````typescript
import type { ReactNode, Ref } from "react";
import React from "react";
import type { TextAreaProps as AriaTextAreaProps, TextFieldProps as AriaTextFieldProps } from "react-aria-components";
import { TextArea as AriaTextArea, TextField as AriaTextField } from "react-aria-components";
import { HintText } from "@/components/base/input/hint-text";
import { Label } from "@/components/base/input/label";
import { cx } from "@/lib/utils/cx";

// Creates a data URL for an SVG resize handle with a given color.
const getResizeHandleBg = (color: string) => {
    return `url(data:image/svg+xml;base64,${btoa(`<svg width="18" height="18" viewBox="0 0 18 18" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M10 2L2 10" stroke="${color}" stroke-linecap="round"/><path d="M11 7L7 11" stroke="${color}" stroke-linecap="round"/></svg>`)})`;
};

interface TextAreaBaseProps extends AriaTextAreaProps {
    ref?: Ref<HTMLTextAreaElement>;
}

export const TextAreaBase = ({ className, ...props }: TextAreaBaseProps) => {
    return (
        <AriaTextArea
            {...props}
            style={
                {
                    "--resize-handle-bg": getResizeHandleBg("#D5D7DA"),
                    "--resize-handle-bg-dark": getResizeHandleBg("#373A41"),
                } as React.CSSProperties
            }
            className={(state) =>
                cx(
                    "w-full scroll-py-3 rounded-lg bg-background px-3.5 py-3 text-md text-foreground shadow-xs ring-1 ring-border transition duration-100 ease-linear ring-inset placeholder:text-muted-foreground autofill:rounded-lg autofill:text-foreground focus:outline-hidden",

                    // Resize handle
                    "[&::-webkit-resizer]:bg-(image:--resize-handle-bg) [&::-webkit-resizer]:bg-contain dark:[&::-webkit-resizer]:bg-(image:--resize-handle-bg-dark)",

                    state.isFocused && !state.isDisabled && "ring-2 ring-brand",
                    state.isDisabled && "cursor-not-allowed bg-disabled_subtle text-disabled ring-disabled",
                    state.isInvalid && "ring-error_subtle",
                    state.isInvalid && state.isFocused && "ring-2 ring-error",

                    typeof className === "function" ? className(state) : className,
                )
            }
        />
    );
};

TextAreaBase.displayName = "TextAreaBase";

interface TextFieldProps extends AriaTextFieldProps {
    /** Label text for the textarea */
    label?: string;
    /** Helper text displayed below the textarea */
    hint?: ReactNode;
    /** Tooltip message displayed after the label. */
    tooltip?: string;
    /** Class name for the textarea wrapper */
    textAreaClassName?: TextAreaBaseProps["className"];
    /** Ref for the textarea wrapper */
    ref?: Ref<HTMLDivElement>;
    /** Ref for the textarea */
    textAreaRef?: TextAreaBaseProps["ref"];
    /** Whether to hide required indicator from label. */
    hideRequiredIndicator?: boolean;
    /** Placeholder text. */
    placeholder?: string;
    /** Visible height of textarea in rows . */
    rows?: number;
    /** Visible width of textarea in columns. */
    cols?: number;
}

export const TextArea = ({
    label,
    hint,
    tooltip,
    textAreaRef,
    hideRequiredIndicator,
    textAreaClassName,
    placeholder,
    className,
    rows,
    cols,
    ...props
}: TextFieldProps) => {
    return (
        <AriaTextField
            {...props}
            className={(state) =>
                cx("group flex h-max w-full flex-col items-start justify-start gap-1.5", typeof className === "function" ? className(state) : className)
            }
        >
            {({ isInvalid, isRequired }) => (
                <>
                    {label && (
                        <Label isRequired={hideRequiredIndicator ? !hideRequiredIndicator : isRequired} tooltip={tooltip}>
                            {label}
                        </Label>
                    )}

                    <TextAreaBase placeholder={placeholder} className={textAreaClassName} ref={textAreaRef} rows={rows} cols={cols} />

                    {hint && <HintText isInvalid={isInvalid}>{hint}</HintText>}
                </>
            )}
        </AriaTextField>
    );
};

TextArea.displayName = "TextArea";
````

## File: src/components/base/tooltip/tooltip.tsx
````typescript
import type { ReactNode } from "react";
import type {
    ButtonProps as AriaButtonProps,
    TooltipProps as AriaTooltipProps,
    TooltipTriggerComponentProps as AriaTooltipTriggerComponentProps,
} from "react-aria-components";
import { Button as AriaButton, OverlayArrow as AriaOverlayArrow, Tooltip as AriaTooltip, TooltipTrigger as AriaTooltipTrigger } from "react-aria-components";
import { cx } from "@/lib/utils/cx";

interface TooltipProps extends AriaTooltipTriggerComponentProps, Omit<AriaTooltipProps, "children"> {
    /**
     * The title of the tooltip.
     */
    title: ReactNode;
    /**
     * The description of the tooltip.
     */
    description?: ReactNode;
    /**
     * Whether to show the arrow on the tooltip.
     *
     * @default false
     */
    arrow?: boolean;
    /**
     * Delay in milliseconds before the tooltip is shown.
     *
     * @default 300
     */
    delay?: number;
}

export const Tooltip = ({
    title,
    description,
    children,
    arrow = false,
    delay = 300,
    closeDelay = 0,
    trigger,
    isDisabled,
    isOpen,
    defaultOpen,
    offset = 6,
    crossOffset,
    placement = "top",
    onOpenChange,
    ...tooltipProps
}: TooltipProps) => {
    const isTopOrBottomLeft = ["top left", "top end", "bottom left", "bottom end"].includes(placement);
    const isTopOrBottomRight = ["top right", "top start", "bottom right", "bottom start"].includes(placement);
    // Set negative cross offset for left and right placement to visually balance the tooltip.
    const calculatedCrossOffset = isTopOrBottomLeft ? -12 : isTopOrBottomRight ? 12 : 0;

    return (
        <AriaTooltipTrigger {...{ trigger, delay, closeDelay, isDisabled, isOpen, defaultOpen, onOpenChange }}>
            {children}

            <AriaTooltip
                {...tooltipProps}
                offset={offset}
                placement={placement}
                crossOffset={crossOffset ?? calculatedCrossOffset}
                className={({ isEntering, isExiting }) => cx(isEntering && "ease-out animate-in", isExiting && "ease-in animate-out")}
            >
                {({ isEntering, isExiting }) => (
                    <div
                        className={cx(
                            "z-50 flex max-w-xs origin-(--trigger-anchor-point) flex-col items-start gap-1 rounded-lg bg-primary-solid px-3 shadow-lg will-change-transform",
                            description ? "py-3" : "py-2",

                            isEntering &&
                                "ease-out animate-in fade-in zoom-in-95 in-placement-left:slide-in-from-right-0.5 in-placement-right:slide-in-from-left-0.5 in-placement-top:slide-in-from-bottom-0.5 in-placement-bottom:slide-in-from-top-0.5",
                            isExiting &&
                                "ease-in animate-out fade-out zoom-out-95 in-placement-left:slide-out-to-right-0.5 in-placement-right:slide-out-to-left-0.5 in-placement-top:slide-out-to-bottom-0.5 in-placement-bottom:slide-out-to-top-0.5",
                        )}
                    >
                        <span className="text-xs font-semibold text-white">{title}</span>

                        {description && <span className="text-xs font-medium text-tooltip-supporting-text">{description}</span>}

                        {arrow && (
                            <AriaOverlayArrow>
                                <svg
                                    viewBox="0 0 100 100"
                                    className="size-2.5 fill-bg-primary-solid in-placement-left:-rotate-90 in-placement-right:rotate-90 in-placement-top:rotate-0 in-placement-bottom:rotate-180"
                                >
                                    <path d="M0,0 L35.858,35.858 Q50,50 64.142,35.858 L100,0 Z" />
                                </svg>
                            </AriaOverlayArrow>
                        )}
                    </div>
                )}
            </AriaTooltip>
        </AriaTooltipTrigger>
    );
};

type TooltipTriggerProps = AriaButtonProps;

export const TooltipTrigger = ({ children, className, ...buttonProps }: TooltipTriggerProps) => {
    return (
        <AriaButton {...buttonProps} className={(values) => cx("h-max w-max outline-hidden", typeof className === "function" ? className(values) : className)}>
            {children}
        </AriaButton>
    );
};
````

## File: src/components/community/ProfileHero.tsx
````typescript
import { format } from "date-fns";
import type { CommunityPost, FollowStats, ProfileActivityStats, CommunityProfile } from "@/lib/community";
import { getInitials } from "@/lib/community-utils";
import { getCommunityPostRarity, type PromptForgeRarity } from "@/lib/community-rarity";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/base/primitives/avatar";
import { Badge } from "@/components/base/badges/badges";
import { Button } from "@/components/base/buttons/button";
import { cn } from "@/lib/utils";
import { ArrowUp, CheckCircle as CheckCircle2, Fire as Flame, Star } from "@phosphor-icons/react";

interface ProfileHeroProps {
  profile: CommunityProfile;
  followStats: FollowStats;
  activityStats: ProfileActivityStats;
  bestRarity: PromptForgeRarity;
  memberSinceAt?: number | null;
  isOwnProfile: boolean;
  isFollowing: boolean;
  followPending: boolean;
  onToggleFollow: () => void;
}

const RARITY_RING: Record<PromptForgeRarity, string> = {
  common: "ring-[rgba(var(--pf-slate-rgb)/0.7)]",
  rare: "ring-[rgba(var(--pf-arcane-rgb)/0.65)]",
  epic: "ring-[rgba(var(--pf-ember-rgb)/0.6)]",
  legendary: "ring-[rgba(var(--pf-gold-rgb)/0.7)]",
};

const RARITY_GLOW: Record<PromptForgeRarity, string> = {
  common: "",
  rare: "shadow-[0_0_18px_rgba(var(--pf-arcane-rgb)/0.18)]",
  epic: "shadow-[0_0_22px_rgba(var(--pf-ember-rgb)/0.16)]",
  legendary: "shadow-[0_0_26px_rgba(var(--pf-gold-rgb)/0.2)]",
};

const RARITY_LABEL: Record<PromptForgeRarity, string> = {
  common: "",
  rare: "Rare Creator",
  epic: "Epic Creator",
  legendary: "Legendary Creator",
};

const RARITY_BADGE_COLOR: Record<PromptForgeRarity, string> = {
  common: "",
  rare: "border-[rgba(var(--pf-arcane-rgb)/0.5)] bg-[rgba(var(--pf-arcane-rgb)/0.12)] text-[var(--pf-arcane-teal)]",
  epic: "border-[rgba(var(--pf-ember-rgb)/0.5)] bg-[rgba(var(--pf-ember-rgb)/0.12)] text-[var(--pf-ember-orange)]",
  legendary: "border-[rgba(var(--pf-gold-rgb)/0.5)] bg-[rgba(var(--pf-gold-rgb)/0.12)] text-[var(--pf-forge-gold)]",
};

export function getBestRarityFromPosts(posts: CommunityPost[]): PromptForgeRarity {
  const order: PromptForgeRarity[] = ["common", "rare", "epic", "legendary"];
  let best: PromptForgeRarity = "common";
  for (const post of posts) {
    const rarity = getCommunityPostRarity(post);
    if (order.indexOf(rarity) > order.indexOf(best)) {
      best = rarity;
    }
  }
  return best;
}

const STAT_CELLS: Array<{
  key: keyof ProfileActivityStats;
  label: string;
  icon: typeof Flame;
  format: (value: number) => string;
}> = [
  { key: "totalPosts", label: "Prompts", icon: Flame, format: (v) => String(v) },
  { key: "totalUpvotes", label: "Upvotes", icon: ArrowUp, format: (v) => String(v) },
  { key: "totalVerified", label: "Verified", icon: CheckCircle2, format: (v) => String(v) },
  { key: "averageRating", label: "Avg Rating", icon: Star, format: (v) => v > 0 ? v.toFixed(1) : "--" },
];

export function ProfileHero({
  profile,
  followStats,
  activityStats,
  bestRarity,
  memberSinceAt = null,
  isOwnProfile,
  isFollowing,
  followPending,
  onToggleFollow,
}: ProfileHeroProps) {
  const showRarityBadge = bestRarity !== "common";
  const memberSinceLabel = memberSinceAt
    ? `Member since ${format(new Date(memberSinceAt), "MMMM yyyy")}`
    : "Member since recently";

  return (
    <div className="mb-4 space-y-3">
      {/* Hero card */}
      <div className="pf-gilded-frame pf-hero-surface px-4 py-6 sm:px-6 sm:py-8">
        <div className="relative z-[1] flex flex-col items-center gap-4 sm:flex-row sm:items-start sm:gap-5">
          {/* Avatar with rarity ring */}
          <div
            className={cn(
              "relative shrink-0 rounded-full ring-[3px] ring-offset-2 ring-offset-transparent",
              RARITY_RING[bestRarity],
              RARITY_GLOW[bestRarity],
            )}
          >
            <Avatar className="h-20 w-20 border-2 border-border/40 sm:h-24 sm:w-24">
              <AvatarImage src={profile.avatarUrl ?? undefined} alt={profile.displayName} />
              <AvatarFallback className="text-lg font-semibold">
                {getInitials(profile.displayName)}
              </AvatarFallback>
            </Avatar>
          </div>

          {/* Identity */}
          <div className="flex min-w-0 flex-1 flex-col items-center gap-2 sm:items-start">
            <div className="flex flex-wrap items-center justify-center gap-2 sm:justify-start">
              <h1 className="pf-text-display text-xl font-bold text-[rgba(var(--pf-parchment-rgb)/0.97)] sm:text-2xl"
                style={{ textShadow: "0 2px 12px rgba(0,0,0,0.5)" }}
              >
                {profile.displayName}
              </h1>
              {isOwnProfile && (
                <Badge type="modern" className="type-chip border border-border/60 bg-background/30 text-foreground/80">
                  You
                </Badge>
              )}
              {showRarityBadge && (
                <Badge
                  type="modern"
                  className={cn("type-chip border text-xs font-semibold", RARITY_BADGE_COLOR[bestRarity])}
                >
                  {RARITY_LABEL[bestRarity]}
                </Badge>
              )}
            </div>
            <p className="type-meta text-[rgba(var(--pf-parchment-rgb)/0.82)]">{memberSinceLabel}</p>

            {/* Follow stats as side-by-side stat cells */}
            <div className="grid w-full grid-cols-2 gap-2 sm:max-w-[280px]">
              <div className="rounded-lg border border-border/60 bg-background/20 px-3 py-2 text-center">
                <span className="type-numeric block text-base text-[rgba(var(--pf-parchment-rgb)/0.97)]">
                  {followStats.followersCount}
                </span>{" "}
                <span className="type-meta text-[rgba(var(--pf-parchment-rgb)/0.82)]">Followers</span>
              </div>
              <div className="rounded-lg border border-border/60 bg-background/20 px-3 py-2 text-center">
                <span className="type-numeric block text-base text-[rgba(var(--pf-parchment-rgb)/0.97)]">
                  {followStats.followingCount}
                </span>{" "}
                <span className="type-meta text-[rgba(var(--pf-parchment-rgb)/0.82)]">Following</span>
              </div>
            </div>

            {/* Follow button */}
            {!isOwnProfile && (
              <Button
                type="button"
                size="sm"
                color={isFollowing ? "secondary" : "primary"}
                className="type-button-label mt-1 h-10 min-w-[100px] sm:h-9"
                onClick={onToggleFollow}
                disabled={followPending}
              >
                {followPending ? "Saving..." : isFollowing ? "Following" : "Follow"}
              </Button>
            )}
          </div>
        </div>
      </div>

      {/* Activity stats strip */}
      <div className="grid grid-cols-2 gap-2 sm:grid-cols-4">
        {STAT_CELLS.map(({ key, label, icon: Icon, format }) => (
          <div
            key={key}
            className="pf-card flex flex-col items-center gap-1 rounded-xl border border-border/60 px-3 py-3 text-center"
            style={{ transform: "none" }}
          >
            <Icon className="h-4 w-4 text-muted-foreground" />
            <span className="type-numeric text-lg font-bold text-foreground">
              {format(activityStats[key])}
            </span>
            <span className="type-meta text-muted-foreground">{label}</span>
          </div>
        ))}
      </div>

      {/* Section divider + heading */}
      <div className="space-y-2 pt-1">
        <div className="pf-divider" />
        <div className="flex items-center justify-between px-1">
          <h2 className="type-post-title text-foreground">Published Prompts</h2>
          <Badge
            type="modern"
            className="type-chip type-numeric border border-border/60 bg-background/60 text-muted-foreground"
          >
            {activityStats.totalPosts}
          </Badge>
        </div>
      </div>
    </div>
  );
}
````

## File: src/components/fantasy/PFHeroNavbar.tsx
````typescript
import { cx } from "@/lib/utils/cx";

export type PFNavLink = { label: string; href: string };

export type PFHeroNavbarProps = {
  logoSrc?: string;
  heroBgSrc?: string;
  runeTileSrc?: string;
  links?: PFNavLink[];
  primaryCta?: PFNavLink;
  secondaryCta?: PFNavLink;
  headline?: string;
  subhead?: string;
};

export function PFHeroNavbar({
  logoSrc = "/pf/promptforge-wordmark.png",
  heroBgSrc = "/pf/promptforge-background-1920x1080.png",
  runeTileSrc = "/pf/promptforge-rune-texture-tile-1024.png",
  links = [
    { label: "Artifacts", href: "#artifacts" },
    { label: "Templates", href: "#templates" },
    { label: "Community", href: "#community" },
    { label: "Docs", href: "#docs" },
  ],
  primaryCta = { label: "Enter the Forge", href: "#start" },
  secondaryCta = { label: "Browse Templates", href: "#templates" },
  headline = "Forge the Prompt",
  subhead = "Craft, refine, and share prompt artifacts — powered by arcane glow and forged-metal polish.",
}: PFHeroNavbarProps) {
  return (
    <header className="relative overflow-hidden">
      <div className="absolute inset-0">
        <div className="absolute inset-0 bg-cover bg-center" style={{ backgroundImage: `url(${heroBgSrc})` }} />
        <div className="absolute inset-0 bg-linear-to-r from-black/75 via-black/40 to-black/70" />
        <div className="absolute inset-0 mask-[radial-gradient(60%_60%_at_50%_35%,black,transparent)] bg-black/55" />
        <div
          className="absolute inset-0 opacity-[0.10] mix-blend-overlay"
          style={{ backgroundImage: `url(${runeTileSrc})`, backgroundSize: "640px 640px" }}
        />
      </div>

      <div className="relative z-10 mx-auto max-w-6xl px-6 pb-16 pt-6">
        <nav className="flex items-center justify-between gap-6">
          <a href="#" className="flex items-center gap-3">
            <img src={logoSrc} alt="PromptForge" className="h-9 w-auto" />
          </a>

          <div className="hidden items-center gap-7 md:flex">
            {links.map((link) => (
              <a key={link.href} href={link.href} className="pf-nav-link text-sm font-semibold">
                {link.label}
              </a>
            ))}
          </div>

          <div className="flex items-center gap-3">
            <a href={secondaryCta.href} className={cx("pf-button pf-button-ghost", "h-10 px-4 text-sm")}>
              {secondaryCta.label}
            </a>
            <a href={primaryCta.href} className={cx("pf-button pf-button-primary", "h-10 px-4 text-sm")}>
              {primaryCta.label}
            </a>
          </div>
        </nav>

        <section className="mt-12 md:mt-16">
          <div className="pf-gilded-frame p-7 md:p-10">
            <div className="max-w-2xl">
              <div className="inline-flex items-center gap-2 rounded-full border border-[rgba(214,166,64,.45)] bg-black/30 px-3 py-1 text-xs font-semibold text-[rgba(230,225,213,.85)]">
                <span className="h-2 w-2 rounded-full bg-[rgb(var(--pf-arcane-rgb))] shadow-[0_0_18px_rgba(18,200,181,.35)]" />
                New: community artifacts + rarity tiers
              </div>

              <h1 className="pf-text-display mt-5 text-4xl leading-[1.02] md:text-6xl">{headline}</h1>

              <p className="mt-4 text-base text-[rgba(230,225,213,.82)] md:text-lg">{subhead}</p>

              <div className="mt-7 flex flex-col gap-3 sm:flex-row">
                <a href={primaryCta.href} className={cx("pf-button pf-button-primary", "h-12 px-6")}>
                  {primaryCta.label}
                </a>
                <a href={secondaryCta.href} className={cx("pf-button pf-button-secondary", "h-12 px-6")}>
                  {secondaryCta.label}
                </a>
              </div>

              <div className="mt-8 pf-divider" />

              <div className="mt-5 grid grid-cols-1 gap-4 text-sm sm:grid-cols-3">
                <HeroStat label="Forge time" value="~30s" hint="from draft to artifact" />
                <HeroStat label="Quality tiers" value="Common → Legendary" hint="rarity frames included" />
                <HeroStat label="Modes" value="Arcane / Ember" hint="focus vs destructive actions" />
              </div>
            </div>
          </div>
        </section>
      </div>
    </header>
  );
}

function HeroStat({ label, value, hint }: { label: string; value: string; hint: string }) {
  return (
    <div className="rounded-2xl border border-white/10 bg-black/25 px-4 py-3">
      <div className="text-xs text-[rgba(230,225,213,.68)]">{label}</div>
      <div className="mt-1 font-bold text-[rgba(230,225,213,.95)]">{value}</div>
      <div className="mt-1 text-xs text-[rgba(230,225,213,.62)]">{hint}</div>
    </div>
  );
}
````

## File: src/components/QualityScore.tsx
````typescript
import { Card } from "@/components/base/primitives/card";
import { Progress } from "@/components/base/primitives/progress";
import { CheckCircle as CheckCircle2, WarningCircle as AlertCircle } from "@phosphor-icons/react";

interface QualityScoreProps {
  score: {
    total: number;
    clarity: number;
    context: number;
    specificity: number;
    structure: number;
    tips: string[];
  };
}

function ScoreBar({ label, value, max }: { label: string; value: number; max: number }) {
  const pct = Math.round((value / max) * 100);
  return (
    <div className="space-y-1">
      <div className="flex justify-between text-xs">
        <span className="text-muted-foreground">{label}</span>
        <span className="font-medium text-foreground">{value}/{max}</span>
      </div>
      <Progress value={pct} className="h-1.5" />
    </div>
  );
}

export function QualityScore({ score }: QualityScoreProps) {
  const getColor = (total: number) => {
    if (total >= 75) return "text-primary";
    if (total >= 50) return "text-accent-foreground";
    return "text-destructive";
  };

  return (
    <Card className="p-3 sm:p-4 bg-card border-border">
      <div className="flex items-center gap-3 mb-3 sm:mb-4">
        <div className={`text-2xl sm:text-3xl font-bold ${getColor(score.total)}`}>{score.total}</div>
        <div>
          <p className="text-sm font-medium text-foreground">Quality Score</p>
          <p className="text-xs text-muted-foreground">out of 100</p>
        </div>
      </div>

      <div className="space-y-2 sm:space-y-3 mb-3 sm:mb-4">
        <ScoreBar label="Clarity" value={score.clarity} max={25} />
        <ScoreBar label="Context" value={score.context} max={25} />
        <ScoreBar label="Specificity" value={score.specificity} max={25} />
        <ScoreBar label="Structure" value={score.structure} max={25} />
      </div>

      <div className="space-y-1.5 sm:space-y-2">
        {score.tips.map((tip, i) => (
          <div key={i} className="flex gap-2 text-xs">
            {score.total >= 75 ? (
              <CheckCircle2 className="w-3.5 h-3.5 text-primary shrink-0 mt-0.5" />
            ) : (
              <AlertCircle className="w-3.5 h-3.5 text-muted-foreground shrink-0 mt-0.5" />
            )}
            <span className="text-muted-foreground">{tip}</span>
          </div>
        ))}
      </div>
    </Card>
  );
}
````

## File: src/components/route-fallbacks.tsx
````typescript
import type { ReactNode } from "react";
import { PageShell } from "@/components/PageShell";
import { Card } from "@/components/base/primitives/card";
import { Skeleton } from "@/components/base/primitives/skeleton";

function RouteFallbackFrame({ children }: { children: ReactNode }) {
  return (
    <PageShell>
      <div className="space-y-4 sm:space-y-5">{children}</div>
    </PageShell>
  );
}

function HeroFallback() {
  return (
    <div className="space-y-2 text-center">
      <Skeleton className="mx-auto h-8 w-56 sm:h-9 sm:w-72" />
      <Skeleton className="mx-auto h-4 w-full max-w-[520px]" />
    </div>
  );
}

export function BuilderRouteFallback() {
  return (
    <RouteFallbackFrame>
      <HeroFallback />
      <Card className="space-y-3 border-border/80 bg-card/85 p-4">
        <Skeleton className="h-10 w-full" />
        <div className="grid grid-cols-1 gap-3 lg:grid-cols-2">
          <Skeleton className="h-56 w-full rounded-lg" />
          <Skeleton className="h-56 w-full rounded-lg" />
        </div>
        <Skeleton className="h-11 w-full" />
      </Card>
    </RouteFallbackFrame>
  );
}

export function CommunityRouteFallback() {
  return (
    <RouteFallbackFrame>
      <HeroFallback />
      <Card className="space-y-3 border-border/80 bg-card/85 p-4">
        <Skeleton className="h-11 w-full" />
        <div className="grid grid-cols-2 gap-2 sm:flex sm:rounded-lg sm:bg-muted sm:p-1">
          <Skeleton className="h-11 w-full sm:h-10" />
          <Skeleton className="h-11 w-full sm:h-10" />
        </div>
      </Card>
      <div className="grid grid-cols-1 gap-3 lg:grid-cols-2">
        <Skeleton className="h-56 w-full rounded-lg" />
        <Skeleton className="h-56 w-full rounded-lg" />
      </div>
    </RouteFallbackFrame>
  );
}

export function LibraryRouteFallback() {
  return (
    <RouteFallbackFrame>
      <HeroFallback />
      <Card className="space-y-3 border-border/80 bg-card/85 p-4">
        <Skeleton className="h-11 w-full" />
        <Skeleton className="h-11 w-full" />
      </Card>
      <Card className="space-y-2 border-border/80 bg-card/85 p-4">
        <Skeleton className="h-24 w-full rounded-lg" />
        <Skeleton className="h-24 w-full rounded-lg" />
        <Skeleton className="h-24 w-full rounded-lg" />
      </Card>
    </RouteFallbackFrame>
  );
}

export function GenericRouteFallback() {
  return (
    <RouteFallbackFrame>
      <HeroFallback />
      <Card className="space-y-3 border-border/80 bg-card/85 p-4">
        <Skeleton className="h-10 w-full" />
        <Skeleton className="h-40 w-full rounded-lg" />
      </Card>
    </RouteFallbackFrame>
  );
}
````

## File: src/hooks/use-clipboard.ts
````typescript
import { useCallback, useState } from "react";

const DEFAULT_TIMEOUT = 2000;

type UseClipboardReturnType = {
  /**
   * The state indicating whether the text has been copied.
   * If a string is provided, it will be used as the identifier for the copied state.
   */
  copied: string | boolean;
  /**
   * Function to copy text to the clipboard using the modern clipboard API.
   * Falls back to the fallback function if the modern API fails.
   *
   * @param {string} text - The text to be copied.
   * @param {string} [id] - Optional identifier to set the copied state.
   * @returns {Promise<Object>} - A promise that resolves to an object containing:
   *  - `success` (boolean): Whether the copy operation was successful.
   *  - `error` (Error | undefined): The error object if the copy operation failed.
   */
  copy: (text: string, id?: string) => Promise<{ success: boolean; error?: Error }>;
};

/**
 * Custom hook to copy text to the clipboard.
 *
 * @returns {UseClipboardReturnType} - An object containing the copied state and the copy function.
 */
export const useClipboard = (): UseClipboardReturnType => {
  const [copied, setCopied] = useState<string | boolean>(false);

  // Fallback function for older browsers
  const fallback = (text: string, id?: string) => {
    try {
      // Textarea to copy the text to the clipboard
      const textArea = document.createElement("textarea");
      textArea.value = text;
      textArea.style.position = "absolute";
      textArea.style.left = "-99999px";

      document.body.appendChild(textArea);
      textArea.select();

      const success = document.execCommand("copy");
      textArea.remove();

      setCopied(id || true);
      setTimeout(() => setCopied(false), DEFAULT_TIMEOUT);

      return success ? { success: true } : { success: false, error: new Error("execCommand returned false") };
    } catch (err) {
      return {
        success: false,
        error: err instanceof Error ? err : new Error("Fallback copy failed"),
      };
    }
  };

  const copy = useCallback(async (text: string, id?: string) => {
    if (navigator.clipboard && window.isSecureContext) {
      try {
        await navigator.clipboard.writeText(text);

        setCopied(id || true);
        setTimeout(() => setCopied(false), DEFAULT_TIMEOUT);

        return { success: true };
      } catch {
        // If modern method fails, try fallback
        return fallback(text, id);
      }
    }
    return fallback(text, id);
  }, []);

  return { copied, copy };
};
````

## File: src/hooks/useNewPostsIndicator.ts
````typescript
import { useCallback, useEffect, useRef, useState } from "react";
import { loadFeed, type CommunityPost } from "@/lib/community";

interface UseNewPostsIndicatorOptions {
  enabled: boolean;
  intervalMs?: number;
}

interface UseNewPostsIndicatorResult {
  newCount: number;
  dismiss: () => void;
}

export function useNewPostsIndicator({
  enabled,
  intervalMs = 45_000,
}: UseNewPostsIndicatorOptions): UseNewPostsIndicatorResult {
  const [newCount, setNewCount] = useState(0);
  const newestSeenAt = useRef<number | null>(null);
  const latestObservedAt = useRef<number | null>(null);
  const pollInFlight = useRef(false);
  const seenVersion = useRef(0);

  const dismiss = useCallback(() => {
    seenVersion.current += 1;
    setNewCount(0);
    if (latestObservedAt.current) {
      newestSeenAt.current = latestObservedAt.current;
    }
  }, []);

  useEffect(() => {
    if (!enabled) {
      setNewCount(0);
      newestSeenAt.current = null;
      latestObservedAt.current = null;
      pollInFlight.current = false;
      seenVersion.current += 1;
      return;
    }

    let cancelled = false;

    const poll = async () => {
      if (cancelled || pollInFlight.current || document.visibilityState === "hidden") {
        return;
      }

      pollInFlight.current = true;
      const baselineSeenAt = newestSeenAt.current;
      const baselineVersion = seenVersion.current;

      try {
        const latestPosts = await loadFeed({ sort: "new", page: 0, limit: 20 });
        if (cancelled) return;
        if (baselineVersion !== seenVersion.current) return;

        const latest = latestPosts[0] as CommunityPost | undefined;
        if (!latest) {
          setNewCount(0);
          return;
        }

        latestObservedAt.current = latest.createdAt;

        if (baselineSeenAt === null) {
          newestSeenAt.current = latest.createdAt;
          seenVersion.current += 1;
          setNewCount(0);
          return;
        }

        if (latest.createdAt <= baselineSeenAt) {
          setNewCount(0);
          return;
        }

        const count = latestPosts.filter((post) => post.createdAt > baselineSeenAt).length;
        setNewCount(count);
      } catch (error) {
        if (import.meta.env.DEV) {
          console.debug("useNewPostsIndicator poll failed", error);
        }
      } finally {
        pollInFlight.current = false;
      }
    };

    void poll();
    const id = window.setInterval(() => {
      void poll();
    }, intervalMs);

    const onVisibility = () => {
      if (document.visibilityState === "visible") {
        void poll();
      }
    };

    document.addEventListener("visibilitychange", onVisibility);

    return () => {
      cancelled = true;
      window.clearInterval(id);
      document.removeEventListener("visibilitychange", onVisibility);
    };
  }, [enabled, intervalMs]);

  return { newCount, dismiss };
}
````

## File: src/hooks/useNotifications.ts
````typescript
import { useCallback, useEffect, useMemo, useRef, useState } from "react";
import { useAuth } from "@/hooks/useAuth";
import {
  type Notification,
  getUnreadCount,
  loadNotifications,
  markAllAsRead as markAllNotificationsAsRead,
  markAsRead as markNotificationAsRead,
} from "@/lib/notifications";

export interface UseNotificationsResult {
  notifications: Notification[];
  unreadCount: number;
  loading: boolean;
  error: string | null;
  refresh: () => Promise<void>;
  markAsRead: (notificationId: string) => Promise<void>;
  markAllAsRead: () => Promise<void>;
}

const DEFAULT_LIMIT = 30;
const POLL_INTERVAL_MS = 30_000;

export function useNotifications(limit = DEFAULT_LIMIT): UseNotificationsResult {
  const { user } = useAuth();
  const [notifications, setNotifications] = useState<Notification[]>([]);
  const [unreadCount, setUnreadCount] = useState(0);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const isMountedRef = useRef(true);

  useEffect(() => {
    return () => {
      isMountedRef.current = false;
    };
  }, []);

  const reset = useCallback(() => {
    if (!isMountedRef.current) return;
    setNotifications([]);
    setUnreadCount(0);
    setLoading(false);
    setError(null);
  }, []);

  const refresh = useCallback(async () => {
    if (!user) {
      reset();
      return;
    }

    if (!isMountedRef.current) return;
    setLoading(true);
    try {
      const [items, count] = await Promise.all([
        loadNotifications(limit, 0),
        getUnreadCount(),
      ]);
      if (!isMountedRef.current) return;
      setNotifications(items);
      setUnreadCount(count);
      setError(null);
    } catch (nextError) {
      if (!isMountedRef.current) return;
      setError(nextError instanceof Error ? nextError.message : "Failed to load notifications.");
    } finally {
      if (isMountedRef.current) {
        setLoading(false);
      }
    }
  }, [limit, reset, user]);

  const markAsRead = useCallback(async (notificationId: string) => {
    if (!user) return;

    try {
      const changed = await markNotificationAsRead(notificationId);
      if (!changed) return;
      if (!isMountedRef.current) return;

      const markedAt = Date.now();
      setNotifications((previous) =>
        previous.map((notification) =>
          notification.id === notificationId && !notification.readAt
            ? { ...notification, readAt: markedAt }
            : notification,
        ),
      );
      setUnreadCount((previous) => Math.max(0, previous - 1));
      setError(null);
    } catch (nextError) {
      if (!isMountedRef.current) return;
      setError(nextError instanceof Error ? nextError.message : "Failed to mark notification as read.");
    }
  }, [user]);

  const markAllAsRead = useCallback(async () => {
    if (!user) return;

    try {
      const changedCount = await markAllNotificationsAsRead();
      if (changedCount === 0) return;
      if (!isMountedRef.current) return;

      const markedAt = Date.now();
      setNotifications((previous) =>
        previous.map((notification) =>
          notification.readAt ? notification : { ...notification, readAt: markedAt },
        ),
      );
      setUnreadCount(0);
      setError(null);
    } catch (nextError) {
      if (!isMountedRef.current) return;
      setError(nextError instanceof Error ? nextError.message : "Failed to mark all notifications as read.");
    }
  }, [user]);

  useEffect(() => {
    if (!user) {
      reset();
      return;
    }
    void refresh();
  }, [refresh, reset, user]);

  useEffect(() => {
    if (!user?.id) return;

    let intervalId: ReturnType<typeof setInterval> | null = null;
    const canUseVisibilityApi = typeof document !== "undefined";

    const stopPolling = () => {
      if (!intervalId) return;
      clearInterval(intervalId);
      intervalId = null;
    };

    const startPolling = () => {
      if (intervalId) return;
      intervalId = setInterval(() => {
        if (canUseVisibilityApi && document.visibilityState === "hidden") return;
        void refresh();
      }, POLL_INTERVAL_MS);
    };

    const onVisibilityChange = () => {
      if (document.visibilityState === "hidden") {
        stopPolling();
        return;
      }
      startPolling();
      void refresh();
    };

    if (!canUseVisibilityApi || document.visibilityState !== "hidden") {
      startPolling();
    }
    if (canUseVisibilityApi) {
      document.addEventListener("visibilitychange", onVisibilityChange);
    }

    return () => {
      stopPolling();
      if (canUseVisibilityApi) {
        document.removeEventListener("visibilitychange", onVisibilityChange);
      }
    };
  }, [refresh, user?.id]);

  return useMemo(
    () => ({
      notifications,
      unreadCount,
      loading,
      error,
      refresh,
      markAsRead,
      markAllAsRead,
    }),
    [error, loading, markAllAsRead, markAsRead, notifications, refresh, unreadCount],
  );
}
````

## File: src/lib/utils/countries.tsx
````typescript
import type { SelectItemType } from "@/components/base/select/select";

/**
 * List of countries with their respective country code, flag, phone code, and phone mask.
 */
export const countries = [
    {
        name: "Afghanistan",
        code: "AF",
        flag: "https://www.untitledui.com/images/flags/AF.svg",
        phoneCode: "93",
        phoneMask: "+93-##-###-####",
    },
    {
        name: "Albania",
        code: "AL",
        flag: "https://www.untitledui.com/images/flags/AL.svg",
        phoneCode: "355",
        phoneMask: "+355 (###) ###-###",
    },
    {
        name: "Algeria",
        code: "DZ",
        flag: "https://www.untitledui.com/images/flags/DZ.svg",
        phoneCode: "213",
        phoneMask: "+213-##-###-####",
    },
    {
        name: "Andorra",
        code: "AD",
        flag: "https://www.untitledui.com/images/flags/AD.svg",
        phoneCode: "376",
        phoneMask: "+376-###-###",
    },
    {
        name: "Angola",
        code: "AO",
        flag: "https://www.untitledui.com/images/flags/AO.svg",
        phoneCode: "244",
        phoneMask: "+244 (###) ###-###",
    },
    {
        name: "Antigua and Barbuda",
        code: "AG",
        flag: "https://www.untitledui.com/images/flags/AG.svg",
        phoneCode: "+1-268",
        phoneMask: "+1 (268) ###-####",
    },
    {
        name: "Argentina",
        code: "AR",
        flag: "https://www.untitledui.com/images/flags/AR.svg",
        phoneCode: "54",
        phoneMask: "+54 (###) ###-####",
    },
    {
        name: "Armenia",
        code: "AM",
        flag: "https://www.untitledui.com/images/flags/AM.svg",
        phoneCode: "374",
        phoneMask: "+374-##-###-###",
    },
    {
        name: "Australia",
        code: "AU",
        flag: "https://www.untitledui.com/images/flags/AU.svg",
        phoneCode: "61",
        phoneMask: "+61-#-####-####",
    },
    {
        name: "Austria",
        code: "AT",
        flag: "https://www.untitledui.com/images/flags/AT.svg",
        phoneCode: "43",
        phoneMask: "+43 (###) ###-####",
    },
    {
        name: "Azerbaijan",
        code: "AZ",
        flag: "https://www.untitledui.com/images/flags/AZ.svg",
        phoneCode: "994",
        phoneMask: "+994-##-###-##-##",
    },
    {
        name: "Bahamas",
        code: "BS",
        flag: "https://www.untitledui.com/images/flags/BS.svg",
        phoneCode: "+1-242",
        phoneMask: "+1 (242) ###-####",
    },
    {
        name: "Bahrain",
        code: "BH",
        flag: "https://www.untitledui.com/images/flags/BH.svg",
        phoneCode: "973",
        phoneMask: "+973-####-####",
    },
    {
        name: "Bangladesh",
        code: "BD",
        flag: "https://www.untitledui.com/images/flags/BD.svg",
        phoneCode: "880",
        phoneMask: "+880-##-###-###",
    },
    {
        name: "Barbados",
        code: "BB",
        flag: "https://www.untitledui.com/images/flags/BB.svg",
        phoneCode: "+1-246",
        phoneMask: "+1 (246) ###-####",
    },
    {
        name: "Belarus",
        code: "BY",
        flag: "https://www.untitledui.com/images/flags/BY.svg",
        phoneCode: "375",
        phoneMask: "+375 (##) ###-##-##",
    },
    {
        name: "Belgium",
        code: "BE",
        flag: "https://www.untitledui.com/images/flags/BE.svg",
        phoneCode: "32",
        phoneMask: "+32 (###) ###-###",
    },
    {
        name: "Belize",
        code: "BZ",
        flag: "https://www.untitledui.com/images/flags/BZ.svg",
        phoneCode: "501",
        phoneMask: "+501-###-####",
    },
    {
        name: "Benin",
        code: "BJ",
        flag: "https://www.untitledui.com/images/flags/BJ.svg",
        phoneCode: "229",
        phoneMask: "+229-##-##-####",
    },
    {
        name: "Bhutan",
        code: "BT",
        flag: "https://www.untitledui.com/images/flags/BT.svg",
        phoneCode: "975",
        phoneMask: "+975-#-###-###",
    },
    {
        name: "Bolivia",
        code: "BO",
        flag: "https://www.untitledui.com/images/flags/BO.svg",
        phoneCode: "591",
        phoneMask: "+591-#-###-####",
    },
    {
        name: "Bosnia and Herzegovina",
        code: "BA",
        flag: "https://www.untitledui.com/images/flags/BA.svg",
        phoneCode: "387",
        phoneMask: "+387-##-####",
    },
    {
        name: "Botswana",
        code: "BW",
        flag: "https://www.untitledui.com/images/flags/BW.svg",
        phoneCode: "267",
        phoneMask: "+267-##-###-###",
    },
    {
        name: "Brazil",
        code: "BR",
        flag: "https://www.untitledui.com/images/flags/BR.svg",
        phoneCode: "55",
        phoneMask: "+55 (##) 9####-####",
    },
    {
        name: "Brunei",
        code: "BN",
        flag: "https://www.untitledui.com/images/flags/BN.svg",
        phoneCode: "673",
        phoneMask: "+673-###-####",
    },
    {
        name: "Bulgaria",
        code: "BG",
        flag: "https://www.untitledui.com/images/flags/BG.svg",
        phoneCode: "359",
        phoneMask: "+359 (###) ###-###",
    },
    {
        name: "Burkina Faso",
        code: "BF",
        flag: "https://www.untitledui.com/images/flags/BF.svg",
        phoneCode: "226",
        phoneMask: "+226-##-##-####",
    },
    {
        name: "Burundi",
        code: "BI",
        flag: "https://www.untitledui.com/images/flags/BI.svg",
        phoneCode: "257",
        phoneMask: "+257-##-##-####",
    },
    {
        name: "Cambodia",
        code: "KH",
        flag: "https://www.untitledui.com/images/flags/KH.svg",
        phoneCode: "855",
        phoneMask: "+855-##-###-###",
    },
    {
        name: "Cameroon",
        code: "CM",
        flag: "https://www.untitledui.com/images/flags/CM.svg",
        phoneCode: "237",
        phoneMask: "+237-####-####",
    },
    {
        name: "Canada",
        code: "CA",
        flag: "https://www.untitledui.com/images/flags/CA.svg",
        phoneCode: "1",
        phoneMask: "+1 (###) ###-####",
    },
    {
        name: "Central African Republic",
        code: "CF",
        flag: "https://www.untitledui.com/images/flags/CF.svg",
        phoneCode: "236",
        phoneMask: "+236-##-##-####",
    },
    {
        name: "Chad",
        code: "TD",
        flag: "https://www.untitledui.com/images/flags/TD.svg",
        phoneCode: "235",
        phoneMask: "+235-##-##-##-##",
    },
    {
        name: "Chile",
        code: "CL",
        flag: "https://www.untitledui.com/images/flags/CL.svg",
        phoneCode: "56",
        phoneMask: "+56-#-####-####",
    },
    {
        name: "China",
        code: "CN",
        flag: "https://www.untitledui.com/images/flags/CN.svg",
        phoneCode: "86",
        phoneMask: "+86-##-#####-#####",
    },
    {
        name: "Colombia",
        code: "CO",
        flag: "https://www.untitledui.com/images/flags/CO.svg",
        phoneCode: "57",
        phoneMask: "+57 (###) ###-####",
    },
    {
        name: "Comoros",
        code: "KM",
        flag: "https://www.untitledui.com/images/flags/KM.svg",
        phoneCode: "269",
        phoneMask: "+269-##-#####",
    },
    {
        name: "Costa Rica",
        code: "CR",
        flag: "https://www.untitledui.com/images/flags/CR.svg",
        phoneCode: "506",
        phoneMask: "+506-####-####",
    },
    {
        name: "Croatia",
        code: "HR",
        flag: "https://www.untitledui.com/images/flags/HR.svg",
        phoneCode: "385",
        phoneMask: "+385-##-###-###",
    },
    {
        name: "Cuba",
        code: "CU",
        flag: "https://www.untitledui.com/images/flags/CU.svg",
        phoneCode: "53",
        phoneMask: "+53-#-###-####",
    },
    {
        name: "Cyprus",
        code: "CY",
        flag: "https://www.untitledui.com/images/flags/CY.svg",
        phoneCode: "357",
        phoneMask: "+357-##-###-###",
    },
    {
        name: "Czech Republic",
        code: "CZ",
        flag: "https://www.untitledui.com/images/flags/CZ.svg",
        phoneCode: "420",
        phoneMask: "+420 (###) ###-###",
    },
    {
        name: "Democratic Republic of the Congo",
        code: "CD",
        flag: "https://www.untitledui.com/images/flags/CD.svg",
        phoneCode: "243",
        phoneMask: "+243 (###) ###-###",
    },
    {
        name: "Denmark",
        code: "DK",
        flag: "https://www.untitledui.com/images/flags/DK.svg",
        phoneCode: "45",
        phoneMask: "+45-##-##-##-##",
    },
    {
        name: "Djibouti",
        code: "DJ",
        flag: "https://www.untitledui.com/images/flags/DJ.svg",
        phoneCode: "253",
        phoneMask: "+253-##-##-##-##",
    },
    {
        name: "Dominica",
        code: "DM",
        flag: "https://www.untitledui.com/images/flags/DM.svg",
        phoneCode: "+1-767",
        phoneMask: "+1 (767) ###-####",
    },
    {
        name: "Dominican Republic",
        code: "DO",
        flag: "https://www.untitledui.com/images/flags/DO.svg",
        phoneCode: "+1-809 and 1-829",
        phoneMask: "+1 (849) ###-####",
    },
    {
        name: "East Timor",
        code: "TL",
        flag: "https://www.untitledui.com/images/flags/TL.svg",
        phoneCode: "670",
        phoneMask: "+670-78#-#####",
    },
    {
        name: "Ecuador",
        code: "EC",
        flag: "https://www.untitledui.com/images/flags/EC.svg",
        phoneCode: "593",
        phoneMask: "+593-#-###-####",
    },
    {
        name: "Egypt",
        code: "EG",
        flag: "https://www.untitledui.com/images/flags/EG.svg",
        phoneCode: "20",
        phoneMask: "+20 (###) ###-####",
    },
    {
        name: "El Salvador",
        code: "SV",
        flag: "https://www.untitledui.com/images/flags/SV.svg",
        phoneCode: "503",
        phoneMask: "+503-##-##-####",
    },
    {
        name: "Equatorial Guinea",
        code: "GQ",
        flag: "https://www.untitledui.com/images/flags/GQ.svg",
        phoneCode: "240",
        phoneMask: "+240-##-###-####",
    },
    {
        name: "Eritrea",
        code: "ER",
        flag: "https://www.untitledui.com/images/flags/ER.svg",
        phoneCode: "291",
        phoneMask: "+291-#-###-###",
    },
    {
        name: "Estonia",
        code: "EE",
        flag: "https://www.untitledui.com/images/flags/EE.svg",
        phoneCode: "372",
        phoneMask: "+372-###-####",
    },
    {
        name: "Eswatini",
        code: "SZ",
        flag: "https://www.untitledui.com/images/flags/SZ.svg",
        phoneCode: "268",
        phoneMask: "+268-##-##-####",
    },
    {
        name: "Ethiopia",
        code: "ET",
        flag: "https://www.untitledui.com/images/flags/ET.svg",
        phoneCode: "251",
        phoneMask: "+251-##-###-####",
    },
    {
        name: "Fiji",
        code: "FJ",
        flag: "https://www.untitledui.com/images/flags/FJ.svg",
        phoneCode: "679",
        phoneMask: "+679-##-#####",
    },
    {
        name: "Finland",
        code: "FI",
        flag: "https://www.untitledui.com/images/flags/FI.svg",
        phoneCode: "358",
        phoneMask: "+358 (###) ###-##-##",
    },
    {
        name: "France",
        code: "FR",
        flag: "https://www.untitledui.com/images/flags/FR.svg",
        phoneCode: "33",
        phoneMask: "+590 (###) ###-###",
    },
    {
        name: "Gabon",
        code: "GA",
        flag: "https://www.untitledui.com/images/flags/GA.svg",
        phoneCode: "241",
        phoneMask: "+241-#-##-##-##",
    },
    {
        name: "Gambia",
        code: "GM",
        flag: "https://www.untitledui.com/images/flags/GM.svg",
        phoneCode: "220",
        phoneMask: "+220 (###) ##-##",
    },
    {
        name: "Georgia",
        code: "GE",
        flag: "https://www.untitledui.com/images/flags/GE.svg",
        phoneCode: "995",
        phoneMask: "+995 (###) ###-###",
    },
    {
        name: "Germany",
        code: "DE",
        flag: "https://www.untitledui.com/images/flags/DE.svg",
        phoneCode: "49",
        phoneMask: "+49-###-###",
    },
    {
        name: "Ghana",
        code: "GH",
        flag: "https://www.untitledui.com/images/flags/GH.svg",
        phoneCode: "233",
        phoneMask: "+233 (###) ###-###",
    },
    {
        name: "Greece",
        code: "GR",
        flag: "https://www.untitledui.com/images/flags/GR.svg",
        phoneCode: "30",
        phoneMask: "+30 (###) ###-####",
    },
    {
        name: "Grenada",
        code: "GD",
        flag: "https://www.untitledui.com/images/flags/GD.svg",
        phoneCode: "+1-473",
        phoneMask: "+1 (473) ###-####",
    },
    {
        name: "Guatemala",
        code: "GT",
        flag: "https://www.untitledui.com/images/flags/GT.svg",
        phoneCode: "502",
        phoneMask: "+502-#-###-####",
    },
    {
        name: "Guinea",
        code: "GN",
        flag: "https://www.untitledui.com/images/flags/GN.svg",
        phoneCode: "224",
        phoneMask: "+224-##-###-###",
    },
    {
        name: "Guinea-Bissau",
        code: "GW",
        flag: "https://www.untitledui.com/images/flags/GW.svg",
        phoneCode: "245",
        phoneMask: "+245-#-######",
    },
    {
        name: "Guyana",
        code: "GY",
        flag: "https://www.untitledui.com/images/flags/GY.svg",
        phoneCode: "592",
        phoneMask: "+592-###-####",
    },
    {
        name: "Haiti",
        code: "HT",
        flag: "https://www.untitledui.com/images/flags/HT.svg",
        phoneCode: "509",
        phoneMask: "+509-##-##-####",
    },
    {
        name: "Honduras",
        code: "HN",
        flag: "https://www.untitledui.com/images/flags/HN.svg",
        phoneCode: "504",
        phoneMask: "+504-####-####",
    },
    {
        name: "Hungary",
        code: "HU",
        flag: "https://www.untitledui.com/images/flags/HU.svg",
        phoneCode: "36",
        phoneMask: "+36 (###) ###-###",
    },
    {
        name: "Iceland",
        code: "IS",
        flag: "https://www.untitledui.com/images/flags/IS.svg",
        phoneCode: "354",
        phoneMask: "+354-###-####",
    },
    {
        name: "India",
        code: "IN",
        flag: "https://www.untitledui.com/images/flags/IN.svg",
        phoneCode: "91",
        phoneMask: "+91 (####) ###-###",
    },
    {
        name: "Indonesia",
        code: "ID",
        flag: "https://www.untitledui.com/images/flags/ID.svg",
        phoneCode: "62",
        phoneMask: "+62 (8##) ###-##-###",
    },
    {
        name: "Iran",
        code: "IR",
        flag: "https://www.untitledui.com/images/flags/IR.svg",
        phoneCode: "98",
        phoneMask: "+98 (###) ###-####",
    },
    {
        name: "Iraq",
        code: "IQ",
        flag: "https://www.untitledui.com/images/flags/IQ.svg",
        phoneCode: "964",
        phoneMask: "+964 (###) ###-####",
    },
    {
        name: "Ireland",
        code: "IE",
        flag: "https://www.untitledui.com/images/flags/IE.svg",
        phoneCode: "353",
        phoneMask: "+353 (###) ###-###",
    },
    {
        name: "Israel",
        code: "IL",
        flag: "https://www.untitledui.com/images/flags/IL.svg",
        phoneCode: "972",
        phoneMask: "+972-#-###-####",
    },
    {
        name: "Italy",
        code: "IT",
        flag: "https://www.untitledui.com/images/flags/IT.svg",
        phoneCode: "39",
        phoneMask: "+39 (###) ####-###",
    },
    {
        name: "Jamaica",
        code: "JM",
        flag: "https://www.untitledui.com/images/flags/JM.svg",
        phoneCode: "+1-876",
        phoneMask: "+1 (876) ###-####",
    },
    {
        name: "Japan",
        code: "JP",
        flag: "https://www.untitledui.com/images/flags/JP.svg",
        phoneCode: "81",
        phoneMask: "+81 (###) ###-###",
    },
    {
        name: "Jordan",
        code: "JO",
        flag: "https://www.untitledui.com/images/flags/JO.svg",
        phoneCode: "962",
        phoneMask: "+962-#-####-####",
    },
    {
        name: "Kazakhstan",
        code: "KZ",
        flag: "https://www.untitledui.com/images/flags/KZ.svg",
        phoneCode: "7",
        phoneMask: "+7 (7##) ###-##-##",
    },
    {
        name: "Kenya",
        code: "KE",
        flag: "https://www.untitledui.com/images/flags/KE.svg",
        phoneCode: "254",
        phoneMask: "+254-###-######",
    },
    {
        name: "Kiribati",
        code: "KI",
        flag: "https://www.untitledui.com/images/flags/KI.svg",
        phoneCode: "686",
        phoneMask: "+686-##-###",
    },
    {
        name: "Kuwait",
        code: "KW",
        flag: "https://www.untitledui.com/images/flags/KW.svg",
        phoneCode: "965",
        phoneMask: "+965-####-####",
    },
    {
        name: "Kyrgyzstan",
        code: "KG",
        flag: "https://www.untitledui.com/images/flags/KG.svg",
        phoneCode: "996",
        phoneMask: "+996 (###) ###-###",
    },
    {
        name: "Laos",
        code: "LA",
        flag: "https://www.untitledui.com/images/flags/LA.svg",
        phoneCode: "856",
        phoneMask: "+856-##-###-###",
    },
    {
        name: "Latvia",
        code: "LV",
        flag: "https://www.untitledui.com/images/flags/LV.svg",
        phoneCode: "371",
        phoneMask: "+371-##-###-###",
    },
    {
        name: "Lebanon",
        code: "LB",
        flag: "https://www.untitledui.com/images/flags/LB.svg",
        phoneCode: "961",
        phoneMask: "+961-#-###-###",
    },
    {
        name: "Lesotho",
        code: "LS",
        flag: "https://www.untitledui.com/images/flags/LS.svg",
        phoneCode: "266",
        phoneMask: "+266-#-###-####",
    },
    {
        name: "Liberia",
        code: "LR",
        flag: "https://www.untitledui.com/images/flags/LR.svg",
        phoneCode: "231",
        phoneMask: "+231-##-###-###",
    },
    {
        name: "Libya",
        code: "LY",
        flag: "https://www.untitledui.com/images/flags/LY.svg",
        phoneCode: "218",
        phoneMask: "+218-21-###-####",
    },
    {
        name: "Liechtenstein",
        code: "LI",
        flag: "https://www.untitledui.com/images/flags/LI.svg",
        phoneCode: "423",
        phoneMask: "+423 (###) ###-####",
    },
    {
        name: "Lithuania",
        code: "LT",
        flag: "https://www.untitledui.com/images/flags/LT.svg",
        phoneCode: "370",
        phoneMask: "+370 (###) ##-###",
    },
    {
        name: "Luxembourg",
        code: "LU",
        flag: "https://www.untitledui.com/images/flags/LU.svg",
        phoneCode: "352",
        phoneMask: "+352 (###) ###-###",
    },
    {
        name: "Madagascar",
        code: "MG",
        flag: "https://www.untitledui.com/images/flags/MG.svg",
        phoneCode: "261",
        phoneMask: "+261-##-##-#####",
    },
    {
        name: "Malawi",
        code: "MW",
        flag: "https://www.untitledui.com/images/flags/MW.svg",
        phoneCode: "265",
        phoneMask: "+265-#-####-####",
    },
    {
        name: "Malaysia",
        code: "MY",
        flag: "https://www.untitledui.com/images/flags/MY.svg",
        phoneCode: "60",
        phoneMask: "+60-#-###-###",
    },
    {
        name: "Maldives",
        code: "MV",
        flag: "https://www.untitledui.com/images/flags/MV.svg",
        phoneCode: "960",
        phoneMask: "+960-###-####",
    },
    {
        name: "Mali",
        code: "ML",
        flag: "https://www.untitledui.com/images/flags/ML.svg",
        phoneCode: "223",
        phoneMask: "+223-##-##-####",
    },
    {
        name: "Malta",
        code: "MT",
        flag: "https://www.untitledui.com/images/flags/MT.svg",
        phoneCode: "356",
        phoneMask: "+356-####-####",
    },
    {
        name: "Marshall Islands",
        code: "MH",
        flag: "https://www.untitledui.com/images/flags/MH.svg",
        phoneCode: "692",
        phoneMask: "+692-###-####",
    },
    {
        name: "Mauritania",
        code: "MR",
        flag: "https://www.untitledui.com/images/flags/MR.svg",
        phoneCode: "222",
        phoneMask: "+222-##-##-####",
    },
    {
        name: "Mauritius",
        code: "MU",
        flag: "https://www.untitledui.com/images/flags/MU.svg",
        phoneCode: "230",
        phoneMask: "+230-###-####",
    },
    {
        name: "Mexico",
        code: "MX",
        flag: "https://www.untitledui.com/images/flags/MX.svg",
        phoneCode: "52",
        phoneMask: "+52-##-##-####",
    },
    {
        name: "Micronesia",
        code: "FM",
        flag: "https://www.untitledui.com/images/flags/FM.svg",
        phoneCode: "691",
        phoneMask: "+691-###-####",
    },
    {
        name: "Moldova",
        code: "MD",
        flag: "https://www.untitledui.com/images/flags/MD.svg",
        phoneCode: "373",
        phoneMask: "+373-####-####",
    },
    {
        name: "Monaco",
        code: "MC",
        flag: "https://www.untitledui.com/images/flags/MC.svg",
        phoneCode: "377",
        phoneMask: "+377-##-###-###",
    },
    {
        name: "Mongolia",
        code: "MN",
        flag: "https://www.untitledui.com/images/flags/MN.svg",
        phoneCode: "976",
        phoneMask: "+976-##-##-####",
    },
    {
        name: "Montenegro",
        code: "ME",
        flag: "https://www.untitledui.com/images/flags/ME.svg",
        phoneCode: "382",
        phoneMask: "+382-##-###-###",
    },
    {
        name: "Morocco",
        code: "MA",
        flag: "https://www.untitledui.com/images/flags/MA.svg",
        phoneCode: "212",
        phoneMask: "+212-##-####-###",
    },
    {
        name: "Mozambique",
        code: "MZ",
        flag: "https://www.untitledui.com/images/flags/MZ.svg",
        phoneCode: "258",
        phoneMask: "+258-##-###-###",
    },
    {
        name: "Myanmar",
        code: "MM",
        flag: "https://www.untitledui.com/images/flags/MM.svg",
        phoneCode: "95",
        phoneMask: "+95-###-###",
    },
    {
        name: "Namibia",
        code: "NA",
        flag: "https://www.untitledui.com/images/flags/NA.svg",
        phoneCode: "264",
        phoneMask: "+264-##-###-####",
    },
    {
        name: "Nauru",
        code: "NR",
        flag: "https://www.untitledui.com/images/flags/NR.svg",
        phoneCode: "674",
        phoneMask: "+674-###-####",
    },
    {
        name: "Nepal",
        code: "NP",
        flag: "https://www.untitledui.com/images/flags/NP.svg",
        phoneCode: "977",
        phoneMask: "+977-##-###-###",
    },
    {
        name: "Netherlands",
        code: "NL",
        flag: "https://www.untitledui.com/images/flags/NL.svg",
        phoneCode: "31",
        phoneMask: "+31-##-###-####",
    },
    {
        name: "New Zealand",
        code: "NZ",
        flag: "https://www.untitledui.com/images/flags/NZ.svg",
        phoneCode: "64",
        phoneMask: "+64 (###) ###-####",
    },
    {
        name: "Nicaragua",
        code: "NI",
        flag: "https://www.untitledui.com/images/flags/NI.svg",
        phoneCode: "505",
        phoneMask: "+505-####-####",
    },
    {
        name: "Niger",
        code: "NE",
        flag: "https://www.untitledui.com/images/flags/NE.svg",
        phoneCode: "227",
        phoneMask: "+227-##-##-####",
    },
    {
        name: "Nigeria",
        code: "NG",
        flag: "https://www.untitledui.com/images/flags/NG.svg",
        phoneCode: "234",
        phoneMask: "+234 (###) ###-####",
    },
    {
        name: "North Korea",
        code: "KP",
        flag: "https://www.untitledui.com/images/flags/KP.svg",
        phoneCode: "850",
        phoneMask: "+850-####-#############",
    },
    {
        name: "North Macedonia",
        code: "MK",
        flag: "https://www.untitledui.com/images/flags/MK.svg",
        phoneCode: "389",
        phoneMask: "+389-##-###-###",
    },
    {
        name: "Norway",
        code: "NO",
        flag: "https://www.untitledui.com/images/flags/NO.svg",
        phoneCode: "47",
        phoneMask: "+47 (###) ##-###",
    },
    {
        name: "Oman",
        code: "OM",
        flag: "https://www.untitledui.com/images/flags/OM.svg",
        phoneCode: "968",
        phoneMask: "+968-##-###-###",
    },
    {
        name: "Pakistan",
        code: "PK",
        flag: "https://www.untitledui.com/images/flags/PK.svg",
        phoneCode: "92",
        phoneMask: "+92 (###) ###-####",
    },
    {
        name: "Palau",
        code: "PW",
        flag: "https://www.untitledui.com/images/flags/PW.svg",
        phoneCode: "680",
        phoneMask: "+680-###-####",
    },
    {
        name: "Panama",
        code: "PA",
        flag: "https://www.untitledui.com/images/flags/PA.svg",
        phoneCode: "507",
        phoneMask: "+507-###-####",
    },
    {
        name: "Papua New Guinea",
        code: "PG",
        flag: "https://www.untitledui.com/images/flags/PG.svg",
        phoneCode: "675",
        phoneMask: "+675 (###) ##-###",
    },
    {
        name: "Paraguay",
        code: "PY",
        flag: "https://www.untitledui.com/images/flags/PY.svg",
        phoneCode: "595",
        phoneMask: "+595 (###) ###-###",
    },
    {
        name: "Peru",
        code: "PE",
        flag: "https://www.untitledui.com/images/flags/PE.svg",
        phoneCode: "51",
        phoneMask: "+51 (###) ###-###",
    },
    {
        name: "Philippines",
        code: "PH",
        flag: "https://www.untitledui.com/images/flags/PH.svg",
        phoneCode: "63",
        phoneMask: "+63 (###) ###-####",
    },
    {
        name: "Poland",
        code: "PL",
        flag: "https://www.untitledui.com/images/flags/PL.svg",
        phoneCode: "48",
        phoneMask: "+48 (###) ###-###",
    },
    {
        name: "Portugal",
        code: "PT",
        flag: "https://www.untitledui.com/images/flags/PT.svg",
        phoneCode: "351",
        phoneMask: "+351-##-###-####",
    },
    {
        name: "Qatar",
        code: "QA",
        flag: "https://www.untitledui.com/images/flags/QA.svg",
        phoneCode: "974",
        phoneMask: "+974-####-####",
    },
    {
        name: "Romania",
        code: "RO",
        flag: "https://www.untitledui.com/images/flags/RO.svg",
        phoneCode: "40",
        phoneMask: "+40-##-###-####",
    },
    {
        name: "Russia",
        code: "RU",
        flag: "https://www.untitledui.com/images/flags/RU.svg",
        phoneCode: "7",
        phoneMask: "+7 (###) ###-##-##",
    },
    {
        name: "Rwanda",
        code: "RW",
        flag: "https://www.untitledui.com/images/flags/RW.svg",
        phoneCode: "250",
        phoneMask: "+250 (###) ###-###",
    },
    {
        name: "Saint Kitts and Nevis",
        code: "KN",
        flag: "https://www.untitledui.com/images/flags/KN.svg",
        phoneCode: "+1-869",
        phoneMask: "+1 (869) ###-####",
    },
    {
        name: "Saint Lucia",
        code: "LC",
        flag: "https://www.untitledui.com/images/flags/LC.svg",
        phoneCode: "+1-758",
        phoneMask: "+1 (758) ###-####",
    },
    {
        name: "Saint Vincent and the Grenadines",
        code: "VC",
        flag: "https://www.untitledui.com/images/flags/VC.svg",
        phoneCode: "+1-784",
        phoneMask: "+1 (784) ###-####",
    },
    {
        name: "Samoa",
        code: "WS",
        flag: "https://www.untitledui.com/images/flags/WS.svg",
        phoneCode: "685",
        phoneMask: "+685-##-####",
    },
    {
        name: "San Marino",
        code: "SM",
        flag: "https://www.untitledui.com/images/flags/SM.svg",
        phoneCode: "378",
        phoneMask: "+378-####-######",
    },
    {
        name: "Sao Tome and Principe",
        code: "ST",
        flag: "https://www.untitledui.com/images/flags/ST.svg",
        phoneCode: "239",
        phoneMask: "+239-##-#####",
    },
    {
        name: "Saudi Arabia",
        code: "SA",
        flag: "https://www.untitledui.com/images/flags/SA.svg",
        phoneCode: "966",
        phoneMask: "+966-#-###-####",
    },
    {
        name: "Senegal",
        code: "SN",
        flag: "https://www.untitledui.com/images/flags/SN.svg",
        phoneCode: "221",
        phoneMask: "+221-##-###-####",
    },
    {
        name: "Serbia",
        code: "RS",
        flag: "https://www.untitledui.com/images/flags/RS.svg",
        phoneCode: "381",
        phoneMask: "+381-##-###-####",
    },
    {
        name: "Seychelles",
        code: "SC",
        flag: "https://www.untitledui.com/images/flags/SC.svg",
        phoneCode: "248",
        phoneMask: "+248-#-###-###",
    },
    {
        name: "Sierra Leone",
        code: "SL",
        flag: "https://www.untitledui.com/images/flags/SL.svg",
        phoneCode: "232",
        phoneMask: "+232-##-######",
    },
    {
        name: "Singapore",
        code: "SG",
        flag: "https://www.untitledui.com/images/flags/SG.svg",
        phoneCode: "65",
        phoneMask: "+65-####-####",
    },
    {
        name: "Slovakia",
        code: "SK",
        flag: "https://www.untitledui.com/images/flags/SK.svg",
        phoneCode: "421",
        phoneMask: "+421 (###) ###-###",
    },
    {
        name: "Slovenia",
        code: "SI",
        flag: "https://www.untitledui.com/images/flags/SI.svg",
        phoneCode: "386",
        phoneMask: "+386-##-###-###",
    },
    {
        name: "Solomon Islands",
        code: "SB",
        flag: "https://www.untitledui.com/images/flags/SB.svg",
        phoneCode: "677",
        phoneMask: "+677-#####",
    },
    {
        name: "Somalia",
        code: "SO",
        flag: "https://www.untitledui.com/images/flags/SO.svg",
        phoneCode: "252",
        phoneMask: "+252-#-###-###",
    },
    {
        name: "South Africa",
        code: "ZA",
        flag: "https://www.untitledui.com/images/flags/ZA.svg",
        phoneCode: "27",
        phoneMask: "+27-##-###-####",
    },
    {
        name: "South Korea",
        code: "KR",
        flag: "https://www.untitledui.com/images/flags/KR.svg",
        phoneCode: "82",
        phoneMask: "+82-##-###-####",
    },
    {
        name: "South Sudan",
        code: "SS",
        flag: "https://www.untitledui.com/images/flags/SS.svg",
        phoneCode: "211",
        phoneMask: "+211-##-###-####",
    },
    {
        name: "Spain",
        code: "ES",
        flag: "https://www.untitledui.com/images/flags/ES.svg",
        phoneCode: "34",
        phoneMask: "+34 (###) ###-###",
    },
    {
        name: "Sri Lanka",
        code: "LK",
        flag: "https://www.untitledui.com/images/flags/LK.svg",
        phoneCode: "94",
        phoneMask: "+94-##-###-####",
    },
    {
        name: "Suriname",
        code: "SR",
        flag: "https://www.untitledui.com/images/flags/SR.svg",
        phoneCode: "597",
        phoneMask: "+597-###-###",
    },
    {
        name: "Sweden",
        code: "SE",
        flag: "https://www.untitledui.com/images/flags/SE.svg",
        phoneCode: "46",
        phoneMask: "+46-##-###-####",
    },
    {
        name: "Switzerland",
        code: "CH",
        flag: "https://www.untitledui.com/images/flags/CH.svg",
        phoneCode: "41",
        phoneMask: "+41-##-###-####",
    },
    {
        name: "Syria",
        code: "SY",
        flag: "https://www.untitledui.com/images/flags/SY.svg",
        phoneCode: "963",
        phoneMask: "+963-##-####-###",
    },
    {
        name: "Tajikistan",
        code: "TJ",
        flag: "https://www.untitledui.com/images/flags/TJ.svg",
        phoneCode: "992",
        phoneMask: "+992-##-###-####",
    },
    {
        name: "Tanzania",
        code: "TZ",
        flag: "https://www.untitledui.com/images/flags/TZ.svg",
        phoneCode: "255",
        phoneMask: "+255-##-###-####",
    },
    {
        name: "Thailand",
        code: "TH",
        flag: "https://www.untitledui.com/images/flags/TH.svg",
        phoneCode: "66",
        phoneMask: "+66-##-###-###",
    },
    {
        name: "Togo",
        code: "TG",
        flag: "https://www.untitledui.com/images/flags/TG.svg",
        phoneCode: "228",
        phoneMask: "+228-##-###-###",
    },
    {
        name: "Tonga",
        code: "TO",
        flag: "https://www.untitledui.com/images/flags/TO.svg",
        phoneCode: "676",
        phoneMask: "+676-#####",
    },
    {
        name: "Trinidad and Tobago",
        code: "TT",
        flag: "https://www.untitledui.com/images/flags/TT.svg",
        phoneCode: "+1-868",
        phoneMask: "+1 (868) ###-####",
    },
    {
        name: "Tunisia",
        code: "TN",
        flag: "https://www.untitledui.com/images/flags/TN.svg",
        phoneCode: "216",
        phoneMask: "+216-##-###-###",
    },
    {
        name: "Turkey",
        code: "TR",
        flag: "https://www.untitledui.com/images/flags/TR.svg",
        phoneCode: "90",
        phoneMask: "+90 (###) ###-####",
    },
    {
        name: "Turkmenistan",
        code: "TM",
        flag: "https://www.untitledui.com/images/flags/TM.svg",
        phoneCode: "993",
        phoneMask: "+993-#-###-####",
    },
    {
        name: "Tuvalu",
        code: "TV",
        flag: "https://www.untitledui.com/images/flags/TV.svg",
        phoneCode: "688",
        phoneMask: "+688-2####",
    },
    {
        name: "Uganda",
        code: "UG",
        flag: "https://www.untitledui.com/images/flags/UG.svg",
        phoneCode: "256",
        phoneMask: "+256 (###) ###-###",
    },
    {
        name: "Ukraine",
        code: "UA",
        flag: "https://www.untitledui.com/images/flags/UA.svg",
        phoneCode: "380",
        phoneMask: "+380 (##) ###-##-##",
    },
    {
        name: "United Arab Emirates",
        code: "AE",
        flag: "https://www.untitledui.com/images/flags/AE.svg",
        phoneCode: "971",
        phoneMask: "+971-#-###-####",
    },
    {
        name: "United Kingdom",
        code: "GB",
        flag: "https://www.untitledui.com/images/flags/GB.svg",
        phoneCode: "44",
    },
    {
        name: "United States",
        code: "US",
        flag: "https://www.untitledui.com/images/flags/US.svg",
        phoneCode: "1",
        phoneMask: "+1 (###) ###-####",
    },
    {
        name: "Uruguay",
        code: "UY",
        flag: "https://www.untitledui.com/images/flags/UY.svg",
        phoneCode: "598",
        phoneMask: "+598-#-###-##-##",
    },
    {
        name: "Uzbekistan",
        code: "UZ",
        flag: "https://www.untitledui.com/images/flags/UZ.svg",
        phoneCode: "998",
        phoneMask: "+998-##-###-####",
    },
    {
        name: "Vanuatu",
        code: "VU",
        flag: "https://www.untitledui.com/images/flags/VU.svg",
        phoneCode: "678",
        phoneMask: "+678-#####",
    },
    {
        name: "Venezuela",
        code: "VE",
        flag: "https://www.untitledui.com/images/flags/VE.svg",
        phoneCode: "58",
        phoneMask: "+58 (###) ###-####",
    },
    {
        name: "Vietnam",
        code: "VN",
        flag: "https://www.untitledui.com/images/flags/VN.svg",
        phoneCode: "84",
        phoneMask: "+84 (###) ####-###",
    },
    {
        name: "Yemen",
        code: "YE",
        flag: "https://www.untitledui.com/images/flags/YE.svg",
        phoneCode: "967",
        phoneMask: "+967-##-###-###",
    },
    {
        name: "Zambia",
        code: "ZM",
        flag: "https://www.untitledui.com/images/flags/ZM.svg",
        phoneCode: "260",
        phoneMask: "+260-##-###-####",
    },
    {
        name: "Zimbabwe",
        code: "ZW",
        flag: "https://www.untitledui.com/images/flags/ZW.svg",
        phoneCode: "263",
        phoneMask: "+263-#-######",
    },
];

/**
 * Phone code options for the select component.
 */
export const phoneCodeOptions: SelectItemType[] = countries.map((country) => ({
    id: country.code,
    label: country.code,
}));

export default countries;
````

## File: src/pages/History.tsx
````typescript
import { useCallback } from "react";
import { useNavigate } from "react-router-dom";
import { PageShell, PageHero } from "@/components/PageShell";
import { VersionHistoryContent } from "@/components/VersionHistory";
import { Card } from "@/components/base/primitives/card";
import { usePromptBuilder } from "@/hooks/usePromptBuilder";
import { useToast } from "@/hooks/use-toast";
import { queueRestoredVersionPrompt } from "@/lib/history-restore";

const History = () => {
  const navigate = useNavigate();
  const { toast } = useToast();
  const { versions } = usePromptBuilder();

  const handleRestore = useCallback(
    (prompt: string) => {
      const queued = queueRestoredVersionPrompt(prompt);
      if (!queued) {
        toast({
          title: "Restore failed",
          description: "Could not transfer this version to Builder. Try again.",
          variant: "destructive",
        });
        return;
      }
      toast({ title: "Version ready", description: "Restored prompt sent to Builder." });
      navigate("/");
    },
    [navigate, toast],
  );

  return (
    <PageShell>
        <PageHero
          title="Version History"
          subtitle="Restore a saved version to Builder."
          className="pf-gilded-frame pf-hero-surface"
        />

        <Card className="pf-card border-border/80 bg-card/85 p-3 sm:max-h-[calc(100vh-220px)] sm:overflow-hidden sm:p-4">
          <VersionHistoryContent
            versions={versions}
            onRestore={handleRestore}
            className="pr-1 sm:h-full sm:max-h-[calc(100vh-260px)]"
          />
        </Card>
    </PageShell>
  );
};

export default History;
````

## File: src/pages/NotFound.tsx
````typescript
import { useLocation } from "react-router-dom";
import { useEffect } from "react";
import { PageShell } from "@/components/PageShell";
import { StateCard } from "@/components/base/primitives/state-card";

const NotFound = () => {
  const location = useLocation();

  useEffect(() => {
    console.error("404 Error: User attempted to access non-existent route:", location.pathname);
  }, [location.pathname]);

  return (
    <PageShell mainClassName="pf-community-page flex items-center justify-center py-10">
      <div className="w-full max-w-lg">
        <StateCard
          variant="error"
          title="Page not found"
          description={`This page (${location.pathname}) does not exist or has moved.`}
          primaryAction={{ label: "Back to Builder", to: "/" }}
          secondaryAction={{ label: "Open Community", to: "/community" }}
          className="pf-card p-6"
        />
      </div>
    </PageShell>
  );
};

export default NotFound;
````

## File: src/styles/typography.css
````css
.prose:not(:where([class~="not-prose"], [class~="not-prose"] *)) {
    --tw-prose-body: hsl(var(--muted-foreground));
    --tw-prose-headings: hsl(var(--foreground));
    --tw-prose-lead: hsl(var(--muted-foreground));
    --tw-prose-links: hsl(var(--muted-foreground));
    --tw-prose-bold: hsl(var(--foreground));
    --tw-prose-counters: hsl(var(--muted-foreground));
    --tw-prose-bullets: hsl(var(--muted-foreground));
    --tw-prose-hr: hsl(var(--border));
    --tw-prose-quotes: hsl(var(--foreground));
    --tw-prose-quote-borders: hsl(var(--primary));
    --tw-prose-captions: hsl(var(--muted-foreground));
    --tw-prose-code: hsl(var(--muted-foreground));
    --tw-prose-pre-code: hsl(var(--muted-foreground));
    --tw-prose-pre-bg: hsl(var(--card));
    --tw-prose-th-borders: hsl(var(--border));
    --tw-prose-td-borders: hsl(var(--border));

    /* Base */
    color: var(--tw-prose-body);
    font-size: var(--type-base-size);
    line-height: var(--type-base-line);
}

.prose :not(:where([class~="not-prose"], [class~="not-prose"] *)) {
    /* Text */
    &:where(p) {
        margin-top: calc(var(--spacing) * 4);
        margin-bottom: calc(var(--spacing) * 4);
    }

    &:where([class~="lead"]) {
        font-size: var(--type-base-size);
        line-height: var(--type-base-line);
        margin-top: 1.2em;
        margin-bottom: 1.2em;
    }

    /* Lists */
    &:where(ol) {
        list-style-type: decimal;

        margin-top: calc(var(--spacing) * 4);
        margin-bottom: calc(var(--spacing) * 4);
        padding-inline-start: calc(var(--spacing) * 5.75);
    }
    &:where(ul) {
        list-style-type: disc;

        margin-top: calc(var(--spacing) * 4);
        margin-bottom: calc(var(--spacing) * 4);
        padding-inline-start: calc(var(--spacing) * 5.75);
    }
    &:where(li) {
        margin-top: calc(var(--spacing) * 2);
        margin-bottom: calc(var(--spacing) * 2);
    }
    &:where(ol > li) {
        padding-inline-start: 1px;
        margin-top: 0;
        margin-bottom: 0;
    }
    &:where(ul > li) {
        padding-inline-start: 1px;
        margin-top: 0;
        margin-bottom: 0;
    }

    /* Horizontal rules */
    &:where(hr) {
        margin-top: calc(var(--spacing) * 8);
        margin-bottom: calc(var(--spacing) * 8);
    }

    /* Quotes */
    &:where(blockquote) {
        color: var(--tw-prose-quotes);

        border-left-width: 2px;
        border-left-color: var(--tw-prose-quote-borders);

        padding-inline-start: 0;
        margin-top: calc(var(--spacing) * 10);
        margin-bottom: calc(var(--spacing) * 10);
    }
    &:where(blockquote p) {
        margin: 0;
        font-weight: 500;
        font-style: italic;

        font-size: var(--type-xl-size);
        line-height: var(--type-xl-line);
    }
    &:where(blockquote p:first-of-type::before) {
        content: open-quote;
    }
    &:where(blockquote p:last-of-type::after) {
        content: close-quote;
    }

    /* Headings */
    &:where(h1) {
        color: var(--tw-prose-headings);
        font-weight: 600;

        font-size: var(--type-3xl-size);
        line-height: var(--type-3xl-line);
        margin-bottom: calc(var(--spacing) * 5);
        margin-top: calc(var(--spacing) * 10);
    }
    &:where(h2) {
        color: var(--tw-prose-headings);
        font-weight: 600;

        font-size: var(--type-2xl-size);
        line-height: var(--type-2xl-line);
        margin-bottom: calc(var(--spacing) * 4);
        margin-top: calc(var(--spacing) * 8);
    }
    &:where(h3) {
        color: var(--tw-prose-headings);
        font-weight: 600;

        font-size: var(--type-xl-size);
        line-height: var(--type-xl-line);
        margin-bottom: calc(var(--spacing) * 3);
        margin-top: calc(var(--spacing) * 8);
    }
    &:where(h4) {
        color: var(--tw-prose-headings);
        font-weight: 600;

        font-size: var(--type-lg-size);
        line-height: var(--type-lg-line);
        margin-bottom: calc(var(--spacing) * 2);
        margin-top: calc(var(--spacing) * 5);
    }

    &:where(h2 + *) {
        margin-top: 0;
    }
    &:where(h3 + *) {
        margin-top: 0;
    }
    &:where(h4 + *) {
        margin-top: 0;
    }

    &:where(h1 strong) {
        font-weight: 900;
        color: inherit;
    }
    &:where(h2 strong) {
        font-weight: 800;
        color: inherit;
    }
    &:where(h3 strong) {
        font-weight: 700;
        color: inherit;
    }
    &:where(h4 strong) {
        font-weight: 700;
        color: inherit;
    }

    /* Media */

    &:where(img) {
        border-radius: var(--radius);
        width: 100%;
        object-fit: cover;

        margin-top: calc(var(--spacing) * 8);
        margin-bottom: calc(var(--spacing) * 8);
    }
    &:where(video) {
        margin-top: calc(var(--spacing) * 8);
        margin-bottom: calc(var(--spacing) * 8);
    }
    &:where(figure) {
        margin-top: calc(var(--spacing) * 10);
        margin-bottom: calc(var(--spacing) * 10);
    }
    &:where(figure > *) {
        margin-top: 0;
        margin-bottom: 0;
    }
    &:where(figure:has(> blockquote)) {
        border-left-width: 2px;
        border-left-color: var(--tw-prose-quote-borders);
        padding-top: calc(var(--spacing) * 2);
        padding-bottom: calc(var(--spacing) * 2);

        padding-inline-start: calc(var(--spacing) * 4);
    }
    &:where(figure:has(> blockquote) blockquote) {
        padding-inline-start: 0;
        border: none;
    }
    &:where(img + figcaption) {
        display: flex;
        align-items: center;
        gap: calc(var(--spacing) * 1.5);
    }
    &:where(figcaption) {
        color: var(--tw-prose-captions);

        font-size: var(--type-sm-size);
        line-height: var(--type-sm-line);
        margin-top: calc(var(--spacing) * 3);
    }
    &:where(cite) {
        font-style: normal;
    }

    /* Inline elements */
    &:where(a:not(h1 a, h2 a, h3 a, h4 a, h5 a, h6 a)) {
        font-weight: 400;
        text-decoration: underline;
        text-underline-offset: 3px;
    }

    &:where(a:focus-visible) {
        border-radius: calc(var(--radius) - 0.5rem);
        outline: 2px solid hsl(var(--ring));
        outline-offset: 2px;
    }
    &:where(:is(h1, h2, h3) a) {
        color: var(--tw-prose-headings);
        font-weight: inherit;
        text-decoration: none;
    }

    /* Inline code element */
    &:where(code:not(pre code)) {
        font-size: 0.875rem;
        line-height: 1.25rem;
        font-weight: 700;
        border-radius: calc(var(--radius) - 0.375rem);
        padding: calc(var(--spacing) * 0.5) calc(var(--spacing) * 1.5);
        margin: calc(var(--spacing) * -0.5) 0px;
        background: hsl(var(--muted));
        box-shadow: 0 0 0 1px hsl(var(--border));

        &::before,
        &::after {
            content: "";
        }
    }
}

.prose.prose-centered-quote :not(:where([class~="not-prose"], [class~="not-prose"] *)) {
    &:where(blockquote) {
        padding-inline-start: 0px !important;
        border-left: none;
        text-align: center;
    }
    &:where(figure:has(> blockquote)) {
        border-left: none;
        padding-inline-start: 0px !important;
        padding-top: 0px !important;
        padding-bottom: 0px !important;
        text-align: center;
    }
}

.prose.prose-minimal-quote :not(:where([class~="not-prose"], [class~="not-prose"] *)) {
    &:where(blockquote) {
        border-left: none;
        padding-inline-start: 0px !important;
    }
    &:where(figure:has(> blockquote)) {
        border-left: none;
        padding-inline-start: 0px !important;
    }
}

.prose.md\:prose-lg:not(:where([class~="not-prose"], [class~="not-prose"] *)) {
    @media (width >= 48rem /* 768px */) {
        /* Base */
        font-size: var(--type-lg-size);
        line-height: var(--type-lg-line);
    }
}

.prose.md\:prose-lg :not(:where([class~="not-prose"], [class~="not-prose"] *)) {
    @media (width >= 48rem /* 768px */) {
        /* Text */
        &:where(p) {
            margin-top: calc(var(--spacing) * 4.5);
            margin-bottom: calc(var(--spacing) * 4.5);
        }

        &:where([class~="lead"]) {
            font-size: var(--type-xl-size);
            line-height: var(--type-xl-line);
            margin-top: 1.09em;
            margin-bottom: 1.09em;
        }

        /* Lists */
        &:where(ol) {
            margin-top: calc(var(--spacing) * 4.5);
            margin-bottom: calc(var(--spacing) * 4.5);
            padding-inline-start: calc(var(--spacing) * 6.5);
        }
        &:where(ul) {
            margin-top: calc(var(--spacing) * 4.5);
            margin-bottom: calc(var(--spacing) * 4.5);
            padding-inline-start: calc(var(--spacing) * 6.5);
        }

        &:where(ol > li) {
            padding-inline-start: 1px;
            margin-top: 0;
            margin-bottom: 0;
        }
        &:where(ul > li) {
            padding-inline-start: 1px;
            margin-top: 0;
            margin-bottom: 0;
        }

        /* Horizontal rules */
        &:where(hr) {
            margin-top: calc(var(--spacing) * 8);
            margin-bottom: calc(var(--spacing) * 8);
        }

        /* Quotes */
        &:where(blockquote) {
            padding-inline-start: 0;
            margin-top: calc(var(--spacing) * 12);
            margin-bottom: calc(var(--spacing) * 12);
        }
        &:where(blockquote p) {
            margin: 0;

            font-size: var(--type-2xl-size);
            line-height: var(--type-2xl-line);
        }

        /* Headings */
        &:where(h1) {
            font-size: var(--type-4xl-size);
            line-height: var(--type-4xl-line);
            margin-bottom: calc(var(--spacing) * 6);
            margin-top: calc(var(--spacing) * 12);
        }
        &:where(h2) {
            font-size: var(--type-3xl-size);
            line-height: var(--type-3xl-line);
            margin-bottom: calc(var(--spacing) * 5);
            margin-top: calc(var(--spacing) * 10);
        }
        &:where(h3) {
            font-size: var(--type-2xl-size);
            line-height: var(--type-2xl-line);
            margin-bottom: calc(var(--spacing) * 4);
            margin-top: calc(var(--spacing) * 8);
        }
        &:where(h4) {
            font-size: var(--type-xl-size);
            line-height: var(--type-xl-line);
            margin-bottom: calc(var(--spacing) * 3);
            margin-top: calc(var(--spacing) * 8);
        }
        &:where(h2 + *) {
            margin-top: 0;
        }
        &:where(h3 + *) {
            margin-top: 0;
        }
        &:where(h4 + *) {
            margin-top: 0;
        }

        &:where(figure) {
            margin-top: calc(var(--spacing) * 12);
            margin-bottom: calc(var(--spacing) * 12);
        }
        &:where(figure > *) {
            margin-top: 0;
            margin-bottom: 0;
        }
        &:where(figure:has(> blockquote)) {
            padding-inline-start: calc(var(--spacing) * 5);
        }
        &:where(figure > blockquote + figcaption) {
            font-size: var(--type-base-size);
            line-height: var(--type-base-line);
        }

        &:where(figcaption) {
            margin-top: calc(var(--spacing) * 4);
        }

        /* Inline elements */
        &:where(a:not(h1 a, h2 a, h3 a, h4 a, h5 a, h6 a)) {
            font-weight: 400;
            text-decoration: underline;
            text-underline-offset: 3px;
        }
        &:where(:is(h1, h2, h3) a) {
            color: var(--tw-prose-headings);
            font-weight: inherit;
            text-decoration: none;
        }

        /* Inline code element */
        &:where(code:not(pre code)) {
            font-size: 0.875rem;
            line-height: 1.25rem;
            font-weight: 700;
            border-radius: calc(var(--radius) - 0.375rem);
            padding: calc(var(--spacing) * 0.5) calc(var(--spacing) * 1.5);
            margin: calc(var(--spacing) * -0.5) 0px;
            background: hsl(var(--muted));
            box-shadow: 0 0 0 1px hsl(var(--border));
        }
    }
}

/* Remove top margin from first element */
.prose > :first-child:not(:where([class~="not-prose"], [class~="not-prose"] *)) {
    margin-top: 0;
}
.prose > :last-child:not(:where([class~="not-prose"], [class~="not-prose"] *)) {
    margin-bottom: 0;
}
````

## File: src/styles/untitled-compat.css
````css
/*
 * Transitional compatibility layer for Untitled UI utility class tokens.
 * Keep this file narrow and delete aliases as call sites migrate to semantic tokens.
 */

@theme {
  /* Legacy text size token used by Untitled components. */
  --text-md: var(--type-base-size);
  --text-md--line-height: var(--type-base-line);

  /* Legacy semantic color aliases mapped to the active semantic token set. */
  --color-brand: hsl(var(--primary));
  --color-brand-solid: hsl(var(--primary));
  --color-brand-solid_hover: color-mix(in srgb, hsl(var(--primary)) 88%, black);
  --color-brand-primary: hsl(var(--primary));
  --color-brand-primary_alt: hsl(var(--primary));
  --color-brand-secondary: hsl(var(--primary));
  --color-brand-secondary_hover: color-mix(in srgb, hsl(var(--primary)) 88%, black);
  --color-brand-tertiary: hsl(var(--accent-foreground));
  --color-primary-solid: hsl(var(--primary));
  --color-primary_hover: color-mix(in srgb, hsl(var(--primary)) 90%, black);
  --color-secondary_hover: color-mix(in srgb, hsl(var(--secondary)) 85%, black);
  --color-tertiary: hsl(var(--muted));
  --color-quaternary: hsl(var(--muted));
  --color-disabled: hsl(var(--muted));
  --color-disabled_subtle: hsl(var(--muted));
  --color-error: hsl(var(--destructive));
  --color-error-primary: hsl(var(--destructive));
  --color-error-primary_hover: color-mix(in srgb, hsl(var(--destructive)) 88%, black);
  --color-error-solid: hsl(var(--destructive));
  --color-error-solid_hover: color-mix(in srgb, hsl(var(--destructive)) 88%, black);
  --color-error_subtle: color-mix(in srgb, hsl(var(--destructive)) 24%, hsl(var(--background)));
  --color-focus-ring: hsl(var(--ring));
  --color-bg-brand-solid: var(--color-brand-solid);
  --color-border-brand: hsl(var(--primary));
  --color-border-primary: hsl(var(--border));
  --color-border-disabled: hsl(var(--border));
  --color-border-error_subtle: var(--color-error_subtle);
  --color-fg-brand-primary: hsl(var(--primary));
  --color-fg-brand-secondary_alt: hsl(var(--primary));
  --color-fg-brand-secondary_hover: color-mix(in srgb, hsl(var(--primary)) 88%, black);
  --color-fg-disabled: hsl(var(--muted-foreground));
  --color-fg-disabled_subtle: color-mix(in srgb, hsl(var(--muted-foreground)) 70%, hsl(var(--muted)));
  --color-fg-error-primary: hsl(var(--destructive));
  --color-fg-error-secondary: color-mix(in srgb, hsl(var(--destructive)) 70%, hsl(var(--muted-foreground)));
  --color-fg-quaternary: hsl(var(--muted-foreground));
  --color-fg-quaternary_hover: hsl(var(--foreground));
  --color-fg-success-secondary: hsl(var(--primary));
  --color-fg-white: hsl(var(--primary-foreground));
  --color-placeholder: hsl(var(--muted-foreground));
  --color-text-placeholder_subtle: color-mix(in srgb, hsl(var(--muted-foreground)) 70%, hsl(var(--background)));
  --color-text-secondary_hover: hsl(var(--foreground));
  --color-text-tertiary: hsl(var(--muted-foreground));
  --color-text-tertiary_hover: hsl(var(--foreground));
  --color-tooltip-supporting-text: hsl(var(--muted-foreground));
  --color-button-primary-icon: hsl(var(--primary-foreground));
  --color-button-primary-icon_hover: hsl(var(--primary-foreground));
  --color-button-destructive-primary-icon: hsl(var(--destructive-foreground));
  --color-button-destructive-primary-icon_hover: hsl(var(--destructive-foreground));
  --shadow-xs-skeumorphic: var(--shadow-xs), inset 0 -1px 0 0 hsl(0 0% 0% / 0.08);

  /* Untitled base palette values used by utility-* aliases. */
  --color-brand-50: color-mix(in srgb, hsl(var(--primary)) 12%, white);
  --color-brand-100: color-mix(in srgb, hsl(var(--primary)) 18%, white);
  --color-brand-200: color-mix(in srgb, hsl(var(--primary)) 28%, white);
  --color-brand-300: color-mix(in srgb, hsl(var(--primary)) 40%, white);
  --color-brand-400: color-mix(in srgb, hsl(var(--primary)) 55%, white);
  --color-brand-500: hsl(var(--primary));
  --color-brand-700: color-mix(in srgb, hsl(var(--primary)) 70%, black);

  --color-error-50: color-mix(in srgb, hsl(var(--destructive)) 12%, white);
  --color-error-100: color-mix(in srgb, hsl(var(--destructive)) 18%, white);
  --color-error-200: color-mix(in srgb, hsl(var(--destructive)) 28%, white);
  --color-error-300: color-mix(in srgb, hsl(var(--destructive)) 40%, white);
  --color-error-400: color-mix(in srgb, hsl(var(--destructive)) 55%, white);
  --color-error-500: hsl(var(--destructive));
  --color-error-700: color-mix(in srgb, hsl(var(--destructive)) 70%, black);

  --color-warning-50: color-mix(in srgb, hsl(var(--accent)) 12%, white);
  --color-warning-100: color-mix(in srgb, hsl(var(--accent)) 18%, white);
  --color-warning-200: color-mix(in srgb, hsl(var(--accent)) 28%, white);
  --color-warning-300: color-mix(in srgb, hsl(var(--accent)) 40%, white);
  --color-warning-400: color-mix(in srgb, hsl(var(--accent)) 55%, white);
  --color-warning-500: hsl(var(--accent));
  --color-warning-700: color-mix(in srgb, hsl(var(--accent)) 70%, black);

  --color-success-50: color-mix(in srgb, hsl(var(--primary)) 12%, white);
  --color-success-100: color-mix(in srgb, hsl(var(--primary)) 18%, white);
  --color-success-200: color-mix(in srgb, hsl(var(--primary)) 28%, white);
  --color-success-300: color-mix(in srgb, hsl(var(--primary)) 40%, white);
  --color-success-400: color-mix(in srgb, hsl(var(--primary)) 55%, white);
  --color-success-500: hsl(var(--primary));
  --color-success-700: color-mix(in srgb, hsl(var(--primary)) 70%, black);

  --color-gray-50: hsl(var(--background));
  --color-gray-100: hsl(var(--card));
  --color-gray-200: hsl(var(--muted));
  --color-gray-300: hsl(var(--border));
  --color-gray-400: color-mix(in srgb, hsl(var(--border)) 65%, hsl(var(--muted-foreground)));
  --color-gray-500: hsl(var(--muted-foreground));
  --color-gray-700: hsl(var(--foreground));

  --color-gray-blue-50: color-mix(in srgb, hsl(var(--primary)) 8%, hsl(var(--background)));
  --color-gray-blue-100: color-mix(in srgb, hsl(var(--primary)) 12%, hsl(var(--card)));
  --color-gray-blue-200: color-mix(in srgb, hsl(var(--primary)) 18%, hsl(var(--card)));
  --color-gray-blue-300: color-mix(in srgb, hsl(var(--primary)) 26%, hsl(var(--card)));
  --color-gray-blue-400: color-mix(in srgb, hsl(var(--primary)) 38%, hsl(var(--card)));
  --color-gray-blue-500: color-mix(in srgb, hsl(var(--primary)) 55%, hsl(var(--card)));
  --color-gray-blue-700: color-mix(in srgb, hsl(var(--primary)) 70%, black);

  --color-blue-light-50: color-mix(in srgb, hsl(var(--primary)) 12%, white);
  --color-blue-light-100: color-mix(in srgb, hsl(var(--primary)) 18%, white);
  --color-blue-light-200: color-mix(in srgb, hsl(var(--primary)) 28%, white);
  --color-blue-light-300: color-mix(in srgb, hsl(var(--primary)) 40%, white);
  --color-blue-light-400: color-mix(in srgb, hsl(var(--primary)) 55%, white);
  --color-blue-light-500: hsl(var(--primary));
  --color-blue-light-700: color-mix(in srgb, hsl(var(--primary)) 70%, black);

  --color-blue-50: color-mix(in srgb, hsl(var(--primary)) 12%, white);
  --color-blue-100: color-mix(in srgb, hsl(var(--primary)) 18%, white);
  --color-blue-200: color-mix(in srgb, hsl(var(--primary)) 28%, white);
  --color-blue-300: color-mix(in srgb, hsl(var(--primary)) 40%, white);
  --color-blue-400: color-mix(in srgb, hsl(var(--primary)) 55%, white);
  --color-blue-500: hsl(var(--primary));
  --color-blue-700: color-mix(in srgb, hsl(var(--primary)) 70%, black);

  --color-indigo-50: color-mix(in srgb, hsl(var(--primary)) 12%, white);
  --color-indigo-100: color-mix(in srgb, hsl(var(--primary)) 18%, white);
  --color-indigo-200: color-mix(in srgb, hsl(var(--primary)) 28%, white);
  --color-indigo-300: color-mix(in srgb, hsl(var(--primary)) 40%, white);
  --color-indigo-400: color-mix(in srgb, hsl(var(--primary)) 55%, white);
  --color-indigo-500: hsl(var(--primary));
  --color-indigo-700: color-mix(in srgb, hsl(var(--primary)) 70%, black);

  --color-purple-50: color-mix(in srgb, hsl(var(--primary)) 12%, white);
  --color-purple-100: color-mix(in srgb, hsl(var(--primary)) 18%, white);
  --color-purple-200: color-mix(in srgb, hsl(var(--primary)) 28%, white);
  --color-purple-300: color-mix(in srgb, hsl(var(--primary)) 40%, white);
  --color-purple-400: color-mix(in srgb, hsl(var(--primary)) 55%, white);
  --color-purple-500: hsl(var(--primary));
  --color-purple-700: color-mix(in srgb, hsl(var(--primary)) 70%, black);

  --color-pink-50: color-mix(in srgb, hsl(var(--destructive)) 12%, white);
  --color-pink-100: color-mix(in srgb, hsl(var(--destructive)) 18%, white);
  --color-pink-200: color-mix(in srgb, hsl(var(--destructive)) 28%, white);
  --color-pink-300: color-mix(in srgb, hsl(var(--destructive)) 40%, white);
  --color-pink-400: color-mix(in srgb, hsl(var(--destructive)) 55%, white);
  --color-pink-500: hsl(var(--destructive));
  --color-pink-700: color-mix(in srgb, hsl(var(--destructive)) 70%, black);

  --color-orange-50: color-mix(in srgb, hsl(var(--destructive)) 12%, white);
  --color-orange-100: color-mix(in srgb, hsl(var(--destructive)) 18%, white);
  --color-orange-200: color-mix(in srgb, hsl(var(--destructive)) 28%, white);
  --color-orange-300: color-mix(in srgb, hsl(var(--destructive)) 40%, white);
  --color-orange-400: color-mix(in srgb, hsl(var(--destructive)) 55%, white);
  --color-orange-500: hsl(var(--destructive));
  --color-orange-700: color-mix(in srgb, hsl(var(--destructive)) 70%, black);

  /* Utility aliases used by Untitled components. */
  --color-utility-brand-50: var(--color-brand-50);
  --color-utility-brand-100: var(--color-brand-100);
  --color-utility-brand-200: var(--color-brand-200);
  --color-utility-brand-300: var(--color-brand-300);
  --color-utility-brand-400: var(--color-brand-400);
  --color-utility-brand-500: var(--color-brand-500);
  --color-utility-brand-700: var(--color-brand-700);

  --color-utility-error-50: var(--color-error-50);
  --color-utility-error-100: var(--color-error-100);
  --color-utility-error-200: var(--color-error-200);
  --color-utility-error-300: var(--color-error-300);
  --color-utility-error-400: var(--color-error-400);
  --color-utility-error-500: var(--color-error-500);
  --color-utility-error-700: var(--color-error-700);

  --color-utility-warning-50: var(--color-warning-50);
  --color-utility-warning-100: var(--color-warning-100);
  --color-utility-warning-200: var(--color-warning-200);
  --color-utility-warning-300: var(--color-warning-300);
  --color-utility-warning-400: var(--color-warning-400);
  --color-utility-warning-500: var(--color-warning-500);
  --color-utility-warning-700: var(--color-warning-700);

  --color-utility-success-50: var(--color-success-50);
  --color-utility-success-100: var(--color-success-100);
  --color-utility-success-200: var(--color-success-200);
  --color-utility-success-300: var(--color-success-300);
  --color-utility-success-400: var(--color-success-400);
  --color-utility-success-500: var(--color-success-500);
  --color-utility-success-700: var(--color-success-700);

  --color-utility-gray-50: var(--color-gray-50);
  --color-utility-gray-100: var(--color-gray-100);
  --color-utility-gray-200: var(--color-gray-200);
  --color-utility-gray-300: var(--color-gray-300);
  --color-utility-gray-400: var(--color-gray-400);
  --color-utility-gray-500: var(--color-gray-500);
  --color-utility-gray-700: var(--color-gray-700);

  --color-utility-gray-blue-50: var(--color-gray-blue-50);
  --color-utility-gray-blue-100: var(--color-gray-blue-100);
  --color-utility-gray-blue-200: var(--color-gray-blue-200);
  --color-utility-gray-blue-300: var(--color-gray-blue-300);
  --color-utility-gray-blue-400: var(--color-gray-blue-400);
  --color-utility-gray-blue-500: var(--color-gray-blue-500);
  --color-utility-gray-blue-700: var(--color-gray-blue-700);

  --color-utility-blue-light-50: var(--color-blue-light-50);
  --color-utility-blue-light-100: var(--color-blue-light-100);
  --color-utility-blue-light-200: var(--color-blue-light-200);
  --color-utility-blue-light-300: var(--color-blue-light-300);
  --color-utility-blue-light-400: var(--color-blue-light-400);
  --color-utility-blue-light-500: var(--color-blue-light-500);
  --color-utility-blue-light-700: var(--color-blue-light-700);

  --color-utility-blue-50: var(--color-blue-50);
  --color-utility-blue-100: var(--color-blue-100);
  --color-utility-blue-200: var(--color-blue-200);
  --color-utility-blue-300: var(--color-blue-300);
  --color-utility-blue-400: var(--color-blue-400);
  --color-utility-blue-500: var(--color-blue-500);
  --color-utility-blue-700: var(--color-blue-700);

  --color-utility-indigo-50: var(--color-indigo-50);
  --color-utility-indigo-100: var(--color-indigo-100);
  --color-utility-indigo-200: var(--color-indigo-200);
  --color-utility-indigo-300: var(--color-indigo-300);
  --color-utility-indigo-400: var(--color-indigo-400);
  --color-utility-indigo-500: var(--color-indigo-500);
  --color-utility-indigo-700: var(--color-indigo-700);

  --color-utility-purple-50: var(--color-purple-50);
  --color-utility-purple-100: var(--color-purple-100);
  --color-utility-purple-200: var(--color-purple-200);
  --color-utility-purple-300: var(--color-purple-300);
  --color-utility-purple-400: var(--color-purple-400);
  --color-utility-purple-500: var(--color-purple-500);
  --color-utility-purple-700: var(--color-purple-700);

  --color-utility-pink-50: var(--color-pink-50);
  --color-utility-pink-100: var(--color-pink-100);
  --color-utility-pink-200: var(--color-pink-200);
  --color-utility-pink-300: var(--color-pink-300);
  --color-utility-pink-400: var(--color-pink-400);
  --color-utility-pink-500: var(--color-pink-500);
  --color-utility-pink-700: var(--color-pink-700);

  --color-utility-orange-50: var(--color-orange-50);
  --color-utility-orange-100: var(--color-orange-100);
  --color-utility-orange-200: var(--color-orange-200);
  --color-utility-orange-300: var(--color-orange-300);
  --color-utility-orange-400: var(--color-orange-400);
  --color-utility-orange-500: var(--color-orange-500);
  --color-utility-orange-700: var(--color-orange-700);
}
````

## File: src/utils/is-react-component.ts
````typescript
/* We cannot use type `unknown` instead of `any` here because it will break the type assertion `isReactComponent` function is providing. */
/* eslint-disable @typescript-eslint/no-explicit-any */
import type React from "react";

type ReactComponent = React.FC<any> | React.ComponentClass<any, any>;
const FORWARD_REF_SYMBOL = Symbol.for("react.forward_ref");

/**
 * Checks if a given value is a function component.
 */
export const isFunctionComponent = (component: any): component is React.FC<any> => {
  return typeof component === "function";
};

/**
 * Checks if a given value is a class component.
 */
export const isClassComponent = (component: any): component is React.ComponentClass<any, any> => {
  return (
    typeof component === "function" &&
    component.prototype &&
    (!!component.prototype.isReactComponent || !!component.prototype.render)
  );
};

/**
 * Checks if a given value is a forward ref component.
 */
export const isForwardRefComponent = (component: any): component is React.ForwardRefExoticComponent<any> => {
  if (typeof component !== "object" || component === null) {
    return false;
  }

  const symbolType = (component as { $$typeof?: unknown }).$$typeof;
  return symbolType === FORWARD_REF_SYMBOL;
};

/**
 * Checks if a given value is a valid React component.
 */
export const isReactComponent = (component: any): component is ReactComponent => {
  return isFunctionComponent(component) || isForwardRefComponent(component) || isClassComponent(component);
};
````

## File: src/components/application/activity-feeds/activity-feeds.tsx
````typescript
import { useState } from "react";
import { Badge } from "@/components/base/badges/badges";
import { BadgeGroup } from "@/components/base/badges/badge-groups";
import { ButtonGroup, ButtonGroupItem } from "@/components/base/button-group/button-group";
import { ButtonUtility } from "@/components/base/buttons/button-utility";
import { Avatar, AvatarFallback } from "@/components/base/primitives/avatar";
import { Card } from "@/components/base/primitives/card";
import { cn } from "@/lib/utils";
import {
  Chat as MessageSquare,
  DotsThreeOutline as MoreHorizontal,
  FileText,
  Paperclip,
  Tag,
  UserPlus,
} from "@phosphor-icons/react";

type FeedMode = "activity" | "messages";
type FeedLayout = "divided" | "connected" | "spaced";
type ActivityTone = "default" | "success" | "warning" | "error" | "info";

interface ActivityEntry {
  id: string;
  actor: string;
  action: string;
  target: string;
  detail: string;
  timestamp: string;
  tone: ActivityTone;
  kind: "file" | "invite" | "comment" | "labels";
}

interface MessageEntry {
  id: string;
  actor: string;
  handle: string;
  message: string;
  timestamp: string;
  attachment?: string;
}

const ACTIVITY_ENTRIES: ActivityEntry[] = [
  {
    id: "activity-1",
    actor: "Phoenix Baker",
    action: "added a file to",
    target: "Marketing site redesign",
    detail: "Tech requirements.pdf • 720 KB",
    timestamp: "Just now",
    tone: "info",
    kind: "file",
  },
  {
    id: "activity-2",
    actor: "Lana Steiner",
    action: "was invited to the team by",
    target: "Alina Hester",
    detail: "Workspace access updated.",
    timestamp: "2 mins ago",
    tone: "success",
    kind: "invite",
  },
  {
    id: "activity-3",
    actor: "Candice Wu",
    action: "commented in",
    target: "Marketing site redesign",
    detail: "Can we simplify the onboarding flow copy?",
    timestamp: "3 hours ago",
    tone: "warning",
    kind: "comment",
  },
  {
    id: "activity-4",
    actor: "Natali Craig",
    action: "added labels to",
    target: "Marketing site redesign",
    detail: "Design, Product, Marketing",
    timestamp: "6 hours ago",
    tone: "default",
    kind: "labels",
  },
];

const MESSAGE_ENTRIES: MessageEntry[] = [
  {
    id: "message-1",
    actor: "Phoenix Baker",
    handle: "@phoenix",
    message: "Looks good!",
    timestamp: "Just now",
  },
  {
    id: "message-2",
    actor: "Lana Steiner",
    handle: "@lana",
    message: "Thanks so much, happy with that.",
    timestamp: "2 mins ago",
  },
  {
    id: "message-3",
    actor: "Orlando Diggs",
    handle: "@orlando",
    message: "Shared the draft for review.",
    timestamp: "3:42pm 20 Jan 2025",
    attachment: "Datasheet_draft_02.pdf • 720 KB",
  },
  {
    id: "message-4",
    actor: "Rene Wells",
    handle: "@rene",
    message: "Hey @olivia, just wanted to say thanks for your help on this.",
    timestamp: "9:24am 20 Jan 2025",
  },
];

function initials(name: string) {
  return name
    .split(" ")
    .slice(0, 2)
    .map((part) => part[0]?.toUpperCase() ?? "")
    .join("");
}

function activityIcon(kind: ActivityEntry["kind"]) {
  if (kind === "file") return FileText;
  if (kind === "invite") return UserPlus;
  if (kind === "labels") return Tag;
  return MessageSquare;
}

function activityLabel(kind: ActivityEntry["kind"]) {
  if (kind === "file") return "File";
  if (kind === "invite") return "Invite";
  if (kind === "labels") return "Labels";
  return "Comment";
}

export function ActivityFeedsBlock() {
  const [mode, setMode] = useState<FeedMode>("activity");
  const [layout, setLayout] = useState<FeedLayout>("divided");

  const isActivityMode = mode === "activity";
  const activityEntries = isActivityMode ? ACTIVITY_ENTRIES : [];
  const messageEntries = isActivityMode ? [] : MESSAGE_ENTRIES;
  const entryCount = isActivityMode ? activityEntries.length : messageEntries.length;

  return (
    <Card className="overflow-hidden border-border/80 bg-card/90">
      <div className="flex flex-wrap items-center justify-between gap-3 border-b border-border/70 px-4 py-3 sm:px-5">
        <div className="space-y-1">
          <h3 className="text-sm font-semibold text-foreground">Activity Feeds</h3>
          <BadgeGroup addonText={`${entryCount} items`}>
            {mode === "activity" ? "Activity feed" : "Messages feed"}
          </BadgeGroup>
        </div>

        <div className="flex flex-wrap items-center gap-2">
          <ButtonGroup
            size="sm"
            value={mode}
            onValueChange={(value) => value && setMode(value as FeedMode)}
            aria-label="Feed mode"
          >
            <ButtonGroupItem value="activity" size="sm">
              Activity
            </ButtonGroupItem>
            <ButtonGroupItem value="messages" size="sm">
              Messages
            </ButtonGroupItem>
          </ButtonGroup>

          <ButtonGroup
            size="sm"
            value={layout}
            onValueChange={(value) => value && setLayout(value as FeedLayout)}
            aria-label="Feed layout"
          >
            <ButtonGroupItem value="divided" size="sm">
              Divided
            </ButtonGroupItem>
            <ButtonGroupItem value="connected" size="sm">
              Connected
            </ButtonGroupItem>
            <ButtonGroupItem value="spaced" size="sm">
              Spaced
            </ButtonGroupItem>
          </ButtonGroup>
        </div>
      </div>

      <ul
        role="list"
        className={cn(
          "relative",
          layout === "divided" && "divide-y divide-border/70",
          layout === "connected" && "before:absolute before:bottom-4 before:left-[2.1rem] before:top-4 before:w-px before:bg-border/70",
          layout === "spaced" && "space-y-3 p-3 sm:p-4",
        )}
      >
        {isActivityMode
          ? activityEntries.map((entry) => {
              const Icon = activityIcon(entry.kind);
              return (
                <li
                  key={entry.id}
                  className={cn(
                    "relative flex gap-3 px-4 py-4 sm:px-5",
                    layout === "spaced" && "rounded-lg border border-border/70 bg-background px-3 py-3.5 sm:px-4",
                  )}
                >
                  {layout === "connected" && (
                    <span
                      aria-hidden="true"
                      className="absolute left-[2.1rem] top-7 z-10 h-2.5 w-2.5 -translate-x-1/2 rounded-full border border-border bg-background"
                    />
                  )}

                  <Avatar className="h-9 w-9 border border-border/70">
                    <AvatarFallback className="bg-muted text-xs font-semibold text-muted-foreground">
                      {initials(entry.actor)}
                    </AvatarFallback>
                  </Avatar>

                  <div className="min-w-0 flex-1">
                    <p className="text-sm text-foreground">
                      <span className="font-semibold">{entry.actor}</span>{" "}
                      <span className="text-muted-foreground">{entry.action}</span>{" "}
                      <span className="font-medium">{entry.target}</span>
                    </p>
                    <p className="mt-1 text-sm text-muted-foreground">{entry.detail}</p>
                    <div className="mt-2 flex items-center gap-2">
                      <Badge tone={entry.tone} size="sm">
                        {activityLabel(entry.kind)}
                      </Badge>
                      <span className="inline-flex items-center gap-1 text-xs text-muted-foreground">
                        <Icon className="h-3.5 w-3.5" />
                        {entry.timestamp}
                      </span>
                    </div>
                  </div>

                  <ButtonUtility
                    icon={MoreHorizontal}
                    size="xs"
                    color="tertiary"
                    tooltip="More actions"
                    aria-label={`Actions for ${entry.target}`}
                  />
                </li>
              );
            })
          : messageEntries.map((entry) => (
              <li
                key={entry.id}
                className={cn(
                  "relative flex gap-3 px-4 py-4 sm:px-5",
                  layout === "spaced" && "rounded-lg border border-border/70 bg-background px-3 py-3.5 sm:px-4",
                )}
              >
                {layout === "connected" && (
                  <span
                    aria-hidden="true"
                    className="absolute left-[2.1rem] top-7 z-10 h-2.5 w-2.5 -translate-x-1/2 rounded-full border border-border bg-background"
                  />
                )}

                <Avatar className="h-9 w-9 border border-border/70">
                  <AvatarFallback className="bg-muted text-xs font-semibold text-muted-foreground">
                    {initials(entry.actor)}
                  </AvatarFallback>
                </Avatar>

                <div className="min-w-0 flex-1">
                  <p className="text-sm text-foreground">
                    <span className="font-semibold">{entry.actor}</span>{" "}
                    <span className="text-muted-foreground">{entry.handle}</span>
                  </p>
                  <p className="mt-1 text-sm text-foreground">{entry.message}</p>

                  {entry.attachment ? (
                    <div className="mt-2 inline-flex items-center gap-1.5 rounded-md border border-border/70 bg-muted/40 px-2 py-1 text-xs text-muted-foreground">
                      <Paperclip className="h-3.5 w-3.5" />
                      {entry.attachment}
                    </div>
                  ) : null}
                </div>

                <div className="flex shrink-0 items-start gap-2">
                  <span className="mt-1 text-xs text-muted-foreground">{entry.timestamp}</span>
                  <ButtonUtility
                    icon={MoreHorizontal}
                    size="xs"
                    color="tertiary"
                    tooltip="More actions"
                    aria-label={`Actions for message by ${entry.actor}`}
                  />
                </div>
              </li>
            ))}
      </ul>
    </Card>
  );
}
````

## File: src/components/application/lists/feed-list.tsx
````typescript
import { useMemo, useState } from "react";
import { Badge } from "@/components/base/badges/badges";
import { BadgeGroup } from "@/components/base/badges/badge-groups";
import { ButtonGroup, ButtonGroupItem } from "@/components/base/button-group/button-group";
import { ButtonUtility } from "@/components/base/buttons/button-utility";
import { Avatar, AvatarFallback } from "@/components/base/primitives/avatar";
import { Card } from "@/components/base/primitives/card";
import { cn } from "@/lib/utils";
import {
  Bell,
  Chat as MessageSquare,
  DotsThreeOutline as MoreHorizontal,
  GitPullRequest,
  Heart,
  Rocket,
} from "@phosphor-icons/react";

type FeedFilter = "all" | "mentions" | "deployments";

interface FeedItem {
  id: string;
  type: FeedFilter;
  actor: string;
  action: string;
  target: string;
  summary: string;
  timestamp: string;
  tone: "default" | "success" | "warning" | "error" | "info";
}

const FEED_ITEMS: FeedItem[] = [
  {
    id: "1",
    type: "deployments",
    actor: "Ava Chen",
    action: "deployed",
    target: "Community Feed v2",
    summary: "Production rollout completed with no errors.",
    timestamp: "2m ago",
    tone: "success",
  },
  {
    id: "2",
    type: "mentions",
    actor: "Mika Rivera",
    action: "mentioned you in",
    target: "Prompt quality follow-up",
    summary: "Can you review the suggested prompt scoring rules?",
    timestamp: "14m ago",
    tone: "info",
  },
  {
    id: "3",
    type: "all",
    actor: "Jordan Wu",
    action: "opened",
    target: "PR #482",
    summary: "Refactor community voting aggregation and tests.",
    timestamp: "33m ago",
    tone: "warning",
  },
  {
    id: "4",
    type: "all",
    actor: "Sara Kim",
    action: "reacted to",
    target: "Feed fallback copy",
    summary: "Left positive feedback on the empty-state text.",
    timestamp: "1h ago",
    tone: "default",
  },
];

function itemIcon(type: FeedFilter) {
  if (type === "mentions") {
    return MessageSquare;
  }

  if (type === "deployments") {
    return Rocket;
  }

  return Bell;
}

function itemInitials(actor: string) {
  return actor
    .split(" ")
    .slice(0, 2)
    .map((part) => part[0]?.toUpperCase() ?? "")
    .join("");
}

function toneLabel(tone: FeedItem["tone"]) {
  if (tone === "success") return "Healthy";
  if (tone === "warning") return "Needs review";
  if (tone === "error") return "Blocked";
  if (tone === "info") return "Update";
  return "Note";
}

export function FeedListBlock() {
  const [filter, setFilter] = useState<FeedFilter>("all");

  const visibleItems = useMemo(() => {
    if (filter === "all") {
      return FEED_ITEMS;
    }

    return FEED_ITEMS.filter((item) => item.type === filter);
  }, [filter]);

  return (
    <Card className="overflow-hidden border-border/80 bg-card/90">
      <div className="flex flex-wrap items-center justify-between gap-3 border-b border-border/70 px-4 py-3 sm:px-5">
        <div className="space-y-1">
          <h3 className="text-sm font-semibold text-foreground">Activity Feed</h3>
          <BadgeGroup addonText={`${visibleItems.length} items`}>Last 24 hours</BadgeGroup>
        </div>
        <ButtonGroup value={filter} onValueChange={(value) => value && setFilter(value as FeedFilter)} aria-label="Feed filter">
          <ButtonGroupItem value="all">All</ButtonGroupItem>
          <ButtonGroupItem value="mentions">Mentions</ButtonGroupItem>
          <ButtonGroupItem value="deployments" iconLeading={GitPullRequest}>
            Deployments
          </ButtonGroupItem>
        </ButtonGroup>
      </div>

      <ul role="list" className="divide-y divide-border/70">
        {visibleItems.map((item) => {
          const Icon = itemIcon(item.type);
          return (
            <li key={item.id} className="flex gap-3 px-4 py-4 sm:px-5">
              <Avatar className="h-9 w-9 border border-border/70">
                <AvatarFallback className="bg-muted text-xs font-semibold text-muted-foreground">
                  {itemInitials(item.actor)}
                </AvatarFallback>
              </Avatar>

              <div className="min-w-0 flex-1">
                <p className="text-sm text-foreground">
                  <span className="font-semibold">{item.actor}</span>{" "}
                  <span className="text-muted-foreground">{item.action}</span>{" "}
                  <span className="font-medium text-foreground">{item.target}</span>
                </p>
                <p className="mt-1 text-sm text-muted-foreground">{item.summary}</p>
                <div className="mt-2 flex items-center gap-2">
                  <Badge tone={item.tone} size="sm">
                    {toneLabel(item.tone)}
                  </Badge>
                  <span className="inline-flex items-center gap-1 text-xs text-muted-foreground">
                    <Icon className="h-3.5 w-3.5" />
                    {item.type === "mentions" ? "Mention" : item.type === "deployments" ? "Deployment" : "Notification"}
                  </span>
                </div>
              </div>

              <div className={cn("flex shrink-0 items-start gap-2", "text-xs text-muted-foreground")}>
                <span className="mt-1">{item.timestamp}</span>
                <ButtonUtility
                  icon={MoreHorizontal}
                  size="xs"
                  color="tertiary"
                  tooltip="More actions"
                  aria-label={`Actions for ${item.target}`}
                />
                <ButtonUtility icon={Heart} size="xs" color="tertiary" tooltip="Save" aria-label={`Save ${item.target}`} />
              </div>
            </li>
          );
        })}
      </ul>
    </Card>
  );
}
````

## File: src/components/base/avatar/base-components/avatar-add-button.tsx
````typescript
import type { ButtonProps as AriaButtonProps } from "react-aria-components";
import { Tooltip as AriaTooltip, TooltipTrigger as AriaTooltipTrigger } from "@/components/base/tooltip/tooltip";
import { cx } from "@/lib/utils/cx";
import { Plus } from "@phosphor-icons/react";

const sizes = {
    xs: { root: "size-6", icon: "size-4" },
    sm: { root: "size-8", icon: "size-4" },
    md: { root: "size-10", icon: "size-5" },
};

interface AvatarAddButtonProps extends AriaButtonProps {
    size: "xs" | "sm" | "md";
    title?: string;
    className?: string;
}

export const AvatarAddButton = ({ size, className, title = "Add user", ...props }: AvatarAddButtonProps) => (
    <AriaTooltip title={title}>
        <AriaTooltipTrigger
            {...props}
            aria-label={title}
            className={cx(
                "flex cursor-pointer items-center justify-center rounded-full border border-dashed border-primary bg-primary text-fg-quaternary outline-focus-ring transition duration-100 ease-linear hover:bg-primary_hover hover:text-fg-quaternary_hover focus-visible:outline-2 focus-visible:outline-offset-2 disabled:border-disabled disabled:bg-disabled disabled:text-disabled",
                sizes[size].root,
                className,
            )}
        >
            <Plus className={cx("text-current transition-inherit-all", sizes[size].icon)} />
        </AriaTooltipTrigger>
    </AriaTooltip>
);
````

## File: src/components/base/avatar/avatar-profile-photo.tsx
````typescript
import { useState } from "react";
import { cx } from "@/lib/utils/cx";
import { renderIconSlot } from "@/lib/utils/icon-slot";
import { type AvatarProps } from "./avatar";
import { AvatarOnlineIndicator, VerifiedTick } from "./base-components";
import { User as User01 } from "@phosphor-icons/react";

const styles = {
    sm: {
        root: "size-18 p-0.75",
        rootWithPlaceholder: "p-1",
        content: "",
        icon: "size-9",
        initials: "text-display-sm font-semibold",
        badge: "bottom-0.5 right-0.5",
    },
    md: {
        root: "size-24 p-1",
        rootWithPlaceholder: "p-1.25",
        content: "shadow-xl",
        icon: "size-12",
        initials: "text-display-md font-semibold",
        badge: "bottom-1 right-1",
    },
    lg: {
        root: "size-40 p-1.5",
        rootWithPlaceholder: "p-1.75",
        content: "shadow-2xl",
        icon: "size-20",
        initials: "text-display-xl font-semibold",
        badge: "bottom-2 right-2",
    },
};

const tickSizeMap = {
    sm: "2xl",
    md: "3xl",
    lg: "4xl",
} as const;

interface AvatarProfilePhotoProps extends AvatarProps {
    size: "sm" | "md" | "lg";
}

export const AvatarProfilePhoto = ({
    contrastBorder = true,
    size = "md",
    src,
    alt,
    initials,
    placeholder,
    placeholderIcon: PlaceholderIcon,
    verified,
    badge,
    status,
    className,
}: AvatarProfilePhotoProps) => {
    const [isFailed, setIsFailed] = useState(false);

    const renderMainContent = () => {
        if (src && !isFailed) {
            return (
                <img
                    src={src}
                    alt={alt}
                    onError={() => setIsFailed(true)}
                    className={cx(
                        "size-full rounded-full object-cover",
                        contrastBorder && "outline-1 -outline-offset-1 outline-avatar-contrast-border",
                        styles[size].content,
                    )}
                />
            );
        }

        if (initials) {
            return (
                <div className={cx("flex size-full items-center justify-center rounded-full bg-tertiary ring-1 ring-secondary_alt", styles[size].content)}>
                    <span className={cx("text-quaternary", styles[size].initials)}>{initials}</span>
                </div>
            );
        }

        if (PlaceholderIcon) {
            return (
                <div className={cx("flex size-full items-center justify-center rounded-full bg-tertiary ring-1 ring-secondary_alt", styles[size].content)}>
                    {renderIconSlot(PlaceholderIcon, { className: cx("text-fg-quaternary", styles[size].icon) })}
                </div>
            );
        }

        return (
            <div className={cx("flex size-full items-center justify-center rounded-full bg-tertiary ring-1 ring-secondary_alt", styles[size].content)}>
                {placeholder || <User01 className={cx("text-fg-quaternary", styles[size].icon)} />}
            </div>
        );
    };

    const renderBadgeContent = () => {
        if (status) {
            return <AvatarOnlineIndicator status={status} size={tickSizeMap[size]} className={styles[size].badge} />;
        }

        if (verified) {
            return <VerifiedTick size={tickSizeMap[size]} className={cx("absolute", styles[size].badge)} />;
        }

        return badge;
    };

    return (
        <div
            className={cx(
                "relative flex shrink-0 items-center justify-center rounded-full bg-primary ring-1 ring-secondary_alt",
                styles[size].root,
                (!src || isFailed) && styles[size].rootWithPlaceholder,
                className,
            )}
        >
            {renderMainContent()}
            {renderBadgeContent()}
        </div>
    );
};
````

## File: src/components/base/avatar/avatar.tsx
````typescript
import { type ReactNode, useState } from "react";
import { cx } from "@/lib/utils/cx";
import { renderIconSlot, type IconSlot } from "@/lib/utils/icon-slot";
import { AvatarOnlineIndicator, VerifiedTick } from "./base-components";
import { User as User01 } from "@phosphor-icons/react";

type AvatarSize = "xxs" | "xs" | "sm" | "md" | "lg" | "xl" | "2xl";

export interface AvatarProps {
    size?: AvatarSize;
    className?: string;
    src?: string | null;
    alt?: string;
    /**
     * Display a contrast border around the avatar.
     */
    contrastBorder?: boolean;
    /**
     * Display a badge (i.e. company logo).
     */
    badge?: ReactNode;
    /**
     * Display a status indicator.
     */
    status?: "online" | "offline";
    /**
     * Display a verified tick icon.
     *
     * @default false
     */
    verified?: boolean;

    /**
     * The initials of the user to display if no image is available.
     */
    initials?: string;
    /**
     * An icon to display if no image is available.
     */
    placeholderIcon?: IconSlot<{ className?: string }>;
    /**
     * A placeholder to display if no image is available.
     */
    placeholder?: ReactNode;

    /**
     * Whether the avatar should show a focus ring when the parent group is in focus.
     * For example, when the avatar is wrapped inside a link.
     *
     * @default false
     */
    focusable?: boolean;
}

const styles = {
    xxs: { root: "size-4 outline-[0.5px] -outline-offset-[0.5px]", initials: "text-xs font-semibold", icon: "size-3" },
    xs: { root: "size-6 outline-[0.5px] -outline-offset-[0.5px]", initials: "text-xs font-semibold", icon: "size-4" },
    sm: { root: "size-8 outline-[0.75px] -outline-offset-[0.75px]", initials: "text-sm font-semibold", icon: "size-5" },
    md: { root: "size-10 outline-1 -outline-offset-1", initials: "text-md font-semibold", icon: "size-6" },
    lg: { root: "size-12 outline-1 -outline-offset-1", initials: "text-lg font-semibold", icon: "size-7" },
    xl: { root: "size-14 outline-1 -outline-offset-1", initials: "text-xl font-semibold", icon: "size-8" },
    "2xl": { root: "size-16 outline-1 -outline-offset-1", initials: "text-display-xs font-semibold", icon: "size-8" },
};

export const Avatar = ({
    contrastBorder = true,
    size = "md",
    src,
    alt,
    initials,
    placeholder,
    placeholderIcon: PlaceholderIcon,
    badge,
    status,
    verified,
    focusable = false,
    className,
}: AvatarProps) => {
    const [isFailed, setIsFailed] = useState(false);

    const renderMainContent = () => {
        if (src && !isFailed) {
            return <img data-avatar-img className="size-full rounded-full object-cover" src={src} alt={alt} onError={() => setIsFailed(true)} />;
        }

        if (initials) {
            return <span className={cx("text-quaternary", styles[size].initials)}>{initials}</span>;
        }

        if (PlaceholderIcon) {
            return renderIconSlot(PlaceholderIcon, { className: cx("text-fg-quaternary", styles[size].icon) });
        }

        return placeholder || <User01 className={cx("text-fg-quaternary", styles[size].icon)} />;
    };

    const renderBadgeContent = () => {
        if (status) {
            return <AvatarOnlineIndicator status={status} size={size === "xxs" ? "xs" : size} />;
        }

        if (verified) {
            return (
                <VerifiedTick
                    size={size === "xxs" ? "xs" : size}
                    className={cx("absolute right-0 bottom-0", (size === "xxs" || size === "xs") && "-right-px -bottom-px")}
                />
            );
        }

        return badge;
    };

    return (
        <div
            data-avatar
            className={cx(
                "relative inline-flex shrink-0 items-center justify-center rounded-full bg-avatar-bg outline-transparent",
                // Focus styles
                focusable && "group-outline-focus-ring group-focus-visible:outline-2 group-focus-visible:outline-offset-2",
                contrastBorder && "outline outline-avatar-contrast-border",
                styles[size].root,
                className,
            )}
        >
            {renderMainContent()}
            {renderBadgeContent()}
        </div>
    );
};
````

## File: src/components/base/badges/badge-groups.tsx
````typescript
import type { ReactNode } from "react";
import { cn } from "@/lib/utils";
import { renderIconSlot, type IconSlot } from "@/lib/utils/icon-slot";
import { Badge } from "./badges";
import type { BadgeTone } from "./badge-types";
import { ArrowRight } from "@phosphor-icons/react";

interface BadgeGroupProps {
  addonText: string;
  children?: ReactNode;
  tone?: BadgeTone;
  iconTrailing?: IconSlot<{ className?: string }>;
  className?: string;
}

export const BadgeGroup = ({
  addonText,
  children,
  tone = "default",
  iconTrailing: IconTrailing = ArrowRight,
  className,
}: BadgeGroupProps) => {
  return (
    <span
      className={cn(
        "inline-flex items-center gap-1 rounded-full border border-border bg-card px-1 py-1 text-xs font-medium text-foreground",
        className,
      )}
    >
      <Badge tone={tone} size="sm" className="border-transparent">
        {addonText}
      </Badge>
      {children ? <span className="pr-1">{children}</span> : null}
      {renderIconSlot(IconTrailing, { className: "mr-1 h-3.5 w-3.5 text-muted-foreground" })}
    </span>
  );
};
````

## File: src/components/base/button-group/button-group.tsx
````typescript
import type { ReactNode } from "react";
import * as ToggleGroupPrimitive from "@radix-ui/react-toggle-group";
import { cn } from "@/lib/utils";
import { renderIconSlot, type IconSlot } from "@/lib/utils/icon-slot";

type ButtonGroupSize = "sm" | "md" | "lg";

const sizeStyles: Record<ButtonGroupSize, string> = {
  sm: "h-8 px-3 text-xs",
  md: "h-9 px-3.5 text-sm",
  lg: "h-10 px-4 text-sm",
};

const iconStyles: Record<ButtonGroupSize, string> = {
  sm: "h-4 w-4",
  md: "h-4.5 w-4.5",
  lg: "h-5 w-5",
};

interface ButtonGroupProps extends Omit<ToggleGroupPrimitive.ToggleGroupSingleProps, "type"> {
  size?: ButtonGroupSize;
  className?: string;
}

interface ButtonGroupItemProps extends ToggleGroupPrimitive.ToggleGroupItemProps {
  size?: ButtonGroupSize;
  iconLeading?: IconSlot<{ className?: string }>;
  iconTrailing?: IconSlot<{ className?: string }>;
}

export const ButtonGroup = ({ className, children, size = "md", ...props }: ButtonGroupProps) => {
  return (
    <ToggleGroupPrimitive.Root
      {...props}
      type="single"
      className={cn("inline-flex items-center rounded-md border border-border bg-card p-1", className)}
      data-size={size}
    >
      {children}
    </ToggleGroupPrimitive.Root>
  );
};

export const ButtonGroupItem = ({
  className,
  children,
  iconLeading: IconLeading,
  iconTrailing: IconTrailing,
  size = "md",
  ...props
}: ButtonGroupItemProps) => {
  return (
    <ToggleGroupPrimitive.Item
      className={cn(
        "inline-flex items-center justify-center gap-1.5 rounded-sm font-medium text-muted-foreground transition-colors outline-none hover:bg-muted hover:text-foreground focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 data-[state=on]:bg-background data-[state=on]:text-foreground",
        sizeStyles[size],
        className,
      )}
      {...props}
    >
      {renderIconSlot(IconLeading, { className: iconStyles[size] })}
      {children}
      {renderIconSlot(IconTrailing, { className: iconStyles[size] })}
    </ToggleGroupPrimitive.Item>
  );
};
````

## File: src/components/base/buttons/button-utility.tsx
````typescript
import type { AnchorHTMLAttributes, ButtonHTMLAttributes } from "react";
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/base/primitives/tooltip";
import { cn } from "@/lib/utils";
import { renderIconSlot, type IconSlot } from "@/lib/utils/icon-slot";

type UtilityButtonColor = "secondary" | "tertiary";
type UtilityButtonSize = "xs" | "sm";

interface CommonProps {
  isDisabled?: boolean;
  size?: UtilityButtonSize;
  color?: UtilityButtonColor;
  icon?: IconSlot<{ className?: string }>;
  tooltip?: string;
  tooltipPlacement?: "top" | "right" | "bottom" | "left";
}

interface UtilityButtonAsButton extends CommonProps, Omit<ButtonHTMLAttributes<HTMLButtonElement>, "color"> {
  href?: never;
}

interface UtilityButtonAsLink extends CommonProps, Omit<AnchorHTMLAttributes<HTMLAnchorElement>, "color"> {
  href: string;
}

export type ButtonUtilityProps = UtilityButtonAsButton | UtilityButtonAsLink;

const colorStyles: Record<UtilityButtonColor, string> = {
  secondary: "border border-border bg-card text-foreground shadow-sm hover:bg-muted",
  tertiary: "text-muted-foreground hover:bg-muted hover:text-foreground",
};

const sizeStyles: Record<UtilityButtonSize, string> = {
  xs: "h-8 w-8",
  sm: "h-9 w-9",
};

const iconStyles: Record<UtilityButtonSize, string> = {
  xs: "h-4 w-4",
  sm: "h-5 w-5",
};

export const ButtonUtility = ({
  icon: Icon,
  size = "sm",
  color = "secondary",
  tooltip,
  tooltipPlacement = "top",
  isDisabled,
  className,
  ...props
}: ButtonUtilityProps) => {
  const content = renderIconSlot(Icon, { className: iconStyles[size] });

  const sharedClassName = cn(
    "inline-flex items-center justify-center rounded-md transition-colors outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50",
    sizeStyles[size],
    colorStyles[color],
    className,
  );

  const element =
    "href" in props && props.href ? (
      <a
        {...props}
        aria-disabled={isDisabled}
        onClick={(event) => {
          if (isDisabled) {
            event.preventDefault();
          }
          props.onClick?.(event);
        }}
        className={sharedClassName}
      >
        {content}
      </a>
    ) : (
      <button
        {...props}
        type={props.type ?? "button"}
        disabled={isDisabled}
        className={sharedClassName}
      >
        {content}
      </button>
    );

  if (!tooltip) {
    return element;
  }

  return (
    <TooltipProvider>
      <Tooltip>
        <TooltipTrigger asChild>{element}</TooltipTrigger>
        <TooltipContent side={tooltipPlacement}>{tooltip}</TooltipContent>
      </Tooltip>
    </TooltipProvider>
  );
};
````

## File: src/components/base/select/combobox.tsx
````typescript
import type { FocusEventHandler, PointerEventHandler, RefAttributes, RefObject } from "react";
import { useCallback, useContext, useRef, useState } from "react";
import type { ComboBoxProps as AriaComboBoxProps, GroupProps as AriaGroupProps, ListBoxProps as AriaListBoxProps } from "react-aria-components";
import { ComboBox as AriaComboBox, Group as AriaGroup, Input as AriaInput, ListBox as AriaListBox, ComboBoxStateContext } from "react-aria-components";
import { HintText } from "@/components/base/input/hint-text";
import { Label } from "@/components/base/input/label";
import { Popover } from "@/components/base/select/popover";
import { type CommonProps, SelectContext, type SelectItemType, sizes } from "@/components/base/select/select";
import { useResizeObserver } from "@/hooks/use-resize-observer";
import { cx } from "@/lib/utils/cx";
import { MagnifyingGlass as SearchIcon } from "@phosphor-icons/react";

interface ComboBoxProps extends Omit<AriaComboBoxProps<SelectItemType>, "children" | "items">, RefAttributes<HTMLDivElement>, CommonProps {
    shortcut?: boolean;
    items?: SelectItemType[];
    popoverClassName?: string;
    shortcutClassName?: string;
    children: AriaListBoxProps<SelectItemType>["children"];
}

interface ComboBoxValueProps extends AriaGroupProps {
    size: "sm" | "md";
    shortcut: boolean;
    placeholder?: string;
    shortcutClassName?: string;
    onFocus?: FocusEventHandler;
    onPointerEnter?: PointerEventHandler;
    ref?: RefObject<HTMLDivElement | null>;
}

const ComboBoxValue = ({ size, shortcut, placeholder, shortcutClassName, ...otherProps }: ComboBoxValueProps) => {
    const state = useContext(ComboBoxStateContext);

    const value = state?.selectedItem?.value || null;
    const inputValue = state?.inputValue || null;

    const first = inputValue?.split(value?.supportingText)?.[0] || "";
    const last = inputValue?.split(first)[1];

    return (
        <AriaGroup
            {...otherProps}
            className={({ isFocusWithin, isDisabled }) =>
                cx(
                    "relative flex w-full items-center gap-2 rounded-lg bg-background shadow-xs ring-1 ring-border outline-hidden transition-shadow duration-100 ease-linear ring-inset",
                    isDisabled && "cursor-not-allowed bg-disabled_subtle",
                    isFocusWithin && "ring-2 ring-brand",
                    sizes[size].root,
                )
            }
        >
            {({ isDisabled }) => (
                <>
                    <SearchIcon className="pointer-events-none size-5 shrink-0 text-fg-quaternary" />

                    <div className="relative flex w-full items-center gap-2">
                        {inputValue && (
                            <span className="absolute top-1/2 z-0 inline-flex w-full -translate-y-1/2 gap-2 truncate" aria-hidden="true">
                                <p className={cx("text-md font-medium text-foreground", isDisabled && "text-disabled")}>{first}</p>
                                {last && <p className={cx("-ml-0.75 text-md text-tertiary", isDisabled && "text-disabled")}>{last}</p>}
                            </span>
                        )}

                        <AriaInput
                            placeholder={placeholder}
                            className="z-10 w-full appearance-none bg-transparent text-md text-transparent caret-foreground placeholder:text-placeholder focus:outline-hidden disabled:cursor-not-allowed disabled:text-disabled disabled:placeholder:text-disabled"
                        />
                    </div>

                    {shortcut && (
                        <div
                            className={cx(
                                "absolute inset-y-0.5 right-0.5 z-10 flex items-center rounded-r-[inherit] bg-linear-to-r from-transparent to-background to-40% pl-8",
                                isDisabled && "to-bg-disabled_subtle",
                                sizes[size].shortcut,
                                shortcutClassName,
                            )}
                        >
                            <span
                                className={cx(
                                    "pointer-events-none rounded px-1 py-px text-xs font-medium text-quaternary ring-1 ring-secondary select-none ring-inset",
                                    isDisabled && "bg-transparent text-disabled",
                                )}
                                aria-hidden="true"
                            >
                                ⌘K
                            </span>
                        </div>
                    )}
                </>
            )}
        </AriaGroup>
    );
};

export const ComboBox = ({ placeholder = "Search", shortcut = true, size = "sm", children, items, shortcutClassName, ...otherProps }: ComboBoxProps) => {
    const placeholderRef = useRef<HTMLDivElement>(null);
    const [popoverWidth, setPopoverWidth] = useState("");

    // Resize observer for popover width
    const onResize = useCallback(() => {
        if (!placeholderRef.current) return;

        const divRect = placeholderRef.current?.getBoundingClientRect();

        setPopoverWidth(divRect.width + "px");
    }, [placeholderRef, setPopoverWidth]);

    useResizeObserver({
        ref: placeholderRef,
        box: "border-box",
        onResize,
    });

    return (
        <SelectContext.Provider value={{ size }}>
            <AriaComboBox menuTrigger="focus" {...otherProps}>
                {(state) => (
                    <div className="flex flex-col gap-1.5">
                        {otherProps.label && (
                            <Label isRequired={state.isRequired} tooltip={otherProps.tooltip}>
                                {otherProps.label}
                            </Label>
                        )}

                        <ComboBoxValue
                            ref={placeholderRef}
                            placeholder={placeholder}
                            shortcut={shortcut}
                            shortcutClassName={shortcutClassName}
                            size={size}
                            // This is a workaround to correctly calculating the trigger width
                            // while using ResizeObserver wasn't 100% reliable.
                            onFocus={onResize}
                            onPointerEnter={onResize}
                        />

                        <Popover size={size} triggerRef={placeholderRef} style={{ width: popoverWidth }} className={otherProps.popoverClassName}>
                            <AriaListBox items={items} className="size-full outline-hidden">
                                {children}
                            </AriaListBox>
                        </Popover>

                        {otherProps.hint && <HintText isInvalid={state.isInvalid}>{otherProps.hint}</HintText>}
                    </div>
                )}
            </AriaComboBox>
        </SelectContext.Provider>
    );
};
````

## File: src/components/base/select/select-item.tsx
````typescript
import { useContext } from "react";
import type { ListBoxItemProps as AriaListBoxItemProps } from "react-aria-components";
import { ListBoxItem as AriaListBoxItem, Text as AriaText } from "react-aria-components";
import { Avatar } from "@/components/base/avatar/avatar";
import { cx } from "@/lib/utils/cx";
import { renderIconSlot } from "@/lib/utils/icon-slot";
import type { SelectItemType } from "./select";
import { SelectContext } from "./select";
import { Check } from "@phosphor-icons/react";

const sizes = {
    sm: "p-2 pr-2.5",
    md: "p-2.5 pl-2",
};

interface SelectItemProps extends Omit<AriaListBoxItemProps<SelectItemType>, "id">, SelectItemType {}

export const SelectItem = ({ label, id, value, avatarUrl, supportingText, isDisabled, icon: Icon, className, children, ...props }: SelectItemProps) => {
    const { size } = useContext(SelectContext);

    const labelOrChildren = label || (typeof children === "string" ? children : "");
    const textValue = supportingText ? labelOrChildren + " " + supportingText : labelOrChildren;

    return (
        <AriaListBoxItem
            id={id}
            value={
                value ?? {
                    id,
                    label: labelOrChildren,
                    avatarUrl,
                    supportingText,
                    isDisabled,
                    icon: Icon,
                }
            }
            textValue={textValue}
            isDisabled={isDisabled}
            {...props}
            className={(state) => cx("w-full px-1.5 py-px outline-hidden", typeof className === "function" ? className(state) : className)}
        >
            {(state) => (
                <div
                    className={cx(
                        "flex cursor-pointer items-center gap-2 rounded-md outline-hidden select-none",
                        state.isSelected && "bg-active",
                        state.isDisabled && "cursor-not-allowed",
                        state.isFocused && "bg-primary_hover",
                        state.isFocusVisible && "ring-2 ring-focus-ring ring-inset",

                        // Icon styles
                        "*:data-icon:size-5 *:data-icon:shrink-0 *:data-icon:text-fg-quaternary",
                        state.isDisabled && "*:data-icon:text-fg-disabled",

                        sizes[size],
                    )}
                >
                    {avatarUrl ? (
                        <Avatar aria-hidden="true" size="xs" src={avatarUrl} alt={label} />
                    ) : (
                        renderIconSlot(Icon, { "data-icon": true, "aria-hidden": true })
                    )}

                    <div className="flex w-full min-w-0 flex-1 flex-wrap gap-x-2">
                        <AriaText
                            slot="label"
                            className={cx("truncate text-md font-medium whitespace-nowrap text-primary", state.isDisabled && "text-disabled")}
                        >
                            {label || (typeof children === "function" ? children(state) : children)}
                        </AriaText>

                        {supportingText && (
                            <AriaText slot="description" className={cx("text-md whitespace-nowrap text-tertiary", state.isDisabled && "text-disabled")}>
                                {supportingText}
                            </AriaText>
                        )}
                    </div>

                    {state.isSelected && (
                        <Check
                            aria-hidden="true"
                            className={cx(
                                "ml-auto text-fg-brand-primary",
                                size === "sm" ? "size-4 stroke-[2.5px]" : "size-5",
                                state.isDisabled && "text-fg-disabled",
                            )}
                        />
                    )}
                </div>
            )}
        </AriaListBoxItem>
    );
};
````

## File: src/components/base/select/select-native.tsx
````typescript
import { type SelectHTMLAttributes, useId } from "react";
import { HintText } from "@/components/base/input/hint-text";
import { Label } from "@/components/base/input/label";
import { cx } from "@/lib/utils/cx";
import { CaretDown as ChevronDown } from "@phosphor-icons/react";

interface NativeSelectProps extends SelectHTMLAttributes<HTMLSelectElement> {
    label?: string;
    hint?: string;
    selectClassName?: string;
    options: { label: string; value: string; disabled?: boolean }[];
}

export const NativeSelect = ({ label, hint, options, className, selectClassName, ...props }: NativeSelectProps) => {
    const id = useId();
    const selectId = `select-native-${id}`;
    const hintId = `select-native-hint-${id}`;

    return (
        <div className={cx("w-full in-data-input-wrapper:w-max", className)}>
            {label && (
                <Label htmlFor={selectId} id={selectId} className="mb-1.5">
                    {label}
                </Label>
            )}

            <div className="relative grid w-full items-center">
                <select
                    {...props}
                    id={selectId}
                    aria-describedby={hintId}
                    aria-labelledby={selectId}
                    className={cx(
                        "appearance-none rounded-lg bg-background px-3.5 py-2.5 text-md font-medium text-foreground shadow-xs ring-1 ring-border outline-hidden transition duration-100 ease-linear ring-inset placeholder:text-muted-foreground focus-visible:ring-2 focus-visible:ring-ring disabled:cursor-not-allowed disabled:bg-disabled_subtle disabled:text-disabled",
                        // Styles when the select is within an `InputGroup`
                        "in-data-input-wrapper:flex in-data-input-wrapper:h-full in-data-input-wrapper:gap-1 in-data-input-wrapper:bg-inherit in-data-input-wrapper:px-3 in-data-input-wrapper:py-2 in-data-input-wrapper:font-normal in-data-input-wrapper:text-tertiary in-data-input-wrapper:shadow-none in-data-input-wrapper:ring-transparent",
                        // Styles for the select when `TextField` is disabled
                        "in-data-input-wrapper:group-disabled:pointer-events-none in-data-input-wrapper:group-disabled:cursor-not-allowed in-data-input-wrapper:group-disabled:bg-transparent in-data-input-wrapper:group-disabled:text-disabled",
                        // Common styles for sizes and border radius within `InputGroup`
                        "in-data-input-wrapper:in-data-leading:rounded-r-none in-data-input-wrapper:in-data-trailing:rounded-l-none in-data-input-wrapper:in-data-[input-size=md]:py-2.5 in-data-input-wrapper:in-data-leading:in-data-[input-size=md]:pl-3.5 in-data-input-wrapper:in-data-[input-size=sm]:py-2 in-data-input-wrapper:in-data-[input-size=sm]:pl-3",
                        // For "leading" dropdown within `InputGroup`
                        "in-data-input-wrapper:in-data-leading:in-data-[input-size=md]:pr-4.5 in-data-input-wrapper:in-data-leading:in-data-[input-size=sm]:pr-4.5",
                        // For "trailing" dropdown within `InputGroup`
                        "in-data-input-wrapper:in-data-trailing:in-data-[input-size=md]:pr-8 in-data-input-wrapper:in-data-trailing:in-data-[input-size=sm]:pr-7.5",
                        selectClassName,
                    )}
                >
                    {options.map((opt) => (
                        <option key={opt.value} value={opt.value}>
                            {opt.label}
                        </option>
                    ))}
                </select>
                <ChevronDown
                    aria-hidden="true"
                    className="pointer-events-none absolute right-3.5 size-5 text-fg-quaternary in-data-input-wrapper:right-0 in-data-input-wrapper:size-4 in-data-input-wrapper:stroke-[2.625px] in-data-input-wrapper:in-data-trailing:in-data-[input-size=sm]:right-3"
                />
            </div>

            {hint && (
                <HintText className="mt-2" id={hintId}>
                    {hint}
                </HintText>
            )}
        </div>
    );
};
````

## File: src/components/ContextPanel.tsx
````typescript
import { Switch } from "@/components/base/primitives/switch";
import { Label } from "@/components/base/label";
import { ContextSourceChips } from "@/components/ContextSourceChips";
import { StructuredContextForm } from "@/components/StructuredContextForm";
import { ContextInterview } from "@/components/ContextInterview";
import { ProjectNotes } from "@/components/ProjectNotes";
import { ContextIntegrations } from "@/components/ContextIntegrations";
import { ContextQualityMeter } from "@/components/ContextQualityMeter";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/base/tabs";
import type {
  ContextConfig,
  ContextSource,
  StructuredContext,
  InterviewAnswer,
  DatabaseConnection,
  RagParameters,
} from "@/lib/context-types";

interface ContextPanelProps {
  contextConfig: ContextConfig;
  onUpdateSources: (sources: ContextSource[]) => void;
  onUpdateDatabaseConnections: (connections: DatabaseConnection[]) => void;
  onUpdateRag: (updates: Partial<RagParameters>) => void;
  onUpdateStructured: (updates: Partial<StructuredContext>) => void;
  onUpdateInterview: (answers: InterviewAnswer[]) => void;
  onUpdateProjectNotes: (notes: string) => void;
  onToggleDelimiters: (value: boolean) => void;
}

export function ContextPanel({
  contextConfig,
  onUpdateSources,
  onUpdateDatabaseConnections,
  onUpdateRag,
  onUpdateStructured,
  onUpdateInterview,
  onUpdateProjectNotes,
  onToggleDelimiters,
}: ContextPanelProps) {
  const handleAddSource = (source: ContextSource) => {
    onUpdateSources([...contextConfig.sources, source]);
  };

  const handleRemoveSource = (id: string) => {
    onUpdateSources(contextConfig.sources.filter((s) => s.id !== id));
  };

  const structuredCount = Object.values(contextConfig.structured).filter(
    (v) => typeof v === "string" && v.trim().length > 0
  ).length;

  const hasNotes = contextConfig.projectNotes.trim().length > 0;
  const interviewCount = contextConfig.interviewAnswers.filter(
    (a) => a.answer.trim().length > 0
  ).length;
  const integrationCount =
    contextConfig.databaseConnections.length + (contextConfig.rag.enabled ? 1 : 0);

  return (
    <div className="space-y-3">
      {/* Sources — always visible */}
      <ContextSourceChips
        sources={contextConfig.sources}
        onAdd={handleAddSource}
        onRemove={handleRemoveSource}
      />

      <Tabs defaultValue="structured" className="w-full">
        <TabsList className="h-auto w-full grid grid-cols-2 gap-1 bg-muted/30 p-1 sm:grid-cols-4">
          <TabsTrigger value="structured" aria-label="Structured context tab" className="interactive-chip h-11 px-2 text-sm sm:h-10 sm:text-sm">
            Structured{structuredCount > 0 ? ` (${structuredCount})` : ""}
          </TabsTrigger>
          <TabsTrigger value="integrations" aria-label="Integrations tab" className="interactive-chip h-11 px-2 text-sm sm:h-10 sm:text-sm">
            Integrations{integrationCount > 0 ? ` (${integrationCount})` : ""}
          </TabsTrigger>
          <TabsTrigger value="interview" aria-label="Context interview tab" className="interactive-chip h-11 px-2 text-sm sm:h-10 sm:text-sm">
            Interview{interviewCount > 0 ? ` (${interviewCount})` : ""}
          </TabsTrigger>
          <TabsTrigger value="notes" aria-label="Project notes tab" className="interactive-chip h-11 px-2 text-sm sm:h-10 sm:text-sm">
            Notes{hasNotes ? " (1)" : ""}
          </TabsTrigger>
        </TabsList>

        <TabsContent value="structured" className="mt-3">
          <StructuredContextForm values={contextConfig.structured} onUpdate={onUpdateStructured} />
        </TabsContent>

        <TabsContent value="integrations" className="mt-3">
          <ContextIntegrations
            databaseConnections={contextConfig.databaseConnections}
            rag={contextConfig.rag}
            onUpdateDatabaseConnections={onUpdateDatabaseConnections}
            onUpdateRag={onUpdateRag}
          />
        </TabsContent>

        <TabsContent value="interview" className="mt-3">
          <ContextInterview answers={contextConfig.interviewAnswers} onUpdate={onUpdateInterview} />
        </TabsContent>

        <TabsContent value="notes" className="mt-3">
          <ProjectNotes value={contextConfig.projectNotes} onChange={onUpdateProjectNotes} />
        </TabsContent>
      </Tabs>

      {/* Settings & quality — compact row */}
      <div className="flex items-center justify-between pt-2 border-t border-border">
        <div className="flex items-center gap-2">
          <Switch
            checked={contextConfig.useDelimiters}
            onCheckedChange={onToggleDelimiters}
          />
          <Label className="text-sm text-muted-foreground sm:text-base">Delimiters</Label>
        </div>
        <ContextQualityMeter contextConfig={contextConfig} />
      </div>
    </div>
  );
}
````

## File: src/integrations/neon/client.ts
````typescript
import { createClient, SupabaseAuthAdapter } from "@neondatabase/neon-js";
import type { Database } from "./types";
import {
  NEON_AUTH_URL,
  NEON_DATA_API_URL,
  TEST_AUTH_URL,
  TEST_DATA_API_URL,
  hasBackendEnvConfig,
  isBackendConfigured,
} from "@/lib/backend-config";

export { hasBackendEnvConfig, isBackendConfigured };

const DATA_API_URL = NEON_DATA_API_URL ?? TEST_DATA_API_URL;
const AUTH_URL = NEON_AUTH_URL ?? TEST_AUTH_URL;

export const neon = createClient<Database>({
  auth: {
    adapter: SupabaseAuthAdapter(),
    url: AUTH_URL,
    allowAnonymous: true,
  },
  dataApi: {
    url: DATA_API_URL,
  },
});
````

## File: src/lib/notifications.ts
````typescript
import { neon } from "@/integrations/neon/client";
import { type CommunityProfile, loadProfilesByIds } from "@/lib/community";
import { toProfileMap } from "@/lib/community-utils";
import { isPostgrestError } from "@/lib/saved-prompt-shared";

export type NotificationType = "upvote" | "verified" | "comment" | "remix";

export interface Notification {
  id: string;
  userId: string;
  actorId: string | null;
  type: NotificationType;
  postId: string | null;
  commentId: string | null;
  readAt: number | null;
  createdAt: number;
  actorDisplayName: string;
  actorAvatarUrl: string | null;
  postTitle: string;
}

interface NotificationRow {
  id: string;
  user_id: string;
  actor_id: string | null;
  type: string;
  post_id: string | null;
  comment_id: string | null;
  read_at: string | null;
  created_at: string;
}

interface PostTitleRow {
  id: string;
  title: string;
}

function toError(error: unknown, fallback: string): Error {
  if (error instanceof Error) return error;
  if (isPostgrestError(error)) return new Error(error.message || fallback);
  return new Error(fallback);
}

function normalizeNotificationType(value: string): NotificationType {
  if (value === "upvote") return "upvote";
  if (value === "verified") return "verified";
  if (value === "remix") return "remix";
  return "comment";
}

function toPostTitleMap(posts: PostTitleRow[]): Record<string, string> {
  return posts.reduce<Record<string, string>>((map, post) => {
    map[post.id] = post.title;
    return map;
  }, {});
}

function uniqueNonEmpty(values: Array<string | null | undefined>): string[] {
  return Array.from(new Set(values.filter((value): value is string => Boolean(value))));
}

async function requireUserId(): Promise<string> {
  const { data, error } = await neon.auth.getUser();
  if (error) throw toError(error, "Authentication failed.");
  const user = data.user;
  if (!user?.id) {
    throw new Error("Sign in required.");
  }
  return user.id;
}

export async function loadNotifications(limit = 25, offset = 0): Promise<Notification[]> {
  const userId = await requireUserId();
  const normalizedLimit = Math.min(Math.max(limit, 1), 100);
  const normalizedOffset = Math.max(offset, 0);

  try {
    const { data, error } = await neon
      .from("notifications")
      .select("id, user_id, actor_id, type, post_id, comment_id, read_at, created_at")
      .eq("user_id", userId)
      .order("created_at", { ascending: false })
      .range(normalizedOffset, normalizedOffset + normalizedLimit - 1);

    if (error) throw error;
    const rows = (data || []) as NotificationRow[];
    if (rows.length === 0) return [];

    const actorIds = uniqueNonEmpty(rows.map((row) => row.actor_id));
    const postIds = uniqueNonEmpty(rows.map((row) => row.post_id));

    const [profilesResult, postsResult] = await Promise.allSettled([
      loadProfilesByIds(actorIds),
      postIds.length > 0
        ? neon.from("community_posts").select("id, title").in("id", postIds)
        : Promise.resolve({ data: [] as PostTitleRow[], error: null }),
    ]);

    const profiles =
      profilesResult.status === "fulfilled"
        ? profilesResult.value
        : [];

    const postRows =
      postsResult.status === "fulfilled" && !postsResult.value.error
        ? ((postsResult.value.data || []) as PostTitleRow[])
        : [];

    const profileById = toProfileMap(profiles);
    const postTitleById = toPostTitleMap(postRows);

    return rows.map((row) => {
      const actor = row.actor_id ? profileById[row.actor_id] : undefined;
      return {
        id: row.id,
        userId: row.user_id,
        actorId: row.actor_id,
        type: normalizeNotificationType(row.type),
        postId: row.post_id,
        commentId: row.comment_id,
        readAt: row.read_at ? new Date(row.read_at).getTime() : null,
        createdAt: new Date(row.created_at).getTime(),
        actorDisplayName: actor?.displayName || "Community member",
        actorAvatarUrl: actor?.avatarUrl || null,
        postTitle: row.post_id ? postTitleById[row.post_id] || "your post" : "your post",
      };
    });
  } catch (error) {
    throw toError(error, "Failed to load notifications.");
  }
}

export async function getUnreadCount(): Promise<number> {
  const userId = await requireUserId();

  try {
    const { count, error } = await neon
      .from("notifications")
      .select("id", { count: "exact", head: true })
      .eq("user_id", userId)
      .is("read_at", null);

    if (error) throw error;
    return count ?? 0;
  } catch (error) {
    throw toError(error, "Failed to load unread notifications.");
  }
}

export async function markAsRead(notificationId: string): Promise<boolean> {
  const userId = await requireUserId();

  try {
    const { data, error } = await neon
      .from("notifications")
      .update({ read_at: new Date().toISOString() })
      .eq("id", notificationId)
      .eq("user_id", userId)
      .is("read_at", null)
      .select("id")
      .maybeSingle();

    if (error) throw error;
    return Boolean(data?.id);
  } catch (error) {
    throw toError(error, "Failed to mark notification as read.");
  }
}

export async function markAllAsRead(): Promise<number> {
  const userId = await requireUserId();

  try {
    const { data, error } = await neon
      .from("notifications")
      .update({ read_at: new Date().toISOString() })
      .eq("user_id", userId)
      .is("read_at", null)
      .select("id");

    if (error) throw error;
    return (data || []).length;
  } catch (error) {
    throw toError(error, "Failed to mark all notifications as read.");
  }
}
````

## File: src/pages/Contact.tsx
````typescript
import { ContactSimpleForm } from "@/components/marketing/contact/contact-simple-form";
import { PageShell } from "@/components/PageShell";

const Contact = () => {
  return (
    <PageShell mainClassName="pf-community-page py-0 sm:py-0">
      <ContactSimpleForm />
    </PageShell>
  );
};

export default Contact;
````

## File: src/pages/LibraryBulkEdit.tsx
````typescript
import { useEffect } from "react";
import { useNavigate, useSearchParams } from "react-router-dom";
import { PageHero, PageShell } from "@/components/PageShell";
import { decodeSelectionIds } from "@/lib/library-pages";

const LIBRARY_SELECTION_STORAGE_KEY = "library-selection-ids";

const LibraryBulkEdit = () => {
  const navigate = useNavigate();
  const [searchParams] = useSearchParams();

  useEffect(() => {
    const ids = decodeSelectionIds(searchParams);
    if (typeof window !== "undefined" && ids.length > 0) {
      window.sessionStorage.setItem(LIBRARY_SELECTION_STORAGE_KEY, JSON.stringify(ids));
    }
    navigate("/library", { replace: true });
  }, [navigate, searchParams]);

  return (
    <PageShell>
      <PageHero
        title="Bulk edit moved"
        subtitle="Redirecting to Library where bulk actions are now inline."
        className="pf-gilded-frame pf-hero-surface"
      />
    </PageShell>
  );
};

export default LibraryBulkEdit;
````

## File: src/styles/promptforge-fantasy.css
````css
:root {
  --pf-arcane-teal: #12c8b5;
  --pf-deep-teal: #0a6a64;
  --pf-forge-gold: #d6a640;
  --pf-antique-gold: #b8872b;
  --pf-ember-orange: #ff7a18;
  --pf-ember-dark: #5a1f0a;

  --pf-coal: #0b0f14;
  --pf-midnight: #1d2630;
  --pf-slate: #2e3a46;

  --pf-parchment: #e6e1d5;
  --pf-ash: #b7b0a5;

  --pf-arcane-rgb: 18 200 181;
  --pf-deep-rgb: 10 106 100;
  --pf-gold-rgb: 214 166 64;
  --pf-ember-rgb: 255 122 24;
  --pf-coal-rgb: 11 15 20;
  --pf-midnight-rgb: 29 38 48;
  --pf-slate-rgb: 46 58 70;
  --pf-parchment-rgb: 230 225 213;

  --pf-radius-sm: 12px;
  --pf-radius-md: 18px;
  --pf-radius-lg: 26px;
  --pf-radius-xl: 32px;

  --pf-shadow-card: 0 18px 40px rgba(0, 0, 0, 0.45);
  --pf-shadow-elevated: 0 26px 70px rgba(0, 0, 0, 0.55);
  --pf-inner-bevel:
    inset 0 1px 0 rgba(230, 225, 213, 0.12),
    inset 0 -1px 0 rgba(0, 0, 0, 0.35);

  --pf-glow-arcane: 0 0 24px rgba(18, 200, 181, 0.28);
  --pf-glow-ember: 0 0 28px rgba(255, 122, 24, 0.22);
  --pf-glow-gold: 0 0 28px rgba(214, 166, 64, 0.18);

  --pf-ease: cubic-bezier(0.2, 0.8, 0.2, 1);
  --pf-fast: 140ms;
  --pf-base: 220ms;
  --pf-slow: 360ms;

  --pf-font-display: Cinzel, "Trajan Pro", "Times New Roman", serif;
  --pf-font-body: Inter, system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif;

  --pf-hero-image: url("/pf/promptforge-background-1920x1080.png");
  --pf-rune-image: url("/pf/promptforge-rune-texture-tile-1024.png");
}

.pf-text-display {
  font-family: var(--pf-font-display);
  letter-spacing: -0.02em;
}

.pf-divider {
  height: 1px;
  background: linear-gradient(90deg,
      rgba(var(--pf-gold-rgb) / 0),
      rgba(var(--pf-gold-rgb) / 0.7),
      rgba(var(--pf-arcane-rgb) / 0.55),
      rgba(var(--pf-gold-rgb) / 0.7),
      rgba(var(--pf-gold-rgb) / 0));
  filter: drop-shadow(0 0 10px rgba(var(--pf-arcane-rgb) / 0.18));
}

.pf-gilded-frame {
  position: relative;
  border-radius: var(--pf-radius-lg);
  border: 1px solid rgba(var(--pf-gold-rgb) / 0.55);
  box-shadow: var(--pf-shadow-card);
  background: linear-gradient(180deg, rgba(18, 24, 32, 0.92), rgba(11, 15, 20, 0.92));
  overflow: hidden;
}

.pf-gilded-frame::before {
  content: "";
  position: absolute;
  inset: 0;
  pointer-events: none;
  background:
    radial-gradient(600px 260px at 25% 20%, rgba(var(--pf-arcane-rgb) / 0.16), transparent 60%),
    radial-gradient(700px 340px at 80% 0%, rgba(var(--pf-gold-rgb) / 0.11), transparent 62%),
    linear-gradient(180deg, rgba(255, 255, 255, 0.04), rgba(0, 0, 0, 0.14));
}

.pf-hero-surface {
  position: relative;
  overflow: hidden;
}

.pf-hero-surface::before {
  content: "";
  position: absolute;
  inset: 0;
  pointer-events: none;
  background-image:
    linear-gradient(120deg, rgba(0, 0, 0, 0.56), rgba(0, 0, 0, 0.2) 35%, rgba(0, 0, 0, 0.58)),
    radial-gradient(580px 240px at 12% -10%, rgba(var(--pf-gold-rgb) / 0.18), transparent 62%),
    radial-gradient(520px 220px at 85% 0%, rgba(var(--pf-arcane-rgb) / 0.18), transparent 58%),
    var(--pf-hero-image);
  background-position: center;
  background-size: cover;
}

.pf-hero-surface::after {
  content: "";
  position: absolute;
  inset: 0;
  pointer-events: none;
  opacity: 0.1;
  background-image: var(--pf-rune-image);
  background-size: 680px 680px;
  background-position: center;
  mix-blend-mode: plus-lighter;
}

.pf-hero-surface>* {
  position: relative;
  z-index: 1;
}

.pf-hero-surface .ui-section-label {
  color: rgba(var(--pf-gold-rgb) / 0.95);
  text-shadow: 0 1px 10px rgba(0, 0, 0, 0.45);
}

.pf-hero-surface .page-hero-title {
  color: rgba(var(--pf-parchment-rgb) / 0.97);
  text-shadow: 0 3px 14px rgba(0, 0, 0, 0.52);
}

.pf-hero-surface .page-hero-subtitle {
  color: rgba(var(--pf-parchment-rgb) / 0.84);
  text-shadow: 0 1px 10px rgba(0, 0, 0, 0.46);
}

.pf-panel {
  position: relative;
  border-radius: var(--pf-radius-lg);
  border: 2px solid rgba(var(--pf-gold-rgb) / 0.4);
  box-shadow: var(--pf-shadow-card);
  background:
    radial-gradient(700px 250px at 25% 0%, rgba(var(--pf-arcane-rgb) / 0.1), transparent 65%),
    linear-gradient(180deg, rgba(18, 24, 32, 0.94), rgba(11, 15, 20, 0.94));
  overflow: hidden;
}

.pf-panel::after {
  content: "";
  position: absolute;
  inset: 0;
  pointer-events: none;
  background: linear-gradient(180deg, rgba(255, 255, 255, 0.035), rgba(0, 0, 0, 0.16));
  box-shadow: var(--pf-inner-bevel);
}

.pf-panel-overflow-visible {
  overflow: visible;
}

.pf-input {
  border-radius: var(--pf-radius-md);
  border: 2px solid rgba(var(--pf-slate-rgb) / 0.85);
  background: rgba(var(--pf-coal-rgb) / 0.92);
  color: var(--pf-parchment);
  box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.05);
  transition:
    border-color var(--pf-fast) var(--pf-ease),
    box-shadow var(--pf-fast) var(--pf-ease);
}

.pf-input:focus {
  outline: none;
  border-color: rgba(var(--pf-arcane-rgb) / 0.9);
  box-shadow:
    0 0 0 4px rgba(var(--pf-arcane-rgb) / 0.12),
    inset 0 1px 0 rgba(255, 255, 255, 0.05);
}

.pf-button {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: 0.55rem;
  padding: 0.72rem 1rem;
  border-radius: var(--pf-radius-md);
  font-weight: 700;
  letter-spacing: -0.01em;
  transition:
    transform var(--pf-fast) var(--pf-ease),
    box-shadow var(--pf-fast) var(--pf-ease),
    filter var(--pf-fast) var(--pf-ease);
  user-select: none;
  -webkit-tap-highlight-color: transparent;
}

.pf-button:active {
  transform: translateY(0);
}

.pf-button-primary {
  border: 2px solid rgba(var(--pf-gold-rgb) / 0.88);
  background: linear-gradient(180deg, rgba(var(--pf-arcane-rgb) / 0.22), rgba(var(--pf-deep-rgb) / 1));
  color: var(--pf-parchment);
  box-shadow: var(--pf-glow-arcane), var(--pf-inner-bevel);
}

.pf-button-primary:hover {
  transform: translateY(-1px);
  box-shadow:
    0 0 34px rgba(var(--pf-arcane-rgb) / 0.32),
    var(--pf-inner-bevel);
}

.pf-button-secondary {
  border: 2px solid rgba(var(--pf-arcane-rgb) / 0.7);
  background: linear-gradient(180deg, rgba(var(--pf-midnight-rgb) / 0.9), rgba(var(--pf-coal-rgb) / 0.95));
  color: var(--pf-parchment);
  box-shadow:
    0 0 18px rgba(var(--pf-arcane-rgb) / 0.14),
    var(--pf-inner-bevel);
}

.pf-button-secondary:hover {
  transform: translateY(-1px);
  box-shadow:
    0 0 26px rgba(var(--pf-arcane-rgb) / 0.22),
    var(--pf-inner-bevel);
}

.pf-button-ghost {
  border: 1px solid rgba(var(--pf-gold-rgb) / 0.35);
  background: rgba(var(--pf-coal-rgb) / 0.35);
  color: rgba(var(--pf-parchment-rgb) / 0.9);
}

.pf-button-ghost:hover {
  filter: brightness(1.08);
  transform: translateY(-1px);
}

.pf-card {
  border-radius: var(--pf-radius-lg);
  background: linear-gradient(180deg, rgba(18, 24, 32, 0.92), rgba(11, 15, 20, 0.94));
  box-shadow: var(--pf-shadow-card);
  border: 2px solid rgba(var(--pf-slate-rgb) / 0.9);
  transition:
    transform var(--pf-fast) var(--pf-ease),
    box-shadow var(--pf-fast) var(--pf-ease),
    border-color var(--pf-fast) var(--pf-ease);
  overflow: hidden;
}

.pf-card:hover {
  transform: translateY(-2px);
  box-shadow: var(--pf-shadow-elevated);
}

.pf-rarity-common {
  border-color: rgba(var(--pf-slate-rgb) / 0.95);
}

.pf-rarity-rare {
  border-color: rgba(var(--pf-arcane-rgb) / 0.88);
  box-shadow:
    var(--pf-shadow-card),
    0 0 22px rgba(var(--pf-arcane-rgb) / 0.14);
}

.pf-rarity-epic {
  border-color: rgba(var(--pf-ember-rgb) / 0.85);
  box-shadow:
    var(--pf-shadow-card),
    0 0 22px rgba(var(--pf-ember-rgb) / 0.12);
}

.pf-rarity-legendary {
  border-color: rgba(var(--pf-gold-rgb) / 0.92);
  box-shadow:
    var(--pf-shadow-card),
    0 0 26px rgba(var(--pf-gold-rgb) / 0.14);
}

.pf-nav-link {
  position: relative;
  color: rgba(var(--pf-parchment-rgb) / 0.84);
  transition: color var(--pf-fast) var(--pf-ease);
}

.pf-nav-link:hover {
  color: rgba(var(--pf-parchment-rgb) / 1);
}

.pf-nav-link::after {
  content: "";
  position: absolute;
  left: 0;
  right: 0;
  bottom: -8px;
  height: 2px;
  background: linear-gradient(90deg,
      rgba(var(--pf-gold-rgb) / 0),
      rgba(var(--pf-gold-rgb) / 0.85),
      rgba(var(--pf-arcane-rgb) / 0.75),
      rgba(var(--pf-gold-rgb) / 0));
  opacity: 0;
  transform: translateY(4px);
  transition:
    opacity var(--pf-fast) var(--pf-ease),
    transform var(--pf-fast) var(--pf-ease);
}

.pf-nav-link:hover::after {
  opacity: 1;
  transform: translateY(0px);
}

.pf-nav-header {
  position: sticky;
}

.pf-nav-header::after {
  content: "";
  position: absolute;
  left: 0;
  right: 0;
  bottom: -1px;
  height: 1px;
  pointer-events: none;
  background: linear-gradient(90deg,
      rgba(var(--pf-gold-rgb) / 0),
      rgba(var(--pf-gold-rgb) / 0.7),
      rgba(var(--pf-arcane-rgb) / 0.6),
      rgba(var(--pf-gold-rgb) / 0.7),
      rgba(var(--pf-gold-rgb) / 0));
}

.pf-nav-button {
  transition:
    border-color var(--pf-fast) var(--pf-ease),
    box-shadow var(--pf-fast) var(--pf-ease),
    transform var(--pf-fast) var(--pf-ease);
}

.pf-nav-button:hover {
  border-color: rgba(var(--pf-gold-rgb) / 0.4);
  box-shadow: 0 0 16px rgba(var(--pf-arcane-rgb) / 0.14);
  transform: translateY(-1px);
}

.pf-shell-backdrop {
  position: relative;
}

.pf-shell-backdrop::before {
  content: "";
  position: fixed;
  inset: 0;
  z-index: 0;
  pointer-events: none;
  background-image:
    radial-gradient(860px 340px at 14% -8%, rgba(var(--pf-gold-rgb) / 0.09), transparent 68%),
    radial-gradient(900px 420px at 90% -2%, rgba(var(--pf-arcane-rgb) / 0.1), transparent 70%),
    linear-gradient(180deg, hsl(var(--background)), hsl(var(--background)));
}

.pf-shell-main,
.pf-shell-footer {
  position: relative;
  z-index: 1;
}

.pf-shell-footer {
  backdrop-filter: blur(8px);
}

.pf-shell-footer::before {
  content: "";
  position: absolute;
  left: 0;
  right: 0;
  top: 0;
  height: 1px;
  pointer-events: none;
  background: linear-gradient(
    90deg,
    rgba(var(--pf-gold-rgb) / 0),
    rgba(var(--pf-gold-rgb) / 0.55),
    rgba(var(--pf-arcane-rgb) / 0.45),
    rgba(var(--pf-gold-rgb) / 0.55),
    rgba(var(--pf-gold-rgb) / 0)
  );
}

.pf-shell-footer-link {
  position: relative;
  transition:
    color var(--pf-fast) var(--pf-ease),
    opacity var(--pf-fast) var(--pf-ease);
}

.pf-shell-footer-link::after {
  content: "";
  position: absolute;
  left: 0;
  right: 0;
  bottom: -2px;
  height: 1px;
  opacity: 0;
  background: linear-gradient(90deg, rgba(var(--pf-gold-rgb) / 0.1), rgba(var(--pf-arcane-rgb) / 0.6));
  transition: opacity var(--pf-fast) var(--pf-ease);
}

.pf-shell-footer-link:hover::after {
  opacity: 1;
}

.pf-mobile-nav {
  border-top-color: color-mix(in srgb, hsl(var(--border)) 65%, rgba(var(--pf-gold-rgb) / 0.55));
}

.pf-mobile-nav::before {
  content: "";
  position: absolute;
  left: 0;
  right: 0;
  top: -1px;
  height: 1px;
  pointer-events: none;
  background: linear-gradient(
    90deg,
    rgba(var(--pf-gold-rgb) / 0),
    rgba(var(--pf-gold-rgb) / 0.58),
    rgba(var(--pf-arcane-rgb) / 0.56),
    rgba(var(--pf-gold-rgb) / 0.58),
    rgba(var(--pf-gold-rgb) / 0)
  );
}

.pf-dialog-surface {
  border: 1px solid color-mix(in srgb, hsl(var(--border)) 62%, rgba(var(--pf-gold-rgb) / 0.55));
  background:
    radial-gradient(620px 220px at 20% -10%, rgba(var(--pf-arcane-rgb) / 0.09), transparent 64%),
    radial-gradient(580px 240px at 88% -14%, rgba(var(--pf-gold-rgb) / 0.09), transparent 62%),
    hsl(var(--card));
  box-shadow:
    0 22px 44px rgba(0, 0, 0, 0.35),
    inset 0 1px 0 rgba(255, 255, 255, 0.03);
}

.pf-community-page {
  position: relative;
  z-index: 1;
}

.pf-community-toolbar {
  border: 1px solid color-mix(in srgb, hsl(var(--border)) 72%, rgba(var(--pf-gold-rgb) / 0.35));
}

.pf-community-popover {
  border-color: color-mix(in srgb, hsl(var(--border)) 68%, rgba(var(--pf-gold-rgb) / 0.45));
  background:
    radial-gradient(460px 220px at 15% -15%, rgba(var(--pf-arcane-rgb) / 0.1), transparent 66%),
    hsl(var(--popover));
}

.pf-community-preview {
  border-color: color-mix(in srgb, hsl(var(--border)) 64%, rgba(var(--pf-arcane-rgb) / 0.45));
  background:
    linear-gradient(180deg, hsl(var(--card) / 0.88), hsl(var(--card) / 0.78));
}

/* Rarity pulse animations — subtle ambient glow for high-engagement cards */
@media (prefers-reduced-motion: no-preference) {
  .pf-rarity-legendary {
    animation: pf-pulse-gold 4s ease-in-out infinite;
  }

  .pf-rarity-epic {
    animation: pf-pulse-ember 6s ease-in-out infinite;
  }
}

@keyframes pf-pulse-gold {
  0%, 100% {
    box-shadow:
      var(--pf-shadow-card),
      0 0 26px rgba(var(--pf-gold-rgb) / 0.14);
  }
  50% {
    box-shadow:
      var(--pf-shadow-card),
      0 0 36px rgba(var(--pf-gold-rgb) / 0.22),
      0 0 60px rgba(var(--pf-gold-rgb) / 0.08);
  }
}

@keyframes pf-pulse-ember {
  0%, 100% {
    box-shadow:
      var(--pf-shadow-card),
      0 0 22px rgba(var(--pf-ember-rgb) / 0.12);
  }
  50% {
    box-shadow:
      var(--pf-shadow-card),
      0 0 30px rgba(var(--pf-ember-rgb) / 0.18),
      0 0 50px rgba(var(--pf-ember-rgb) / 0.06);
  }
}
````

## File: src/styles/theme.css
````css
@theme {
    /* FONT FAMILY */
    --font-body: var(--font-inter, "Inter"), -apple-system, "Segoe UI", Roboto, Arial, sans-serif;
    --font-display: var(--font-inter, "Inter"), -apple-system, "Segoe UI", Roboto, Arial, sans-serif;
    --font-mono: ui-monospace, "Roboto Mono", SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;

    /* FONT SIZE
     * Keep @theme text tokens aligned to --type-* scale to avoid line-height drift
     * between Tailwind text utilities and design-system semantic tokens.
     */
    --text-xs: var(--type-xs-size);
    --text-xs--line-height: var(--type-xs-line);

    --text-sm: var(--type-sm-size);
    --text-sm--line-height: var(--type-sm-line);

    --text-md: var(--type-base-size);
    --text-md--line-height: var(--type-base-line);

    --text-lg: var(--type-lg-size);
    --text-lg--line-height: var(--type-lg-line);

    --text-xl: var(--type-xl-size);
    --text-xl--line-height: var(--type-xl-line);

    --text-display-xs: var(--type-2xl-size);
    --text-display-xs--line-height: var(--type-2xl-line);

    --text-display-sm: var(--type-3xl-size);
    --text-display-sm--line-height: var(--type-3xl-line);

    --text-display-md: var(--type-4xl-size);
    --text-display-md--line-height: var(--type-4xl-line);
    --text-display-md--letter-spacing: -0.72px;

    --text-display-lg: var(--type-5xl-size);
    --text-display-lg--line-height: var(--type-5xl-line);
    --text-display-lg--letter-spacing: -0.96px;

    --text-display-xl: calc(var(--spacing) * 15);
    --text-display-xl--line-height: calc(var(--spacing) * 18);
    --text-display-xl--letter-spacing: -1.2px;

    --text-display-2xl: calc(var(--spacing) * 18);
    --text-display-2xl--line-height: calc(var(--spacing) * 22.5);
    --text-display-2xl--letter-spacing: -1.44px;

    /* MAX WIDTH */
    --max-width-container: 1280px;

    /* BREAKPOINTS */
    --breakpoint-xxs: 320px;
    /* This must match the breakpoint in Sonner: https://github.com/emilkowalski/sonner/blob/main/src/styles.css */
    --breakpoint-xs: 600px;

    /* RADIUS */
    --radius-none: 0px;
    --radius-xs: 0.125rem;
    --radius-sm: 0.25rem;
    --radius-DEFAULT: 0.25rem;
    --radius-md: 0.375rem;
    --radius-lg: 0.5rem;
    --radius-xl: 0.75rem;
    --radius-2xl: 1rem;
    --radius-3xl: 1.5rem;
    --radius-full: 9999px;

    /* SHADOW */
    --shadow-xs: 0px 1px 2px rgba(10, 13, 18, 0.05);
    --shadow-sm: 0px 1px 3px rgba(10, 13, 18, 0.1), 0px 1px 2px -1px rgba(10, 13, 18, 0.1);
    --shadow-md: 0px 4px 6px -1px rgba(10, 13, 18, 0.1), 0px 2px 4px -2px rgba(10, 13, 18, 0.06);
    --shadow-lg: 0px 12px 16px -4px rgba(10, 13, 18, 0.08), 0px 4px 6px -2px rgba(10, 13, 18, 0.03), 0px 2px 2px -1px rgba(10, 13, 18, 0.04);
    --shadow-xl: 0px 20px 24px -4px rgba(10, 13, 18, 0.08), 0px 8px 8px -4px rgba(10, 13, 18, 0.03), 0px 3px 3px -1.5px rgba(10, 13, 18, 0.04);
    --shadow-2xl: 0px 24px 48px -12px rgba(10, 13, 18, 0.18), 0px 4px 4px -2px rgba(10, 13, 18, 0.04);
    --shadow-3xl: 0px 32px 64px -12px rgba(10, 13, 18, 0.14), 0px 5px 5px -2.5px rgba(10, 13, 18, 0.04);

    --shadow-skeumorphic: 0px 0px 0px 1px rgba(10, 13, 18, 0.18) inset, 0px -2px 0px 0px rgba(10, 13, 18, 0.05) inset;
    --shadow-xs-skeumorphic: var(--shadow-skeumorphic), var(--shadow-xs);

    --shadow-modern-mockup-inner-lg: 0px 0px 3.765px 1.255px rgba(10, 13, 18, 0.08) inset, 0px 0px 2.51px 1.255px rgba(10, 13, 18, 0.03) inset;
    --shadow-modern-mockup-inner-md: 0px 0px 1.692px 0.564px rgba(10, 13, 18, 0.08) inset, 0px 0px 1.128px 0.564px rgba(10, 13, 18, 0.03) inset;
    --shadow-modern-mockup-inner-sm: 0px 0px 4.48px 1.493px rgba(10, 13, 18, 0.08) inset, 0px 0px 2.987px 1.493px rgba(10, 13, 18, 0.03) inset;

    --shadow-modern-mockup-outer-lg:
        0px 7.529px 10.039px -2.51px rgba(10, 13, 18, 0.08), 0px 2.51px 3.765px -1.255px rgba(10, 13, 18, 0.03),
        0px 1.255px 1.255px -0.627px rgba(10, 13, 18, 0.04);
    --shadow-modern-mockup-outer-md:
        0px 3.385px 4.513px -1.128px rgba(10, 13, 18, 0.08), 0px 1.128px 1.692px -0.564px rgba(10, 13, 18, 0.03),
        0px 0.564px 0.564px -0.282px rgba(10, 13, 18, 0.04);

    --drop-shadow-iphone-mockup: 20px 12px 18px rgba(16, 24, 40, 0.2);

    /* ANIMATIONS */
    --animate-marquee: marquee 60s linear infinite;
    --animate-caret-blink: caret-blink 1s infinite;

    @keyframes marquee {
        0% {
            transform: translateX(0);
        }
        100% {
            transform: translateX(-100%);
        }
    }

    @keyframes caret-blink {
        0%,
        50% {
            opacity: 1;
        }
        51%,
        100% {
            opacity: 0;
        }
    }

    /* BASE COLOR */
    --color-transparent: rgb(0 0 0 / 0);

    --color-white: rgb(255 255 255);
    --color-black: rgb(0 0 0);

    --color-brand-25: rgb(252 250 255);
    --color-brand-50: rgb(249 245 255);
    --color-brand-100: rgb(244 235 255);
    --color-brand-200: rgb(233 215 254);
    --color-brand-300: rgb(214 187 251);
    --color-brand-400: rgb(182 146 246);
    --color-brand-500: rgb(158 119 237);
    --color-brand-600: rgb(127 86 217);
    --color-brand-700: rgb(105 65 198);
    --color-brand-800: rgb(83 56 158);
    --color-brand-900: rgb(66 48 125);
    --color-brand-950: rgb(44 28 95);

    --color-error-25: rgb(255 251 250);
    --color-error-50: rgb(254 243 242);
    --color-error-100: rgb(254 228 226);
    --color-error-200: rgb(254 205 202);
    --color-error-300: rgb(253 162 155);
    --color-error-400: rgb(249 112 102);
    --color-error-500: rgb(240 68 56);
    --color-error-600: rgb(217 45 32);
    --color-error-700: rgb(180 35 24);
    --color-error-800: rgb(145 32 24);
    --color-error-900: rgb(122 39 26);
    --color-error-950: rgb(85 22 12);

    --color-warning-25: rgb(255 252 245);
    --color-warning-50: rgb(255 250 235);
    --color-warning-100: rgb(254 240 199);
    --color-warning-200: rgb(254 223 137);
    --color-warning-300: rgb(254 200 75);
    --color-warning-400: rgb(253 176 34);
    --color-warning-500: rgb(247 144 9);
    --color-warning-600: rgb(220 104 3);
    --color-warning-700: rgb(181 71 8);
    --color-warning-800: rgb(147 55 13);
    --color-warning-900: rgb(122 46 14);
    --color-warning-950: rgb(78 29 9);

    --color-success-25: rgb(246 254 249);
    --color-success-50: rgb(236 253 243);
    --color-success-100: rgb(220 250 230);
    --color-success-200: rgb(171 239 198);
    --color-success-300: rgb(117 224 167);
    --color-success-400: rgb(71 205 137);
    --color-success-500: rgb(23 178 106);
    --color-success-600: rgb(7 148 85);
    --color-success-700: rgb(6 118 71);
    --color-success-800: rgb(8 93 58);
    --color-success-900: rgb(7 77 49);
    --color-success-950: rgb(5 51 33);

    --color-gray-25: rgb(253 253 253);
    --color-gray-50: rgb(250 250 250);
    --color-gray-100: rgb(245 245 245);
    --color-gray-200: rgb(233 234 235);
    --color-gray-300: rgb(213 215 218);
    --color-gray-400: rgb(164 167 174);
    --color-gray-500: rgb(113 118 128);
    --color-gray-600: rgb(83 88 98);
    --color-gray-700: rgb(65 70 81);
    --color-gray-800: rgb(37 43 55);
    --color-gray-900: rgb(24 29 39);
    --color-gray-950: rgb(10 13 18);

    --color-gray-blue-25: rgb(252 252 253);
    --color-gray-blue-50: rgb(248 249 252);
    --color-gray-blue-100: rgb(234 236 245);
    --color-gray-blue-200: rgb(213 217 235);
    --color-gray-blue-300: rgb(179 184 219);
    --color-gray-blue-400: rgb(113 123 188);
    --color-gray-blue-500: rgb(78 91 166);
    --color-gray-blue-600: rgb(62 71 132);
    --color-gray-blue-700: rgb(54 63 114);
    --color-gray-blue-800: rgb(41 48 86);
    --color-gray-blue-900: rgb(16 19 35);
    --color-gray-blue-950: rgb(13 15 28);

    --color-gray-cool-25: rgb(252 252 253);
    --color-gray-cool-50: rgb(249 249 251);
    --color-gray-cool-100: rgb(239 241 245);
    --color-gray-cool-200: rgb(220 223 234);
    --color-gray-cool-300: rgb(185 192 212);
    --color-gray-cool-400: rgb(125 137 176);
    --color-gray-cool-500: rgb(93 107 152);
    --color-gray-cool-600: rgb(74 85 120);
    --color-gray-cool-700: rgb(64 73 104);
    --color-gray-cool-800: rgb(48 55 79);
    --color-gray-cool-900: rgb(17 19 34);
    --color-gray-cool-950: rgb(14 16 27);

    --color-gray-modern-25: rgb(252 252 253);
    --color-gray-modern-50: rgb(248 250 252);
    --color-gray-modern-100: rgb(238 242 246);
    --color-gray-modern-200: rgb(227 232 239);
    --color-gray-modern-300: rgb(205 213 223);
    --color-gray-modern-400: rgb(154 164 178);
    --color-gray-modern-500: rgb(105 117 134);
    --color-gray-modern-600: rgb(75 85 101);
    --color-gray-modern-700: rgb(54 65 82);
    --color-gray-modern-800: rgb(32 41 57);
    --color-gray-modern-900: rgb(18 25 38);
    --color-gray-modern-950: rgb(13 18 28);

    --color-gray-neutral-25: rgb(252 252 253);
    --color-gray-neutral-50: rgb(249 250 251);
    --color-gray-neutral-100: rgb(243 244 246);
    --color-gray-neutral-200: rgb(229 231 235);
    --color-gray-neutral-300: rgb(210 214 219);
    --color-gray-neutral-400: rgb(157 164 174);
    --color-gray-neutral-500: rgb(108 115 127);
    --color-gray-neutral-600: rgb(77 87 97);
    --color-gray-neutral-700: rgb(56 66 80);
    --color-gray-neutral-800: rgb(31 42 55);
    --color-gray-neutral-900: rgb(17 25 39);
    --color-gray-neutral-950: rgb(13 18 28);

    --color-gray-iron-25: rgb(252 252 252);
    --color-gray-iron-50: rgb(250 250 250);
    --color-gray-iron-100: rgb(244 244 245);
    --color-gray-iron-200: rgb(228 228 231);
    --color-gray-iron-300: rgb(209 209 214);
    --color-gray-iron-400: rgb(160 160 171);
    --color-gray-iron-500: rgb(112 112 123);
    --color-gray-iron-600: rgb(81 82 92);
    --color-gray-iron-700: rgb(63 63 70);
    --color-gray-iron-800: rgb(38 39 43);
    --color-gray-iron-900: rgb(26 26 30);
    --color-gray-iron-950: rgb(19 19 22);

    --color-gray-true-25: rgb(252 252 252);
    --color-gray-true-50: rgb(247 247 247);
    --color-gray-true-100: rgb(245 245 245);
    --color-gray-true-200: rgb(229 229 229);
    --color-gray-true-300: rgb(214 214 214);
    --color-gray-true-400: rgb(163 163 163);
    --color-gray-true-500: rgb(115 115 115);
    --color-gray-true-600: rgb(82 82 82);
    --color-gray-true-700: rgb(66 66 66);
    --color-gray-true-800: rgb(41 41 41);
    --color-gray-true-900: rgb(20 20 20);
    --color-gray-true-950: rgb(15 15 15);

    --color-gray-warm-25: rgb(253 253 252);
    --color-gray-warm-50: rgb(250 250 249);
    --color-gray-warm-100: rgb(245 245 244);
    --color-gray-warm-200: rgb(231 229 228);
    --color-gray-warm-300: rgb(215 211 208);
    --color-gray-warm-400: rgb(169 162 157);
    --color-gray-warm-500: rgb(121 113 107);
    --color-gray-warm-600: rgb(87 83 78);
    --color-gray-warm-700: rgb(68 64 60);
    --color-gray-warm-800: rgb(41 37 36);
    --color-gray-warm-900: rgb(28 25 23);
    --color-gray-warm-950: rgb(23 20 18);

    --color-moss-25: rgb(250 253 247);
    --color-moss-50: rgb(245 251 238);
    --color-moss-100: rgb(230 244 215);
    --color-moss-200: rgb(206 234 176);
    --color-moss-300: rgb(172 220 121);
    --color-moss-400: rgb(134 203 60);
    --color-moss-500: rgb(102 159 42);
    --color-moss-600: rgb(79 122 33);
    --color-moss-700: rgb(63 98 26);
    --color-moss-800: rgb(51 80 21);
    --color-moss-900: rgb(43 66 18);
    --color-moss-950: rgb(26 40 11);

    --color-green-light-25: rgb(250 254 245);
    --color-green-light-50: rgb(243 254 231);
    --color-green-light-100: rgb(227 251 204);
    --color-green-light-200: rgb(208 248 171);
    --color-green-light-300: rgb(166 239 103);
    --color-green-light-400: rgb(133 225 58);
    --color-green-light-500: rgb(102 198 28);
    --color-green-light-600: rgb(76 163 13);
    --color-green-light-700: rgb(59 124 15);
    --color-green-light-800: rgb(50 98 18);
    --color-green-light-900: rgb(43 83 20);
    --color-green-light-950: rgb(21 41 10);

    --color-green-25: rgb(246 254 249);
    --color-green-50: rgb(237 252 242);
    --color-green-100: rgb(211 248 223);
    --color-green-200: rgb(170 240 196);
    --color-green-300: rgb(115 226 163);
    --color-green-400: rgb(60 203 127);
    --color-green-500: rgb(22 179 100);
    --color-green-600: rgb(9 146 80);
    --color-green-700: rgb(8 116 67);
    --color-green-800: rgb(9 92 55);
    --color-green-900: rgb(8 76 46);
    --color-green-950: rgb(5 46 28);

    --color-teal-25: rgb(246 254 252);
    --color-teal-50: rgb(240 253 249);
    --color-teal-100: rgb(204 251 239);
    --color-teal-200: rgb(153 246 224);
    --color-teal-300: rgb(95 233 208);
    --color-teal-400: rgb(46 211 183);
    --color-teal-500: rgb(21 183 158);
    --color-teal-600: rgb(14 147 132);
    --color-teal-700: rgb(16 117 105);
    --color-teal-800: rgb(18 93 86);
    --color-teal-900: rgb(19 78 72);
    --color-teal-950: rgb(10 41 38);

    --color-cyan-25: rgb(245 254 255);
    --color-cyan-50: rgb(236 253 255);
    --color-cyan-100: rgb(207 249 254);
    --color-cyan-200: rgb(165 240 252);
    --color-cyan-300: rgb(103 227 249);
    --color-cyan-400: rgb(34 204 238);
    --color-cyan-500: rgb(6 174 212);
    --color-cyan-600: rgb(8 138 178);
    --color-cyan-700: rgb(14 112 144);
    --color-cyan-800: rgb(21 91 117);
    --color-cyan-900: rgb(22 76 99);
    --color-cyan-950: rgb(13 45 58);

    --color-blue-light-25: rgb(245 251 255);
    --color-blue-light-50: rgb(240 249 255);
    --color-blue-light-100: rgb(224 242 254);
    --color-blue-light-200: rgb(185 230 254);
    --color-blue-light-300: rgb(124 212 253);
    --color-blue-light-400: rgb(54 191 250);
    --color-blue-light-500: rgb(11 165 236);
    --color-blue-light-600: rgb(0 134 201);
    --color-blue-light-700: rgb(2 106 162);
    --color-blue-light-800: rgb(6 89 134);
    --color-blue-light-900: rgb(11 74 111);
    --color-blue-light-950: rgb(6 44 65);

    --color-blue-25: rgb(245 250 255);
    --color-blue-50: rgb(239 248 255);
    --color-blue-100: rgb(209 233 255);
    --color-blue-200: rgb(178 221 255);
    --color-blue-300: rgb(132 202 255);
    --color-blue-400: rgb(83 177 253);
    --color-blue-500: rgb(46 144 250);
    --color-blue-600: rgb(21 112 239);
    --color-blue-700: rgb(23 92 211);
    --color-blue-800: rgb(24 73 169);
    --color-blue-900: rgb(25 65 133);
    --color-blue-950: rgb(16 42 86);

    --color-blue-dark-25: rgb(245 248 255);
    --color-blue-dark-50: rgb(239 244 255);
    --color-blue-dark-100: rgb(209 224 255);
    --color-blue-dark-200: rgb(178 204 255);
    --color-blue-dark-300: rgb(132 173 255);
    --color-blue-dark-400: rgb(82 139 255);
    --color-blue-dark-500: rgb(41 112 255);
    --color-blue-dark-600: rgb(21 94 239);
    --color-blue-dark-700: rgb(0 78 235);
    --color-blue-dark-800: rgb(0 64 193);
    --color-blue-dark-900: rgb(0 53 158);
    --color-blue-dark-950: rgb(0 34 102);

    --color-indigo-25: rgb(245 248 255);
    --color-indigo-50: rgb(238 244 255);
    --color-indigo-100: rgb(224 234 255);
    --color-indigo-200: rgb(199 215 254);
    --color-indigo-300: rgb(164 188 253);
    --color-indigo-400: rgb(128 152 249);
    --color-indigo-500: rgb(97 114 243);
    --color-indigo-600: rgb(68 76 231);
    --color-indigo-700: rgb(53 56 205);
    --color-indigo-800: rgb(45 49 166);
    --color-indigo-900: rgb(45 50 130);
    --color-indigo-950: rgb(31 35 91);

    --color-violet-25: rgb(251 250 255);
    --color-violet-50: rgb(245 243 255);
    --color-violet-100: rgb(236 233 254);
    --color-violet-200: rgb(221 214 254);
    --color-violet-300: rgb(195 181 253);
    --color-violet-400: rgb(164 138 251);
    --color-violet-500: rgb(135 91 247);
    --color-violet-600: rgb(120 57 238);
    --color-violet-700: rgb(105 39 218);
    --color-violet-800: rgb(87 32 183);
    --color-violet-900: rgb(73 28 150);
    --color-violet-950: rgb(46 18 94);

    --color-purple-25: rgb(250 250 255);
    --color-purple-50: rgb(244 243 255);
    --color-purple-100: rgb(235 233 254);
    --color-purple-200: rgb(217 214 254);
    --color-purple-300: rgb(189 180 254);
    --color-purple-400: rgb(155 138 251);
    --color-purple-500: rgb(122 90 248);
    --color-purple-600: rgb(105 56 239);
    --color-purple-700: rgb(89 37 220);
    --color-purple-800: rgb(74 31 184);
    --color-purple-900: rgb(62 28 150);
    --color-purple-950: rgb(39 17 95);

    --color-fuchsia-25: rgb(254 250 255);
    --color-fuchsia-50: rgb(253 244 255);
    --color-fuchsia-100: rgb(251 232 255);
    --color-fuchsia-200: rgb(246 208 254);
    --color-fuchsia-300: rgb(238 170 253);
    --color-fuchsia-400: rgb(228 120 250);
    --color-fuchsia-500: rgb(212 68 241);
    --color-fuchsia-600: rgb(186 36 213);
    --color-fuchsia-700: rgb(159 26 177);
    --color-fuchsia-800: rgb(130 24 144);
    --color-fuchsia-900: rgb(111 24 119);
    --color-fuchsia-950: rgb(71 16 76);

    --color-pink-25: rgb(254 246 251);
    --color-pink-50: rgb(253 242 250);
    --color-pink-100: rgb(252 231 246);
    --color-pink-200: rgb(252 206 238);
    --color-pink-300: rgb(250 167 224);
    --color-pink-400: rgb(246 112 199);
    --color-pink-500: rgb(238 70 188);
    --color-pink-600: rgb(221 37 144);
    --color-pink-700: rgb(193 21 116);
    --color-pink-800: rgb(158 22 95);
    --color-pink-900: rgb(133 22 81);
    --color-pink-950: rgb(78 13 48);

    --color-rose-25: rgb(255 245 246);
    --color-rose-50: rgb(255 241 243);
    --color-rose-100: rgb(255 228 232);
    --color-rose-200: rgb(254 205 214);
    --color-rose-300: rgb(254 163 180);
    --color-rose-400: rgb(253 111 142);
    --color-rose-500: rgb(246 61 104);
    --color-rose-600: rgb(227 27 84);
    --color-rose-700: rgb(192 16 72);
    --color-rose-800: rgb(161 16 67);
    --color-rose-900: rgb(137 18 62);
    --color-rose-950: rgb(81 11 36);

    --color-orange-dark-25: rgb(255 249 245);
    --color-orange-dark-50: rgb(255 244 237);
    --color-orange-dark-100: rgb(255 230 213);
    --color-orange-dark-200: rgb(255 214 174);
    --color-orange-dark-300: rgb(255 156 102);
    --color-orange-dark-400: rgb(255 105 46);
    --color-orange-dark-500: rgb(255 68 5);
    --color-orange-dark-600: rgb(230 46 5);
    --color-orange-dark-700: rgb(188 27 6);
    --color-orange-dark-800: rgb(151 24 12);
    --color-orange-dark-900: rgb(119 26 13);
    --color-orange-dark-950: rgb(87 19 10);

    --color-orange-25: rgb(254 250 245);
    --color-orange-50: rgb(254 246 238);
    --color-orange-100: rgb(253 234 215);
    --color-orange-200: rgb(249 219 175);
    --color-orange-300: rgb(247 178 122);
    --color-orange-400: rgb(243 135 68);
    --color-orange-500: rgb(239 104 32);
    --color-orange-600: rgb(224 79 22);
    --color-orange-700: rgb(185 56 21);
    --color-orange-800: rgb(147 47 25);
    --color-orange-900: rgb(119 41 23);
    --color-orange-950: rgb(81 28 16);

    --color-yellow-25: rgb(254 253 240);
    --color-yellow-50: rgb(254 251 232);
    --color-yellow-100: rgb(254 247 195);
    --color-yellow-200: rgb(254 238 149);
    --color-yellow-300: rgb(253 226 114);
    --color-yellow-400: rgb(250 197 21);
    --color-yellow-500: rgb(234 170 8);
    --color-yellow-600: rgb(202 133 4);
    --color-yellow-700: rgb(161 92 7);
    --color-yellow-800: rgb(133 74 14);
    --color-yellow-900: rgb(113 59 18);
    --color-yellow-950: rgb(84 44 13);

    /* LIGHT MODE VARIABLES */

    --color-alpha-white: rgb(255 255 255);
    --color-alpha-black: rgb(0 0 0);

    /* UTILITY COLORS */
    --color-utility-blue-50: var(--color-blue-50);
    --color-utility-blue-100: var(--color-blue-100);
    --color-utility-blue-200: var(--color-blue-200);
    --color-utility-blue-300: var(--color-blue-300);
    --color-utility-blue-400: var(--color-blue-400);
    --color-utility-blue-500: var(--color-blue-500);
    --color-utility-blue-600: var(--color-blue-600);
    --color-utility-blue-700: var(--color-blue-700);

    --color-utility-brand-50: var(--color-brand-50);
    --color-utility-brand-50_alt: var(--color-brand-50);
    --color-utility-brand-100: var(--color-brand-100);
    --color-utility-brand-100_alt: var(--color-brand-100);
    --color-utility-brand-200: var(--color-brand-200);
    --color-utility-brand-200_alt: var(--color-brand-200);
    --color-utility-brand-300: var(--color-brand-300);
    --color-utility-brand-300_alt: var(--color-brand-300);
    --color-utility-brand-400: var(--color-brand-400);
    --color-utility-brand-400_alt: var(--color-brand-400);
    --color-utility-brand-500: var(--color-brand-500);
    --color-utility-brand-500_alt: var(--color-brand-500);
    --color-utility-brand-600: var(--color-brand-600);
    --color-utility-brand-600_alt: var(--color-brand-600);
    --color-utility-brand-700: var(--color-brand-700);
    --color-utility-brand-700_alt: var(--color-brand-700);
    --color-utility-brand-800: var(--color-brand-800);
    --color-utility-brand-800_alt: var(--color-brand-800);
    --color-utility-brand-900: var(--color-brand-900);
    --color-utility-brand-900_alt: var(--color-brand-900);

    --color-utility-gray-50: var(--color-gray-50);
    --color-utility-gray-100: var(--color-gray-100);
    --color-utility-gray-200: var(--color-gray-200);
    --color-utility-gray-300: var(--color-gray-300);
    --color-utility-gray-400: var(--color-gray-400);
    --color-utility-gray-500: var(--color-gray-500);
    --color-utility-gray-600: var(--color-gray-600);
    --color-utility-gray-700: var(--color-gray-700);
    --color-utility-gray-800: var(--color-gray-800);
    --color-utility-gray-900: var(--color-gray-900);

    --color-utility-error-50: var(--color-error-50);
    --color-utility-error-100: var(--color-error-100);
    --color-utility-error-200: var(--color-error-200);
    --color-utility-error-300: var(--color-error-300);
    --color-utility-error-400: var(--color-error-400);
    --color-utility-error-500: var(--color-error-500);
    --color-utility-error-600: var(--color-error-600);
    --color-utility-error-700: var(--color-error-700);

    --color-utility-warning-50: var(--color-warning-50);
    --color-utility-warning-100: var(--color-warning-100);
    --color-utility-warning-200: var(--color-warning-200);
    --color-utility-warning-300: var(--color-warning-300);
    --color-utility-warning-400: var(--color-warning-400);
    --color-utility-warning-500: var(--color-warning-500);
    --color-utility-warning-600: var(--color-warning-600);
    --color-utility-warning-700: var(--color-warning-700);

    --color-utility-success-50: var(--color-success-50);
    --color-utility-success-100: var(--color-success-100);
    --color-utility-success-200: var(--color-success-200);
    --color-utility-success-300: var(--color-success-300);
    --color-utility-success-400: var(--color-success-400);
    --color-utility-success-500: var(--color-success-500);
    --color-utility-success-600: var(--color-success-600);
    --color-utility-success-700: var(--color-success-700);

    --color-utility-orange-50: var(--color-orange-50);
    --color-utility-orange-100: var(--color-orange-100);
    --color-utility-orange-200: var(--color-orange-200);
    --color-utility-orange-300: var(--color-orange-300);
    --color-utility-orange-400: var(--color-orange-400);
    --color-utility-orange-500: var(--color-orange-500);
    --color-utility-orange-600: var(--color-orange-600);
    --color-utility-orange-700: var(--color-orange-700);

    --color-utility-blue-dark-50: var(--color-blue-dark-50);
    --color-utility-blue-dark-100: var(--color-blue-dark-100);
    --color-utility-blue-dark-200: var(--color-blue-dark-200);
    --color-utility-blue-dark-300: var(--color-blue-dark-300);
    --color-utility-blue-dark-400: var(--color-blue-dark-400);
    --color-utility-blue-dark-500: var(--color-blue-dark-500);
    --color-utility-blue-dark-600: var(--color-blue-dark-600);
    --color-utility-blue-dark-700: var(--color-blue-dark-700);

    --color-utility-indigo-50: var(--color-indigo-50);
    --color-utility-indigo-100: var(--color-indigo-100);
    --color-utility-indigo-200: var(--color-indigo-200);
    --color-utility-indigo-300: var(--color-indigo-300);
    --color-utility-indigo-400: var(--color-indigo-400);
    --color-utility-indigo-500: var(--color-indigo-500);
    --color-utility-indigo-600: var(--color-indigo-600);
    --color-utility-indigo-700: var(--color-indigo-700);

    --color-utility-fuchsia-50: var(--color-fuchsia-50);
    --color-utility-fuchsia-100: var(--color-fuchsia-100);
    --color-utility-fuchsia-200: var(--color-fuchsia-200);
    --color-utility-fuchsia-300: var(--color-fuchsia-300);
    --color-utility-fuchsia-400: var(--color-fuchsia-400);
    --color-utility-fuchsia-500: var(--color-fuchsia-500);
    --color-utility-fuchsia-600: var(--color-fuchsia-600);
    --color-utility-fuchsia-700: var(--color-fuchsia-700);

    --color-utility-pink-50: var(--color-pink-50);
    --color-utility-pink-100: var(--color-pink-100);
    --color-utility-pink-200: var(--color-pink-200);
    --color-utility-pink-300: var(--color-pink-300);
    --color-utility-pink-400: var(--color-pink-400);
    --color-utility-pink-500: var(--color-pink-500);
    --color-utility-pink-600: var(--color-pink-600);
    --color-utility-pink-700: var(--color-pink-700);

    --color-utility-purple-50: var(--color-purple-50);
    --color-utility-purple-100: var(--color-purple-100);
    --color-utility-purple-200: var(--color-purple-200);
    --color-utility-purple-300: var(--color-purple-300);
    --color-utility-purple-400: var(--color-purple-400);
    --color-utility-purple-500: var(--color-purple-500);
    --color-utility-purple-600: var(--color-purple-600);
    --color-utility-purple-700: var(--color-purple-700);

    --color-utility-orange-dark-50: var(--color-orange-dark-50);
    --color-utility-orange-dark-100: var(--color-orange-dark-100);
    --color-utility-orange-dark-200: var(--color-orange-dark-200);
    --color-utility-orange-dark-300: var(--color-orange-dark-300);
    --color-utility-orange-dark-400: var(--color-orange-dark-400);
    --color-utility-orange-dark-500: var(--color-orange-dark-500);
    --color-utility-orange-dark-600: var(--color-orange-dark-600);
    --color-utility-orange-dark-700: var(--color-orange-dark-700);

    --color-utility-blue-light-50: var(--color-blue-light-50);
    --color-utility-blue-light-100: var(--color-blue-light-100);
    --color-utility-blue-light-200: var(--color-blue-light-200);
    --color-utility-blue-light-300: var(--color-blue-light-300);
    --color-utility-blue-light-400: var(--color-blue-light-400);
    --color-utility-blue-light-500: var(--color-blue-light-500);
    --color-utility-blue-light-600: var(--color-blue-light-600);
    --color-utility-blue-light-700: var(--color-blue-light-700);

    --color-utility-gray-blue-50: var(--color-gray-blue-50);
    --color-utility-gray-blue-100: var(--color-gray-blue-100);
    --color-utility-gray-blue-200: var(--color-gray-blue-200);
    --color-utility-gray-blue-300: var(--color-gray-blue-300);
    --color-utility-gray-blue-400: var(--color-gray-blue-400);
    --color-utility-gray-blue-500: var(--color-gray-blue-500);
    --color-utility-gray-blue-600: var(--color-gray-blue-600);
    --color-utility-gray-blue-700: var(--color-gray-blue-700);

    --color-utility-green-50: var(--color-green-50);
    --color-utility-green-100: var(--color-green-100);
    --color-utility-green-200: var(--color-green-200);
    --color-utility-green-300: var(--color-green-300);
    --color-utility-green-400: var(--color-green-400);
    --color-utility-green-500: var(--color-green-500);
    --color-utility-green-600: var(--color-green-600);
    --color-utility-green-700: var(--color-green-700);

    --color-utility-yellow-50: var(--color-yellow-50);
    --color-utility-yellow-100: var(--color-yellow-100);
    --color-utility-yellow-200: var(--color-yellow-200);
    --color-utility-yellow-300: var(--color-yellow-300);
    --color-utility-yellow-400: var(--color-yellow-400);
    --color-utility-yellow-500: var(--color-yellow-500);
    --color-utility-yellow-600: var(--color-yellow-600);
    --color-utility-yellow-700: var(--color-yellow-700);

    /* TEXT COLORS */
    --color-text-white: var(--color-white);
    --color-text-primary: var(--color-gray-900);
    --color-text-secondary: var(--color-gray-700);
    --color-text-secondary_hover: var(--color-gray-800);
    --color-text-tertiary: var(--color-gray-600);
    --color-text-tertiary_hover: var(--color-gray-700);
    --color-text-quaternary: var(--color-gray-500);
    --color-text-error-primary: var(--color-error-600);
    --color-text-error-primary_hover: var(--color-error-700);
    --color-text-warning-primary: var(--color-warning-600);
    --color-text-success-primary: var(--color-success-600);
    --color-text-disabled: var(--color-gray-500);
    --color-text-placeholder: var(--color-gray-500);
    --color-text-placeholder_subtle: var(--color-gray-300);
    --color-text-primary_on-brand: var(--color-white);
    --color-text-secondary_on-brand: var(--color-brand-200);
    --color-text-tertiary_on-brand: var(--color-brand-200);
    --color-text-quaternary_on-brand: var(--color-brand-300);
    --color-text-brand-primary: var(--color-brand-900);
    --color-text-brand-secondary: var(--color-brand-700);
    --color-text-brand-secondary_hover: var(--color-brand-800);
    --color-text-brand-tertiary: var(--color-brand-600);
    --color-text-brand-tertiary_alt: var(--color-brand-600);

    /* BORDER COLORS */
    --color-border-primary: var(--color-gray-300);
    --color-border-secondary: var(--color-gray-200);
    --color-border-secondary_alt: rgb(0 0 0 / 0.08);
    --color-border-tertiary: var(--color-gray-100);
    --color-border-error: var(--color-error-500);
    --color-border-error_subtle: var(--color-error-300);
    --color-border-disabled: var(--color-gray-300);
    --color-border-disabled_subtle: var(--color-gray-200);
    --color-border-brand: var(--color-brand-500);
    --color-border-brand_alt: var(--color-brand-600);

    /* FOREGROUND COLORS */
    --color-fg-white: var(--color-white);
    --color-fg-primary: var(--color-gray-900);
    --color-fg-secondary: var(--color-gray-700);
    --color-fg-secondary_hover: var(--color-gray-800);
    --color-fg-tertiary: var(--color-gray-600);
    --color-fg-tertiary_hover: var(--color-gray-700);
    --color-fg-quaternary: var(--color-gray-400);
    --color-fg-quaternary_hover: var(--color-gray-500);
    --color-fg-warning-primary: var(--color-warning-600);
    --color-fg-warning-secondary: var(--color-warning-500);
    --color-fg-success-primary: var(--color-success-600);
    --color-fg-success-secondary: var(--color-success-500);
    --color-fg-error-primary: var(--color-error-600);
    --color-fg-error-secondary: var(--color-error-500);
    --color-fg-disabled: var(--color-gray-400);
    --color-fg-disabled_subtle: var(--color-gray-300);
    --color-fg-brand-primary: var(--color-brand-600);
    --color-fg-brand-primary_alt: var(--color-fg-brand-primary);
    --color-fg-brand-secondary: var(--color-brand-500);
    --color-fg-brand-secondary_alt: var(--color-fg-brand-secondary);
    --color-fg-brand-secondary_hover: var(--color-brand-600);

    /* BACKGROUND COLORS */
    --color-bg-primary: var(--color-white);
    --color-bg-primary-solid: var(--color-gray-950);
    --color-bg-primary_alt: var(--color-white);
    --color-bg-primary_hover: var(--color-gray-50);
    --color-bg-secondary: var(--color-gray-50);
    --color-bg-secondary-solid: var(--color-gray-600);
    --color-bg-secondary_subtle: var(--color-gray-25);
    --color-bg-secondary_hover: var(--color-gray-100);
    --color-bg-secondary_alt: var(--color-gray-50);
    --color-bg-tertiary: var(--color-gray-100);
    --color-bg-quaternary: var(--color-gray-200);
    --color-bg-error-primary: var(--color-error-50);
    --color-bg-error-secondary: var(--color-error-100);
    --color-bg-error-solid: var(--color-error-600);
    --color-bg-error-solid_hover: var(--color-error-700);
    --color-bg-warning-primary: var(--color-warning-50);
    --color-bg-warning-secondary: var(--color-warning-100);
    --color-bg-warning-solid: var(--color-warning-600);
    --color-bg-success-primary: var(--color-success-50);
    --color-bg-success-secondary: var(--color-success-100);
    --color-bg-success-solid: var(--color-success-600);
    --color-bg-disabled: var(--color-gray-100);
    --color-bg-disabled_subtle: var(--color-gray-50);
    --color-bg-active: var(--color-gray-50);
    --color-bg-overlay: var(--color-gray-950);
    --color-bg-brand-primary: var(--color-brand-50);
    --color-bg-brand-primary_alt: var(--color-brand-50);
    --color-bg-brand-secondary: var(--color-brand-100);
    --color-bg-brand-solid: var(--color-brand-600);
    --color-bg-brand-solid_hover: var(--color-brand-700);
    --color-bg-brand-section: var(--color-brand-800);
    --color-bg-brand-section_subtle: var(--color-brand-700);

    /* COMPONENT COLORS */
    --color-app-store-badge-border: rgb(166 166 166);
    --color-avatar-bg: var(--color-gray-100);
    --color-avatar-contrast-border: rgb(0 0 0 / 0.08);
    --color-avatar-profile-photo-border: var(--color-white);
    --color-avatar-styles-bg-neutral: rgb(224 224 224);
    --color-button-destructive-primary-icon: var(--color-error-300);
    --color-button-destructive-primary-icon_hover: var(--color-error-200);
    --color-button-primary-icon: var(--color-brand-300);
    --color-button-primary-icon_hover: var(--color-brand-200);
    --color-featured-icon-light-fg-brand: var(--color-brand-600);
    --color-featured-icon-light-fg-error: var(--color-error-600);
    --color-featured-icon-light-fg-gray: var(--color-gray-500);
    --color-featured-icon-light-fg-success: var(--color-success-600);
    --color-featured-icon-light-fg-warning: var(--color-warning-600);
    --color-focus-ring-error: var(--color-error-500);
    --color-focus-ring: var(--color-brand-500);
    --color-footer-button-fg: var(--color-brand-200);
    --color-footer-button-fg_hover: var(--color-white);
    --color-icon-fg-brand: var(--color-brand-600);
    --color-icon-fg-brand_on-brand: var(--color-brand-200);
    --color-screen-mockup-border: var(--color-gray-900);
    --color-slider-handle-bg: var(--color-white);
    --color-slider-handle-border: var(--color-brand-600);
    --color-toggle-border: var(--color-gray-300);
    --color-toggle-button-fg_disabled: var(--color-gray-50);
    --color-toggle-slim-border_pressed-hover: var(--color-bg-brand-solid_hover);
    --color-toggle-slim-border_pressed: var(--color-bg-brand-solid);
    --color-tooltip-supporting-text: var(--color-gray-300);
    --color-text-editor-icon-fg: var(--color-gray-400);
    --color-text-editor-icon-fg_active: var(--color-gray-500);

    /* BACKGROUND PROPERTY COLORS */
    --background-color-primary: var(--color-bg-primary);
    --background-color-primary-solid: var(--color-bg-primary-solid);
    --background-color-primary_alt: var(--color-bg-primary_alt);
    --background-color-primary_hover: var(--color-bg-primary_hover);
    --background-color-secondary: var(--color-bg-secondary);
    --background-color-secondary-solid: var(--color-bg-secondary-solid);
    --background-color-secondary_alt: var(--color-bg-secondary_alt);
    --background-color-secondary_hover: var(--color-bg-secondary_hover);
    --background-color-secondary_subtle: var(--color-bg-secondary_subtle);
    --background-color-tertiary: var(--color-bg-tertiary);
    --background-color-quaternary: var(--color-bg-quaternary);
    --background-color-active: var(--color-bg-active);
    --background-color-disabled: var(--color-bg-disabled);
    --background-color-disabled_subtle: var(--color-bg-disabled_subtle);
    --background-color-overlay: var(--color-bg-overlay);
    --background-color-brand-primary: var(--color-bg-brand-primary);
    --background-color-brand-primary_alt: var(--color-bg-brand-primary_alt);
    --background-color-brand-secondary: var(--color-bg-brand-secondary);
    --background-color-brand-solid: var(--color-bg-brand-solid);
    --background-color-brand-solid_hover: var(--color-bg-brand-solid_hover);
    --background-color-brand-section: var(--color-bg-brand-section);
    --background-color-brand-section_subtle: var(--color-bg-brand-section_subtle);
    --background-color-error-primary: var(--color-bg-error-primary);
    --background-color-error-secondary: var(--color-bg-error-secondary);
    --background-color-error-solid: var(--color-bg-error-solid);
    --background-color-error-solid_hover: var(--color-bg-error-solid_hover);
    --background-color-warning-primary: var(--color-bg-warning-primary);
    --background-color-warning-secondary: var(--color-bg-warning-secondary);
    --background-color-warning-solid: var(--color-bg-warning-solid);
    --background-color-success-primary: var(--color-bg-success-primary);
    --background-color-success-secondary: var(--color-bg-success-secondary);
    --background-color-border-tertiary: var(--color-border-tertiary);
    --background-color-success-solid: var(--color-bg-success-solid);
    --background-color-border-brand: var(--color-border-brand);
    --background-color-border-brand_alt: var(--color-border-brand_alt);

    /* TEXT PROPERTY COLORS */
    --text-color-primary: var(--color-text-primary);
    --text-color-primary_on-brand: var(--color-text-primary_on-brand);
    --text-color-secondary: var(--color-text-secondary);
    --text-color-secondary_hover: var(--color-text-secondary_hover);
    --text-color-secondary_on-brand: var(--color-text-secondary_on-brand);
    --text-color-tertiary: var(--color-text-tertiary);
    --text-color-tertiary_hover: var(--color-text-tertiary_hover);
    --text-color-tertiary_on-brand: var(--color-text-tertiary_on-brand);
    --text-color-quaternary: var(--color-text-quaternary);
    --text-color-quaternary_on-brand: var(--color-text-quaternary_on-brand);
    --text-color-disabled: var(--color-text-disabled);
    --text-color-placeholder: var(--color-text-placeholder);
    --text-color-placeholder_subtle: var(--color-text-placeholder_subtle);
    --text-color-brand-primary: var(--color-text-brand-primary);
    --text-color-brand-secondary: var(--color-text-brand-secondary);
    --text-color-brand-secondary_hover: var(--color-text-brand-secondary_hover);
    --text-color-brand-tertiary: var(--color-text-brand-tertiary);
    --text-color-brand-tertiary_alt: var(--color-text-brand-tertiary_alt);
    --text-color-error-primary: var(--color-text-error-primary);
    --text-color-error-primary_hover: var(--color-text-error-primary_hover);
    --text-color-warning-primary: var(--color-text-warning-primary);
    --text-color-success-primary: var(--color-text-success-primary);
    --text-color-tooltip-supporting-text: var(--color-tooltip-supporting-text);

    /* BORDER PROPERTY COLORS */
    --border-color-primary: var(--color-border-primary);
    --border-color-secondary: var(--color-border-secondary);
    --border-color-secondary_alt: var(--color-border-secondary_alt);
    --border-color-tertiary: var(--color-border-tertiary);
    --border-color-disabled: var(--color-border-disabled);
    --border-color-disabled_subtle: var(--color-border-disabled_subtle);
    --border-color-error: var(--color-border-error);
    --border-color-error_subtle: var(--color-border-error_subtle);
    --border-color-brand: var(--color-border-brand);
    --border-color-brand_alt: var(--color-border-brand_alt);
    --border-color-brand-solid: var(--color-bg-brand-solid);
    --border-color-brand-solid_hover: var(--color-bg-brand-solid_hover);

    /* RING PROPERTY COLORS */
    --ring-color-primary: var(--color-border-primary);
    --ring-color-secondary: var(--color-border-secondary);
    --ring-color-secondary_alt: var(--color-border-secondary_alt);
    --ring-color-tertiary: var(--color-border-tertiary);
    --ring-color-error: var(--color-border-error);
    --ring-color-error_subtle: var(--color-border-error_subtle);
    --ring-color-disabled: var(--color-border-disabled);
    --ring-color-disabled_subtle: var(--color-border-disabled_subtle);
    --ring-color-brand: var(--color-border-brand);
    --ring-color-brand-solid: var(--color-bg-brand-solid);
    --ring-color-brand-solid_hover: var(--color-bg-brand-solid_hover);
    --ring-color-brand_alt: var(--color-border-brand_alt);
    --ring-color-bg-brand-solid: var(--color-bg-brand-solid);

    /* OUTLINE PROPERTY COLORS */
    --outline-color-primary: var(--color-border-primary);
    --outline-color-secondary: var(--color-border-secondary);
    --outline-color-secondary_alt: var(--color-border-secondary_alt);
    --outline-color-tertiary: var(--color-border-tertiary);
    --outline-color-error: var(--color-border-error);
    --outline-color-error_subtle: var(--color-border-error_subtle);
    --outline-color-disabled: var(--color-border-disabled);
    --outline-color-disabled_subtle: var(--color-border-disabled_subtle);
    --outline-color-brand: var(--color-border-brand);
    --outline-color-brand-solid: var(--color-bg-brand-solid);
    --outline-color-brand-solid_hover: var(--color-bg-brand-solid_hover);
    --outline-color-brand_alt: var(--color-border-brand_alt);
}

@layer base {
    /* DARK MODE VARIABLES */

    :where(.dark, .dark-mode) {
        --color-alpha-white: rgb(12 14 18);
        --color-alpha-black: rgb(255 255 255);

        /* UTILITY COLORS */

        --color-gray-25: rgb(250 250 250);
        --color-gray-50: rgb(247 247 247);
        --color-gray-100: rgb(240 240 241);
        --color-gray-200: rgb(236 236 237);
        --color-gray-300: rgb(206 207 210);
        --color-gray-400: rgb(148 151 156);
        --color-gray-500: rgb(133 136 142);
        --color-gray-600: rgb(97 101 108);
        --color-gray-700: rgb(55 58 65);
        --color-gray-800: rgb(34 38 47);
        --color-gray-900: rgb(19 22 27);
        --color-gray-950: rgb(12 14 18);

        --color-utility-blue-50: var(--color-blue-950);
        --color-utility-blue-100: var(--color-blue-900);
        --color-utility-blue-200: var(--color-blue-800);
        --color-utility-blue-300: var(--color-blue-700);
        --color-utility-blue-400: var(--color-blue-600);
        --color-utility-blue-500: var(--color-blue-500);
        --color-utility-blue-600: var(--color-blue-400);
        --color-utility-blue-700: var(--color-blue-300);

        --color-utility-brand-50: var(--color-brand-950);
        --color-utility-brand-50_alt: var(--color-utility-gray-50);
        --color-utility-brand-100: var(--color-brand-900);
        --color-utility-brand-100_alt: var(--color-utility-gray-100);
        --color-utility-brand-200: var(--color-brand-800);
        --color-utility-brand-200_alt: var(--color-utility-gray-200);
        --color-utility-brand-300: var(--color-brand-700);
        --color-utility-brand-300_alt: var(--color-utility-gray-300);
        --color-utility-brand-400: var(--color-brand-600);
        --color-utility-brand-400_alt: var(--color-utility-gray-400);
        --color-utility-brand-500: var(--color-brand-500);
        --color-utility-brand-500_alt: var(--color-utility-gray-500);
        --color-utility-brand-600: var(--color-brand-400);
        --color-utility-brand-600_alt: var(--color-utility-gray-600);
        --color-utility-brand-700: var(--color-brand-300);
        --color-utility-brand-700_alt: var(--color-utility-gray-700);
        --color-utility-brand-800: var(--color-brand-200);
        --color-utility-brand-800_alt: var(--color-utility-gray-800);
        --color-utility-brand-900: var(--color-brand-100);
        --color-utility-brand-900_alt: var(--color-utility-gray-900);

        --color-utility-gray-50: var(--color-gray-900);
        --color-utility-gray-100: var(--color-gray-800);
        --color-utility-gray-200: var(--color-gray-700);
        --color-utility-gray-300: var(--color-gray-700);
        --color-utility-gray-400: var(--color-gray-600);
        --color-utility-gray-500: var(--color-gray-500);
        --color-utility-gray-600: var(--color-gray-400);
        --color-utility-gray-700: var(--color-gray-300);
        --color-utility-gray-800: var(--color-gray-200);
        --color-utility-gray-900: var(--color-gray-100);

        --color-utility-error-50: var(--color-error-950);
        --color-utility-error-100: var(--color-error-900);
        --color-utility-error-200: var(--color-error-800);
        --color-utility-error-300: var(--color-error-700);
        --color-utility-error-400: var(--color-error-600);
        --color-utility-error-500: var(--color-error-500);
        --color-utility-error-600: var(--color-error-400);
        --color-utility-error-700: var(--color-error-300);

        --color-utility-warning-50: var(--color-warning-950);
        --color-utility-warning-100: var(--color-warning-900);
        --color-utility-warning-200: var(--color-warning-800);
        --color-utility-warning-300: var(--color-warning-700);
        --color-utility-warning-400: var(--color-warning-600);
        --color-utility-warning-500: var(--color-warning-500);
        --color-utility-warning-600: var(--color-warning-400);
        --color-utility-warning-700: var(--color-warning-300);

        --color-utility-success-50: var(--color-success-950);
        --color-utility-success-100: var(--color-success-900);
        --color-utility-success-200: var(--color-success-800);
        --color-utility-success-300: var(--color-success-700);
        --color-utility-success-400: var(--color-success-600);
        --color-utility-success-500: var(--color-success-500);
        --color-utility-success-600: var(--color-success-400);
        --color-utility-success-700: var(--color-success-300);

        --color-utility-orange-50: var(--color-orange-950);
        --color-utility-orange-100: var(--color-orange-900);
        --color-utility-orange-200: var(--color-orange-800);
        --color-utility-orange-300: var(--color-orange-700);
        --color-utility-orange-400: var(--color-orange-600);
        --color-utility-orange-500: var(--color-orange-500);
        --color-utility-orange-600: var(--color-orange-400);
        --color-utility-orange-700: var(--color-orange-300);

        --color-utility-blue-dark-50: var(--color-blue-dark-950);
        --color-utility-blue-dark-100: var(--color-blue-dark-900);
        --color-utility-blue-dark-200: var(--color-blue-dark-800);
        --color-utility-blue-dark-300: var(--color-blue-dark-700);
        --color-utility-blue-dark-400: var(--color-blue-dark-600);
        --color-utility-blue-dark-500: var(--color-blue-dark-500);
        --color-utility-blue-dark-600: var(--color-blue-dark-400);
        --color-utility-blue-dark-700: var(--color-blue-dark-300);

        --color-utility-indigo-50: var(--color-indigo-950);
        --color-utility-indigo-100: var(--color-indigo-900);
        --color-utility-indigo-200: var(--color-indigo-800);
        --color-utility-indigo-300: var(--color-indigo-700);
        --color-utility-indigo-400: var(--color-indigo-600);
        --color-utility-indigo-500: var(--color-indigo-500);
        --color-utility-indigo-600: var(--color-indigo-400);
        --color-utility-indigo-700: var(--color-indigo-300);

        --color-utility-fuchsia-50: var(--color-fuchsia-950);
        --color-utility-fuchsia-100: var(--color-fuchsia-900);
        --color-utility-fuchsia-200: var(--color-fuchsia-800);
        --color-utility-fuchsia-300: var(--color-fuchsia-700);
        --color-utility-fuchsia-400: var(--color-fuchsia-600);
        --color-utility-fuchsia-500: var(--color-fuchsia-500);
        --color-utility-fuchsia-600: var(--color-fuchsia-400);
        --color-utility-fuchsia-700: var(--color-fuchsia-300);

        --color-utility-pink-50: var(--color-pink-950);
        --color-utility-pink-100: var(--color-pink-900);
        --color-utility-pink-200: var(--color-pink-800);
        --color-utility-pink-300: var(--color-pink-700);
        --color-utility-pink-400: var(--color-pink-600);
        --color-utility-pink-500: var(--color-pink-500);
        --color-utility-pink-600: var(--color-pink-400);
        --color-utility-pink-700: var(--color-pink-300);

        --color-utility-purple-50: var(--color-purple-950);
        --color-utility-purple-100: var(--color-purple-900);
        --color-utility-purple-200: var(--color-purple-800);
        --color-utility-purple-300: var(--color-purple-700);
        --color-utility-purple-400: var(--color-purple-600);
        --color-utility-purple-500: var(--color-purple-500);
        --color-utility-purple-600: var(--color-purple-400);
        --color-utility-purple-700: var(--color-purple-300);

        --color-utility-orange-dark-50: var(--color-orange-dark-950);
        --color-utility-orange-dark-100: var(--color-orange-dark-900);
        --color-utility-orange-dark-200: var(--color-orange-dark-800);
        --color-utility-orange-dark-300: var(--color-orange-dark-700);
        --color-utility-orange-dark-400: var(--color-orange-dark-600);
        --color-utility-orange-dark-500: var(--color-orange-dark-500);
        --color-utility-orange-dark-600: var(--color-orange-dark-400);
        --color-utility-orange-dark-700: var(--color-orange-dark-300);

        --color-utility-blue-light-50: var(--color-blue-light-950);
        --color-utility-blue-light-100: var(--color-blue-light-900);
        --color-utility-blue-light-200: var(--color-blue-light-800);
        --color-utility-blue-light-300: var(--color-blue-light-700);
        --color-utility-blue-light-400: var(--color-blue-light-600);
        --color-utility-blue-light-500: var(--color-blue-light-500);
        --color-utility-blue-light-600: var(--color-blue-light-400);
        --color-utility-blue-light-700: var(--color-blue-light-300);

        --color-utility-gray-blue-50: var(--color-gray-blue-950);
        --color-utility-gray-blue-100: var(--color-gray-blue-900);
        --color-utility-gray-blue-200: var(--color-gray-blue-800);
        --color-utility-gray-blue-300: var(--color-gray-blue-700);
        --color-utility-gray-blue-400: var(--color-gray-blue-600);
        --color-utility-gray-blue-500: var(--color-gray-blue-500);
        --color-utility-gray-blue-600: var(--color-gray-blue-400);
        --color-utility-gray-blue-700: var(--color-gray-blue-300);

        --color-utility-green-50: var(--color-green-950);
        --color-utility-green-100: var(--color-green-900);
        --color-utility-green-200: var(--color-green-800);
        --color-utility-green-300: var(--color-green-700);
        --color-utility-green-400: var(--color-green-600);
        --color-utility-green-500: var(--color-green-500);
        --color-utility-green-600: var(--color-green-400);
        --color-utility-green-700: var(--color-green-300);

        --color-utility-yellow-50: var(--color-yellow-950);
        --color-utility-yellow-100: var(--color-yellow-900);
        --color-utility-yellow-200: var(--color-yellow-800);
        --color-utility-yellow-300: var(--color-yellow-700);
        --color-utility-yellow-400: var(--color-yellow-600);
        --color-utility-yellow-500: var(--color-yellow-500);
        --color-utility-yellow-600: var(--color-yellow-400);
        --color-utility-yellow-700: var(--color-yellow-300);

        /* TEXT COLORS */
        --color-text-white: var(--color-white);
        --color-text-primary: var(--color-gray-50);
        --color-text-secondary: var(--color-gray-300);
        --color-text-secondary_hover: var(--color-gray-200);
        --color-text-tertiary: var(--color-gray-400);
        --color-text-tertiary_hover: var(--color-gray-300);
        --color-text-quaternary: var(--color-gray-400);
        --color-text-error-primary: var(--color-error-400);
        --color-text-warning-primary: var(--color-warning-400);
        --color-text-success-primary: var(--color-success-400);
        --color-text-disabled: var(--color-gray-500);
        --color-text-brand-primary: var(--color-gray-50);
        --color-text-brand-secondary: var(--color-gray-300);
        --color-text-brand-tertiary: var(--color-gray-400);
        --color-text-placeholder: var(--color-gray-500);
        --color-text-placeholder_subtle: var(--color-gray-700);
        --color-text-primary_on-brand: var(--color-gray-50);
        --color-text-secondary_on-brand: var(--color-gray-300);
        --color-text-tertiary_on-brand: var(--color-gray-400);
        --color-text-quaternary_on-brand: var(--color-gray-400);
        --color-text-brand-secondary_hover: var(--color-gray-200);
        --color-text-brand-tertiary_alt: var(--color-gray-50);
        --color-text-error-primary_hover: var(--color-error-300);

        /* BORDER COLORS */
        --color-border-primary: var(--color-gray-700);
        --color-border-secondary: var(--color-gray-800);
        --color-border-secondary_alt: var(--color-gray-800);
        --color-border-tertiary: var(--color-gray-800);
        --color-border-brand: var(--color-brand-400);
        --color-border-brand_alt: var(--color-gray-700);
        --color-border-error: var(--color-error-400);
        --color-border-error_subtle: var(--color-error-500);
        --color-border-disabled: var(--color-gray-700);
        --color-border-disabled_subtle: var(--color-gray-800);

        /* FOREGROUND COLORS */
        --color-fg-white: var(--color-white);
        --color-fg-primary: var(--color-white);
        --color-fg-secondary: var(--color-gray-300);
        --color-fg-tertiary: var(--color-gray-400);
        --color-fg-tertiary_hover: var(--color-gray-300);
        --color-fg-quaternary: var(--color-gray-600);
        --color-fg-quaternary_hover: var(--color-gray-500);
        --color-fg-error-primary: var(--color-error-500);
        --color-fg-error-secondary: var(--color-error-400);
        --color-fg-warning-primary: var(--color-warning-500);
        --color-fg-warning-secondary: var(--color-warning-400);
        --color-fg-success-primary: var(--color-success-500);
        --color-fg-success-secondary: var(--color-success-400);
        --color-fg-secondary_hover: var(--color-gray-200);
        --color-fg-disabled: var(--color-gray-500);
        --color-fg-disabled_subtle: var(--color-gray-600);
        --color-fg-brand-primary: var(--color-brand-500);
        --color-fg-brand-secondary: var(--color-brand-500);
        --color-fg-brand-primary_alt: var(--color-gray-300);
        --color-fg-brand-secondary_alt: var(--color-gray-600);
        --color-fg-brand-secondary_hover: var(--color-gray-500);

        /* BACKGROUND COLORS */
        --color-bg-primary: var(--color-gray-950);
        --color-bg-primary-solid: var(--color-bg-secondary);
        --color-bg-primary_alt: var(--color-bg-secondary);
        --color-bg-primary_hover: var(--color-gray-800);
        --color-bg-secondary: var(--color-gray-900);
        --color-bg-secondary-solid: var(--color-gray-600);
        --color-bg-secondary_subtle: var(--color-gray-900);
        --color-bg-secondary_hover: var(--color-gray-800);
        --color-bg-tertiary: var(--color-gray-800);
        --color-bg-quaternary: var(--color-gray-700);
        --color-bg-error-primary: var(--color-error-950);
        --color-bg-error-secondary: var(--color-error-600);
        --color-bg-error-solid: var(--color-error-600);
        --color-bg-error-solid_hover: var(--color-error-500);
        --color-bg-warning-primary: var(--color-warning-950);
        --color-bg-warning-secondary: var(--color-warning-600);
        --color-bg-warning-solid: var(--color-warning-600);
        --color-bg-success-primary: var(--color-success-950);
        --color-bg-success-secondary: var(--color-success-600);
        --color-bg-success-solid: var(--color-success-600);
        --color-bg-active: var(--color-gray-800);
        --color-bg-disabled: var(--color-gray-800);
        --color-bg-disabled_subtle: var(--color-gray-900);
        --color-bg-brand-primary: var(--color-brand-500);
        --color-bg-brand-primary_alt: var(--color-bg-secondary);
        --color-bg-brand-secondary: var(--color-brand-600);
        --color-bg-secondary_alt: var(--color-bg-primary);
        --color-bg-brand-solid: var(--color-brand-600);
        --color-bg-brand-solid_hover: var(--color-brand-500);
        --color-bg-overlay: var(--color-gray-800);
        --color-bg-brand-section: var(--color-bg-secondary);
        --color-bg-brand-section_subtle: var(--color-bg-primary);

        /* COMPONENT COLORS */
        --color-app-store-badge-border: var(--color-white);
        --color-avatar-bg: var(--color-gray-800);
        --color-avatar-contrast-border: rgb(255 255 255 / 0.12);
        --color-avatar-profile-photo-border: var(--color-gray-950);
        --color-avatar-styles-bg-neutral: rgb(224 224 224 / 1);
        --color-button-destructive-primary-icon: var(--color-error-300);
        --color-button-destructive-primary-icon_hover: var(--color-error-200);
        --color-button-primary-icon: var(--color-brand-300);
        --color-button-primary-icon_hover: var(--color-brand-200);
        --color-featured-icon-light-fg-brand: var(--color-brand-200);
        --color-featured-icon-light-fg-error: var(--color-error-200);
        --color-featured-icon-light-fg-gray: var(--color-gray-200);
        --color-featured-icon-light-fg-success: var(--color-success-200);
        --color-featured-icon-light-fg-warning: var(--color-warning-200);
        --color-focus-ring-error: var(--color-error-500);
        --color-focus-ring: var(--color-brand-500);
        --color-footer-button-fg: var(--color-gray-300);
        --color-footer-button-fg_hover: var(--color-gray-100);
        --color-icon-fg-brand: var(--color-gray-400);
        --color-icon-fg-brand_on-brand: var(--color-gray-400);
        --color-nav-item-button-icon-fg: var(--color-gray-400);
        --color-nav-item-button-icon-fg_active: var(--color-gray-300);
        --color-nav-item-icon-fg: var(--color-gray-400);
        --color-nav-item-icon-fg_active: var(--color-gray-300);
        --color-screen-mockup-border: var(--color-gray-700);
        --color-slider-handle-bg: var(--color-fg-brand-primary);
        --color-slider-handle-border: var(--color-bg-primary);
        --color-toggle-border: var(--color-transparent);
        --color-toggle-button-fg_disabled: var(--color-gray-600);
        --color-toggle-slim-border_pressed-hover: var(--color-transparent);
        --color-toggle-slim-border_pressed: var(--color-transparent);
        --color-tooltip-supporting-text: var(--color-gray-300);
        --color-text-editor-icon-fg: var(--color-gray-400);
        --color-text-editor-icon-fg_active: var(--color-white);

        /* BACKGROUND PROPERTY COLORS */
        --background-color-primary: var(--color-bg-primary);
        --background-color-primary-solid: var(--color-bg-primary-solid);
        --background-color-primary_alt: var(--color-bg-primary_alt);
        --background-color-primary_hover: var(--color-bg-primary_hover);
        --background-color-secondary: var(--color-bg-secondary);
        --background-color-secondary-solid: var(--color-bg-secondary-solid);
        --background-color-secondary_alt: var(--color-bg-secondary_alt);
        --background-color-secondary_hover: var(--color-bg-secondary_hover);
        --background-color-secondary_subtle: var(--color-bg-secondary_subtle);
        --background-color-tertiary: var(--color-bg-tertiary);
        --background-color-quaternary: var(--color-bg-quaternary);
        --background-color-active: var(--color-bg-active);
        --background-color-disabled: var(--color-bg-disabled);
        --background-color-disabled_subtle: var(--color-bg-disabled_subtle);
        --background-color-overlay: var(--color-bg-overlay);
        --background-color-brand-primary: var(--color-bg-brand-primary);
        --background-color-brand-primary_alt: var(--color-bg-brand-primary_alt);
        --background-color-brand-secondary: var(--color-bg-brand-secondary);
        --background-color-brand-solid: var(--color-bg-brand-solid);
        --background-color-brand-solid_hover: var(--color-bg-brand-solid_hover);
        --background-color-brand-section: var(--color-bg-brand-section);
        --background-color-brand-section_subtle: var(--color-bg-brand-section_subtle);
        --background-color-error-primary: var(--color-bg-error-primary);
        --background-color-error-secondary: var(--color-bg-error-secondary);
        --background-color-error-solid: var(--color-bg-error-solid);
        --background-color-error-solid_hover: var(--color-bg-error-solid_hover);
        --background-color-warning-primary: var(--color-bg-warning-primary);
        --background-color-warning-secondary: var(--color-bg-warning-secondary);
        --background-color-warning-solid: var(--color-bg-warning-solid);
        --background-color-success-primary: var(--color-bg-success-primary);
        --background-color-success-secondary: var(--color-bg-success-secondary);
        --background-color-success-solid: var(--color-bg-success-solid);
        --background-color-border-brand: var(--color-border-brand);
        --background-color-border-tertiary: var(--color-border-tertiary);
        --background-color-border-brand_alt: var(--color-border-brand_alt);

        /* TEXT PROPERTY COLORS */
        --text-color-primary: var(--color-text-primary);
        --text-color-primary_on-brand: var(--color-text-primary_on-brand);
        --text-color-secondary: var(--color-text-secondary);
        --text-color-secondary_hover: var(--color-text-secondary_hover);
        --text-color-secondary_on-brand: var(--color-text-secondary_on-brand);
        --text-color-tertiary: var(--color-text-tertiary);
        --text-color-tertiary_hover: var(--color-text-tertiary_hover);
        --text-color-tertiary_on-brand: var(--color-text-tertiary_on-brand);
        --text-color-quaternary: var(--color-text-quaternary);
        --text-color-quaternary_on-brand: var(--color-text-quaternary_on-brand);
        --text-color-disabled: var(--color-text-disabled);
        --text-color-placeholder: var(--color-text-placeholder);
        --text-color-placeholder_subtle: var(--color-text-placeholder_subtle);
        --text-color-brand-primary: var(--color-text-brand-primary);
        --text-color-brand-secondary: var(--color-text-brand-secondary);
        --text-color-brand-secondary_hover: var(--color-text-brand-secondary_hover);
        --text-color-brand-tertiary: var(--color-text-brand-tertiary);
        --text-color-brand-tertiary_alt: var(--color-text-brand-tertiary_alt);
        --text-color-error-primary: var(--color-text-error-primary);
        --text-color-error-primary_hover: var(--color-text-error-primary_hover);
        --text-color-warning-primary: var(--color-text-warning-primary);
        --text-color-success-primary: var(--color-text-success-primary);
        --text-color-tooltip-supporting-text: var(--color-tooltip-supporting-text);

        /* BORDER PROPERTY COLORS */
        --border-color-primary: var(--color-border-primary);
        --border-color-secondary: var(--color-border-secondary);
        --border-color-secondary_alt: var(--color-border-secondary_alt);
        --border-color-tertiary: var(--color-border-tertiary);
        --border-color-disabled: var(--color-border-disabled);
        --border-color-brand: var(--color-border-brand);
        --border-color-brand-solid: var(--color-bg-brand-solid);
        --border-color-brand-solid_hover: var(--color-bg-brand-solid_hover);
        --border-color-error: var(--color-border-error);
        --border-color-disabled_subtle: var(--color-border-disabled_subtle);
        --border-color-brand_alt: var(--color-border-brand_alt);
        --border-color-error_subtle: var(--color-border-error_subtle);

        /* RING PROPERTY COLORS */
        --ring-color-primary: var(--color-border-primary);
        --ring-color-secondary: var(--color-border-secondary);
        --ring-color-secondary_alt: var(--color-border-secondary_alt);
        --ring-color-tertiary: var(--color-border-tertiary);
        --ring-color-brand: var(--color-border-brand);
        --ring-color-brand-solid: var(--color-bg-brand-solid);
        --ring-color-brand-solid_hover: var(--color-bg-brand-solid_hover);
        --ring-color-error: var(--color-border-error);
        --ring-color-error_subtle: var(--color-border-error_subtle);
        --ring-color-disabled: var(--color-border-disabled);
        --ring-color-disabled_subtle: var(--color-border-disabled_subtle);
        --ring-color-brand_alt: var(--color-border-brand_alt);
        --ring-color-bg-brand-solid: var(--color-bg-brand-solid);

        /* OUTLINE PROPERTY COLORS */
        --outline-color-primary: var(--color-border-primary);
        --outline-color-secondary: var(--color-border-secondary);
        --outline-color-secondary_alt: var(--color-border-secondary_alt);
        --outline-color-tertiary: var(--color-border-tertiary);
        --outline-color-disabled: var(--color-border-disabled);
        --outline-color-disabled_subtle: var(--color-border-disabled_subtle);
        --outline-color-brand: var(--color-border-brand);
        --outline-color-brand-solid: var(--color-bg-brand-solid);
        --outline-color-brand-solid_hover: var(--color-bg-brand-solid_hover);
        --outline-color-brand_alt: var(--color-border-brand_alt);
        --outline-color-error: var(--color-border-error);
        --outline-color-error_subtle: var(--color-border-error_subtle);
    }
}
````

## File: src/vite-env.d.ts
````typescript
/// <reference types="vite/client" />

interface ImportMetaEnv {
  readonly VITE_NEON_PROJECT_ID?: string;
  readonly VITE_NEON_DATA_API_URL?: string;
  readonly VITE_NEON_AUTH_URL?: string;
  readonly VITE_NEON_PUBLISHABLE_KEY?: string;
  readonly VITE_AGENT_SERVICE_URL?: string;
  readonly VITE_ENHANCE_REQUEST_TIMEOUT_MS?: string;
  readonly VITE_ENHANCE_TRANSPORT?: string;
  readonly VITE_ENHANCE_WS_CONNECT_TIMEOUT_MS?: string;
  readonly VITE_BUILDER_REDESIGN_PHASE1?: string;
  readonly VITE_BUILDER_REDESIGN_PHASE2?: string;
  readonly VITE_BUILDER_REDESIGN_PHASE3?: string;
  readonly VITE_BUILDER_REDESIGN_PHASE4?: string;
  readonly VITE_COMMUNITY_MOBILE_ENHANCEMENTS?: string;
}

interface ImportMeta {
  readonly env: ImportMetaEnv;
}
````

## File: index.html
````html
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-title" content="PromptForge" />
    <meta name="apple-mobile-web-app-status-bar-style" content="default" />
    <title>PromptForge — Quality Prompts Grounded in Context</title>
    <meta name="description" content="Build, score, and remix prompts with grounded context, quality checks, and community collaboration." />
    <meta name="author" content="Lakefront Digital" />
    <link rel="icon" type="image/x-icon" href="/favicon.ico" />
    <link rel="apple-touch-icon" href="/apple-touch-icon.png" />
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon-180x180.png" />
    <link rel="apple-touch-icon" sizes="167x167" href="/apple-touch-icon-167x167.png" />
    <link rel="apple-touch-icon" sizes="152x152" href="/apple-touch-icon-152x152.png" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;700&family=Inter:wght@400;500;600;700&display=swap"
      rel="stylesheet"
    />

    <meta property="og:site_name" content="PromptForge" />
    <meta property="og:title" content="PromptForge — Quality Prompts Grounded in Context" />
    <meta property="og:description" content="Build, score, and remix prompts with grounded context, quality checks, and community collaboration." />
    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://prompt.lakefrontdigital.io" />
    <meta property="og:image" content="https://prompt.lakefrontdigital.io/social-card-launch.svg" />

    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="PromptForge — Quality Prompts Grounded in Context" />
    <meta name="twitter:description" content="Build, score, and remix prompts with grounded context, quality checks, and community collaboration." />
    <meta name="twitter:image" content="https://prompt.lakefrontdigital.io/social-card-launch.svg" />
  </head>

  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
````

## File: src/components/base/input/input.tsx
````typescript
import { type ComponentType, type HTMLAttributes, type ReactNode, type Ref, createContext, useContext } from "react";
import type { InputProps as AriaInputProps, TextFieldProps as AriaTextFieldProps } from "react-aria-components";
import { Group as AriaGroup, Input as AriaInput, TextField as AriaTextField } from "react-aria-components";
import { HintText } from "@/components/base/input/hint-text";
import { Label } from "@/components/base/input/label";
import { Tooltip, TooltipTrigger } from "@/components/base/tooltip/tooltip";
import { cx, sortCx } from "@/lib/utils/cx";
import { Info as InfoCircle, Question as HelpCircle } from "@phosphor-icons/react";

export interface InputBaseProps extends TextFieldProps {
    /** Tooltip message on hover. */
    tooltip?: string;
    /**
     * Input size.
     * @default "sm"
     */
    size?: "sm" | "md";
    /** Placeholder text. */
    placeholder?: string;
    /** Class name for the icon. */
    iconClassName?: string;
    /** Class name for the input. */
    inputClassName?: string;
    /** Class name for the input wrapper. */
    wrapperClassName?: string;
    /** Class name for the tooltip. */
    tooltipClassName?: string;
    /** Keyboard shortcut to display. */
    shortcut?: string | boolean;
    ref?: Ref<HTMLInputElement>;
    groupRef?: Ref<HTMLDivElement>;
    /** Icon component to display on the left side of the input. */
    icon?: ComponentType<HTMLAttributes<HTMLOrSVGElement>>;
}

export const InputBase = ({
    ref,
    tooltip,
    shortcut,
    groupRef,
    size = "sm",
    isInvalid,
    isDisabled,
    icon: Icon,
    placeholder,
    wrapperClassName,
    tooltipClassName,
    inputClassName,
    iconClassName,
    // Omit this prop to avoid invalid HTML attribute warning
    isRequired: _isRequired,
    ...inputProps
}: Omit<InputBaseProps, "label" | "hint">) => {
    // Check if the input has a leading icon or tooltip
    const hasTrailingIcon = tooltip || isInvalid;
    const hasLeadingIcon = Icon;

    // If the input is inside a `TextFieldContext`, use its context to simplify applying styles
    const context = useContext(TextFieldContext);

    const inputSize = context?.size || size;

    const sizes = sortCx({
        sm: {
            root: cx("px-3 py-2", hasTrailingIcon && "pr-9", hasLeadingIcon && "pl-10"),
            iconLeading: "left-3",
            iconTrailing: "right-3",
            shortcut: "pr-2.5",
        },
        md: {
            root: cx("px-3.5 py-2.5", hasTrailingIcon && "pr-9.5", hasLeadingIcon && "pl-10.5"),
            iconLeading: "left-3.5",
            iconTrailing: "right-3.5",
            shortcut: "pr-3",
        },
    });

    return (
        <AriaGroup
            {...{ isDisabled, isInvalid }}
            ref={groupRef}
            className={({ isFocusWithin, isDisabled, isInvalid }) =>
                cx(
                    "relative flex w-full flex-row place-content-center place-items-center rounded-lg bg-background shadow-xs ring-1 ring-border transition-shadow duration-100 ease-linear ring-inset",

                    isFocusWithin && !isDisabled && "ring-2 ring-brand",

                    // Disabled state styles
                    isDisabled && "cursor-not-allowed bg-muted ring-border",
                    "group-disabled:cursor-not-allowed group-disabled:bg-muted group-disabled:ring-border",

                    // Invalid state styles
                    isInvalid && "ring-destructive/35",
                    "group-invalid:ring-destructive/35",

                    // Invalid state with focus-within styles
                    isInvalid && isFocusWithin && "ring-2 ring-error",
                    isFocusWithin && "group-invalid:ring-2 group-invalid:ring-error",

                    context?.wrapperClassName,
                    wrapperClassName,
                )
            }
        >
            {/* Leading icon and Payment icon */}
            {Icon && (
                <Icon
                    className={cx(
                        "pointer-events-none absolute size-5 text-muted-foreground",
                        isDisabled && "text-muted-foreground/70",
                        sizes[inputSize].iconLeading,
                        context?.iconClassName,
                        iconClassName,
                    )}
                />
            )}

            {/* Input field */}
            <AriaInput
                {...(inputProps as AriaInputProps)}
                ref={ref}
                placeholder={placeholder}
                className={cx(
                    "m-0 w-full bg-transparent text-base text-foreground ring-0 outline-hidden placeholder:text-muted-foreground autofill:rounded-lg autofill:text-foreground",
                    isDisabled && "cursor-not-allowed text-muted-foreground",
                    sizes[inputSize].root,
                    context?.inputClassName,
                    inputClassName,
                )}
            />

            {/* Tooltip and help icon */}
            {tooltip && !isInvalid && (
                <Tooltip title={tooltip} placement="top">
                    <TooltipTrigger
                        className={cx(
                            "absolute cursor-pointer text-muted-foreground transition duration-200 hover:text-foreground focus:text-foreground",
                            sizes[inputSize].iconTrailing,
                            context?.tooltipClassName,
                            tooltipClassName,
                        )}
                    >
                        <HelpCircle className="size-4" />
                    </TooltipTrigger>
                </Tooltip>
            )}

            {/* Invalid icon */}
            {isInvalid && (
                <InfoCircle
                    className={cx(
                        "pointer-events-none absolute size-4 text-destructive",
                        sizes[inputSize].iconTrailing,
                        context?.tooltipClassName,
                        tooltipClassName,
                    )}
                />
            )}

            {/* Shortcut */}
            {shortcut && (
                <div
                    className={cx(
                        "pointer-events-none absolute inset-y-0.5 right-0.5 z-10 flex items-center rounded-r-[inherit] bg-linear-to-r from-transparent to-background to-40% pl-8",
                        sizes[inputSize].shortcut,
                    )}
                >
                    <span
                        className={cx(
                            "pointer-events-none rounded px-1 py-px text-xs font-medium text-muted-foreground ring-1 ring-border select-none ring-inset",
                            isDisabled && "bg-transparent text-muted-foreground",
                        )}
                        aria-hidden="true"
                    >
                        {typeof shortcut === "string" ? shortcut : "⌘K"}
                    </span>
                </div>
            )}
        </AriaGroup>
    );
};

InputBase.displayName = "InputBase";

interface BaseProps {
    /** Label text for the input */
    label?: string;
    /** Helper text displayed below the input */
    hint?: ReactNode;
}

interface TextFieldProps
    extends BaseProps,
        AriaTextFieldProps,
        Pick<InputBaseProps, "size" | "wrapperClassName" | "inputClassName" | "iconClassName" | "tooltipClassName"> {
    ref?: Ref<HTMLDivElement>;
}

const TextFieldContext = createContext<TextFieldProps>({});

export const TextField = ({ className, ...props }: TextFieldProps) => {
    return (
        <TextFieldContext.Provider value={props}>
            <AriaTextField
                {...props}
                data-input-wrapper
                className={(state) =>
                    cx("group flex h-max w-full flex-col items-start justify-start gap-1.5", typeof className === "function" ? className(state) : className)
                }
            />
        </TextFieldContext.Provider>
    );
};

TextField.displayName = "TextField";

interface InputProps extends InputBaseProps, BaseProps {
    /** Whether to hide required indicator from label */
    hideRequiredIndicator?: boolean;
}

export const Input = ({
    size = "sm",
    placeholder,
    icon: Icon,
    label,
    hint,
    shortcut,
    hideRequiredIndicator,
    className,
    ref,
    groupRef,
    tooltip,
    iconClassName,
    inputClassName,
    wrapperClassName,
    tooltipClassName,
    ...props
}: InputProps) => {
    return (
        <TextField aria-label={!label ? placeholder : undefined} {...props} className={className}>
            {({ isRequired, isInvalid }) => (
                <>
                    {label && <Label isRequired={hideRequiredIndicator ? !hideRequiredIndicator : isRequired}>{label}</Label>}

                    <InputBase
                        {...{
                            ref,
                            groupRef,
                            size,
                            placeholder,
                            icon: Icon,
                            shortcut,
                            iconClassName,
                            inputClassName,
                            wrapperClassName,
                            tooltipClassName,
                            tooltip,
                        }}
                    />

                    {hint && <HintText isInvalid={isInvalid}>{hint}</HintText>}
                </>
            )}
        </TextField>
    );
};

Input.displayName = "Input";
````

## File: src/components/BottomNav.tsx
````typescript
import { Link, useLocation } from "react-router-dom";
import { cn } from "@/lib/utils";
import { BOTTOM_NAV_ITEMS, isRouteActive } from "@/lib/navigation";

export function BottomNav() {
  const { pathname } = useLocation();

  return (
    <nav
      className="pf-mobile-nav fixed inset-x-0 bottom-0 z-40 flex items-end justify-around border-t border-border bg-background/95 px-1 pb-[max(0.5rem,env(safe-area-inset-bottom))] pt-1 backdrop-blur sm:hidden"
      aria-label="Mobile navigation"
    >
      {BOTTOM_NAV_ITEMS.map(({ to, label, icon: Icon }) => {
        const isActive = isRouteActive(pathname, to);

        return (
          <Link
            key={to}
            to={to}
            className={cn(
              "mobile-route-link flex min-h-12 flex-1 flex-col items-center justify-center gap-0.5 rounded-md px-1 py-2 text-xs leading-5 font-medium transition-colors",
              isActive
                ? "text-primary font-medium"
                : "text-muted-foreground hover:text-foreground",
            )}
            aria-current={isActive ? "page" : undefined}
          >
            <Icon className="h-5 w-5" />
            <span>{label}</span>
          </Link>
        );
      })}
    </nav>
  );
}
````

## File: src/components/ToneControls.tsx
````typescript
import { Button } from "@/components/base/buttons/button";
import { toneOptions, complexityOptions } from "@/lib/prompt-builder";

interface ToneControlsProps {
  tone: string;
  complexity: string;
  onUpdate: (updates: { tone?: string; complexity?: string }) => void;
}

export function ToneControls({ tone, complexity, onUpdate }: ToneControlsProps) {
  return (
    <div className="space-y-3 sm:space-y-4">
      <div className="space-y-2">
        <label className="text-sm font-medium text-foreground sm:text-base">Tone</label>
        <div className="flex flex-wrap gap-1.5 sm:gap-2">
          {toneOptions.map((t) => (
            <Button
              key={t}
              color={tone === t ? "primary" : "secondary"}
              size="sm"
              onClick={() => onUpdate({ tone: t })}
              className="h-11 px-2 text-sm sm:h-9 sm:px-3 sm:text-sm"
            >
              {t}
            </Button>
          ))}
        </div>
      </div>
      <div className="space-y-2">
        <label className="text-sm font-medium text-foreground sm:text-base">Complexity</label>
        <div className="flex flex-wrap gap-1.5 sm:gap-2">
          {complexityOptions.map((c) => (
            <Button
              key={c}
              color={complexity === c ? "primary" : "secondary"}
              size="sm"
              onClick={() => onUpdate({ complexity: c })}
              className="h-11 px-2 text-sm sm:h-9 sm:px-3 sm:text-sm"
            >
              {c}
            </Button>
          ))}
        </div>
      </div>
    </div>
  );
}
````

## File: src/components/VersionHistory.tsx
````typescript
import {
  Sheet,
  SheetContent,
  SheetHeader,
  SheetTitle,
} from "@/components/base/primitives/sheet";
import { Button } from "@/components/base/buttons/button";
import { Card } from "@/components/base/primitives/card";
import { StateCard } from "@/components/base/primitives/state-card";
import { ArrowCounterClockwise as RotateCcw } from "@phosphor-icons/react";

interface Version {
  id: string;
  name: string;
  prompt: string;
  timestamp: number;
}

interface VersionHistoryProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  versions: Version[];
  onRestore: (prompt: string) => void;
}

export function VersionHistory({ open, onOpenChange, versions, onRestore }: VersionHistoryProps) {
  return (
    <Sheet open={open} onOpenChange={onOpenChange}>
      <SheetContent className="w-full sm:w-[400px] md:w-[540px]">
        <SheetHeader>
          <SheetTitle className="text-foreground">Version History</SheetTitle>
        </SheetHeader>
        <VersionHistoryContent
          versions={versions}
          onRestore={(prompt) => {
            onRestore(prompt);
            onOpenChange(false);
          }}
          className="mt-4 sm:mt-6 max-h-[calc(100vh-120px)]"
        />
      </SheetContent>
    </Sheet>
  );
}

export function VersionHistoryContent({
  versions,
  onRestore,
  className,
}: {
  versions: Version[];
  onRestore: (prompt: string) => void;
  className?: string;
}) {
  return (
    <div className={`space-y-2 sm:space-y-3 overflow-y-auto ${className ?? ""}`.trim()}>
      {versions.length === 0 ? (
        <StateCard
          variant="empty"
          title="No saved versions yet"
          description="Save a prompt to create restorable versions in this history panel."
          primaryAction={{ label: "Go to Builder", to: "/" }}
        />
      ) : (
        versions.map((version) => (
          <Card key={version.id} className="p-3 sm:p-4 group">
            <div className="flex items-start justify-between gap-2 sm:gap-3">
              <div className="flex-1 min-w-0">
                <p className="text-sm font-medium text-foreground">{version.name}</p>
                <p className="text-xs text-muted-foreground mt-0.5">
                  {new Date(version.timestamp).toLocaleString()}
                </p>
                <p className="text-xs text-muted-foreground mt-1.5 sm:mt-2 line-clamp-3 font-mono">
                  {version.prompt}
                </p>
              </div>
              <Button
                color="tertiary"
                size="sm"
                className="shrink-0 gap-1 text-xs"
                onClick={() => onRestore(version.prompt)}
              >
                <RotateCcw className="w-3 h-3" />
                Restore
              </Button>
            </div>
          </Card>
        ))
      )}
    </div>
  );
}
````

## File: src/hooks/usePromptBuilder.ts
````typescript
import { useState, useCallback, useEffect, useMemo, useRef } from "react";
import { PromptConfig, defaultConfig, buildPrompt, scorePrompt } from "@/lib/prompt-builder";
import {
  listTemplateSummaries as listLocalTemplateSummaries,
  type SaveTemplateResult,
  type TemplateLoadResult,
} from "@/lib/template-store";
import { useAuth } from "@/hooks/useAuth";
import { useToast } from "@/hooks/use-toast";
import { useContextConfig } from "@/hooks/useContextConfig";
import { useDraftPersistence } from "@/hooks/useDraftPersistence";
import * as persistence from "@/lib/persistence";
import {
  MAX_LOCAL_VERSIONS,
  clearCachedCloudVersions,
  clearLocalVersions,
  createVersionId,
  hydrateConfig,
  loadCachedCloudVersions,
  loadLocalDraft,
  loadLocalVersions,
  saveCachedCloudVersions,
  saveLocalVersions,
  toPromptSummary,
} from "@/lib/prompt-builder-cache";
import {
  buildRemixPayload,
  type PromptBuilderRemixContext,
} from "@/lib/prompt-builder-remix";

export function usePromptBuilder() {
  const { user } = useAuth();
  const { toast } = useToast();
  const userId = user?.id ?? null;
  const [config, setConfig] = useState<PromptConfig>(loadLocalDraft);
  const [enhancedPrompt, setEnhancedPrompt] = useState("");
  const [isEnhancing, setIsEnhancing] = useState(false);
  const [versions, setVersions] = useState<persistence.PromptVersion[]>(loadLocalVersions);
  const [templateSummaries, setTemplateSummaries] = useState<persistence.PromptSummary[]>(() =>
    listLocalTemplateSummaries().map(toPromptSummary),
  );
  const [isCloudHydrated, setIsCloudHydrated] = useState(false);
  const [remixContext, setRemixContext] = useState<PromptBuilderRemixContext | null>(null);

  const prevUserId = useRef<string | null>(null);
  const authLoadToken = useRef(0);

  const {
    isDraftDirty,
    markDraftDirty,
    resetDraftState,
    clearDirtyIfClean,
    editsSinceAuthChange,
  } = useDraftPersistence({ userId, config, isCloudHydrated, toast });

  const showPersistenceError = useCallback(
    (title: string, error: unknown, fallback: string) => {
      toast({
        title,
        description: persistence.getPersistenceErrorMessage(error, fallback),
        variant: "destructive",
      });
    },
    [toast],
  );

  useEffect(() => {
    if (userId) return;
    saveLocalVersions(versions);
  }, [userId, versions]);

  // Load draft/prompts/versions when the auth identity changes.
  useEffect(() => {
    const previousUserId = prevUserId.current;
    if (userId === previousUserId) return;
    prevUserId.current = userId;

    // Capture whether the user (or a preset/remix) made edits before auth
    // resolved, so we don't overwrite them with defaultConfig or a cloud draft.
    const hadPendingEdits = editsSinceAuthChange.current;
    const token = ++authLoadToken.current;
    const nextUserId = userId;

    resetDraftState();
    setEnhancedPrompt("");
    if (!hadPendingEdits) {
      setConfig(defaultConfig);
    }
    setTemplateSummaries([]);
    setVersions(nextUserId ? loadCachedCloudVersions(nextUserId) : loadLocalVersions());
    if (!hadPendingEdits) {
      setRemixContext(null);
    }

    if (!nextUserId) {
      setIsCloudHydrated(true);
      if (!hadPendingEdits) {
        setConfig(loadLocalDraft());
      }
      setTemplateSummaries(listLocalTemplateSummaries().map(toPromptSummary));
      setVersions(loadLocalVersions());
      return;
    }

    const migrateVersionsFromGuestToCloud = !previousUserId
      ? async () => {
          const localVersions = loadLocalVersions();
          if (localVersions.length === 0) return;

          const migration = await Promise.allSettled(
            localVersions.map((version) => persistence.saveVersion(nextUserId, version.name, version.prompt)),
          );
          const failedVersions = localVersions.filter((_, index) => migration[index]?.status === "rejected");
          const failedCount = failedVersions.length;
          if (failedCount > 0) {
            saveLocalVersions(failedVersions);
            toast({
              title: "Some local versions were not migrated",
              description:
                failedCount === 1
                  ? "1 local version could not be copied to cloud history."
                  : `${failedCount} local versions could not be copied to cloud history.`,
              variant: "destructive",
            });
            return;
          }
          clearLocalVersions();
        }
      : async () => {};

    setIsCloudHydrated(false);

    void Promise.allSettled([
      persistence.loadDraft(nextUserId),
      persistence.loadPrompts(nextUserId),
      (async () => {
        await migrateVersionsFromGuestToCloud();
        return persistence.loadVersions(nextUserId);
      })(),
    ]).then(([draftResult, promptsResult, versionsResult]) => {
      if (token !== authLoadToken.current) return;

      if (draftResult.status === "fulfilled") {
        if (draftResult.value && !editsSinceAuthChange.current && !hadPendingEdits) {
          setConfig(hydrateConfig(draftResult.value));
        } else if (draftResult.value && (editsSinceAuthChange.current || hadPendingEdits)) {
          toast({
            title: "Cloud draft was not applied",
            description: "You started editing before cloud draft finished loading, so your current edits were kept.",
          });
        }
      } else {
        showPersistenceError("Failed to load draft", draftResult.reason, "Failed to load draft.");
      }

      if (promptsResult.status === "fulfilled") {
        setTemplateSummaries(promptsResult.value);
      } else {
        setTemplateSummaries([]);
        showPersistenceError("Failed to load prompts", promptsResult.reason, "Failed to load prompts.");
      }

      if (versionsResult.status === "fulfilled") {
        const cloudVersions = versionsResult.value;
        if (cloudVersions.length > 0) {
          setVersions(cloudVersions);
          saveCachedCloudVersions(nextUserId, cloudVersions);
        } else {
          setVersions([]);
          clearCachedCloudVersions(nextUserId);
        }
      } else {
        setVersions(loadCachedCloudVersions(nextUserId));
        showPersistenceError(
          "Failed to load version history",
          versionsResult.reason,
          "Failed to load version history.",
        );
      }

      setIsCloudHydrated(true);
      clearDirtyIfClean();
    });
  }, [userId, showPersistenceError, toast, resetDraftState, clearDirtyIfClean, editsSinceAuthChange]);

  const refreshTemplateSummaries = useCallback(async () => {
    if (userId) {
      try {
        const summaries = await persistence.loadPrompts(userId);
        setTemplateSummaries(summaries);
      } catch (error) {
        showPersistenceError("Failed to refresh prompts", error, "Failed to refresh prompts.");
      }
    } else {
      setTemplateSummaries(listLocalTemplateSummaries().map(toPromptSummary));
    }
  }, [userId, showPersistenceError]);

  const updateConfig = useCallback(
    (updates: Partial<PromptConfig>) => {
      setConfig((prev) => ({ ...prev, ...updates }));
      markDraftDirty();
    },
    [markDraftDirty],
  );

  const resetConfig = useCallback(() => {
    setConfig(defaultConfig);
    setEnhancedPrompt("");
    setRemixContext(null);
    if (!userId) {
      persistence.clearLocalDraft();
      resetDraftState();
      return;
    }
    markDraftDirty();
  }, [userId, markDraftDirty, resetDraftState]);

  const clearOriginalPrompt = useCallback(() => {
    setConfig((prev) => ({
      ...prev,
      originalPrompt: "",
    }));
    setEnhancedPrompt("");
    markDraftDirty();
  }, [markDraftDirty]);

  // Context-specific updaters
  const contextConfig = useContextConfig(setConfig, markDraftDirty);

  const builtPrompt = useMemo(() => buildPrompt(config), [config]);
  const score = useMemo(() => scorePrompt(config), [config]);

  const saveVersion = useCallback(
    (name?: string) => {
      const promptToSave = enhancedPrompt || builtPrompt;
      if (!promptToSave) return;
      const versionName = name || `Version ${versions.length + 1}`;

      if (userId) {
        const optimisticId = createVersionId("local");
        const optimisticVersion: persistence.PromptVersion = {
          id: optimisticId,
          name: versionName,
          prompt: promptToSave,
          timestamp: Date.now(),
        };
        const optimisticCache = [
          optimisticVersion,
          ...loadCachedCloudVersions(userId).filter((version) => version.id !== optimisticId),
        ].slice(0, MAX_LOCAL_VERSIONS);

        setVersions((prev) => [optimisticVersion, ...prev.filter((version) => version.id !== optimisticId)].slice(
          0,
          MAX_LOCAL_VERSIONS,
        ));
        saveCachedCloudVersions(userId, optimisticCache);

        const replaceOptimistic = (saved: persistence.PromptVersion) => {
          setVersions((prev) =>
            [saved, ...prev.filter((version) => version.id !== optimisticId)].slice(0, MAX_LOCAL_VERSIONS),
          );
          saveCachedCloudVersions(
            userId,
            [saved, ...loadCachedCloudVersions(userId).filter((version) => version.id !== optimisticId)].slice(
              0,
              MAX_LOCAL_VERSIONS,
            ),
          );
        };

        const rollbackOptimistic = () => {
          setVersions((prev) => prev.filter((version) => version.id !== optimisticId).slice(0, MAX_LOCAL_VERSIONS));
          saveCachedCloudVersions(
            userId,
            loadCachedCloudVersions(userId).filter((version) => version.id !== optimisticId),
          );
        };

        void persistence
          .saveVersion(userId, versionName, promptToSave)
          .then((saved) => {
            if (!saved) {
              rollbackOptimistic();
              showPersistenceError("Failed to save version", null, "Failed to save version.");
              return;
            }
            replaceOptimistic(saved);
          })
          .catch((error) => {
            rollbackOptimistic();
            showPersistenceError("Failed to save version", error, "Failed to save version.");
          });
      } else {
        const version: persistence.PromptVersion = {
          id: createVersionId("local"),
          name: versionName,
          prompt: promptToSave,
          timestamp: Date.now(),
        };
        const next = [version, ...loadLocalVersions()].slice(0, MAX_LOCAL_VERSIONS);
        saveLocalVersions(next);
        setVersions(next);
      }
    },
    [enhancedPrompt, builtPrompt, versions.length, userId, showPersistenceError],
  );

  const loadTemplate = useCallback(
    (template: {
      starterPrompt?: string;
      role: string;
      task: string;
      context: string;
      format: string[];
      lengthPreference: string;
      tone: string;
      complexity: string;
      constraints: string[];
      examples: string;
    }) => {
      setConfig({
        ...defaultConfig,
        originalPrompt: (template.starterPrompt || template.task).trim(),
        role: template.role,
        task: template.task,
        context: template.context,
        format: template.format,
        lengthPreference: template.lengthPreference,
        tone: template.tone,
        complexity: template.complexity,
        constraints: template.constraints,
        examples: template.examples,
      });
      setEnhancedPrompt("");
      setRemixContext(null);
      markDraftDirty();
    },
    [markDraftDirty],
  );

  const startRemix = useCallback(
    (input: {
      postId: string;
      title: string;
      authorName?: string;
      publicConfig: PromptConfig;
      parentTags?: string[];
      parentCategory?: string;
    }) => {
      setConfig(hydrateConfig(input.publicConfig));
      setEnhancedPrompt("");
      setRemixContext({
        postId: input.postId,
        parentTitle: input.title,
        parentAuthor: input.authorName || "Community member",
        parentConfig: hydrateConfig(input.publicConfig),
        parentTags: input.parentTags ?? [],
        parentCategory: input.parentCategory ?? "general",
      });
      markDraftDirty();
    },
    [markDraftDirty],
  );

  const clearRemix = useCallback(() => {
    setRemixContext(null);
  }, []);

  const savePrompt = useCallback(
    async (input: {
      title: string;
      description?: string;
      tags?: string[];
      category?: string;
      targetModel?: string;
      useCase?: string;
      remixNote?: string;
    }): Promise<SaveTemplateResult> => {
      const remixPayload = buildRemixPayload(remixContext, config, {
        tags: input.tags,
        category: input.category,
        remixNote: input.remixNote,
      });
      const result = await persistence.savePrompt(userId, {
        name: input.title,
        description: input.description,
        tags: input.tags,
        category: input.category,
        targetModel: input.targetModel,
        useCase: input.useCase,
        config,
        builtPrompt: builtPrompt || "",
        enhancedPrompt: enhancedPrompt || "",
        ...remixPayload,
      });
      await refreshTemplateSummaries();
      if (remixContext) setRemixContext(null);
      return result;
    },
    [config, builtPrompt, enhancedPrompt, userId, refreshTemplateSummaries, remixContext],
  );

  const saveAndSharePrompt = useCallback(
    async (input: {
      title: string;
      description?: string;
      tags?: string[];
      category?: string;
      targetModel?: string;
      useCase: string;
      remixNote?: string;
    }): Promise<SaveTemplateResult & { postId?: string }> => {
      if (!userId) {
        throw new Error("Sign in to share prompts.");
      }

      const remixPayload = buildRemixPayload(remixContext, config, {
        tags: input.tags,
        category: input.category,
        remixNote: input.remixNote,
      });
      const result = await persistence.savePrompt(userId, {
        name: input.title,
        description: input.description,
        tags: input.tags,
        category: input.category,
        targetModel: input.targetModel,
        useCase: input.useCase,
        config,
        builtPrompt: builtPrompt || "",
        enhancedPrompt: enhancedPrompt || "",
        ...remixPayload,
      });

      const shareResult = await persistence.sharePrompt(userId, result.record.metadata.id, {
        title: input.title,
        description: input.description,
        category: input.category,
        tags: input.tags,
        targetModel: input.targetModel,
        useCase: input.useCase,
      });
      if (!shareResult.shared) {
        throw new Error("Prompt was saved but could not be shared.");
      }

      await refreshTemplateSummaries();
      if (remixContext) setRemixContext(null);
      return { ...result, postId: shareResult.postId };
    },
    [config, builtPrompt, enhancedPrompt, userId, refreshTemplateSummaries, remixContext],
  );

  const shareSavedPrompt = useCallback(
    async (id: string, input?: persistence.PromptShareInput): Promise<persistence.ShareResult> => {
      const result = await persistence.sharePrompt(userId, id, input);
      if (result.shared) await refreshTemplateSummaries();
      return result;
    },
    [userId, refreshTemplateSummaries],
  );

  const unshareSavedPrompt = useCallback(
    async (id: string): Promise<boolean> => {
      const updatedIds = await persistence.unsharePrompts(userId, [id]);
      if (updatedIds.length > 0) await refreshTemplateSummaries();
      return updatedIds.length > 0;
    },
    [userId, refreshTemplateSummaries],
  );

  const unshareSavedPrompts = useCallback(
    async (ids: string[]): Promise<string[]> => {
      const updatedIds = await persistence.unsharePrompts(userId, ids);
      if (updatedIds.length > 0) await refreshTemplateSummaries();
      return updatedIds;
    },
    [userId, refreshTemplateSummaries],
  );

  const saveAsTemplate = useCallback(
    async (input: {
      name: string;
      description?: string;
      tags?: string[];
    }): Promise<SaveTemplateResult> => {
      return savePrompt({
        title: input.name,
        description: input.description,
        tags: input.tags,
      });
    },
    [savePrompt],
  );

  const loadSavedTemplate = useCallback(
    async (id: string): Promise<TemplateLoadResult | null> => {
      const loaded = await persistence.loadPromptById(userId, id);
      if (!loaded) return null;
      setConfig(hydrateConfig(loaded.record.state.promptConfig));
      setEnhancedPrompt("");
      setRemixContext(null);
      markDraftDirty();
      return loaded;
    },
    [userId, markDraftDirty],
  );

  const deleteSavedTemplate = useCallback(
    async (id: string): Promise<boolean> => {
      const deletedIds = await persistence.deletePrompts(userId, [id]);
      if (deletedIds.length > 0) await refreshTemplateSummaries();
      return deletedIds.length > 0;
    },
    [userId, refreshTemplateSummaries],
  );

  const deleteSavedTemplates = useCallback(
    async (ids: string[]): Promise<string[]> => {
      const deletedIds = await persistence.deletePrompts(userId, ids);
      if (deletedIds.length > 0) await refreshTemplateSummaries();
      return deletedIds;
    },
    [userId, refreshTemplateSummaries],
  );

  return {
    config,
    updateConfig,
    resetConfig,
    clearOriginalPrompt,
    builtPrompt,
    score,
    enhancedPrompt,
    setEnhancedPrompt,
    isEnhancing,
    setIsEnhancing,
    isSignedIn: Boolean(userId),
    versions,
    saveVersion,
    loadTemplate,
    savePrompt,
    saveAndSharePrompt,
    shareSavedPrompt,
    unshareSavedPrompt,
    unshareSavedPrompts,
    saveAsTemplate,
    loadSavedTemplate,
    deleteSavedTemplate,
    deleteSavedTemplates,
    templateSummaries,
    remixContext,
    startRemix,
    clearRemix,
    // Context-specific (delegated to useContextConfig)
    ...contextConfig,
  };
}
````

## File: src/integrations/neon/types.ts
````typescript
export type Json =
  | string
  | number
  | boolean
  | null
  | { [key: string]: Json | undefined }
  | Json[]

export type Database = {
  public: {
    Tables: {
      community_comments: {
        Row: {
          body: string
          created_at: string
          id: string
          post_id: string
          updated_at: string
          user_id: string
        }
        Insert: {
          body: string
          created_at?: string
          id?: string
          post_id: string
          updated_at?: string
          user_id: string
        }
        Update: {
          body?: string
          created_at?: string
          id?: string
          post_id?: string
          updated_at?: string
          user_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "community_comments_post_id_fkey"
            columns: ["post_id"]
            isOneToOne: false
            referencedRelation: "community_posts"
            referencedColumns: ["id"]
          },
        ]
      }
      community_posts: {
        Row: {
          author_id: string
          category: string
          comment_count: number
          created_at: string
          description: string
          enhanced_prompt: string
          id: string
          is_public: boolean
          public_config: Json
          rating_avg: number
          rating_count: number
          remix_count: number
          remix_diff: Json | null
          remix_note: string
          remixed_from: string | null
          saved_prompt_id: string
          starter_prompt: string
          tags: string[]
          target_model: string
          title: string
          updated_at: string
          upvote_count: number
          use_case: string
          verified_count: number
        }
        Insert: {
          author_id: string
          category?: string
          comment_count?: number
          created_at?: string
          description?: string
          enhanced_prompt: string
          id?: string
          is_public?: boolean
          public_config?: Json
          rating_avg?: number
          rating_count?: number
          remix_count?: number
          remix_diff?: Json | null
          remix_note?: string
          remixed_from?: string | null
          saved_prompt_id: string
          starter_prompt?: string
          tags?: string[]
          target_model?: string
          title: string
          updated_at?: string
          upvote_count?: number
          use_case?: string
          verified_count?: number
        }
        Update: {
          author_id?: string
          category?: string
          comment_count?: number
          created_at?: string
          description?: string
          enhanced_prompt?: string
          id?: string
          is_public?: boolean
          public_config?: Json
          rating_avg?: number
          rating_count?: number
          remix_count?: number
          remix_diff?: Json | null
          remix_note?: string
          remixed_from?: string | null
          saved_prompt_id?: string
          starter_prompt?: string
          tags?: string[]
          target_model?: string
          title?: string
          updated_at?: string
          upvote_count?: number
          use_case?: string
          verified_count?: number
        }
        Relationships: [
          {
            foreignKeyName: "community_posts_remixed_from_fkey"
            columns: ["remixed_from"]
            isOneToOne: false
            referencedRelation: "community_posts"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "community_posts_saved_prompt_id_fkey"
            columns: ["saved_prompt_id"]
            isOneToOne: true
            referencedRelation: "saved_prompts"
            referencedColumns: ["id"]
          },
        ]
      }
      community_prompt_ratings: {
        Row: {
          created_at: string
          id: string
          post_id: string
          rating: number
          updated_at: string
          user_id: string
        }
        Insert: {
          created_at?: string
          id?: string
          post_id: string
          rating: number
          updated_at?: string
          user_id: string
        }
        Update: {
          created_at?: string
          id?: string
          post_id?: string
          rating?: number
          updated_at?: string
          user_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "community_prompt_ratings_post_id_fkey"
            columns: ["post_id"]
            isOneToOne: false
            referencedRelation: "community_posts"
            referencedColumns: ["id"]
          },
        ]
      }
      community_votes: {
        Row: {
          created_at: string
          id: string
          post_id: string
          user_id: string
          vote_type: string
        }
        Insert: {
          created_at?: string
          id?: string
          post_id: string
          user_id: string
          vote_type: string
        }
        Update: {
          created_at?: string
          id?: string
          post_id?: string
          user_id?: string
          vote_type?: string
        }
        Relationships: [
          {
            foreignKeyName: "community_votes_post_id_fkey"
            columns: ["post_id"]
            isOneToOne: false
            referencedRelation: "community_posts"
            referencedColumns: ["id"]
          },
        ]
      }
      community_reports: {
        Row: {
          comment_id: string | null
          created_at: string
          details: string
          id: string
          post_id: string | null
          reason: string
          reported_user_id: string | null
          reporter_id: string
          status: string
          target_type: string
        }
        Insert: {
          comment_id?: string | null
          created_at?: string
          details?: string
          id?: string
          post_id?: string | null
          reason?: string
          reported_user_id?: string | null
          reporter_id: string
          status?: string
          target_type: string
        }
        Update: {
          comment_id?: string | null
          created_at?: string
          details?: string
          id?: string
          post_id?: string | null
          reason?: string
          reported_user_id?: string | null
          reporter_id?: string
          status?: string
          target_type?: string
        }
        Relationships: [
          {
            foreignKeyName: "community_reports_comment_id_fkey"
            columns: ["comment_id"]
            isOneToOne: false
            referencedRelation: "community_comments"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "community_reports_post_id_fkey"
            columns: ["post_id"]
            isOneToOne: false
            referencedRelation: "community_posts"
            referencedColumns: ["id"]
          },
        ]
      }
      community_user_blocks: {
        Row: {
          blocked_user_id: string
          blocker_id: string
          created_at: string
          id: string
          reason: string
        }
        Insert: {
          blocked_user_id: string
          blocker_id: string
          created_at?: string
          id?: string
          reason?: string
        }
        Update: {
          blocked_user_id?: string
          blocker_id?: string
          created_at?: string
          id?: string
          reason?: string
        }
        Relationships: []
      }
      community_user_follows: {
        Row: {
          created_at: string
          followed_user_id: string
          follower_id: string
          id: string
        }
        Insert: {
          created_at?: string
          followed_user_id: string
          follower_id: string
          id?: string
        }
        Update: {
          created_at?: string
          followed_user_id?: string
          follower_id?: string
          id?: string
        }
        Relationships: []
      }
      support_reviewers: {
        Row: {
          created_at: string
          user_id: string
        }
        Insert: {
          created_at?: string
          user_id: string
        }
        Update: {
          created_at?: string
          user_id?: string
        }
        Relationships: []
      }
      contact_messages: {
        Row: {
          created_at: string
          email: string
          first_name: string
          id: string
          last_name: string
          message: string
          phone_country: string
          phone_number: string
          privacy_consent: boolean
          requester_user_id: string | null
          status: string
          updated_at: string
        }
        Insert: {
          created_at?: string
          email: string
          first_name: string
          id?: string
          last_name: string
          message: string
          phone_country?: string
          phone_number?: string
          privacy_consent: boolean
          requester_user_id?: string | null
          status?: string
          updated_at?: string
        }
        Update: {
          created_at?: string
          email?: string
          first_name?: string
          id?: string
          last_name?: string
          message?: string
          phone_country?: string
          phone_number?: string
          privacy_consent?: boolean
          requester_user_id?: string | null
          status?: string
          updated_at?: string
        }
        Relationships: []
      }
      drafts: {
        Row: {
          config: Json
          id: string
          updated_at: string
          user_id: string
        }
        Insert: {
          config?: Json
          id?: string
          updated_at?: string
          user_id: string
        }
        Update: {
          config?: Json
          id?: string
          updated_at?: string
          user_id?: string
        }
        Relationships: []
      }
      notifications: {
        Row: {
          actor_id: string | null
          comment_id: string | null
          created_at: string
          id: string
          post_id: string | null
          read_at: string | null
          type: string
          user_id: string
        }
        Insert: {
          actor_id?: string | null
          comment_id?: string | null
          created_at?: string
          id?: string
          post_id?: string | null
          read_at?: string | null
          type: string
          user_id: string
        }
        Update: {
          actor_id?: string | null
          comment_id?: string | null
          created_at?: string
          id?: string
          post_id?: string | null
          read_at?: string | null
          type?: string
          user_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "notifications_comment_id_fkey"
            columns: ["comment_id"]
            isOneToOne: false
            referencedRelation: "community_comments"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "notifications_post_id_fkey"
            columns: ["post_id"]
            isOneToOne: false
            referencedRelation: "community_posts"
            referencedColumns: ["id"]
          },
        ]
      }
      profiles: {
        Row: {
          avatar_url: string | null
          created_at: string
          display_name: string | null
          id: string
          updated_at: string
        }
        Insert: {
          avatar_url?: string | null
          created_at?: string
          display_name?: string | null
          id: string
          updated_at?: string
        }
        Update: {
          avatar_url?: string | null
          created_at?: string
          display_name?: string | null
          id?: string
          updated_at?: string
        }
        Relationships: []
      }
      prompt_versions: {
        Row: {
          created_at: string
          id: string
          name: string
          prompt: string
          user_id: string
        }
        Insert: {
          created_at?: string
          id?: string
          name: string
          prompt: string
          user_id: string
        }
        Update: {
          created_at?: string
          id?: string
          name?: string
          prompt?: string
          user_id?: string
        }
        Relationships: []
      }
      saved_prompts: {
        Row: {
          built_prompt: string
          category: string
          config: Json
          created_at: string
          description: string
          enhanced_prompt: string
          fingerprint: string | null
          id: string
          is_shared: boolean
          remix_diff: Json | null
          remix_note: string
          remixed_from: string | null
          revision: number
          tags: string[]
          target_model: string
          title: string
          updated_at: string
          use_case: string
          user_id: string
        }
        Insert: {
          built_prompt?: string
          category?: string
          config?: Json
          created_at?: string
          description?: string
          enhanced_prompt?: string
          fingerprint?: string | null
          id?: string
          is_shared?: boolean
          remix_diff?: Json | null
          remix_note?: string
          remixed_from?: string | null
          revision?: number
          tags?: string[]
          target_model?: string
          title: string
          updated_at?: string
          use_case?: string
          user_id: string
        }
        Update: {
          built_prompt?: string
          category?: string
          config?: Json
          created_at?: string
          description?: string
          enhanced_prompt?: string
          fingerprint?: string | null
          id?: string
          is_shared?: boolean
          remix_diff?: Json | null
          remix_note?: string
          remixed_from?: string | null
          revision?: number
          tags?: string[]
          target_model?: string
          title?: string
          updated_at?: string
          use_case?: string
          user_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "saved_prompts_remixed_from_fkey"
            columns: ["remixed_from"]
            isOneToOne: false
            referencedRelation: "community_posts"
            referencedColumns: ["id"]
          },
        ]
      }
      templates: {
        Row: {
          config: Json
          created_at: string
          description: string
          fingerprint: string | null
          id: string
          name: string
          revision: number
          tags: string[]
          updated_at: string
          user_id: string
        }
        Insert: {
          config?: Json
          created_at?: string
          description?: string
          fingerprint?: string | null
          id?: string
          name: string
          revision?: number
          tags?: string[]
          updated_at?: string
          user_id: string
        }
        Update: {
          config?: Json
          created_at?: string
          description?: string
          fingerprint?: string | null
          id?: string
          name?: string
          revision?: number
          tags?: string[]
          updated_at?: string
          user_id?: string
        }
        Relationships: []
      }
    }
    Views: {
      [_ in never]: never
    }
    Functions: {
      community_posts_search_tsv: {
        Args: {
          p_description: string
          p_tags: string[]
          p_title: string
          p_use_case: string
        }
        Returns: unknown
      }
      community_profiles_by_ids: {
        Args: { input_ids: string[] }
        Returns: {
          avatar_url: string
          display_name: string
          id: string
        }[]
      }
      delete_my_account: {
        Args: never
        Returns: boolean
      }
      dearmor: { Args: { "": string }; Returns: string }
      gen_random_uuid: { Args: never; Returns: string }
      gen_salt: { Args: { "": string }; Returns: string }
      pgp_armor_headers: {
        Args: { "": string }
        Returns: Record<string, unknown>[]
      }
      refresh_community_post_metrics: {
        Args: { target_post_id: string }
        Returns: undefined
      }
      show_db_tree: {
        Args: never
        Returns: {
          tree_structure: string
        }[]
      }
      strip_sensitive_prompt_config: {
        Args: { input_config: Json }
        Returns: Json
      }
    }
    Enums: {
      [_ in never]: never
    }
    CompositeTypes: {
      [_ in never]: never
    }
  }
}

type DatabaseWithoutInternals = Omit<Database, "__InternalSupabase">

type DefaultSchema = DatabaseWithoutInternals[Extract<keyof Database, "public">]

export type Tables<
  DefaultSchemaTableNameOrOptions extends
    | keyof (DefaultSchema["Tables"] & DefaultSchema["Views"])
    | { schema: keyof DatabaseWithoutInternals },
  TableName extends DefaultSchemaTableNameOrOptions extends {
    schema: keyof DatabaseWithoutInternals
  }
    ? keyof (DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"] &
        DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Views"])
    : never = never,
> = DefaultSchemaTableNameOrOptions extends {
  schema: keyof DatabaseWithoutInternals
}
  ? (DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"] &
      DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Views"])[TableName] extends {
      Row: infer R
    }
    ? R
    : never
  : DefaultSchemaTableNameOrOptions extends keyof (DefaultSchema["Tables"] &
        DefaultSchema["Views"])
    ? (DefaultSchema["Tables"] &
        DefaultSchema["Views"])[DefaultSchemaTableNameOrOptions] extends {
        Row: infer R
      }
      ? R
      : never
    : never

export type TablesInsert<
  DefaultSchemaTableNameOrOptions extends
    | keyof DefaultSchema["Tables"]
    | { schema: keyof DatabaseWithoutInternals },
  TableName extends DefaultSchemaTableNameOrOptions extends {
    schema: keyof DatabaseWithoutInternals
  }
    ? keyof DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"]
    : never = never,
> = DefaultSchemaTableNameOrOptions extends {
  schema: keyof DatabaseWithoutInternals
}
  ? DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"][TableName] extends {
      Insert: infer I
    }
    ? I
    : never
  : DefaultSchemaTableNameOrOptions extends keyof DefaultSchema["Tables"]
    ? DefaultSchema["Tables"][DefaultSchemaTableNameOrOptions] extends {
        Insert: infer I
      }
      ? I
      : never
    : never

export type TablesUpdate<
  DefaultSchemaTableNameOrOptions extends
    | keyof DefaultSchema["Tables"]
    | { schema: keyof DatabaseWithoutInternals },
  TableName extends DefaultSchemaTableNameOrOptions extends {
    schema: keyof DatabaseWithoutInternals
  }
    ? keyof DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"]
    : never = never,
> = DefaultSchemaTableNameOrOptions extends {
  schema: keyof DatabaseWithoutInternals
}
  ? DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"][TableName] extends {
      Update: infer U
    }
    ? U
    : never
  : DefaultSchemaTableNameOrOptions extends keyof DefaultSchema["Tables"]
    ? DefaultSchema["Tables"][DefaultSchemaTableNameOrOptions] extends {
        Update: infer U
      }
      ? U
      : never
    : never

export type Enums<
  DefaultSchemaEnumNameOrOptions extends
    | keyof DefaultSchema["Enums"]
    | { schema: keyof DatabaseWithoutInternals },
  EnumName extends DefaultSchemaEnumNameOrOptions extends {
    schema: keyof DatabaseWithoutInternals
  }
    ? keyof DatabaseWithoutInternals[DefaultSchemaEnumNameOrOptions["schema"]]["Enums"]
    : never = never,
> = DefaultSchemaEnumNameOrOptions extends {
  schema: keyof DatabaseWithoutInternals
}
  ? DatabaseWithoutInternals[DefaultSchemaEnumNameOrOptions["schema"]]["Enums"][EnumName]
  : DefaultSchemaEnumNameOrOptions extends keyof DefaultSchema["Enums"]
    ? DefaultSchema["Enums"][DefaultSchemaEnumNameOrOptions]
    : never

export type CompositeTypes<
  PublicCompositeTypeNameOrOptions extends
    | keyof DefaultSchema["CompositeTypes"]
    | { schema: keyof DatabaseWithoutInternals },
  CompositeTypeName extends PublicCompositeTypeNameOrOptions extends {
    schema: keyof DatabaseWithoutInternals
  }
    ? keyof DatabaseWithoutInternals[PublicCompositeTypeNameOrOptions["schema"]]["CompositeTypes"]
    : never = never,
> = PublicCompositeTypeNameOrOptions extends {
  schema: keyof DatabaseWithoutInternals
}
  ? DatabaseWithoutInternals[PublicCompositeTypeNameOrOptions["schema"]]["CompositeTypes"][CompositeTypeName]
  : PublicCompositeTypeNameOrOptions extends keyof DefaultSchema["CompositeTypes"]
    ? DefaultSchema["CompositeTypes"][PublicCompositeTypeNameOrOptions]
    : never

export const Constants = {
  public: {
    Enums: {},
  },
} as const
````

## File: src/lib/navigation.ts
````typescript
import {
  BookOpen,
  ClockCounterClockwise as History,
  PencilSimple as PenSquare,
  Stack as Layers,
  Users,
} from "@phosphor-icons/react";
import type { Icon } from "@phosphor-icons/react";

export interface AppRouteNavItem {
  to: string;
  label: string;
  icon: Icon;
  ariaLabel: string;
}

export const APP_ROUTE_NAV_ITEMS: ReadonlyArray<AppRouteNavItem> = [
  { to: "/", label: "Builder", icon: PenSquare, ariaLabel: "Open builder" },
  { to: "/presets", label: "Presets", icon: Layers, ariaLabel: "Browse preset templates" },
  { to: "/community", label: "Community", icon: Users, ariaLabel: "Open community" },
  { to: "/library", label: "Library", icon: BookOpen, ariaLabel: "Open prompt library" },
  { to: "/history", label: "History", icon: History, ariaLabel: "Open version history" },
];

export const BOTTOM_NAV_ITEMS: ReadonlyArray<AppRouteNavItem> = APP_ROUTE_NAV_ITEMS;

export function isRouteActive(pathname: string, route: string): boolean {
  if (route === "/") return pathname === "/";
  return pathname.startsWith(route);
}
````

## File: src/components/base/buttons/button.tsx
````typescript
import type { AnchorHTMLAttributes, ButtonHTMLAttributes, DetailedHTMLProps } from "react";
import { cva } from "class-variance-authority";
import type { ButtonProps as AriaButtonProps, LinkProps as AriaLinkProps } from "react-aria-components";
import { Button as AriaButton, Link as AriaLink } from "react-aria-components";
import { cx, sortCx } from "@/lib/utils/cx";
import { renderIconSlot, type IconSlot } from "@/lib/utils/icon-slot";

const legacyButtonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium outline-ring transition duration-100 ease-linear focus-visible:outline-2 focus-visible:outline-offset-2 disabled:pointer-events-none disabled:opacity-50 sm:text-sm [&_svg]:pointer-events-none [&_svg]:h-[1em] [&_svg]:w-[1em] [&_svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground shadow-xs hover:brightness-95",
        destructive: "bg-destructive text-destructive-foreground shadow-xs hover:brightness-95",
        brandPrimary:
          "border border-primary/30 text-primary-foreground bg-[linear-gradient(135deg,hsl(var(--delight-warm)),hsl(var(--delight-cool)))] shadow-[0_14px_30px_-20px_hsl(var(--delight-glow)/0.72)] hover:brightness-105",
        brandSecondary: "border border-secondary bg-primary text-secondary shadow-xs hover:brightness-95",
        brandDestructive:
          "border border-destructive/30 text-destructive-foreground bg-[linear-gradient(135deg,hsl(var(--destructive)),hsl(0_70%_42%))] shadow-[0_12px_24px_-18px_hsl(var(--destructive)/0.8)] hover:brightness-105",
        outline: "border border-secondary bg-primary text-secondary shadow-xs hover:brightness-95",
        secondary: "bg-secondary text-secondary-foreground shadow-xs hover:brightness-95",
        ghost: "text-muted-foreground hover:bg-muted hover:text-foreground",
        link: "justify-start rounded p-0 text-primary underline-offset-4 hover:text-primary/90 hover:underline",
        glow:
          "bg-primary text-primary-foreground shadow-[0_0_20px_hsl(var(--primary)/0.3)] hover:brightness-95 hover:shadow-[0_0_30px_hsl(var(--primary)/0.5)] motion-safe:hover:-translate-y-[1px] motion-safe:active:translate-y-0 motion-safe:active:scale-[0.98]",
        soft: "border border-primary/20 bg-secondary text-secondary-foreground hover:brightness-95",
      },
      size: {
        default: "h-11 px-4 py-2 sm:h-10",
        sm: "h-11 rounded-md px-3 sm:h-9",
        lg: "h-12 rounded-md px-8 sm:h-11",
        icon: "h-11 w-11 sm:h-10 sm:w-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  },
);

export const buttonVariants = legacyButtonVariants;

export const styles = sortCx({
  common: {
    root: [
      "group relative inline-flex h-max cursor-pointer items-center justify-center whitespace-nowrap rounded-lg transition duration-100 ease-linear",
      "focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
      "disabled:pointer-events-none disabled:opacity-50",
      "in-data-input-wrapper:focus:!z-50 in-data-input-wrapper:in-data-leading:-mr-px in-data-input-wrapper:in-data-leading:rounded-r-none",
      "in-data-input-wrapper:in-data-trailing:-ml-px in-data-input-wrapper:in-data-trailing:rounded-l-none",
      "*:data-icon:pointer-events-none *:data-icon:shrink-0",
    ].join(" "),
    icon: "size-5 transition-inherit-all",
  },
  sizes: {
    sm: {
      root: "gap-1 rounded-lg px-3 py-2 text-sm font-semibold data-icon-only:size-11 data-icon-only:p-0",
      linkRoot: "gap-1",
    },
    md: {
      root: "gap-1.5 rounded-lg px-3.5 py-2.5 text-sm font-semibold data-icon-only:size-11 data-icon-only:p-0",
      linkRoot: "gap-1.5",
    },
    lg: {
      root: "gap-1.5 rounded-lg px-4 py-2.5 text-base font-semibold data-icon-only:size-12 data-icon-only:p-0",
      linkRoot: "gap-1.5",
    },
    xl: {
      root: "gap-2 rounded-lg px-4.5 py-3 text-base font-semibold data-icon-only:size-12 data-icon-only:p-0",
      linkRoot: "gap-2",
    },
    icon: {
      root: "size-11 p-0 text-sm",
      linkRoot: "",
    },
  },
  colors: {
    primary: {
      root: "bg-primary text-primary-foreground shadow-xs hover:brightness-95 data-loading:brightness-95",
    },
    secondary: {
      root: "border border-border bg-background text-foreground shadow-xs hover:bg-muted data-loading:bg-muted",
    },
    tertiary: {
      root: "text-muted-foreground hover:bg-muted hover:text-foreground data-loading:bg-muted",
    },
    "link-gray": {
      root: [
        "justify-normal rounded p-0 text-muted-foreground hover:text-foreground",
        "*:data-text:underline *:data-text:decoration-transparent *:data-text:underline-offset-2 hover:*:data-text:decoration-current",
      ].join(" "),
    },
    "link-color": {
      root: [
        "justify-normal rounded p-0 text-primary hover:text-primary/90",
        "*:data-text:underline *:data-text:decoration-transparent *:data-text:underline-offset-2 hover:*:data-text:decoration-current",
      ].join(" "),
    },
    "primary-destructive": {
      root: "bg-destructive text-destructive-foreground shadow-xs hover:brightness-95 data-loading:brightness-95",
    },
    "secondary-destructive": {
      root: "border border-destructive/35 bg-background text-destructive shadow-xs hover:bg-destructive/10 data-loading:bg-destructive/10",
    },
    "tertiary-destructive": {
      root: "text-destructive hover:bg-destructive/10 data-loading:bg-destructive/10",
    },
    "link-destructive": {
      root: [
        "justify-normal rounded p-0 text-destructive hover:text-destructive/90",
        "*:data-text:underline *:data-text:decoration-transparent *:data-text:underline-offset-2 hover:*:data-text:decoration-current",
      ].join(" "),
    },
  },
});

type ButtonSize = keyof typeof styles.sizes | "default";
type ButtonIconProps = { className?: string; "data-icon"?: string };

/**
 * Common props shared between button and anchor variants
 */
export interface CommonProps {
  /** Disables the button and shows a disabled state */
  isDisabled?: boolean;
  /** Shows a loading spinner and disables the button */
  isLoading?: boolean;
  /** The size variant of the button */
  size?: ButtonSize;
  /** The color variant of the button */
  color?: keyof typeof styles.colors;
  /** Icon component or element to show before the text */
  iconLeading?: IconSlot<ButtonIconProps>;
  /** Icon component or element to show after the text */
  iconTrailing?: IconSlot<ButtonIconProps>;
  /** Removes horizontal padding from the text content */
  noTextPadding?: boolean;
  /** When true, keeps the text visible during loading state */
  showTextWhileLoading?: boolean;
}

/**
 * Props for the button variant (non-link)
 */
export interface ButtonProps extends CommonProps, DetailedHTMLProps<Omit<ButtonHTMLAttributes<HTMLButtonElement>, "color" | "slot">, HTMLButtonElement> {
  /** Slot name for react-aria component */
  slot?: AriaButtonProps["slot"];
}

/**
 * Props for the link variant (anchor tag)
 */
interface LinkProps extends CommonProps, DetailedHTMLProps<Omit<AnchorHTMLAttributes<HTMLAnchorElement>, "color">, HTMLAnchorElement> {
  /** Options for the configured client side router. */
  routerOptions?: AriaLinkProps["routerOptions"];
}

/** Union type of button and link props */
export type Props = ButtonProps | LinkProps;

export const Button = ({
  size = "sm",
  color = "primary",
  children,
  className,
  noTextPadding,
  iconLeading: IconLeading,
  iconTrailing: IconTrailing,
  isDisabled: disabled,
  isLoading: loading,
  showTextWhileLoading,
  ...otherProps
}: Props) => {
  const resolvedSize = size === "default" ? "sm" : size;
  const href = "href" in otherProps ? otherProps.href : undefined;
  const Component = href ? AriaLink : AriaButton;

  const isIcon = (IconLeading || IconTrailing) && !children;
  const isLinkType = ["link-gray", "link-color", "link-destructive"].includes(color);
  const disabledState = Boolean(disabled || ("disabled" in otherProps && otherProps.disabled));

  noTextPadding = isLinkType || noTextPadding;

  let props = {};

  if (href) {
    props = {
      ...otherProps,
      href: disabledState ? undefined : href,
    };
  } else {
    props = {
      ...otherProps,
      type: (otherProps as ButtonHTMLAttributes<HTMLButtonElement>).type || "button",
      isPending: loading,
    };
  }

  return (
    <Component
      data-loading={loading ? true : undefined}
      data-icon-only={isIcon ? true : undefined}
      {...props}
      isDisabled={disabledState}
      className={cx(
        styles.common.root,
        styles.sizes[resolvedSize].root,
        styles.colors[color].root,
        isLinkType && styles.sizes[resolvedSize].linkRoot,
        (loading || (href && (disabledState || loading))) && "pointer-events-none",
        loading && (showTextWhileLoading ? "[&>*:not([data-icon=loading]):not([data-text])]:hidden" : "[&>*:not([data-icon=loading])]:invisible"),
        className,
      )}
    >
      {/* Leading icon */}
      {renderIconSlot(IconLeading, { "data-icon": "leading", className: styles.common.icon })}

      {loading && (
        <svg
          fill="none"
          data-icon="loading"
          viewBox="0 0 20 20"
          className={cx(styles.common.icon, !showTextWhileLoading && "absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2")}
        >
          <circle className="stroke-current opacity-30" cx="10" cy="10" r="8" fill="none" strokeWidth="2" />
          <circle
            className="origin-center animate-spin stroke-current"
            cx="10"
            cy="10"
            r="8"
            fill="none"
            strokeWidth="2"
            strokeDasharray="12.5 50"
            strokeLinecap="round"
          />
        </svg>
      )}

      {children && (
        <span data-text className={cx("transition-inherit-all", !noTextPadding && "px-0.5")}>
          {children}
        </span>
      )}

      {/* Trailing icon */}
      {renderIconSlot(IconTrailing, { "data-icon": "trailing", className: styles.common.icon })}
    </Component>
  );
};
````

## File: src/components/base/select/multi-select.tsx
````typescript
import type { FocusEventHandler, KeyboardEvent, PointerEventHandler, RefAttributes, RefObject } from "react";
import { createContext, useCallback, useContext, useRef, useState } from "react";
import { FocusScope, useFilter, useFocusManager } from "react-aria";
import type { ComboBoxProps as AriaComboBoxProps, GroupProps as AriaGroupProps, ListBoxProps as AriaListBoxProps, Key } from "react-aria-components";
import { ComboBox as AriaComboBox, Group as AriaGroup, Input as AriaInput, ListBox as AriaListBox, ComboBoxStateContext } from "react-aria-components";
import type { ListData } from "react-stately";
import { useListData } from "react-stately";
import { Avatar } from "@/components/base/avatar/avatar";
import { HintText } from "@/components/base/input/hint-text";
import { Label } from "@/components/base/input/label";
import { Popover } from "@/components/base/select/popover";
import { type SelectItemType, sizes } from "@/components/base/select/select";
import { TagCloseX } from "@/components/base/tags/base-components/tag-close-x";
import { useResizeObserver } from "@/hooks/use-resize-observer";
import { cx } from "@/lib/utils/cx";
import { renderIconSlot, type IconSlot } from "@/lib/utils/icon-slot";
import { SelectItem } from "./select-item";
import { MagnifyingGlass as SearchLg } from "@phosphor-icons/react";

type MultiSelectIconProps = { className?: string; "aria-hidden"?: boolean };

interface ComboBoxValueProps extends AriaGroupProps {
    size: "sm" | "md";
    shortcut?: boolean;
    isDisabled?: boolean;
    placeholder?: string;
    shortcutClassName?: string;
    placeholderIcon?: IconSlot<MultiSelectIconProps> | null;
    ref?: RefObject<HTMLDivElement | null>;
    onFocus?: FocusEventHandler;
    onPointerEnter?: PointerEventHandler;
}

const ComboboxContext = createContext<{
    size: "sm" | "md";
    selectedKeys: Key[];
    selectedItems: ListData<SelectItemType>;
    onRemove: (keys: Set<Key>) => void;
    onInputChange: (value: string) => void;
}>({
    size: "sm",
    selectedKeys: [],
    selectedItems: {} as ListData<SelectItemType>,
    onRemove: () => {},
    onInputChange: () => {},
});

interface MultiSelectProps extends Omit<AriaComboBoxProps<SelectItemType>, "children" | "items">, RefAttributes<HTMLDivElement> {
    hint?: string;
    label?: string;
    tooltip?: string;
    size?: "sm" | "md";
    placeholder?: string;
    shortcut?: boolean;
    items?: SelectItemType[];
    popoverClassName?: string;
    shortcutClassName?: string;
    selectedItems: ListData<SelectItemType>;
    placeholderIcon?: IconSlot<MultiSelectIconProps> | null;
    children: AriaListBoxProps<SelectItemType>["children"];
    onItemCleared?: (key: Key) => void;
    onItemInserted?: (key: Key) => void;
}

export const MultiSelectBase = ({
    items,
    children,
    size = "sm",
    selectedItems,
    onItemCleared,
    onItemInserted,
    shortcut,
    placeholder = "Search",
    // Omit these props to avoid conflicts with the `Select` component
    name: _name,
    className: _className,
    ...props
}: MultiSelectProps) => {
    const { contains } = useFilter({ sensitivity: "base" });
    const selectedKeys = selectedItems.items.map((item) => item.id);

    const filter = useCallback(
        (item: SelectItemType, filterText: string) => {
            return !selectedKeys.includes(item.id) && contains(item.label || item.supportingText || "", filterText);
        },
        [contains, selectedKeys],
    );

    const accessibleList = useListData({
        initialItems: items,
        filter,
    });

    const onRemove = useCallback(
        (keys: Set<Key>) => {
            const key = keys.values().next().value;

            if (!key) return;

            selectedItems.remove(key);
            onItemCleared?.(key);
        },
        [selectedItems, onItemCleared],
    );

    const onSelectionChange = (id: Key | null) => {
        if (!id) {
            return;
        }

        const item = accessibleList.getItem(id);

        if (!item) {
            return;
        }

        if (!selectedKeys.includes(id as string)) {
            selectedItems.append(item);
            onItemInserted?.(id);
        }

        accessibleList.setFilterText("");
    };

    const onInputChange = (value: string) => {
        accessibleList.setFilterText(value);
    };

    const placeholderRef = useRef<HTMLDivElement>(null);
    const [popoverWidth, setPopoverWidth] = useState("");

    // Resize observer for popover width
    const onResize = useCallback(() => {
        if (!placeholderRef.current) return;
        const divRect = placeholderRef.current?.getBoundingClientRect();
        setPopoverWidth(divRect.width + "px");
    }, [placeholderRef, setPopoverWidth]);

    useResizeObserver({
        ref: placeholderRef,
        onResize: onResize,
        box: "border-box",
    });

    return (
        <ComboboxContext.Provider
            value={{
                size,
                selectedKeys,
                selectedItems,
                onInputChange,
                onRemove,
            }}
        >
            <AriaComboBox
                allowsEmptyCollection
                menuTrigger="focus"
                items={accessibleList.items}
                onInputChange={onInputChange}
                inputValue={accessibleList.filterText}
                // This keeps the combobox popover open and the input value unchanged when an item is selected.
                selectedKey={null}
                onSelectionChange={onSelectionChange}
                {...props}
            >
                {(state) => (
                    <div className="flex flex-col gap-1.5">
                        {props.label && (
                            <Label isRequired={state.isRequired} tooltip={props.tooltip}>
                                {props.label}
                            </Label>
                        )}

                        <MultiSelectTagsValue
                            size={size}
                            shortcut={shortcut}
                            ref={placeholderRef}
                            placeholder={placeholder}
                            // This is a workaround to correctly calculating the trigger width
                            // while using ResizeObserver wasn't 100% reliable.
                            onFocus={onResize}
                            onPointerEnter={onResize}
                        />

                        <Popover size={"md"} triggerRef={placeholderRef} style={{ width: popoverWidth }} className={props?.popoverClassName}>
                            <AriaListBox selectionMode="multiple" className="size-full outline-hidden">
                                {children}
                            </AriaListBox>
                        </Popover>

                        {props.hint && <HintText isInvalid={state.isInvalid}>{props.hint}</HintText>}
                    </div>
                )}
            </AriaComboBox>
        </ComboboxContext.Provider>
    );
};

const InnerMultiSelect = ({ isDisabled, shortcut, shortcutClassName, placeholder }: Omit<MultiSelectProps, "selectedItems" | "children">) => {
    const focusManager = useFocusManager();
    const comboBoxContext = useContext(ComboboxContext);
    const comboBoxStateContext = useContext(ComboBoxStateContext);

    const handleInputKeyDown = (event: KeyboardEvent<HTMLInputElement>) => {
        const isCaretAtStart = event.currentTarget.selectionStart === 0 && event.currentTarget.selectionEnd === 0;

        if (!isCaretAtStart && event.currentTarget.value !== "") {
            return;
        }

        switch (event.key) {
            case "Backspace":
            case "ArrowLeft":
                focusManager?.focusPrevious({ wrap: false, tabbable: false });
                break;
            case "ArrowRight":
                focusManager?.focusNext({ wrap: false, tabbable: false });
                break;
        }
    };

    // Ensure dropdown opens on click even if input is already focused
    const handleInputMouseDown = (_event: React.MouseEvent<HTMLInputElement>) => {
        if (comboBoxStateContext && !comboBoxStateContext.isOpen) {
            comboBoxStateContext.open();
        }
    };

    const handleTagKeyDown = (event: KeyboardEvent<HTMLButtonElement>, value: Key) => {
        // Do nothing when tab is clicked to move focus from the tag to the input element.
        if (event.key === "Tab") {
            return;
        }

        event.preventDefault();

        const isFirstTag = comboBoxContext?.selectedItems?.items?.[0]?.id === value;

        switch (event.key) {
            case " ":
            case "Enter":
            case "Backspace":
                if (isFirstTag) {
                    focusManager?.focusNext({ wrap: false, tabbable: false });
                } else {
                    focusManager?.focusPrevious({ wrap: false, tabbable: false });
                }

                comboBoxContext.onRemove(new Set([value]));
                break;

            case "ArrowLeft":
                focusManager?.focusPrevious({ wrap: false, tabbable: false });
                break;
            case "ArrowRight":
                focusManager?.focusNext({ wrap: false, tabbable: false });
                break;
            case "Escape":
                comboBoxStateContext?.close();
                break;
        }
    };

    const isSelectionEmpty = comboBoxContext?.selectedItems?.items?.length === 0;

    return (
        <div className="relative flex w-full flex-1 flex-row flex-wrap items-center justify-start gap-1.5">
            {!isSelectionEmpty &&
                comboBoxContext?.selectedItems?.items?.map((value) => (
                    <span key={value.id} className="flex items-center rounded-md bg-muted/70 py-0.5 pr-1 pl-1.25 ring-1 ring-border ring-inset">
                        <Avatar size="xxs" alt={value?.label} src={value?.avatarUrl} />

                        <p className="ml-1.25 truncate text-sm font-medium whitespace-nowrap text-foreground select-none">{value?.label}</p>

                        <TagCloseX
                            size="md"
                            isDisabled={isDisabled}
                            className="ml-0.75"
                            // For workaround, onKeyDown is added to the button
                            onKeyDown={(event) => handleTagKeyDown(event, value.id)}
                            onPress={() => comboBoxContext.onRemove(new Set([value.id]))}
                        />
                    </span>
                ))}

            <div className={cx("relative flex min-w-[20%] flex-1 flex-row items-center", !isSelectionEmpty && "ml-0.5", shortcut && "min-w-[30%]")}>
                <AriaInput
                    placeholder={placeholder}
                    onKeyDown={handleInputKeyDown}
                    onMouseDown={handleInputMouseDown}
                    className="w-full flex-[1_0_0] appearance-none bg-transparent text-md text-ellipsis text-foreground caret-foreground outline-none placeholder:text-placeholder focus:outline-hidden disabled:cursor-not-allowed disabled:text-disabled disabled:placeholder:text-disabled"
                />

                {shortcut && (
                    <div
                        aria-hidden="true"
                        className={cx(
                            "absolute inset-y-0.5 right-0.5 z-10 flex items-center rounded-r-[inherit] bg-linear-to-r from-transparent to-background to-40% pl-8",
                            shortcutClassName,
                        )}
                    >
                        <span
                            className={cx(
                                "pointer-events-none rounded px-1 py-px text-xs font-medium text-quaternary ring-1 ring-secondary select-none ring-inset",
                                isDisabled && "bg-transparent text-disabled",
                            )}
                        >
                            ⌘K
                        </span>
                    </div>
                )}
            </div>
        </div>
    );
};

export const MultiSelectTagsValue = ({
    size,
    shortcut,
    placeholder,
    shortcutClassName,
    placeholderIcon: Icon = SearchLg,
    // Omit this prop to avoid invalid HTML attribute warning
    isDisabled: _isDisabled,
    ...otherProps
}: ComboBoxValueProps) => {
    return (
        <AriaGroup
            {...otherProps}
            className={({ isFocusWithin, isDisabled }) =>
                cx(
                    "relative flex w-full items-center gap-2 rounded-lg bg-background shadow-xs ring-1 ring-border outline-hidden transition duration-100 ease-linear ring-inset",
                    isDisabled && "cursor-not-allowed bg-disabled_subtle",
                    isFocusWithin && "ring-2 ring-brand",
                    sizes[size].root,
                )
            }
        >
            {({ isDisabled }) => (
                <>
                    {renderIconSlot(Icon, { className: "pointer-events-none size-5 text-fg-quaternary", "aria-hidden": true })}
                    <FocusScope contain={false} autoFocus={false} restoreFocus={false}>
                        <InnerMultiSelect
                            isDisabled={isDisabled}
                            size={size}
                            shortcut={shortcut}
                            shortcutClassName={shortcutClassName}
                            placeholder={placeholder}
                        />
                    </FocusScope>
                </>
            )}
        </AriaGroup>
    );
};

const MultiSelect = MultiSelectBase as typeof MultiSelectBase & {
    Item: typeof SelectItem;
};

MultiSelect.Item = SelectItem;

export { MultiSelect as MultiSelect };
````

## File: src/components/ProjectNotes.tsx
````typescript
import { Textarea } from "@/components/base/textarea";
import { Notepad as StickyNote } from "@phosphor-icons/react";

interface ProjectNotesProps {
  value: string;
  onChange: (value: string) => void;
}

export function ProjectNotes({ value, onChange }: ProjectNotesProps) {
  return (
    <div className="space-y-2">
      <div className="flex items-center gap-1.5">
        <StickyNote className="w-3.5 h-3.5 text-muted-foreground" />
        <label className="text-sm font-medium text-foreground">
          Project notes
        </label>
        <span className="text-sm text-muted-foreground">(reusable across prompts)</span>
      </div>
      <Textarea
        placeholder="Persistent notes, brand voice guidelines, key facts, or any context you reuse across prompts..."
        value={value}
        onChange={(e) => onChange(e.target.value)}
        className="min-h-[80px] bg-background"
      />
    </div>
  );
}
````

## File: src/pages/SupportInbox.tsx
````typescript
import { useCallback, useEffect, useMemo, useState } from "react";
import { PageHero, PageShell } from "@/components/PageShell";
import { Badge } from "@/components/base/badges/badges";
import { Button } from "@/components/base/buttons/button";
import { Card } from "@/components/base/primitives/card";
import { useAuth } from "@/hooks/useAuth";
import {
  isSupportReviewer,
  listContactMessagesForReviewer,
  updateContactMessageStatus,
  type ContactMessageRecord,
  type ContactMessageStatus,
} from "@/lib/contact-support";
import { useToast } from "@/hooks/use-toast";

type AccessState = "loading" | "signed_out" | "forbidden" | "granted";

function formatCreatedAt(value: string): string {
  const date = new Date(value);
  if (Number.isNaN(date.getTime())) return value;
  return new Intl.DateTimeFormat(undefined, {
    dateStyle: "medium",
    timeStyle: "short",
  }).format(date);
}

function statusBadgeClassName(status: ContactMessageStatus): string {
  if (status === "reviewing") return "bg-utility-brand-50 text-utility-brand-700 ring-utility-brand-200";
  if (status === "resolved") return "bg-utility-success-50 text-utility-success-700 ring-utility-success-200";
  return "border border-border bg-background text-foreground";
}

const SupportInbox = () => {
  const { user, loading } = useAuth();
  const { toast } = useToast();
  const [access, setAccess] = useState<AccessState>("loading");
  const [messages, setMessages] = useState<ContactMessageRecord[]>([]);
  const [loadingMessages, setLoadingMessages] = useState(false);
  const [statusBusyId, setStatusBusyId] = useState<string | null>(null);

  const loadMessages = useCallback(async () => {
    setLoadingMessages(true);
    try {
      const rows = await listContactMessagesForReviewer();
      setMessages(rows);
    } catch (error) {
      toast({
        title: "Could not load inbox",
        description: error instanceof Error ? error.message : "Please try again.",
        variant: "destructive",
      });
    } finally {
      setLoadingMessages(false);
    }
  }, [toast]);

  useEffect(() => {
    if (loading) return;
    if (!user?.id) {
      setAccess("signed_out");
      setMessages([]);
      return;
    }

    let cancelled = false;
    void (async () => {
      setAccess("loading");
      try {
        const allowed = await isSupportReviewer();
        if (cancelled) return;
        if (!allowed) {
          setAccess("forbidden");
          setMessages([]);
          return;
        }
        setAccess("granted");
      } catch (error) {
        if (cancelled) return;
        setAccess("forbidden");
        toast({
          title: "Access check failed",
          description: error instanceof Error ? error.message : "Could not verify reviewer access.",
          variant: "destructive",
        });
      }
    })();

    return () => {
      cancelled = true;
    };
  }, [loading, user?.id, toast]);

  useEffect(() => {
    if (access !== "granted") return;
    void loadMessages();
  }, [access, loadMessages]);

  const emptyState = useMemo(() => {
    if (loadingMessages) return "Loading support messages...";
    return "No contact messages yet.";
  }, [loadingMessages]);

  const handleStatusChange = useCallback(async (messageId: string, status: ContactMessageStatus) => {
    setStatusBusyId(messageId);
    try {
      await updateContactMessageStatus(messageId, status);
      setMessages((previous) =>
        previous.map((message) =>
          message.id === messageId
            ? { ...message, status, updatedAt: new Date().toISOString() }
            : message,
        ),
      );
    } catch (error) {
      toast({
        title: "Could not update status",
        description: error instanceof Error ? error.message : "Please try again.",
        variant: "destructive",
      });
    } finally {
      setStatusBusyId(null);
    }
  }, [toast]);

  return (
    <PageShell>
      <PageHero
        title="Support Inbox"
        subtitle="Review and triage contact form submissions."
        className="pf-gilded-frame pf-hero-surface"
      />

      {access === "loading" && (
        <Card className="pf-card border-border/80 bg-card/85 p-4 text-sm text-muted-foreground">
          Verifying access...
        </Card>
      )}

      {access === "signed_out" && (
        <Card className="pf-card border-border/80 bg-card/85 p-4 text-sm text-muted-foreground">
          Sign in with a support reviewer account to access this inbox.
        </Card>
      )}

      {access === "forbidden" && (
        <Card className="pf-card border-border/80 bg-card/85 p-4 text-sm text-muted-foreground">
          This account does not have support inbox access.
        </Card>
      )}

      {access === "granted" && (
        <div className="space-y-3">
          <div className="flex items-center justify-between gap-2">
            <p className="text-sm text-muted-foreground">
              {messages.length} message{messages.length === 1 ? "" : "s"}
            </p>
            <Button
              type="button"
              color="secondary"
              size="sm"
              onClick={() => void loadMessages()}
              disabled={loadingMessages}
            >
              {loadingMessages ? "Refreshing..." : "Refresh"}
            </Button>
          </div>

          {messages.length === 0 && (
            <Card className="pf-card border-border/80 bg-card/85 p-4 text-sm text-muted-foreground">
              {emptyState}
            </Card>
          )}

          {messages.map((message) => (
            <Card key={message.id} className="pf-card space-y-3 border-border/80 bg-card/85 p-4">
              <div className="flex flex-wrap items-start justify-between gap-2">
                <div>
                  <p className="text-sm font-semibold text-foreground">
                    {message.firstName} {message.lastName}
                  </p>
                  <p className="text-xs text-muted-foreground">
                    {message.email}
                    {message.phoneNumber ? ` • ${message.phoneNumber}` : ""}
                  </p>
                  <p className="text-xs text-muted-foreground">
                    Submitted {formatCreatedAt(message.createdAt)}
                  </p>
                </div>
                <Badge type="modern" className={statusBadgeClassName(message.status)}>
                  {message.status}
                </Badge>
              </div>

              <p className="whitespace-pre-wrap text-sm text-foreground">
                {message.message}
              </p>

              <div className="flex flex-wrap gap-2">
                {(["new", "reviewing", "resolved"] as const).map((status) => (
                  <Button
                    key={status}
                    type="button"
                    size="sm"
                    color={message.status === status ? "secondary" : "tertiary"}
                    disabled={statusBusyId === message.id || message.status === status}
                    onClick={() => void handleStatusChange(message.id, status)}
                  >
                    Mark {status}
                  </Button>
                ))}
              </div>
            </Card>
          ))}
        </div>
      )}
    </PageShell>
  );
};

export default SupportInbox;
````

## File: tailwind.config.ts
````typescript
import type { Config } from "tailwindcss";

export default {
  darkMode: ["class"],
  content: ["./pages/**/*.{ts,tsx}", "./components/**/*.{ts,tsx}", "./app/**/*.{ts,tsx}", "./src/**/*.{ts,tsx}"],
  prefix: "",
  theme: {
    container: {
      center: true,
      padding: "2rem",
      screens: {
        "2xl": "1400px",
      },
    },
    extend: {
      spacing: {
        base: "var(--spacing)",
      },
      transitionTimingFunction: {
        snap: "var(--motion-snap)",
      },
      fontSize: {
        "2xs": ["var(--type-2xs-size)", { lineHeight: "var(--type-2xs-line)" }],
        xs: ["var(--type-xs-size)", { lineHeight: "var(--type-xs-line)" }],
        sm: ["var(--type-sm-size)", { lineHeight: "var(--type-sm-line)" }],
        base: ["var(--type-base-size)", { lineHeight: "var(--type-base-line)" }],
        lg: ["var(--type-lg-size)", { lineHeight: "var(--type-lg-line)" }],
        xl: ["var(--type-xl-size)", { lineHeight: "var(--type-xl-line)" }],
        "2xl": ["var(--type-2xl-size)", { lineHeight: "var(--type-2xl-line)" }],
        "3xl": ["var(--type-3xl-size)", { lineHeight: "var(--type-3xl-line)" }],
        "4xl": ["var(--type-4xl-size)", { lineHeight: "var(--type-4xl-line)" }],
        "5xl": ["var(--type-5xl-size)", { lineHeight: "var(--type-5xl-line)" }],
      },
      colors: {
        border: "hsl(var(--border))",
        input: "hsl(var(--input))",
        ring: "hsl(var(--ring))",
        background: "hsl(var(--background))",
        foreground: "hsl(var(--foreground))",
        primary: {
          DEFAULT: "hsl(var(--primary))",
          foreground: "hsl(var(--primary-foreground))",
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary))",
          foreground: "hsl(var(--secondary-foreground))",
        },
        destructive: {
          DEFAULT: "hsl(var(--destructive))",
          foreground: "hsl(var(--destructive-foreground))",
        },
        muted: {
          DEFAULT: "hsl(var(--muted))",
          foreground: "hsl(var(--muted-foreground))",
        },
        accent: {
          DEFAULT: "hsl(var(--accent))",
          foreground: "hsl(var(--accent-foreground))",
        },
        popover: {
          DEFAULT: "hsl(var(--popover))",
          foreground: "hsl(var(--popover-foreground))",
        },
        card: {
          DEFAULT: "hsl(var(--card))",
          foreground: "hsl(var(--card-foreground))",
        },
        sidebar: {
          DEFAULT: "hsl(var(--sidebar-background))",
          foreground: "hsl(var(--sidebar-foreground))",
          primary: "hsl(var(--sidebar-primary))",
          "primary-foreground": "hsl(var(--sidebar-primary-foreground))",
          accent: "hsl(var(--sidebar-accent))",
          "accent-foreground": "hsl(var(--sidebar-accent-foreground))",
          border: "hsl(var(--sidebar-border))",
          ring: "hsl(var(--sidebar-ring))",
        },
        chart: {
          1: "hsl(var(--chart-1))",
          2: "hsl(var(--chart-2))",
          3: "hsl(var(--chart-3))",
          4: "hsl(var(--chart-4))",
          5: "hsl(var(--chart-5))",
        },
        delight: {
          warm: "hsl(var(--delight-warm))",
          cool: "hsl(var(--delight-cool))",
          glow: "hsl(var(--delight-glow))",
          surface: "hsl(var(--delight-surface))",
        },
        pf: {
          arcane: "rgb(var(--pf-arcane-rgb) / <alpha-value>)",
          deep: "rgb(var(--pf-deep-rgb) / <alpha-value>)",
          gold: "rgb(var(--pf-gold-rgb) / <alpha-value>)",
          ember: "rgb(var(--pf-ember-rgb) / <alpha-value>)",
          coal: "rgb(var(--pf-coal-rgb) / <alpha-value>)",
          midnight: "rgb(var(--pf-midnight-rgb) / <alpha-value>)",
          slate: "rgb(var(--pf-slate-rgb) / <alpha-value>)",
          parchment: "rgb(var(--pf-parchment-rgb) / <alpha-value>)",
        },
      },
      borderRadius: {
        lg: "var(--radius)",
        md: "calc(var(--radius) - 2px)",
        sm: "calc(var(--radius) - 4px)",
        "pf-sm": "var(--pf-radius-sm)",
        "pf-md": "var(--pf-radius-md)",
        "pf-lg": "var(--pf-radius-lg)",
        "pf-xl": "var(--pf-radius-xl)",
      },
      keyframes: {
        "accordion-down": {
          from: {
            height: "0",
          },
          to: {
            height: "var(--radix-accordion-content-height)",
          },
        },
        "accordion-up": {
          from: {
            height: "var(--radix-accordion-content-height)",
          },
          to: {
            height: "0",
          },
        },
        "caret-blink": {
          "0%, 50%": {
            opacity: "1",
          },
          "51%, 100%": {
            opacity: "0",
          },
        },
      },
      animation: {
        "accordion-down": "accordion-down 0.2s ease-out",
        "accordion-up": "accordion-up 0.2s ease-out",
        "caret-blink": "caret-blink 1s infinite",
      },
      boxShadow: {
        "2xs": "var(--shadow-2xs)",
        xs: "var(--shadow-xs)",
        sm: "var(--shadow-sm)",
        md: "var(--shadow-md)",
        lg: "var(--shadow-lg)",
        xl: "var(--shadow-xl)",
        "2xl": "var(--shadow-2xl)",
        "pf-card": "var(--pf-shadow-card)",
        "pf-elevated": "var(--pf-shadow-elevated)",
        "pf-arcane": "var(--pf-glow-arcane)",
        "pf-ember": "var(--pf-glow-ember)",
        "pf-gold": "var(--pf-glow-gold)",
      },
      fontFamily: {
        sans: ["var(--font-sans)"],
        serif: ["var(--font-serif)"],
        mono: ["var(--font-mono)"],
        display: ["var(--pf-font-display)"],
      },
    },
  },
  plugins: [],
} satisfies Config;
````

## File: agent_service/README.md
````markdown
# Agent Service

Prompt enhancement backend powered by `@openai/codex-sdk`.

The frontend calls this service directly for AI endpoints.

## Quick start

```bash
npm install
export AZURE_OPENAI_API_KEY="<your-azure-openai-api-key>"
export CODEX_CONFIG_JSON='{"model":"<your-azure-deployment-name>","model_provider":"azure","model_providers":{"azure":{"name":"Azure OpenAI","base_url":"https://fifteenmodels.openai.azure.com/openai/v1","env_key":"AZURE_OPENAI_API_KEY","wire_api":"responses"}}}'
npm run agent:codex
```

## Endpoints

| Method | Path | Description |
|--------|------|-------------|
| `GET` | `/` | Service info |
| `GET` | `/health` | Health check (returns model and sandbox mode) |
| `POST` | `/enhance` | Stream-enhanced prompt via SSE |
| `WS` | `/enhance/ws` | Stream-enhanced prompt via WebSocket |
| `POST` | `/extract-url` | Fetch URL content and return extracted bullet points |
| `POST` | `/infer-builder-fields` | Heuristic builder-field suggestions |

### `POST /enhance` body

```jsonc
{
  "prompt": "Your draft prompt text",       // required
  "thread_id": "thread_abc123",             // optional: resume a previous thread
  "builder_mode": "guided",                 // optional: quick|guided|advanced
  "builder_fields": {                       // optional but recommended: pass all 6 keys, even empty
    "role": "",
    "context": "",
    "task": "",
    "output_format": "",
    "examples": "",
    "guardrails": ""
  },
  "thread_options": {                       // optional
    "modelReasoningEffort": "medium"        // minimal|low|medium|high|xhigh
  }
}
```

### `WS /enhance/ws`

- Subprotocols:
  - `promptforge.enhance.v1` (required)
- First client message: send an `enhance.start` envelope with auth and payload:

```jsonc
{
  "type": "enhance.start",
  "auth": {
    "bearer_token": "<jwt>",   // required unless using apikey/service token fallback
    "apikey": "<key>"          // optional
  },
  "payload": {
    "prompt": "Your draft prompt text"
  }
}
```

- Legacy auth subprotocols (`auth.bearer.*`, `auth.apikey.*`, `auth.service.*`) are still accepted for compatibility, but message auth is recommended to reduce token exposure in edge logs.
- Server messages mirror the SSE event payloads and end with `{ "event": "stream.done", "type": "stream.done" }`.

### `POST /extract-url` body

```jsonc
{
  "url": "https://example.com/article" // required
}
```

### `POST /infer-builder-fields` body

```jsonc
{
  "prompt": "Draft prompt text",          // required
  "current_fields": {                     // optional
    "role": "",
    "tone": "",
    "lengthPreference": "",
    "format": [],
    "constraints": []
  },
  "lock_metadata": {                      // optional
    "role": "user",
    "tone": "empty"
  }
}
```

## Environment variables

### Required

| Variable | Description |
|----------|-------------|
| `AZURE_OPENAI_API_KEY` | Azure OpenAI API key (required when using Azure provider config) |
| `OPENAI_API_KEY` or `CODEX_API_KEY` | Fallback OpenAI API key (used only when no provider config is resolved) |
| `NEON_AUTH_URL` or `NEON_JWKS_URL` | Neon Auth URL (or direct JWKS URL) for bearer-session validation (recommended in production) |

### Provider resolution order

The service resolves AI provider settings in this order:

1. `~/.codex/config.toml`
2. `CODEX_CONFIG_JSON`
3. OpenAI fallback (`OPENAI_API_KEY` / `CODEX_API_KEY`, optional)

Set `REQUIRE_PROVIDER_CONFIG=true` to disable step 3 and fail fast instead of falling back.

### Service configuration

| Variable | Default | Description |
|----------|---------|-------------|
| `HOST` | `0.0.0.0` | Bind address |
| `PORT` | `8001` | Listen port |
| `AGENT_SERVICE_TOKEN` | _(none)_ | Optional service-to-service token (`x-agent-token`) |
| `ALLOWED_ORIGINS` | `*` | Comma-separated list of allowed browser origins |
| `REQUIRE_PROVIDER_CONFIG` | `false` | If `true`, startup fails unless provider config is resolved from `~/.codex/config.toml` or `CODEX_CONFIG_JSON` |
| `FUNCTION_PUBLIC_API_KEY` | _(none)_ | Optional publishable key accepted for unauthenticated calls |
| `ENHANCE_WS_INITIAL_MESSAGE_TIMEOUT_MS` | `5000` | Time allowed for first websocket message before the socket is closed |
| `ENHANCE_WS_MAX_PAYLOAD_BYTES` | `65536` | Maximum websocket message payload size in bytes |
| `ENHANCE_WS_MAX_CONNECTIONS_PER_IP` | `10` | Maximum concurrent `/enhance/ws` connections allowed per client IP |
| `ALLOW_UNVERIFIED_JWT_FALLBACK` | `false` | Dev-only: allow decoded JWT fallback when Neon Auth config/service is unavailable |
| `ALLOW_UNVERIFIED_JWT_FALLBACK_IN_PRODUCTION` | `false` | Explicit override to permit decoded-JWT fallback in production (emergency use only) |
| `MAX_PROMPT_CHARS` | `16000` | Maximum prompt character length |
| `MAX_INFERENCE_PROMPT_CHARS` | `12000` | Maximum inference prompt length |
| `MAX_URL_CHARS` | `2048` | Maximum extract-url input URL length |
| `EXTRACT_FETCH_TIMEOUT_MS` | `15000` | Timeout for page/OpenAI extraction calls |
| `EXTRACT_MAX_RESPONSE_BYTES` | `1048576` | Max downloaded page size (bytes) |
| `EXTRACT_MODEL` | Inherits `CODEX_MODEL`/provider model (or `gpt-4.1-mini` for non-Azure) | OpenAI model for URL extraction summarization |

### Codex client options

| Variable | Default | Description |
|----------|---------|-------------|
| `OPENAI_BASE_URL` / `CODEX_BASE_URL` | _(none)_ | OpenAI-compatible API base URL |
| `CODEX_PATH_OVERRIDE` | _(none)_ | Absolute path to Codex CLI binary |
| `CODEX_CONFIG_JSON` | _(none)_ | JSON object of CLI `--config` overrides, including `model_provider` and `model_providers` when `~/.codex/config.toml` is unavailable |
| `CODEX_ENV_JSON` | _(none)_ | JSON object of env vars for the CLI process |
| `CODEX_MAX_OUTPUT_TOKENS` | _(none)_ | Max output tokens (passed via CLI config) |

### Default thread options

| Variable | Default | Description |
|----------|---------|-------------|
| `CODEX_MODEL` | Provider model (`config.toml`), `AZURE_OPENAI_DEPLOYMENT`, or `gpt-5.2` (non-Azure fallback) | Model/deployment name (for Azure, set this to your deployment name) |
| `CODEX_SANDBOX_MODE` | _(none)_ | `read-only` \| `workspace-write` \| `danger-full-access` |
| `CODEX_WORKING_DIRECTORY` | _(none)_ | Working directory for the Codex agent |
| `CODEX_SKIP_GIT_REPO_CHECK` | `false` | Skip git repo validation |
| `CODEX_MODEL_REASONING_EFFORT` | `high` | `minimal` \| `low` \| `medium` \| `high` \| `xhigh` |
| `CODEX_MODEL_REASONING_SUMMARY` | `detailed` | `auto` \| `concise` \| `detailed` |
| `CODEX_NETWORK_ACCESS_ENABLED` | `false` | Enable network access |
| `CODEX_WEB_SEARCH_MODE` | _(none)_ | `disabled` \| `cached` \| `live` |
| `CODEX_WEB_SEARCH_ENABLED` | `false` | Enable web search |
| `CODEX_APPROVAL_POLICY` | _(none)_ | `never` \| `on-request` \| `on-failure` \| `untrusted` |
| `CODEX_ADDITIONAL_DIRECTORIES` | _(none)_ | JSON array or comma-delimited paths |

### Rate-limit retry

| Variable | Default | Description |
|----------|---------|-------------|
| `CODEX_429_MAX_RETRIES` | `2` | Max retry attempts on 429 errors |
| `CODEX_429_BACKOFF_BASE_SECONDS` | `1.0` | Base delay for exponential backoff |
| `CODEX_429_BACKOFF_MAX_SECONDS` | `20.0` | Maximum backoff delay |

### Endpoint rate limits

| Variable | Default | Description |
|----------|---------|-------------|
| `ENHANCE_PER_MINUTE` | `12` | `/enhance` requests per minute |
| `ENHANCE_PER_DAY` | `300` | `/enhance` requests per day |
| `EXTRACT_PER_MINUTE` | `6` | `/extract-url` requests per minute |
| `EXTRACT_PER_DAY` | `120` | `/extract-url` requests per day |
| `INFER_PER_MINUTE` | `15` | `/infer-builder-fields` requests per minute |
| `INFER_PER_DAY` | `400` | `/infer-builder-fields` requests per day |

## Features

- **Prompt structure analysis**: Pre-flight inspection checks for Role/Task/Context/Format/Constraints sections and includes findings in the prompt input so the enhancer can address gaps.
- **429 retry with backoff**: Automatic retry on rate-limit errors with exponential backoff and jitter. Only retries if no chunks have been emitted yet.
- **Thread resumption**: Pass `thread_id` to continue a previous conversation.
- **SSE streaming**: Compatible with the frontend's `streamEnhance()` parser (supports both `/` and `.` event separators).
- **Client disconnect detection**: Aborts the Codex process when the client disconnects.
- **Neon auth validation**: Verifies JWT bearer tokens via Neon JWKS.
- **CORS + per-endpoint rate limiting**: Browser-safe headers with request throttling for enhance/extract/infer routes.
````

## File: src/components/base/select/select.tsx
````typescript
import type { ReactNode, Ref, RefAttributes } from "react";
import { createContext } from "react";
import type { SelectProps as AriaSelectProps } from "react-aria-components";
import { Button as AriaButton, ListBox as AriaListBox, Select as AriaSelect, SelectValue as AriaSelectValue } from "react-aria-components";
import { Avatar } from "@/components/base/avatar/avatar";
import { HintText } from "@/components/base/input/hint-text";
import { Label } from "@/components/base/input/label";
import { cx } from "@/lib/utils/cx";
import { renderIconSlot, type IconSlot } from "@/lib/utils/icon-slot";
import { ComboBox } from "./combobox";
import { Popover } from "./popover";
import { SelectItem } from "./select-item";
import { CaretDown as ChevronDown } from "@phosphor-icons/react";

type SelectIconProps = { className?: string; "data-icon"?: string | boolean; "aria-hidden"?: boolean };

export type SelectItemType = {
    id: string;
    label?: string;
    avatarUrl?: string;
    isDisabled?: boolean;
    supportingText?: string;
    icon?: IconSlot<SelectIconProps>;
};

export interface CommonProps {
    hint?: string;
    label?: string;
    tooltip?: string;
    size?: "sm" | "md";
    placeholder?: string;
}

interface SelectProps extends Omit<AriaSelectProps<SelectItemType>, "children" | "items">, RefAttributes<HTMLDivElement>, CommonProps {
    items?: SelectItemType[];
    popoverClassName?: string;
    placeholderIcon?: IconSlot<SelectIconProps>;
    children: ReactNode | ((item: SelectItemType) => ReactNode);
}

interface SelectValueProps {
    isOpen: boolean;
    size: "sm" | "md";
    isFocused: boolean;
    isDisabled: boolean;
    placeholder?: string;
    ref?: Ref<HTMLButtonElement>;
    placeholderIcon?: IconSlot<SelectIconProps>;
}

export const sizes = {
    sm: { root: "py-2 px-3", shortcut: "pr-2.5" },
    md: { root: "py-2.5 px-3.5", shortcut: "pr-3" },
};

const SelectValue = ({ isOpen, isFocused, isDisabled, size, placeholder, placeholderIcon, ref }: SelectValueProps) => {
    return (
        <AriaButton
            ref={ref}
            role="combobox"
            className={cx(
                "relative flex w-full cursor-pointer items-center rounded-lg bg-background text-base shadow-xs ring-1 ring-border outline-hidden transition duration-100 ease-linear ring-inset",
                (isFocused || isOpen) && "ring-2 ring-brand",
                isDisabled && "cursor-not-allowed bg-muted text-muted-foreground",
            )}
        >
            <AriaSelectValue<SelectItemType>
                className={cx(
                    "flex h-max w-full items-center justify-start gap-2 truncate text-left align-middle",

                    // Icon styles
                    "*:data-icon:size-5 *:data-icon:shrink-0 *:data-icon:text-muted-foreground in-disabled:*:data-icon:text-muted-foreground/70",

                    sizes[size].root,
                )}
            >
                {(state) => {
                    const Icon = state.selectedItem?.icon || placeholderIcon;
                    return (
                        <>
                            {state.selectedItem?.avatarUrl ? (
                                <Avatar size="xs" src={state.selectedItem.avatarUrl} alt={state.selectedItem.label} />
                            ) : (
                                renderIconSlot(Icon, { "data-icon": true, "aria-hidden": true })
                            )}

                            {state.selectedItem ? (
                                <section className="flex w-full gap-2 truncate">
                                    <p className="truncate text-base font-medium text-foreground">{state.selectedItem?.label}</p>
                                    {state.selectedItem?.supportingText && <p className="text-base text-muted-foreground">{state.selectedItem?.supportingText}</p>}
                                </section>
                            ) : (
                                <p className={cx("text-base text-muted-foreground", isDisabled && "text-muted-foreground")}>{placeholder}</p>
                            )}

                            <ChevronDown
                                aria-hidden="true"
                                className={cx("ml-auto shrink-0 text-muted-foreground", size === "sm" ? "size-4 stroke-[2.5px]" : "size-5")}
                            />
                        </>
                    );
                }}
            </AriaSelectValue>
        </AriaButton>
    );
};

export const SelectContext = createContext<{ size: "sm" | "md" }>({ size: "sm" });

const Select = ({ placeholder = "Select", placeholderIcon, size = "sm", children, items, label, hint, tooltip, className, ...rest }: SelectProps) => {
    return (
        <SelectContext.Provider value={{ size }}>
            <AriaSelect {...rest} className={(state) => cx("flex flex-col gap-1.5", typeof className === "function" ? className(state) : className)}>
                {(state) => (
                    <>
                        {label && (
                            <Label isRequired={state.isRequired} tooltip={tooltip}>
                                {label}
                            </Label>
                        )}

                        <SelectValue {...state} {...{ size, placeholder }} placeholderIcon={placeholderIcon} />

                        <Popover size={size} className={rest.popoverClassName}>
                            <AriaListBox items={items} className="size-full outline-hidden">
                                {children}
                            </AriaListBox>
                        </Popover>

                        {hint && <HintText isInvalid={state.isInvalid}>{hint}</HintText>}
                    </>
                )}
            </AriaSelect>
        </SelectContext.Provider>
    );
};

const _Select = Select as typeof Select & {
    ComboBox: typeof ComboBox;
    Item: typeof SelectItem;
};
_Select.ComboBox = ComboBox;
_Select.Item = SelectItem;

export { _Select as Select };
````

## File: src/components/community/CommunityReportDialog.tsx
````typescript
import { useState } from "react";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/base/dialog";
import { Button } from "@/components/base/buttons/button";
import { Label } from "@/components/base/label";
import {
  Select,
} from "@/components/base/select/select";
import { Textarea } from "@/components/base/textarea";

const REPORT_REASON_OPTIONS = [
  { value: "harassment", label: "Harassment or bullying" },
  { value: "hate", label: "Hate or abuse" },
  { value: "sexual", label: "Sexual content" },
  { value: "violence", label: "Violence or threats" },
  { value: "spam", label: "Spam" },
  { value: "other", label: "Other" },
] as const;

interface CommunityReportDialogProps {
  open: boolean;
  targetLabel: string;
  submitting?: boolean;
  onOpenChange: (open: boolean) => void;
  onSubmit: (payload: { reason: string; details: string }) => Promise<void> | void;
}

export function CommunityReportDialog({
  open,
  targetLabel,
  submitting = false,
  onOpenChange,
  onSubmit,
}: CommunityReportDialogProps) {
  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      {open && (
        <CommunityReportDialogContent
          targetLabel={targetLabel}
          submitting={submitting}
          onOpenChange={onOpenChange}
          onSubmit={onSubmit}
        />
      )}
    </Dialog>
  );
}

interface CommunityReportDialogContentProps {
  targetLabel: string;
  submitting: boolean;
  onOpenChange: (open: boolean) => void;
  onSubmit: (payload: { reason: string; details: string }) => Promise<void> | void;
}

function CommunityReportDialogContent({
  targetLabel,
  submitting,
  onOpenChange,
  onSubmit,
}: CommunityReportDialogContentProps) {
  const [reason, setReason] = useState("harassment");
  const [details, setDetails] = useState("");
  const trimmedDetails = details.trim();

  return (
    <DialogContent className="sm:max-w-md">
      <DialogHeader>
        <DialogTitle>Report content</DialogTitle>
        <DialogDescription>
          Tell us what is wrong with this {targetLabel}. Reports help keep the community safe.
        </DialogDescription>
      </DialogHeader>

      <div className="space-y-3">
        <div className="space-y-1.5">
          <Label>Reason</Label>
          <Select
            selectedKey={reason}
            onSelectionChange={(value) => {
              if (value !== null) {
                setReason(String(value));
              }
            }}
            placeholder="Select a reason"
            aria-label="Report reason"
          >
            {REPORT_REASON_OPTIONS.map((option) => (
              <Select.Item key={option.value} id={option.value}>
                {option.label}
              </Select.Item>
            ))}
          </Select>
        </div>

        <div className="space-y-1.5">
          <Label htmlFor="community-report-details">Details</Label>
          <Textarea
            id="community-report-details"
            value={details}
            onChange={(event) => setDetails(event.target.value)}
            placeholder="Add optional context to help moderation review this report."
            className="min-h-[96px]"
            maxLength={2000}
          />
        </div>
      </div>

      <DialogFooter>
        <Button color="secondary" onClick={() => onOpenChange(false)} disabled={submitting}>
          Cancel
        </Button>
        <Button onClick={() => void onSubmit({ reason, details: trimmedDetails })} disabled={!reason || submitting}>
          {submitting ? "Submitting..." : "Submit report"}
        </Button>
      </DialogFooter>
    </DialogContent>
  );
}
````

## File: src/components/BuilderTabs.tsx
````typescript
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/base/tabs";
import { Input } from "@/components/base/input/input";
import { Textarea } from "@/components/base/textarea";
import { Checkbox } from "@/components/base/primitives/checkbox";
import { Label } from "@/components/base/label";
import { Select } from "@/components/base/select/select";
import { cn } from "@/lib/utils";
import { toConstraintInputId } from "@/lib/builder-tabs";
import { Crosshair as Target, Layout, Lightbulb, Shield, User } from "@phosphor-icons/react";
import {
  PromptConfig,
  roles,
  formatOptions,
  constraintOptions,
  lengthOptions,
} from "@/lib/prompt-builder";

interface BuilderTabsProps {
  config: PromptConfig;
  onUpdate: (updates: Partial<PromptConfig>) => void;
}

export function BuilderTabs({ config, onUpdate }: BuilderTabsProps) {
  const toggleFormat = (format: string) => {
    const next = config.format.includes(format)
      ? config.format.filter((f) => f !== format)
      : [...config.format, format];
    onUpdate({ format: next });
  };

  const toggleConstraint = (constraint: string) => {
    const next = config.constraints.includes(constraint)
      ? config.constraints.filter((c) => c !== constraint)
      : [...config.constraints, constraint];
    onUpdate({ constraints: next });
  };

  return (
    <Tabs defaultValue="role" className="w-full">
      <TabsList className="w-full grid grid-cols-5 h-auto gap-1 bg-muted/30 p-1">
        <TabsTrigger value="role" aria-label="Role tab" className="interactive-chip gap-1 px-2 text-xs sm:text-sm">
          <User className="w-3 h-3" />
          <span className="sm:hidden">Role</span>
          <span className="hidden sm:inline">Role</span>
        </TabsTrigger>
        <TabsTrigger value="task" aria-label="Task tab" className="interactive-chip gap-1 px-2 text-xs sm:text-sm">
          <Target className="w-3 h-3" />
          <span className="sm:hidden">Task</span>
          <span className="hidden sm:inline">Task</span>
        </TabsTrigger>
        <TabsTrigger value="format" aria-label="Format tab" className="interactive-chip gap-1 px-2 text-xs sm:text-sm">
          <Layout className="w-3 h-3" />
          <span className="sm:hidden">Fmt</span>
          <span className="hidden sm:inline">Format</span>
        </TabsTrigger>
        <TabsTrigger value="examples" aria-label="Examples tab" className="interactive-chip gap-1 px-2 text-xs sm:text-sm">
          <Lightbulb className="w-3 h-3" />
          <span className="sm:hidden">Ex</span>
          <span className="hidden sm:inline">Examples</span>
        </TabsTrigger>
        <TabsTrigger value="constraints" aria-label="Rules tab" className="interactive-chip gap-1 px-2 text-xs sm:text-sm">
          <Shield className="w-3 h-3" />
          <span className="sm:hidden">Rules</span>
          <span className="hidden sm:inline">Rules</span>
        </TabsTrigger>
      </TabsList>

      <TabsContent value="role" className="space-y-3 mt-4">
        <p className="text-sm text-muted-foreground">Who should the AI be?</p>
        <Select
          selectedKey={config.role || undefined}
          onSelectionChange={(value) => {
            if (value !== null) {
              onUpdate({ role: String(value) });
            }
          }}
          placeholder="Select a role..."
          aria-label="Select role"
          className="bg-background"
        >
          {roles.map((role) => (
            <Select.Item key={role} id={role}>
              {role}
            </Select.Item>
          ))}
        </Select>
        <Input
          placeholder="Or type a custom role..."
          value={config.customRole}
          onChange={(value) => onUpdate({ customRole: value })}
          wrapperClassName="bg-background"
          aria-label="Custom role input"
        />
      </TabsContent>

      <TabsContent value="task" className="space-y-3 mt-4">
        <p className="text-sm text-muted-foreground">What exactly do you want done?</p>
        <Textarea
          placeholder="Define the task clearly..."
          value={config.task}
          onChange={(e) => onUpdate({ task: e.target.value })}
          className="min-h-[100px] bg-background"
          aria-label="Task description"
        />
      </TabsContent>

      <TabsContent value="format" className="space-y-4 mt-4">
        <p className="text-sm text-muted-foreground">How should the answer be structured?</p>
        <div className="flex flex-wrap gap-2">
          {formatOptions.map((format) => (
            <button
              type="button"
              key={format}
              className={cn(
                "inline-flex items-center rounded-full border px-2.5 py-0.5 text-sm font-semibold transition duration-100 ease-linear focus:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
                config.format.includes(format)
                  ? "border-primary/30 bg-primary/10 text-primary"
                  : "border-border bg-background text-foreground",
                "interactive-chip cursor-pointer select-none"
              )}
              onClick={() => toggleFormat(format)}
              aria-pressed={config.format.includes(format)}
            >
              {format}
            </button>
          ))}
        </div>
        <Input
          placeholder="Custom format..."
          value={config.customFormat}
          onChange={(value) => onUpdate({ customFormat: value })}
          wrapperClassName="bg-background"
          aria-label="Custom format"
        />
        <div className="space-y-2">
          <Label className="text-sm text-muted-foreground">Length</Label>
          <Select
            selectedKey={config.lengthPreference || undefined}
            onSelectionChange={(value) => {
              if (value !== null) {
                onUpdate({ lengthPreference: String(value) });
              }
            }}
            aria-label="Length preference"
            className="bg-background"
          >
            {lengthOptions.map((opt) => (
              <Select.Item key={opt.value} id={opt.value}>
                {opt.label}
              </Select.Item>
            ))}
          </Select>
        </div>
      </TabsContent>

      <TabsContent value="examples" className="space-y-3 mt-4">
        <p className="text-sm text-muted-foreground">Show, don't just tell — provide example inputs/outputs</p>
        <Textarea
          placeholder="Add example inputs and outputs to guide the AI..."
          value={config.examples}
          onChange={(e) => onUpdate({ examples: e.target.value })}
          className="min-h-[120px] bg-background font-mono"
          aria-label="Examples input"
        />
      </TabsContent>

      <TabsContent value="constraints" className="space-y-4 mt-4">
        <p className="text-sm text-muted-foreground">Set boundaries to improve quality</p>
        <div className="space-y-3">
          {constraintOptions.map((constraint) => {
            const constraintInputId = toConstraintInputId(constraint);
            return (
              <div key={constraint} className="flex items-center gap-2">
                <Checkbox
                  id={constraintInputId}
                  checked={config.constraints.includes(constraint)}
                  onCheckedChange={() => toggleConstraint(constraint)}
                />
                <Label htmlFor={constraintInputId} className="text-sm cursor-pointer">
                  {constraint}
                </Label>
              </div>
            );
          })}
        </div>
        <Input
          placeholder="Add custom constraint..."
          value={config.customConstraint}
          onChange={(value) => onUpdate({ customConstraint: value })}
          wrapperClassName="bg-background"
          aria-label="Custom constraint"
        />
      </TabsContent>
    </Tabs>
  );
}
````

## File: src/components/ContextIntegrations.tsx
````typescript
import { useState } from "react";
import { Badge } from "@/components/base/badges/badges";
import { Button } from "@/components/base/buttons/button";
import { Input } from "@/components/base/input/input";
import { Label } from "@/components/base/label";
import { Select } from "@/components/base/select/select";
import { Switch } from "@/components/base/primitives/switch";
import type { DatabaseConnection, RagParameters } from "@/lib/context-types";
import { Database, Plus, X } from "@phosphor-icons/react";

interface ContextIntegrationsProps {
  databaseConnections: DatabaseConnection[];
  rag: RagParameters;
  onUpdateDatabaseConnections: (connections: DatabaseConnection[]) => void;
  onUpdateRag: (updates: Partial<RagParameters>) => void;
}

const PROVIDER_OPTIONS: DatabaseConnection["provider"][] = [
  "postgres",
  "mysql",
  "sqlite",
  "mongodb",
  "other",
];

export function ContextIntegrations({
  databaseConnections,
  rag,
  onUpdateDatabaseConnections,
  onUpdateRag,
}: ContextIntegrationsProps) {
  const [draft, setDraft] = useState<{
    label: string;
    provider: DatabaseConnection["provider"];
    connectionRef: string;
    database: string;
    schema: string;
    tables: string;
    readOnly: boolean;
  }>({
    label: "",
    provider: "postgres",
    connectionRef: "",
    database: "",
    schema: "",
    tables: "",
    readOnly: true,
  });

  const addDatabase = () => {
    if (!draft.connectionRef.trim() || !draft.database.trim()) return;
    const next: DatabaseConnection = {
      id: `db-${Date.now()}`,
      label: draft.label.trim() || draft.database.trim(),
      provider: draft.provider,
      connectionRef: draft.connectionRef.trim(),
      database: draft.database.trim(),
      schema: draft.schema.trim(),
      tables: draft.tables
        .split(",")
        .map((t) => t.trim())
        .filter(Boolean),
      readOnly: draft.readOnly,
      lastValidatedAt: Date.now(),
    };
    onUpdateDatabaseConnections([...databaseConnections, next]);
    setDraft({
      label: "",
      provider: draft.provider,
      connectionRef: "",
      database: "",
      schema: "",
      tables: "",
      readOnly: true,
    });
  };

  const removeDatabase = (id: string) => {
    onUpdateDatabaseConnections(databaseConnections.filter((db) => db.id !== id));
  };

  return (
    <div className="space-y-4">
      <div className="space-y-2">
        <div className="flex items-center justify-between">
          <Label className="text-sm font-medium text-foreground sm:text-base">Database connections</Label>
          <Badge type="modern" className="text-xs">
            {databaseConnections.length}
          </Badge>
        </div>

        <div className="grid grid-cols-1 sm:grid-cols-2 gap-2">
          <Input
            value={draft.label}
            onChange={(value) => setDraft((prev) => ({ ...prev, label: value }))}
            placeholder="Label (optional)"
            wrapperClassName="h-11 sm:h-10"
          />
          <Select
            selectedKey={draft.provider}
            onSelectionChange={(provider) => {
              if (provider !== null) {
                setDraft((prev) => ({ ...prev, provider: String(provider) as DatabaseConnection["provider"] }));
              }
            }}
            className="capitalize"
            size="md"
          >
            {PROVIDER_OPTIONS.map((provider) => (
              <Select.Item key={provider} id={provider} className="capitalize">
                {provider}
              </Select.Item>
            ))}
          </Select>
          <Input
            value={draft.connectionRef}
            onChange={(value) => setDraft((prev) => ({ ...prev, connectionRef: value }))}
            placeholder="Connection ID (secret)"
            wrapperClassName="h-11 sm:h-10"
          />
          <Input
            value={draft.database}
            onChange={(value) => setDraft((prev) => ({ ...prev, database: value }))}
            placeholder="Database name"
            wrapperClassName="h-11 sm:h-10"
          />
          <Input
            value={draft.schema}
            onChange={(value) => setDraft((prev) => ({ ...prev, schema: value }))}
            placeholder="Schema (optional)"
            wrapperClassName="h-11 sm:h-10"
          />
          <Input
            value={draft.tables}
            onChange={(value) => setDraft((prev) => ({ ...prev, tables: value }))}
            placeholder="Tables (comma-separated, optional)"
            wrapperClassName="h-11 sm:h-10"
          />
        </div>

        <div className="flex items-center justify-between">
          <div className="flex items-center gap-2">
            <Switch
              checked={draft.readOnly}
              onCheckedChange={(value) => setDraft((prev) => ({ ...prev, readOnly: value }))}
            />
            <Label className="text-sm text-muted-foreground sm:text-base">Read-only</Label>
          </div>
          <Button size="sm" className="h-11 gap-1.5 text-sm sm:h-9 sm:text-sm" onClick={addDatabase}>
            <Plus className="w-3 h-3" />
            Add connection
          </Button>
        </div>

        {databaseConnections.length > 0 && (
          <div className="flex flex-wrap gap-1.5">
            {databaseConnections.map((db) => (
              <Badge key={db.id} type="modern" className="gap-1.5 text-xs">
                <Database className="w-3 h-3" />
                {db.label}
                <button
                  onClick={() => removeDatabase(db.id)}
                  className="rounded-full p-0.5 hover:bg-destructive/20 transition-colors"
                  aria-label={`Remove ${db.label}`}
                >
                  <X className="w-3 h-3" />
                </button>
              </Badge>
            ))}
          </div>
        )}
      </div>

      <div className="space-y-2 border-t border-border pt-3">
        <div className="flex items-center justify-between">
          <Label className="text-sm font-medium text-foreground sm:text-base">Retrieval settings (RAG)</Label>
          <Switch
            checked={rag.enabled}
            onCheckedChange={(enabled) => onUpdateRag({ enabled })}
          />
        </div>

        <div className="grid grid-cols-1 sm:grid-cols-2 gap-2">
          <Input
            value={rag.vectorStoreRef}
            onChange={(value) => onUpdateRag({ vectorStoreRef: value })}
            placeholder="Vector store ID"
            wrapperClassName="h-11 sm:h-10"
            isDisabled={!rag.enabled}
          />
          <Input
            value={rag.namespace}
            onChange={(value) => onUpdateRag({ namespace: value })}
            placeholder="Namespace"
            wrapperClassName="h-11 sm:h-10"
            isDisabled={!rag.enabled}
          />
          <Select
            selectedKey={rag.retrievalStrategy}
            onSelectionChange={(retrievalStrategy) => {
              if (retrievalStrategy !== null) {
                onUpdateRag({ retrievalStrategy: String(retrievalStrategy) as RagParameters["retrievalStrategy"] });
              }
            }}
            isDisabled={!rag.enabled}
            size="md"
          >
            <Select.Item id="hybrid">Hybrid</Select.Item>
            <Select.Item id="semantic">Semantic</Select.Item>
            <Select.Item id="keyword">Keyword</Select.Item>
          </Select>
          <Input
            value={String(rag.topK)}
            onChange={(value) => onUpdateRag({ topK: Number(value) || 0 })}
            placeholder="Top results (topK)"
            wrapperClassName="h-11 sm:h-10"
            isDisabled={!rag.enabled}
          />
          <Input
            value={String(rag.minScore)}
            onChange={(value) => onUpdateRag({ minScore: Number(value) || 0 })}
            placeholder="Minimum score (0-1)"
            wrapperClassName="h-11 sm:h-10"
            isDisabled={!rag.enabled}
          />
          <Input
            value={String(rag.chunkWindow)}
            onChange={(value) => onUpdateRag({ chunkWindow: Number(value) || 0 })}
            placeholder="Context window (chunks)"
            wrapperClassName="h-11 sm:h-10"
            isDisabled={!rag.enabled}
          />
        </div>
        <Input
          value={rag.documentRefs.join(", ")}
          onChange={(value) =>
            onUpdateRag({
              documentRefs: value
                .split(",")
                .map((ref) => ref.trim())
                .filter(Boolean),
            })
          }
          placeholder="Document IDs (comma-separated)"
          wrapperClassName="h-11 sm:h-10"
          isDisabled={!rag.enabled}
        />
      </div>
    </div>
  );
}
````

## File: src/components/ContextInterview.tsx
````typescript
import { useState } from "react";
import { Button } from "@/components/base/buttons/button";
import { Input } from "@/components/base/input/input";
import { Badge, badgeVariants } from "@/components/base/badges/badges";
import { interviewQuestions } from "@/lib/context-types";
import type { InterviewAnswer } from "@/lib/context-types";
import { cn } from "@/lib/utils";
import { CaretRight as ChevronRight, ChatText as MessageSquareText, Check } from "@phosphor-icons/react";

interface ContextInterviewProps {
  answers: InterviewAnswer[];
  onUpdate: (answers: InterviewAnswer[]) => void;
}

export function ContextInterview({ answers, onUpdate }: ContextInterviewProps) {
  const [expanded, setExpanded] = useState(false);
  const [currentStep, setCurrentStep] = useState(0);

  const getAnswer = (qId: string) => answers.find((a) => a.questionId === qId)?.answer || "";

  const setAnswer = (qId: string, question: string, answer: string) => {
    const existing = answers.filter((a) => a.questionId !== qId);
    onUpdate([...existing, { questionId: qId, question, answer }]);
  };

  const answeredCount = answers.filter((a) => a.answer.trim()).length;
  const currentQ = interviewQuestions[currentStep];

  if (!expanded) {
    return (
      <div className="space-y-2">
        <Button
          color="secondary"
          size="sm"
          className="interactive-chip w-full justify-between gap-2 text-sm"
          onClick={() => setExpanded(true)}
        >
          <span className="flex items-center gap-2">
            <MessageSquareText className="w-3.5 h-3.5" />
            Ask me for missing context
          </span>
          {answeredCount > 0 && (
            <Badge type="modern" className="text-xs">
              {answeredCount}/{interviewQuestions.length}
            </Badge>
          )}
        </Button>
      </div>
    );
  }

  return (
    <div className="space-y-3 rounded-lg border border-border bg-card p-3">
      <div className="flex items-center justify-between">
        <div className="flex items-center gap-2">
          <MessageSquareText className="w-4 h-4 text-primary" />
          <span className="text-sm font-medium text-foreground">
            Context interview ({currentStep + 1}/{interviewQuestions.length})
          </span>
        </div>
        <Button
          color="tertiary"
          size="sm"
          className="interactive-chip h-11 text-sm sm:h-9"
          onClick={() => setExpanded(false)}
        >
          Minimize
        </Button>
      </div>

      <p className="text-sm font-medium text-foreground">{currentQ.question}</p>

      {currentQ.options ? (
        <div className="flex flex-wrap gap-2">
          {currentQ.options.map((opt) => {
            const selected = getAnswer(currentQ.id) === opt;
            return (
              <button
                type="button"
                key={opt}
                className={cn(
                  badgeVariants({ variant: selected ? "default" : "outline" }),
                  "interactive-chip cursor-pointer select-none text-xs"
                )}
                onClick={() => setAnswer(currentQ.id, currentQ.question, selected ? "" : opt)}
                aria-pressed={selected}
              >
                {selected && <Check className="w-3 h-3 mr-1" />}
                {opt}
              </button>
            );
          })}
        </div>
      ) : (
        <Input
          placeholder="Type your answer..."
          value={getAnswer(currentQ.id)}
          onChange={(e) => setAnswer(currentQ.id, currentQ.question, e.target.value)}
          className="bg-background"
        />
      )}

      <div className="flex justify-between pt-1">
        <Button
          color="tertiary"
          size="sm"
          className="interactive-chip text-sm"
          disabled={currentStep === 0}
          onClick={() => setCurrentStep((s) => s - 1)}
        >
          Previous
        </Button>
        {currentStep < interviewQuestions.length - 1 ? (
          <Button
            color="secondary"
            size="sm"
            className="interactive-chip gap-1 text-sm"
            onClick={() => setCurrentStep((s) => s + 1)}
          >
            Next
            <ChevronRight className="w-3 h-3" />
          </Button>
        ) : (
          <Button
            size="sm"
            className="interactive-chip gap-1 text-sm"
            onClick={() => setExpanded(false)}
          >
            <Check className="w-3 h-3" />
            Done
          </Button>
        )}
      </div>
    </div>
  );
}
````

## File: src/components/StructuredContextForm.tsx
````typescript
import { useState } from "react";
import { Input } from "@/components/base/input/input";
import { Button } from "@/components/base/buttons/button";
import type { StructuredContext } from "@/lib/context-types";
import { structuredFieldsMeta } from "@/lib/context-types";
import { CaretDown as ChevronDown, CaretUp as ChevronUp, Lightbulb } from "@phosphor-icons/react";

interface StructuredContextFormProps {
  values: StructuredContext;
  onUpdate: (updates: Partial<StructuredContext>) => void;
}

export function StructuredContextForm({ values, onUpdate }: StructuredContextFormProps) {
  const [showExamples, setShowExamples] = useState<string | null>(null);

  return (
    <div className="space-y-3">
      <label className="text-sm font-medium text-foreground sm:text-base">Structured context</label>
      {structuredFieldsMeta.map((field) => (
        <div key={field.key} className="space-y-1">
          <div className="flex items-center justify-between">
            <label className="text-sm text-muted-foreground sm:text-base">{field.label}</label>
            <Button
              color="tertiary"
              size="sm"
              className="h-11 gap-0.5 px-2 text-sm text-muted-foreground sm:h-9 sm:text-sm"
              onClick={() =>
                setShowExamples(showExamples === field.key ? null : field.key)
              }
            >
              <Lightbulb className="w-3 h-3" />
              {showExamples === field.key ? (
                <ChevronUp className="w-3 h-3" />
              ) : (
                <ChevronDown className="w-3 h-3" />
              )}
            </Button>
          </div>
          <Input
            placeholder={field.placeholder}
            value={values[field.key]}
            onChange={(e) => onUpdate({ [field.key]: e.target.value })}
            className="bg-background"
          />
          {showExamples === field.key && (
            <div className="rounded-md border border-border bg-muted/30 p-2 space-y-1">
              <p className="type-label-caps text-sm font-medium text-muted-foreground">
                Good examples
              </p>
              {field.examples.map((ex, i) => (
                <button
                  key={i}
                  onClick={() => onUpdate({ [field.key]: ex })}
                  className="block w-full cursor-pointer py-0.5 text-left text-sm text-foreground transition-colors hover:text-primary sm:text-base"
                >
                  "{ex}"
                </button>
              ))}
            </div>
          )}
        </div>
      ))}
    </div>
  );
}
````

## File: src/hooks/useAuth.tsx
````typescript
import {
  createContext,
  useContext,
  useEffect,
  useState,
  useCallback,
  type ReactNode,
} from "react";
import { neon } from "@/integrations/neon/client";
import { getBackendConfigErrorMessage, isBackendConfigured } from "@/lib/backend-config";
import { validateDisplayName } from "@/lib/profile";

type SessionResult = Awaited<ReturnType<typeof neon.auth.getSession>>;
export type AuthSession = SessionResult["data"]["session"];
export type AuthUser = NonNullable<NonNullable<AuthSession>["user"]>;
export type AuthOAuthProvider = Parameters<typeof neon.auth.signInWithOAuth>[0]["provider"];

interface AuthContextValue {
  user: AuthUser | null;
  session: AuthSession;
  loading: boolean;
  signUp: (
    email: string,
    password: string,
    displayName?: string,
  ) => Promise<{ error: string | null; session: AuthSession; user: AuthUser | null }>;
  signIn: (
    email: string,
    password: string,
  ) => Promise<{ error: string | null; session: AuthSession; user: AuthUser | null }>;
  signInWithOAuth: (
    provider: AuthOAuthProvider,
  ) => Promise<{ error: string | null; session: AuthSession }>;
  signOut: () => Promise<void>;
  updateDisplayName: (displayName: string) => Promise<{ error: string | null; user: AuthUser | null }>;
  deleteAccount: () => Promise<{ error: string | null }>;
}

const AuthContext = createContext<AuthContextValue | null>(null);
const AUTH_UNAVAILABLE_MESSAGE = getBackendConfigErrorMessage("Authentication");

function resolveSignUpName(email: string, displayName?: string): string {
  const trimmedDisplayName = displayName?.trim();
  if (trimmedDisplayName) {
    return trimmedDisplayName;
  }

  const emailLocalPart = email.split("@")[0]?.trim();
  if (emailLocalPart) {
    return emailLocalPart;
  }

  return "Member";
}

export function AuthProvider({ children }: { children: ReactNode }) {
  const [user, setUser] = useState<AuthUser | null>(null);
  const [session, setSession] = useState<AuthSession>(null);
  const [loading, setLoading] = useState(isBackendConfigured);

  useEffect(() => {
    if (!isBackendConfigured) return;

    let isMounted = true;

    // Get initial session
    neon.auth.getSession()
      .then(({ data: { session: s } }) => {
        if (!isMounted) return;
        setSession(s);
        setUser((s?.user ?? null) as AuthUser | null);
        setLoading(false);
      })
      .catch((error: unknown) => {
        if (!isMounted) return;
        console.error("Failed to initialize auth session:", error);
        setSession(null);
        setUser(null);
        setLoading(false);
      });

    const {
      data: { subscription },
    } = neon.auth.onAuthStateChange((_event, s) => {
      if (!isMounted) return;
      setSession(s);
      setUser((s?.user ?? null) as AuthUser | null);
    });

    return () => {
      isMounted = false;
      subscription.unsubscribe();
    };
  }, []);

  const signUp = useCallback(async (email: string, password: string, displayName?: string) => {
    if (!isBackendConfigured) {
      return { error: AUTH_UNAVAILABLE_MESSAGE, session: null, user: null };
    }

    const safeName = resolveSignUpName(email, displayName);
    const { data, error } = await neon.auth.signUp({
      email,
      password,
      options: {
        data: {
          displayName: safeName,
          name: safeName,
        },
      },
    });
    return {
      error: error?.message ?? null,
      session: data.session,
      user: (data.user ?? null) as AuthUser | null,
    };
  }, []);

  const signIn = useCallback(async (email: string, password: string) => {
    if (!isBackendConfigured) {
      return { error: AUTH_UNAVAILABLE_MESSAGE, session: null, user: null };
    }

    const { data, error } = await neon.auth.signInWithPassword({ email, password });
    return {
      error: error?.message ?? null,
      session: data.session,
      user: (data.user ?? null) as AuthUser | null,
    };
  }, []);

  const signInWithOAuth = useCallback(async (provider: AuthOAuthProvider) => {
    if (!isBackendConfigured) {
      return { error: AUTH_UNAVAILABLE_MESSAGE, session: null };
    }

    const { error } = await neon.auth.signInWithOAuth({
      provider,
      options: { redirectTo: window.location.origin },
    });
    return { error: error?.message ?? null, session: null };
  }, []);

  const signOut = useCallback(async () => {
    if (!isBackendConfigured) {
      setSession(null);
      setUser(null);
      return;
    }

    await neon.auth.signOut();
  }, []);

  const updateDisplayName = useCallback(async (displayName: string) => {
    if (!isBackendConfigured) {
      return { error: AUTH_UNAVAILABLE_MESSAGE, user: null };
    }

    const normalized = displayName.trim();
    const validationError = validateDisplayName(normalized);
    if (validationError) {
      return { error: validationError, user: null };
    }

    if (!user) {
      return { error: "Sign in required.", user: null };
    }

    const { error: profileError } = await neon
      .from("profiles")
      .update({ display_name: normalized })
      .eq("id", user.id);
    if (profileError) {
      return { error: profileError.message || "Failed to update display name.", user: null };
    }

    const { data, error } = await neon.auth.updateUser({
      data: { display_name: normalized },
    });
    if (error) {
      return { error: error.message || "Failed to update display name.", user: null };
    }

    const nextUser = (data.user ?? user) as AuthUser;
    setUser(nextUser);
    setSession((previous) => {
      if (!previous) return previous;
      return { ...previous, user: nextUser };
    });

    return { error: null, user: nextUser };
  }, [user]);

  const deleteAccount = useCallback(async () => {
    if (!isBackendConfigured) {
      return { error: AUTH_UNAVAILABLE_MESSAGE };
    }

    if (!user?.id) {
      return { error: "Sign in required." };
    }

    const { error } = await neon.rpc("delete_my_account");
    if (error) {
      return { error: error.message || "Failed to delete account." };
    }

    await neon.auth.signOut();
    setSession(null);
    setUser(null);
    return { error: null };
  }, [user]);

  return (
    <AuthContext.Provider
      value={{ user, session, loading, signUp, signIn, signInWithOAuth, signOut, updateDisplayName, deleteAccount }}
    >
      {children}
    </AuthContext.Provider>
  );
}

export function useAuth() {
  const ctx = useContext(AuthContext);
  if (!ctx) throw new Error("useAuth must be used within AuthProvider");
  return ctx;
}
````

## File: src/pages/ComponentsShowcase.tsx
````typescript
import { useMemo, useState } from "react";
import { Badge } from "@/components/base/badges/badges";
import { BadgeGroup } from "@/components/base/badges/badge-groups";
import { ButtonGroup, ButtonGroupItem } from "@/components/base/button-group/button-group";
import { ButtonUtility } from "@/components/base/buttons/button-utility";
import { ActivityFeedsBlock } from "@/components/application/activity-feeds/activity-feeds";
import { CodeSnippetTabs } from "@/components/application/code-snippet/code-snippet";
import { FeedListBlock } from "@/components/application/lists/feed-list";
import { ProgressSteps, type ProgressStepItem } from "@/components/application/progress-steps/progress-steps";
import { TeamMembersTableBlock } from "@/components/application/tables/team-members-table";
import { ProgressBar } from "@/components/base/progress-indicators/progress-indicators";
import { ProgressBarCircle, ProgressBarHalfCircle } from "@/components/base/progress-indicators/progress-circles";
import { PageHero, PageShell } from "@/components/PageShell";
import { Card } from "@/components/base/primitives/card";
import { ArrowCounterClockwise as RotateCcw, Minus, Plus } from "@phosphor-icons/react";

const SNIPPETS = [
  {
    id: "tsx",
    label: "React",
    language: "tsx",
    fileName: "components/upload-status.tsx",
    code: `import { ProgressBar } from "@/components/base/progress-indicators/progress-indicators";

export function UploadStatus({ value }: { value: number }) {
  return <ProgressBar value={value} labelPosition="right" />;
}`,
  },
  {
    id: "bash",
    label: "CLI",
    language: "bash",
    fileName: "commands.sh",
    code: `npx untitledui@latest add progress-indicators progress-circles progress-steps
npx untitledui@latest add code-snippet activity-feed table
npx untitledui@latest add button-utility badges badge-groups button-group`,
  },
];

const BASE_STEPS: ProgressStepItem[] = [
  { id: "draft", title: "Draft", description: "Structure content", status: "complete" },
  { id: "review", title: "Review", description: "Validate changes", status: "current" },
  { id: "ship", title: "Ship", description: "Deploy to production", status: "upcoming" },
];

const ComponentsShowcase = () => {
  const [progressValue, setProgressValue] = useState(58);
  const [stepMode, setStepMode] = useState<"icons" | "numbers">("icons");

  const steps = useMemo(() => BASE_STEPS, []);

  const incrementProgress = () => setProgressValue((value) => Math.min(100, value + 10));
  const decrementProgress = () => setProgressValue((value) => Math.max(0, value - 10));
  const resetProgress = () => setProgressValue(58);

  return (
    <PageShell>
      <PageHero
        eyebrow="Untitled UI Integration"
        title="Untitled UI Component Showcase"
        subtitle="Progress indicators, progress steps, activity feeds, tables, code snippets, utility buttons, badges, and button groups implemented in the active design system."
      />

      <div className="mx-auto max-w-5xl space-y-4">
        <Card className="space-y-5 border-border/80 bg-card/90 p-4 sm:p-5">
          <div className="flex flex-wrap items-center justify-between gap-3">
            <div className="space-y-1">
              <h2 className="text-base font-semibold text-foreground">Progress Indicators</h2>
              <div className="flex flex-wrap items-center gap-2">
                <Badge type="modern">Linear + Circular</Badge>
                <BadgeGroup addonText="Live value">{progressValue}%</BadgeGroup>
              </div>
            </div>
            <div className="flex items-center gap-2">
              <ButtonUtility icon={Minus} tooltip="Decrease progress" onClick={decrementProgress} />
              <ButtonUtility icon={Plus} tooltip="Increase progress" onClick={incrementProgress} />
              <ButtonUtility icon={RotateCcw} tooltip="Reset progress" onClick={resetProgress} color="tertiary" />
            </div>
          </div>

          <div className="space-y-5">
            <ProgressBar value={progressValue} labelPosition="right" />
            <ProgressBar value={Math.max(0, progressValue - 12)} labelPosition="bottom" />
            <ProgressBar value={Math.min(100, progressValue + 8)} labelPosition="top-floating" />

            <div className="grid gap-4 sm:grid-cols-2">
              <div className="rounded-lg border border-border/70 p-4">
                <ProgressBarCircle value={progressValue} size="xs" label="Upload" />
              </div>
              <div className="rounded-lg border border-border/70 p-4">
                <ProgressBarHalfCircle value={progressValue} size="md" label="Deploy" />
              </div>
            </div>
          </div>
        </Card>

        <Card className="space-y-4 border-border/80 bg-card/90 p-4 sm:p-5">
          <div className="flex flex-wrap items-center justify-between gap-3">
            <h2 className="text-base font-semibold text-foreground">Progress Steps</h2>
            <ButtonGroup value={stepMode} onValueChange={(value) => value && setStepMode(value as "icons" | "numbers")} aria-label="Progress step mode">
              <ButtonGroupItem value="icons">Icons</ButtonGroupItem>
              <ButtonGroupItem value="numbers">Numbers</ButtonGroupItem>
            </ButtonGroup>
          </div>
          <ProgressSteps steps={steps} showNumbers={stepMode === "numbers"} />
        </Card>

        <div className="space-y-2">
          <h2 className="text-base font-semibold text-foreground">Feed List Block</h2>
          <FeedListBlock />
        </div>

        <div className="space-y-2">
          <h2 className="text-base font-semibold text-foreground">Activity Feeds</h2>
          <ActivityFeedsBlock />
        </div>

        <div className="space-y-2">
          <h2 className="text-base font-semibold text-foreground">Tables</h2>
          <TeamMembersTableBlock />
        </div>

        <Card className="space-y-4 border-border/80 bg-card/90 p-4 sm:p-5">
          <h2 className="text-base font-semibold text-foreground">Code Snippets</h2>
          <CodeSnippetTabs tabs={SNIPPETS} defaultTabId="tsx" />
        </Card>
      </div>
    </PageShell>
  );
};

export default ComponentsShowcase;
````

## File: src/pages/Privacy.tsx
````typescript
import { Link } from "react-router-dom";
import { PageHero, PageShell } from "@/components/PageShell";
import { Card } from "@/components/base/primitives/card";
import { brandCopy } from "@/lib/brand-copy";

const Privacy = () => {
  return (
    <PageShell>
      <PageHero
        eyebrow={brandCopy.brandLine}
        title="Privacy Policy"
        subtitle="How PromptForge handles account, usage, and community data."
        className="pf-gilded-frame pf-hero-surface"
      />

      <div className="mx-auto max-w-3xl space-y-4">
        <Card className="pf-card space-y-4 border-border/80 bg-card/90 p-4 sm:p-6">
          <p className="text-sm text-muted-foreground">Last updated: February 20, 2026</p>
          <article className="prose max-w-[62ch] text-foreground dark:prose-invert prose-headings:text-foreground prose-p:text-foreground prose-li:text-foreground prose-strong:text-foreground">
            <p>
              We collect only the information needed to provide account access, saved prompts, and community features.
              We do not sell your personal data.
            </p>
            <h2>Data we collect</h2>
            <ul>
              <li>
                <strong>Account data:</strong> email address, authentication metadata, and profile details you choose
                to provide.
              </li>
              <li>
                <strong>Product data:</strong> saved prompts, drafts, versions, and community actions (shares, votes,
                comments, reports, and user blocks).
              </li>
            </ul>
            <h2>Security and controls</h2>
            <ul>
              <li>
                <strong>Security:</strong> we apply access controls and row-level permissions to protect
                account-scoped data.
              </li>
              <li>
                <strong>Your controls:</strong> you can update profile fields, remove shared content, and delete your
                account in-app.
              </li>
            </ul>
          </article>
        </Card>

        <Card className="pf-card space-y-2 border-border/80 bg-card/90 p-4 sm:p-5">
          <h2 className="text-base font-semibold text-foreground">Contact</h2>
          <p className="text-sm text-muted-foreground">
            For privacy requests or questions, visit <Link to="/contact" className="underline">Contact Support</Link>.
          </p>
        </Card>
      </div>
    </PageShell>
  );
};

export default Privacy;
````

## File: src/pages/Terms.tsx
````typescript
import { Link } from "react-router-dom";
import { PageHero, PageShell } from "@/components/PageShell";
import { Card } from "@/components/base/primitives/card";
import { brandCopy } from "@/lib/brand-copy";

const Terms = () => {
  return (
    <PageShell>
      <PageHero
        eyebrow={brandCopy.brandLine}
        title="Terms of Use"
        subtitle="Basic rules for using PromptForge and community features."
        className="pf-gilded-frame pf-hero-surface"
      />

      <div className="mx-auto max-w-3xl space-y-4">
        <Card className="pf-card space-y-4 border-border/80 bg-card/90 p-4 sm:p-6">
          <p className="text-sm text-muted-foreground">Last updated: February 20, 2026</p>

          <article className="prose max-w-[62ch] text-foreground dark:prose-invert prose-headings:text-foreground prose-p:text-foreground prose-li:text-foreground prose-strong:text-foreground">
            <h2>Using PromptForge responsibly</h2>
            <p>
              By using PromptForge, you agree not to post unlawful, abusive, or harmful content.
            </p>
            <p>
              You are responsible for content you publish, including shared prompts, comments, and remix notes.
            </p>
            <p>
              Community content may be reported, moderated, hidden, or removed to keep the service safe.
            </p>
            <p>
              Repeated misuse may result in restricted access to community features.
            </p>
            <h2>Service availability</h2>
            <p>
              PromptForge is provided "as is" and may change over time as features improve.
            </p>
          </article>
        </Card>

        <Card className="pf-card space-y-2 border-border/80 bg-card/90 p-4 sm:p-5">
          <h2 className="text-base font-semibold text-foreground">Need help?</h2>
          <p className="text-sm text-muted-foreground">
            Visit <Link to="/contact" className="underline">Contact Support</Link> for account, moderation, or policy
            questions.
          </p>
        </Card>
      </div>
    </PageShell>
  );
};

export default Terms;
````

## File: src/styles/globals.css
````css
@import "tailwindcss";
@config "../../tailwind.config.ts";
@import "./typography.css";
@import "./theme.css";
@import "../index.css";
@import "./promptforge-fantasy.css";

/* Explicit source registration keeps class detection stable for non-standard paths. */
@source "../**/*.{ts,tsx}";
@source "../../docs/**/*.{md,mdx}";
@source not "../test/**";

@plugin "@tailwindcss/typography";
@plugin "tailwindcss-react-aria-components";
@plugin "tailwindcss-animate";

@custom-variant dark (&:where(.dark, .dark *, .dark-mode, .dark-mode *));
@custom-variant label (& [data-label]);
@custom-variant focus-input-within (&:has(input:focus));

@utility scrollbar-hide {

  /* For Webkit-based browsers (Chrome, Safari and Opera) */
  &::-webkit-scrollbar {
    display: none;
    -webkit-appearance: none;
  }

  /* For IE, Edge and Firefox */
  -ms-overflow-style: none;
  /* IE and Edge */
  scrollbar-width: none;
  /* Firefox */
}

@utility transition-inherit-all {
  transition-property: inherit;
  transition-duration: inherit;
  transition-timing-function: inherit;
}

html,
body {
  font-family: var(--font-sans);
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  -webkit-font-variant-ligatures: contextual;
  font-variant-ligatures: contextual;
  -webkit-font-kerning: normal;
  font-kerning: normal;
}

/* Hide the default expand arrow on Safari. */
details summary::-webkit-details-marker {
  display: none;
}

/* Hide default arrows from number inputs. */
/* Chrome, Safari, Edge, Opera */
input::-webkit-outer-spin-button,
input::-webkit-inner-spin-button {
  -webkit-appearance: none;
  margin: 0;
}

/* Firefox */
input[type="number"] {
  -moz-appearance: textfield;
}

/* Hide the default clear button (X) from search inputs. */
input[type="search"]::-webkit-search-cancel-button {
  -webkit-appearance: none;
}
````

## File: src/App.tsx
````typescript
import { Suspense, lazy, type ReactNode } from "react";
import { Toaster } from "@/components/base/primitives/toaster";
import { Toaster as Sonner } from "@/components/base/primitives/sonner";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { BrowserRouter, Routes, Route } from "react-router-dom";
import { AuthProvider } from "@/hooks/useAuth";
import { ThemeProvider } from "@/hooks/useTheme";
import {
  BuilderRouteFallback,
  CommunityRouteFallback,
  GenericRouteFallback,
  LibraryRouteFallback,
} from "@/components/route-fallbacks";

const Index = lazy(() => import("./pages/Index"));
const Community = lazy(() => import("./pages/Community"));
const CommunityPost = lazy(() => import("./pages/CommunityPost"));
const Feed = lazy(() => import("./pages/Feed"));
const Profile = lazy(() => import("./pages/Profile"));
const Library = lazy(() => import("./pages/Library"));
const LibraryBulkEdit = lazy(() => import("./pages/LibraryBulkEdit"));
const Presets = lazy(() => import("./pages/Presets"));
const History = lazy(() => import("./pages/History"));
const Privacy = lazy(() => import("./pages/Privacy"));
const Terms = lazy(() => import("./pages/Terms"));
const Contact = lazy(() => import("./pages/Contact"));
const SupportInbox = lazy(() => import("./pages/SupportInbox"));
const ComponentsShowcase = lazy(() => import("./pages/ComponentsShowcase"));
const NotFound = lazy(() => import("./pages/NotFound"));

const queryClient = new QueryClient();

function withRouteFallback(element: ReactNode, fallback: ReactNode) {
  return <Suspense fallback={fallback}>{element}</Suspense>;
}

const App = () => (
  <QueryClientProvider client={queryClient}>
    <AuthProvider>
      <BrowserRouter>
        <ThemeProvider>
          <Toaster />
          <Sonner />
          <Routes>
            <Route path="/" element={withRouteFallback(<Index />, <BuilderRouteFallback />)} />
            <Route path="/community" element={withRouteFallback(<Community />, <CommunityRouteFallback />)} />
            <Route
              path="/community/:postId"
              element={withRouteFallback(<CommunityPost />, <CommunityRouteFallback />)}
            />
            <Route path="/feed" element={withRouteFallback(<Feed />, <CommunityRouteFallback />)} />
            <Route path="/profile/:userId" element={withRouteFallback(<Profile />, <CommunityRouteFallback />)} />
            <Route path="/library" element={withRouteFallback(<Library />, <LibraryRouteFallback />)} />
            <Route
              path="/library/bulk-edit"
              element={withRouteFallback(<LibraryBulkEdit />, <LibraryRouteFallback />)}
            />
            <Route path="/presets" element={withRouteFallback(<Presets />, <BuilderRouteFallback />)} />
            <Route path="/history" element={withRouteFallback(<History />, <GenericRouteFallback />)} />
            <Route path="/privacy" element={withRouteFallback(<Privacy />, <GenericRouteFallback />)} />
            <Route path="/terms" element={withRouteFallback(<Terms />, <GenericRouteFallback />)} />
            <Route path="/contact" element={withRouteFallback(<Contact />, <GenericRouteFallback />)} />
            <Route path="/support/inbox" element={withRouteFallback(<SupportInbox />, <GenericRouteFallback />)} />
            <Route
              path="/components-showcase"
              element={withRouteFallback(<ComponentsShowcase />, <GenericRouteFallback />)}
            />
            {/* ADD ALL CUSTOM ROUTES ABOVE THE CATCH-ALL "*" ROUTE */}
            <Route path="*" element={withRouteFallback(<NotFound />, <GenericRouteFallback />)} />
          </Routes>
        </ThemeProvider>
      </BrowserRouter>
    </AuthProvider>
  </QueryClientProvider>
);

export default App;
````

## File: src/components/application/tables/team-members-table.tsx
````typescript
import { useState } from "react";
import { Badge } from "@/components/base/badges/badges";
import { BadgeGroup } from "@/components/base/badges/badge-groups";
import { ButtonGroup, ButtonGroupItem } from "@/components/base/button-group/button-group";
import { ButtonUtility } from "@/components/base/buttons/button-utility";
import { Avatar, AvatarFallback } from "@/components/base/primitives/avatar";
import { Button } from "@/components/base/buttons/button";
import { Card } from "@/components/base/primitives/card";
import { Checkbox } from "@/components/base/primitives/checkbox";
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/base/primitives/table";
import { cn } from "@/lib/utils";
import {
  CaretLeft as ChevronLeft,
  CaretRight as ChevronRight,
  DotsThreeOutline as MoreHorizontal,
  Funnel as Filter,
  Users,
} from "@phosphor-icons/react";

type TableSize = "md" | "sm";
type TableRows = "divider" | "alternating";

interface TeamMember {
  id: string;
  name: string;
  username: string;
  role: string;
  email: string;
  teams: string[];
  status: "Active" | "Pending";
}

const TEAM_MEMBERS: TeamMember[] = [
  {
    id: "1",
    name: "Olivia Rhye",
    username: "@olivia",
    role: "Product Designer",
    email: "olivia@example.com",
    teams: ["Design", "Product", "Marketing", "Research"],
    status: "Active",
  },
  {
    id: "2",
    name: "Phoenix Baker",
    username: "@phoenix",
    role: "Product Manager",
    email: "phoenix@example.com",
    teams: ["Design", "Product", "Marketing", "Growth"],
    status: "Active",
  },
  {
    id: "3",
    name: "Lana Steiner",
    username: "@lana",
    role: "Frontend Developer",
    email: "lana@example.com",
    teams: ["Design", "Product", "Frontend"],
    status: "Active",
  },
  {
    id: "4",
    name: "Demi Wilkinson",
    username: "@demi",
    role: "Backend Developer",
    email: "demi@example.com",
    teams: ["Platform", "API", "Security"],
    status: "Pending",
  },
  {
    id: "5",
    name: "Candice Wu",
    username: "@candice",
    role: "Fullstack Developer",
    email: "candice@example.com",
    teams: ["Product", "Frontend", "API"],
    status: "Active",
  },
];

function initials(name: string) {
  return name
    .split(" ")
    .slice(0, 2)
    .map((part) => part[0]?.toUpperCase() ?? "")
    .join("");
}

export function TeamMembersTableBlock() {
  const [size, setSize] = useState<TableSize>("md");
  const [rows, setRows] = useState<TableRows>("divider");
  const [selectedMemberIds, setSelectedMemberIds] = useState<Set<string>>(new Set());
  const [currentPage, setCurrentPage] = useState(1);

  const pageSize = 3;
  const totalPages = Math.max(1, Math.ceil(TEAM_MEMBERS.length / pageSize));
  const pageStartIndex = (currentPage - 1) * pageSize;
  const visibleMembers = TEAM_MEMBERS.slice(pageStartIndex, pageStartIndex + pageSize);

  const selectedOnPageCount = visibleMembers.filter((member) => selectedMemberIds.has(member.id)).length;
  const allVisibleSelected = visibleMembers.length > 0 && selectedOnPageCount === visibleMembers.length;
  const hasPartialSelection = selectedOnPageCount > 0 && !allVisibleSelected;

  const compact = size === "sm";
  const cellClassName = compact ? "py-2 text-xs" : "py-3 text-sm";
  const headClassName = compact ? "h-10 py-2 text-xs" : "h-11 py-2 text-xs";

  return (
    <Card className="overflow-hidden border-border/80 bg-card/90">
      <div className="flex flex-wrap items-center justify-between gap-3 border-b border-border/70 px-4 py-3 sm:px-5">
        <div className="space-y-1">
          <h3 className="text-sm font-semibold text-foreground">Team members</h3>
          <BadgeGroup addonText={`${TEAM_MEMBERS.length} users`} iconTrailing={Users}>
            Last updated just now
          </BadgeGroup>
        </div>

        <div className="flex flex-wrap items-center gap-2">
          <ButtonGroup
            size="sm"
            value={size}
            onValueChange={(value) => value && setSize(value as TableSize)}
            aria-label="Table size"
          >
            <ButtonGroupItem value="md" size="sm">
              Medium
            </ButtonGroupItem>
            <ButtonGroupItem value="sm" size="sm">
              Small
            </ButtonGroupItem>
          </ButtonGroup>

          <ButtonGroup
            size="sm"
            value={rows}
            onValueChange={(value) => value && setRows(value as TableRows)}
            aria-label="Table row style"
          >
            <ButtonGroupItem value="divider" size="sm">
              Divider
            </ButtonGroupItem>
            <ButtonGroupItem value="alternating" size="sm">
              Alternating
            </ButtonGroupItem>
          </ButtonGroup>

          <ButtonUtility
            icon={Filter}
            size="xs"
            color="tertiary"
            tooltip="Filters coming soon"
            aria-label="Table filters"
            isDisabled
          />
        </div>
      </div>

      <Table className={cn(compact && "text-xs")}>
        <TableHeader>
          <TableRow className="hover:bg-transparent">
            <TableHead className={cn("w-10 pl-4", headClassName)}>
              <Checkbox
                aria-label="Select all team members"
                checked={allVisibleSelected ? true : hasPartialSelection ? "indeterminate" : false}
                onCheckedChange={(checked) => {
                  const nextChecked = checked === true;
                  setSelectedMemberIds((prev) => {
                    const next = new Set(prev);
                    visibleMembers.forEach((member) => {
                      if (nextChecked) {
                        next.add(member.id);
                      } else {
                        next.delete(member.id);
                      }
                    });
                    return next;
                  });
                }}
              />
            </TableHead>
            <TableHead className={headClassName}>Name</TableHead>
            <TableHead className={headClassName}>Status</TableHead>
            <TableHead className={headClassName}>Role</TableHead>
            <TableHead className={headClassName}>Email address</TableHead>
            <TableHead className={headClassName}>Teams</TableHead>
            <TableHead className={cn("w-12", headClassName)}>
              <span className="sr-only">Actions</span>
            </TableHead>
          </TableRow>
        </TableHeader>

        <TableBody>
          {visibleMembers.map((member) => {
            const visibleTeams = member.teams.slice(0, 2);
            const hiddenCount = Math.max(0, member.teams.length - visibleTeams.length);
            return (
              <TableRow key={member.id} className={cn(rows === "alternating" && "odd:bg-muted/30")}>
                <TableCell className={cn("pl-4", cellClassName)}>
                  <Checkbox
                    aria-label={`Select ${member.name}`}
                    checked={selectedMemberIds.has(member.id)}
                    onCheckedChange={(checked) => {
                      setSelectedMemberIds((prev) => {
                        const next = new Set(prev);
                        if (checked === true) {
                          next.add(member.id);
                        } else {
                          next.delete(member.id);
                        }
                        return next;
                      });
                    }}
                  />
                </TableCell>

                <TableCell className={cellClassName}>
                  <div className="flex items-center gap-2.5">
                    <Avatar className={cn("border border-border/70", compact ? "h-8 w-8" : "h-9 w-9")}>
                      <AvatarFallback className="bg-muted text-xs font-semibold text-muted-foreground">
                        {initials(member.name)}
                      </AvatarFallback>
                    </Avatar>
                    <div>
                      <p className="font-medium text-foreground">{member.name}</p>
                      <p className="text-xs text-muted-foreground">{member.username}</p>
                    </div>
                  </div>
                </TableCell>

                <TableCell className={cellClassName}>
                  <Badge tone={member.status === "Active" ? "success" : "warning"} size="sm">
                    {member.status}
                  </Badge>
                </TableCell>

                <TableCell className={cn("text-muted-foreground", cellClassName)}>{member.role}</TableCell>
                <TableCell className={cn("text-muted-foreground", cellClassName)}>{member.email}</TableCell>

                <TableCell className={cellClassName}>
                  <div className="flex flex-wrap items-center gap-1.5">
                    {visibleTeams.map((team) => (
                      <Badge key={`${member.id}-${team}`} size="sm">
                        {team}
                      </Badge>
                    ))}
                    {hiddenCount > 0 ? (
                      <Badge tone="default" size="sm">
                        +{hiddenCount}
                      </Badge>
                    ) : null}
                  </div>
                </TableCell>

                <TableCell className={cellClassName}>
                  <ButtonUtility
                    icon={MoreHorizontal}
                    size="xs"
                    color="tertiary"
                    tooltip="More actions"
                    aria-label={`Actions for ${member.name}`}
                  />
                </TableCell>
              </TableRow>
            );
          })}
        </TableBody>
      </Table>

      <div className="flex items-center justify-between border-t border-border/70 px-4 py-3 sm:px-5">
        <p className="text-xs text-muted-foreground">
          Page {currentPage} of {totalPages}
        </p>
        <div className="flex items-center gap-2">
          <Button
            color="secondary"
            size="sm"
            className="h-8 px-2.5 text-xs"
            onClick={() => setCurrentPage((page) => Math.max(1, page - 1))}
            disabled={currentPage === 1}
          >
            <ChevronLeft className="h-3.5 w-3.5" />
            Previous
          </Button>
          <Button
            color="secondary"
            size="sm"
            className="h-8 px-2.5 text-xs"
            onClick={() => setCurrentPage((page) => Math.min(totalPages, page + 1))}
            disabled={currentPage === totalPages}
          >
            Next
            <ChevronRight className="h-3.5 w-3.5" />
          </Button>
        </div>
      </div>
    </Card>
  );
}
````

## File: src/components/base/badges/badges.tsx
````typescript
import type { HTMLAttributes, ReactNode } from "react";
import { cva } from "class-variance-authority";
import { Dot } from "@/components/foundations/dot-icon";
import { cx } from "@/lib/utils/cx";
import type { BadgeColors, BadgeTypeToColorMap, BadgeTypes, FlagTypes, IconComponentType, Sizes } from "./badge-types";
import { badgeTypes } from "./badge-types";

export const badgeVariants = cva(
    "inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition duration-100 ease-linear focus:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
    {
        variants: {
            variant: {
                default: "border-primary/30 bg-primary/10 text-primary",
                secondary: "border-secondary bg-secondary text-secondary-foreground shadow-xs",
                destructive: "border-destructive/35 bg-destructive/10 text-destructive",
                outline: "border-border bg-background text-foreground",
            },
        },
        defaultVariants: {
            variant: "default",
        },
    },
);

export const filledColors: Record<BadgeColors, { root: string; addon: string; addonButton: string }> = {
    gray: {
        root: "bg-muted text-foreground ring-border",
        addon: "text-muted-foreground",
        addonButton: "text-muted-foreground hover:bg-muted/80 hover:text-foreground",
    },
    brand: {
        root: "bg-primary/10 text-primary ring-primary/30",
        addon: "text-primary/80",
        addonButton: "text-primary/70 hover:bg-primary/15 hover:text-primary",
    },
    error: {
        root: "bg-destructive/10 text-destructive ring-destructive/30",
        addon: "text-destructive/80",
        addonButton: "text-destructive/70 hover:bg-destructive/15 hover:text-destructive",
    },
    warning: {
        root: "bg-accent/25 text-accent-foreground ring-accent/35",
        addon: "text-accent-foreground/80",
        addonButton: "text-accent-foreground/70 hover:bg-accent/35 hover:text-accent-foreground",
    },
    success: {
        root: "bg-primary/10 text-primary ring-primary/30",
        addon: "text-primary/80",
        addonButton: "text-primary/70 hover:bg-primary/15 hover:text-primary",
    },
    "gray-blue": {
        root: "bg-secondary text-secondary-foreground ring-border",
        addon: "text-muted-foreground",
        addonButton: "text-muted-foreground hover:bg-secondary/85 hover:text-foreground",
    },
    "blue-light": {
        root: "bg-primary/10 text-primary ring-primary/30",
        addon: "text-primary/80",
        addonButton: "text-primary/70 hover:bg-primary/15 hover:text-primary",
    },
    blue: {
        root: "bg-primary/10 text-primary ring-primary/30",
        addon: "text-primary/80",
        addonButton: "text-primary/70 hover:bg-primary/15 hover:text-primary",
    },
    indigo: {
        root: "bg-secondary text-secondary-foreground ring-border",
        addon: "text-muted-foreground",
        addonButton: "text-muted-foreground hover:bg-secondary/85 hover:text-foreground",
    },
    purple: {
        root: "bg-secondary text-secondary-foreground ring-border",
        addon: "text-muted-foreground",
        addonButton: "text-muted-foreground hover:bg-secondary/85 hover:text-foreground",
    },
    pink: {
        root: "bg-destructive/10 text-destructive ring-destructive/30",
        addon: "text-destructive/80",
        addonButton: "text-destructive/70 hover:bg-destructive/15 hover:text-destructive",
    },
    orange: {
        root: "bg-accent/25 text-accent-foreground ring-accent/35",
        addon: "text-accent-foreground/80",
        addonButton: "text-accent-foreground/70 hover:bg-accent/35 hover:text-accent-foreground",
    },
};

const addonOnlyColors = Object.fromEntries(Object.entries(filledColors).map(([key, value]) => [key, { root: "", addon: value.addon }])) as Record<
    BadgeColors,
    { root: string; addon: string }
>;

const withPillTypes = {
    [badgeTypes.pillColor]: {
        common: "size-max flex items-center whitespace-nowrap rounded-full ring-1 ring-inset",
        styles: filledColors,
    },
    [badgeTypes.badgeColor]: {
        common: "size-max flex items-center whitespace-nowrap rounded-md ring-1 ring-inset",
        styles: filledColors,
    },
    [badgeTypes.badgeModern]: {
        common: "size-max flex items-center whitespace-nowrap rounded-md ring-1 ring-inset shadow-xs",
        styles: {
            gray: {
                root: "bg-primary text-secondary ring-primary",
                addon: "text-muted-foreground",
                addonButton: "text-muted-foreground hover:bg-secondary/85 hover:text-foreground",
            },
        },
    },
};

const withBadgeTypes = {
    [badgeTypes.pillColor]: {
        common: "size-max flex items-center whitespace-nowrap rounded-full ring-1 ring-inset",
        styles: filledColors,
    },
    [badgeTypes.badgeColor]: {
        common: "size-max flex items-center whitespace-nowrap rounded-md ring-1 ring-inset",
        styles: filledColors,
    },
    [badgeTypes.badgeModern]: {
        common: "size-max flex items-center whitespace-nowrap rounded-md ring-1 ring-inset bg-primary text-secondary ring-primary shadow-xs",
        styles: addonOnlyColors,
    },
};

export type BadgeColor<T extends BadgeTypes> = BadgeTypeToColorMap<typeof withPillTypes>[T];

interface BadgeProps<T extends BadgeTypes> extends HTMLAttributes<HTMLSpanElement> {
    type?: T;
    size?: Sizes;
    color?: BadgeColor<T>;
    children: ReactNode;
}

export const Badge = <T extends BadgeTypes>(props: BadgeProps<T>) => {
    const { type = "pill-color", size = "md", color = "gray", children, className, ...rest } = props;

    const colors = withPillTypes[type];

    const pillSizes = {
        sm: "py-0.5 px-2 text-xs font-medium",
        md: "py-0.5 px-2.5 text-sm font-medium",
        lg: "py-1 px-3 text-sm font-medium",
    };
    const badgeSizes = {
        sm: "py-0.5 px-1.5 text-xs font-medium",
        md: "py-0.5 px-2 text-sm font-medium",
        lg: "py-1 px-2.5 text-sm font-medium rounded-lg",
    };

    const sizes = {
        [badgeTypes.pillColor]: pillSizes,
        [badgeTypes.badgeColor]: badgeSizes,
        [badgeTypes.badgeModern]: badgeSizes,
    };

    return (
        <span className={cx(colors.common, sizes[type][size], colors.styles[color].root, className)} {...rest}>
            {children}
        </span>
    );
};

interface BadgeWithDotProps<T extends BadgeTypes> {
    type?: T;
    size?: Sizes;
    color?: BadgeTypeToColorMap<typeof withBadgeTypes>[T];
    className?: string;
    children: ReactNode;
}

export const BadgeWithDot = <T extends BadgeTypes>(props: BadgeWithDotProps<T>) => {
    const { size = "md", color = "gray", type = "pill-color", className, children } = props;

    const colors = withBadgeTypes[type];

    const pillSizes = {
        sm: "gap-1 py-0.5 pl-1.5 pr-2 text-xs font-medium",
        md: "gap-1.5 py-0.5 pl-2 pr-2.5 text-sm font-medium",
        lg: "gap-1.5 py-1 pl-2.5 pr-3 text-sm font-medium",
    };

    const badgeSizes = {
        sm: "gap-1 py-0.5 px-1.5 text-xs font-medium",
        md: "gap-1.5 py-0.5 px-2 text-sm font-medium",
        lg: "gap-1.5 py-1 px-2.5 text-sm font-medium rounded-lg",
    };

    const sizes = {
        [badgeTypes.pillColor]: pillSizes,
        [badgeTypes.badgeColor]: badgeSizes,
        [badgeTypes.badgeModern]: badgeSizes,
    };

    return (
        <span className={cx(colors.common, sizes[type][size], colors.styles[color].root, className)}>
            <Dot className={colors.styles[color].addon} size="sm" />
            {children}
        </span>
    );
};

interface BadgeWithIconProps<T extends BadgeTypes> {
    type?: T;
    size?: Sizes;
    color?: BadgeTypeToColorMap<typeof withBadgeTypes>[T];
    iconLeading?: IconComponentType;
    iconTrailing?: IconComponentType;
    children: ReactNode;
    className?: string;
}

export const BadgeWithIcon = <T extends BadgeTypes>(props: BadgeWithIconProps<T>) => {
    const { size = "md", color = "gray", type = "pill-color", iconLeading: IconLeading, iconTrailing: IconTrailing, children, className } = props;

    const colors = withBadgeTypes[type];

    const icon = IconLeading ? "leading" : "trailing";

    const pillSizes = {
        sm: {
            trailing: "gap-0.5 py-0.5 pl-2 pr-1.5 text-xs font-medium",
            leading: "gap-0.5 py-0.5 pr-2 pl-1.5 text-xs font-medium",
        },
        md: {
            trailing: "gap-1 py-0.5 pl-2.5 pr-2 text-sm font-medium",
            leading: "gap-1 py-0.5 pr-2.5 pl-2 text-sm font-medium",
        },
        lg: {
            trailing: "gap-1 py-1 pl-3 pr-2.5 text-sm font-medium",
            leading: "gap-1 py-1 pr-3 pl-2.5 text-sm font-medium",
        },
    };
    const badgeSizes = {
        sm: {
            trailing: "gap-0.5 py-0.5 pl-2 pr-1.5 text-xs font-medium",
            leading: "gap-0.5 py-0.5 pr-2 pl-1.5 text-xs font-medium",
        },
        md: {
            trailing: "gap-1 py-0.5 pl-2 pr-1.5 text-sm font-medium",
            leading: "gap-1 py-0.5 pr-2 pl-1.5 text-sm font-medium",
        },
        lg: {
            trailing: "gap-1 py-1 pl-2.5 pr-2 text-sm font-medium rounded-lg",
            leading: "gap-1 py-1 pr-2.5 pl-2 text-sm font-medium rounded-lg",
        },
    };

    const sizes = {
        [badgeTypes.pillColor]: pillSizes,
        [badgeTypes.badgeColor]: badgeSizes,
        [badgeTypes.badgeModern]: badgeSizes,
    };

    return (
        <span className={cx(colors.common, sizes[type][size][icon], colors.styles[color].root, className)}>
            {IconLeading && <IconLeading className={cx(colors.styles[color].addon, "size-3 stroke-3")} />}
            {children}
            {IconTrailing && <IconTrailing className={cx(colors.styles[color].addon, "size-3 stroke-3")} />}
        </span>
    );
};

interface BadgeWithFlagProps<T extends BadgeTypes> {
    type?: T;
    size?: Sizes;
    flag?: FlagTypes;
    color?: BadgeTypeToColorMap<typeof withPillTypes>[T];
    children: ReactNode;
}

export const BadgeWithFlag = <T extends BadgeTypes>(props: BadgeWithFlagProps<T>) => {
    const { size = "md", color = "gray", flag = "AU", type = "pill-color", children } = props;

    const colors = withPillTypes[type];

    const pillSizes = {
        sm: "gap-1 py-0.5 pl-0.75 pr-2 text-xs font-medium",
        md: "gap-1.5 py-0.5 pl-1 pr-2.5 text-sm font-medium",
        lg: "gap-1.5 py-1 pl-1.5 pr-3 text-sm font-medium",
    };
    const badgeSizes = {
        sm: "gap-1 py-0.5 pl-1 pr-1.5 text-xs font-medium",
        md: "gap-1.5 py-0.5 pl-1.5 pr-2 text-sm font-medium",
        lg: "gap-1.5 py-1 pl-2 pr-2.5 text-sm font-medium rounded-lg",
    };

    const sizes = {
        [badgeTypes.pillColor]: pillSizes,
        [badgeTypes.badgeColor]: badgeSizes,
        [badgeTypes.badgeModern]: badgeSizes,
    };

    return (
        <span className={cx(colors.common, sizes[type][size], colors.styles[color].root)}>
            <img src={`https://www.untitledui.com/images/flags/${flag}.svg`} className="size-4 max-w-none rounded-full" alt={`${flag} flag`} />
            {children}
        </span>
    );
};

interface BadgeWithImageProps<T extends BadgeTypes> {
    type?: T;
    size?: Sizes;
    imgSrc: string;
    color?: BadgeTypeToColorMap<typeof withPillTypes>[T];
    children: ReactNode;
}

export const BadgeWithImage = <T extends BadgeTypes>(props: BadgeWithImageProps<T>) => {
    const { size = "md", color = "gray", type = "pill-color", imgSrc, children } = props;

    const colors = withPillTypes[type];

    const pillSizes = {
        sm: "gap-1 py-0.5 pl-0.75 pr-2 text-xs font-medium",
        md: "gap-1.5 py-0.5 pl-1 pr-2.5 text-sm font-medium",
        lg: "gap-1.5 py-1 pl-1.5 pr-3 text-sm font-medium",
    };
    const badgeSizes = {
        sm: "gap-1 py-0.5 pl-1 pr-1.5 text-xs font-medium",
        md: "gap-1.5 py-0.5 pl-1.5 pr-2 text-sm font-medium",
        lg: "gap-1.5 py-1 pl-2 pr-2.5 text-sm font-medium rounded-lg",
    };

    const sizes = {
        [badgeTypes.pillColor]: pillSizes,
        [badgeTypes.badgeColor]: badgeSizes,
        [badgeTypes.badgeModern]: badgeSizes,
    };

    return (
        <span className={cx(colors.common, sizes[type][size], colors.styles[color].root)}>
            <img src={imgSrc} className="size-4 max-w-none rounded-full" alt="Badge image" />
            {children}
        </span>
    );
};
````

## File: src/components/community/PromptPreviewPanel.tsx
````typescript
import { useEffect, useRef, useState } from "react";
import { Button } from "@/components/base/buttons/button";
import { cn } from "@/lib/utils";
import { Copy } from "@phosphor-icons/react";

interface PromptPreviewPanelProps {
  text: string;
  mode?: "compact" | "full";
  className?: string;
  onCopy?: () => void | Promise<void>;
}

export function PromptPreviewPanel({ text, mode = "compact", className, onCopy }: PromptPreviewPanelProps) {
  const preRef = useRef<HTMLPreElement | null>(null);
  const [isExpanded, setIsExpanded] = useState(false);
  const [hasOverflow, setHasOverflow] = useState(false);
  const normalized = text.trim();
  const isCompact = mode === "compact";

  useEffect(() => {
    setIsExpanded(false);
  }, [isCompact, normalized]);

  useEffect(() => {
    if (!isCompact) {
      setHasOverflow(false);
      return;
    }

    if (isExpanded) return;

    const element = preRef.current;
    if (!element) {
      setHasOverflow(false);
      return;
    }

    let cancelled = false;
    const measure = () => {
      if (cancelled) return;
      setHasOverflow(element.scrollHeight - element.clientHeight > 1);
    };

    const rafId = window.requestAnimationFrame(measure);
    const onResize = () => measure();
    window.addEventListener("resize", onResize);
    void document.fonts?.ready.then(measure);

    return () => {
      cancelled = true;
      window.cancelAnimationFrame(rafId);
      window.removeEventListener("resize", onResize);
    };
  }, [isCompact, isExpanded, normalized]);

  const canExpand = isCompact && hasOverflow;
  const isCollapsed = isCompact && !isExpanded;

  return (
    <div className={cn("rounded-lg border border-border/80 bg-muted/35 p-3 sm:p-4", className)}>
      <div className="relative">
        {onCopy && (
          <Button
            type="button"
            color="secondary"
            size="sm"
            className="type-button-label utility-action-button utility-action-button--floating absolute right-2 top-2 z-10"
            onClick={(event) => {
              event.preventDefault();
              event.stopPropagation();
              void onCopy();
            }}
          >
            <Copy />
            Copy
          </Button>
        )}
        <pre
          ref={preRef}
          className={cn(
            "type-code type-wrap-safe font-mono text-foreground/95 whitespace-pre-wrap",
            onCopy && "pr-[4.5rem] sm:pr-14",
            isCollapsed && "line-clamp-6",
          )}
        >
          {normalized || "No prompt content yet."}
        </pre>
      </div>
      {canExpand && (
        <div className="mt-2">
          <Button
            type="button"
            color="tertiary"
            size="sm"
            className="type-button-label h-11 px-3 sm:h-9 sm:px-2"
            aria-expanded={isExpanded}
            onClick={() => setIsExpanded((previous) => !previous)}
          >
            {isExpanded ? "Show less" : "Read more"}
          </Button>
        </div>
      )}
    </div>
  );
}
````

## File: src/components/BuilderAdjustDetails.tsx
````typescript
import { Badge } from "@/components/base/badges/badges";
import { Button } from "@/components/base/buttons/button";
import { Card } from "@/components/base/primitives/card";
import { Checkbox } from "@/components/base/primitives/checkbox";
import { Input } from "@/components/base/input/input";
import { Label } from "@/components/base/label";
import { Select } from "@/components/base/select/select";
import { Textarea } from "@/components/base/textarea";
import {
  PromptConfig,
  constraintOptions,
  formatOptions,
  lengthOptions,
  roles,
  toneOptions,
} from "@/lib/prompt-builder";
import { toConstraintInputId } from "@/lib/builder-tabs";
import {
  CaretDown as ChevronDown,
  CaretRight as ChevronRight,
  Sliders as SlidersHorizontal,
} from "@phosphor-icons/react";

interface BuilderAdjustDetailsProps {
  config: PromptConfig;
  isOpen: boolean;
  onOpenChange: (open: boolean) => void;
  onUpdate: (updates: Partial<PromptConfig>) => void;
}

export function BuilderAdjustDetails({ config, isOpen, onOpenChange, onUpdate }: BuilderAdjustDetailsProps) {
  const selectedRole = config.customRole || config.role;
  const formatCount = config.format.length + (config.customFormat.trim() ? 1 : 0);
  const constraintCount = config.constraints.length + (config.customConstraint.trim() ? 1 : 0);

  const toggleFormat = (format: string) => {
    const next = config.format.includes(format)
      ? config.format.filter((entry) => entry !== format)
      : [...config.format, format];
    onUpdate({ format: next });
  };

  const toggleConstraint = (constraint: string) => {
    const next = config.constraints.includes(constraint)
      ? config.constraints.filter((entry) => entry !== constraint)
      : [...config.constraints, constraint];
    onUpdate({ constraints: next });
  };

  return (
    <Card id="builder-zone-2" className="border-border/70 bg-card/80 p-3 sm:p-4">
      <div className="space-y-3">
        <button
          type="button"
          className="flex w-full items-center justify-between gap-2 text-left"
          onClick={() => onOpenChange(!isOpen)}
          aria-expanded={isOpen}
          aria-controls="builder-zone-2-content"
        >
          <div>
            <p className="flex items-center gap-1.5 text-sm font-medium text-foreground">
              <SlidersHorizontal className="h-4 w-4 text-muted-foreground" />
              Adjust details
            </p>
            <p className="text-sm text-muted-foreground">Role, style, format, and constraints.</p>
          </div>
          <div className="flex items-center gap-2">
            {selectedRole && (
              <Badge type="modern" className="max-w-[180px] text-xs">
                <span className="type-wrap-safe">{selectedRole}</span>
              </Badge>
            )}
            {isOpen ? <ChevronDown className="h-4 w-4 text-muted-foreground" /> : <ChevronRight className="h-4 w-4 text-muted-foreground" />}
          </div>
        </button>

        {!isOpen && (
          <p className="text-sm text-muted-foreground">
            {formatCount} format option{formatCount === 1 ? "" : "s"}, {constraintCount} constraint
            {constraintCount === 1 ? "" : "s"}, tone: {config.tone || "none"}.
          </p>
        )}

        {isOpen && (
          <div id="builder-zone-2-content" className="space-y-5 border-t border-border pt-3">
            <div className="grid grid-cols-1 gap-3 sm:grid-cols-2">
              <div className="space-y-2">
                <Label className="text-sm font-medium text-foreground">AI persona</Label>
                <Select
                  selectedKey={config.role || undefined}
                  onSelectionChange={(value) => {
                    if (value !== null) {
                      onUpdate({ role: String(value) });
                    }
                  }}
                  placeholder="Select a role"
                  aria-label="Select role"
                  className="bg-background"
                >
                  {roles.map((role) => (
                    <Select.Item key={role} id={role}>
                      {role}
                    </Select.Item>
                  ))}
                </Select>
                <Input
                  value={config.customRole}
                  onChange={(value) => onUpdate({ customRole: value })}
                  placeholder="Or use a custom role"
                  wrapperClassName="bg-background"
                  aria-label="Custom role"
                />
              </div>

              <div className="space-y-2">
                <Label className="text-sm font-medium text-foreground">Tone</Label>
                <div className="flex flex-wrap gap-2">
                  {toneOptions.map((tone) => (
                    <Button
                      key={tone}
                      type="button"
                      size="sm"
                      color={config.tone === tone ? "primary" : "secondary"}
                      className="h-11 px-2 text-sm sm:h-9"
                      onClick={() => onUpdate({ tone })}
                      aria-pressed={config.tone === tone}
                    >
                      {tone}
                    </Button>
                  ))}
                </div>
              </div>
            </div>

            <div className="space-y-2">
              <Label className="text-sm font-medium text-foreground">Output format</Label>
              <div className="flex flex-wrap gap-2">
                {formatOptions.map((format) => (
                  <Button
                    key={format}
                    type="button"
                    size="sm"
                    color={config.format.includes(format) ? "primary" : "secondary"}
                    className="h-11 px-2 text-sm sm:h-9"
                    onClick={() => toggleFormat(format)}
                    aria-pressed={config.format.includes(format)}
                  >
                    {format}
                  </Button>
                ))}
              </div>
              <Input
                value={config.customFormat}
                onChange={(value) => onUpdate({ customFormat: value })}
                placeholder="Custom format"
                wrapperClassName="bg-background"
                aria-label="Custom format"
              />
            </div>

            <div className="space-y-2">
              <Label className="text-sm font-medium text-foreground">Length</Label>
              <Select
                selectedKey={config.lengthPreference || undefined}
                onSelectionChange={(value) => {
                  if (value !== null) {
                    onUpdate({ lengthPreference: String(value) });
                  }
                }}
                aria-label="Length preference"
                className="bg-background"
              >
                {lengthOptions.map((option) => (
                  <Select.Item key={option.value} id={option.value}>
                    {option.label}
                  </Select.Item>
                ))}
              </Select>
            </div>

            <div className="space-y-3">
              <Label className="text-sm font-medium text-foreground">Constraints</Label>
              <div className="space-y-2">
                {constraintOptions.map((constraint) => {
                  const inputId = toConstraintInputId(constraint);
                  return (
                    <div key={constraint} className="flex items-center gap-2">
                      <Checkbox
                        id={inputId}
                        checked={config.constraints.includes(constraint)}
                        onCheckedChange={() => toggleConstraint(constraint)}
                      />
                      <Label htmlFor={inputId} className="cursor-pointer text-sm">
                        {constraint}
                      </Label>
                    </div>
                  );
                })}
              </div>
              <Input
                value={config.customConstraint}
                onChange={(value) => onUpdate({ customConstraint: value })}
                placeholder="Custom constraint"
                wrapperClassName="bg-background"
                aria-label="Custom constraint"
              />
            </div>

            <div className="space-y-2">
              <Label className="text-sm font-medium text-foreground">Example output (optional)</Label>
              <Textarea
                value={config.examples}
                onChange={(e) => onUpdate({ examples: e.target.value })}
                placeholder="Include sample inputs/outputs for better fidelity"
                className="min-h-[100px] bg-background font-mono"
              />
            </div>
          </div>
        )}
      </div>
    </Card>
  );
}
````

## File: src/components/PromptInput.tsx
````typescript
import { Textarea } from "@/components/base/textarea";
import { Button } from "@/components/base/buttons/button";
import { ArrowCounterClockwise as RotateCcw } from "@phosphor-icons/react";

interface PromptInputProps {
  value: string;
  onChange: (value: string) => void;
  onClear: () => void;
}

export function PromptInput({ value, onChange, onClear }: PromptInputProps) {
  const promptInputId = "builder-original-prompt";
  const promptInputMetaId = "builder-original-prompt-meta";

  return (
    <div className="space-y-2">
      <div className="flex items-center justify-between">
        <label htmlFor={promptInputId} className="text-sm font-medium text-foreground">
          Your Prompt
        </label>
        <div className="flex items-center gap-2">
          <span id={promptInputMetaId} className="text-sm text-muted-foreground">
            {value.length} chars
          </span>
          {value && (
            <Button
              color="tertiary"
              size="sm"
              onClick={onClear}
              aria-label="Clear prompt text"
              className="interactive-chip h-11 gap-1 px-2 text-sm sm:h-9"
            >
              <RotateCcw className="w-3 h-3" />
              Clear Prompt
            </Button>
          )}
        </div>
      </div>
      <Textarea
        id={promptInputId}
        value={value}
        onChange={(e) => onChange(e.target.value)}
        placeholder="Enter your basic prompt here... (e.g., 'Write a blog post about AI')"
        className="min-h-[80px] resize-none text-foreground placeholder:text-muted-foreground sm:min-h-[120px]"
        aria-describedby={promptInputMetaId}
      />
    </div>
  );
}
````

## File: src/lib/persistence.ts
````typescript
import { neon } from "@/integrations/neon/client";
import type { Json } from "@/integrations/neon/types";
import { assertBackendConfigured } from "@/lib/backend-config";
import type { RemixDiff } from "@/lib/community";
import {
  hydrateConfigV1ToWorkingState,
  serializeWorkingStateToV1,
} from "@/lib/prompt-config-adapters";
import { builderRedesignFlags } from "@/lib/feature-flags";
import { normalizePromptCategory } from "@/lib/prompt-categories";
import type { PromptConfig } from "@/lib/prompt-builder";
import { defaultConfig } from "@/lib/prompt-builder";
import {
  escapePostgrestLikePattern,
  isPostgrestError,
  normalizePromptTagsOptional,
  type PostgrestError,
  sanitizePostgresJson,
  sanitizePostgresText,
  type SavedPromptListRow,
  type SavedPromptRow,
} from "@/lib/saved-prompt-shared";
import {
  collectTemplateWarnings,
  computeTemplateFingerprint,
  deriveExternalReferencesFromConfig,
  inferTemplateStarterPrompt,
  listTemplateSummaries as listLocalTemplates,
  loadTemplateById as loadLocalTemplate,
  saveTemplateSnapshot as saveLocalTemplate,
  deleteTemplateById as deleteLocalTemplate,
  type TemplateSummary,
  type TemplateLoadResult,
  type SaveTemplateResult,
  type TemplateSaveInput,
} from "@/lib/template-store";
import { assertCommunityTextAllowed } from "@/lib/content-moderation";

const DRAFT_KEY = "promptforge-draft";
const SAVED_PROMPT_FULL_SELECT_COLUMNS =
  "id, user_id, title, description, category, tags, config, built_prompt, enhanced_prompt, fingerprint, revision, is_shared, target_model, use_case, remixed_from, remix_note, remix_diff, created_at, updated_at";
const SAVED_PROMPT_LIST_SELECT_COLUMNS =
  "id, user_id, title, description, category, tags, config, fingerprint, revision, is_shared, target_model, use_case, remixed_from, created_at, updated_at";

type PersistenceErrorCode = "unauthorized" | "conflict" | "network" | "unknown";

export class PersistenceError extends Error {
  readonly code: PersistenceErrorCode;

  constructor(code: PersistenceErrorCode, message: string, options?: { cause?: unknown }) {
    super(message);
    this.name = "PersistenceError";
    this.code = code;
    if (options?.cause !== undefined) {
      (this as unknown as Record<string, unknown>).cause = options.cause;
    }
  }
}

export interface PromptSummary extends TemplateSummary {
  category: string;
  isShared: boolean;
  communityPostId: string | null;
  targetModel: string;
  useCase: string;
  remixedFrom: string | null;
  builtPrompt: string;
  enhancedPrompt: string;
  upvoteCount: number;
  verifiedCount: number;
  remixCount: number;
  commentCount: number;
}

export interface PromptSaveInput extends TemplateSaveInput {
  category?: string;
  builtPrompt?: string;
  enhancedPrompt?: string;
  targetModel?: string;
  useCase?: string;
  isShared?: boolean;
  remixedFrom?: string | null;
  remixNote?: string;
  remixDiff?: RemixDiff | null;
}

export interface PromptShareInput {
  title?: string;
  description?: string;
  category?: string;
  tags?: string[];
  targetModel?: string;
  useCase?: string;
}

export interface ShareResult {
  shared: boolean;
  postId?: string;
}

export function getPersistenceErrorMessage(error: unknown, fallback: string): string {
  if (error instanceof Error && error.message.trim()) return error.message;
  return fallback;
}

function mapPostgrestError(error: PostgrestError, fallback: string): PersistenceError {
  const message = (error.message || fallback).trim() || fallback;
  const details = [error.details, error.hint].filter(Boolean).join(" ");
  const isUnauthorized =
    error.code === "42501" ||
    /row-level security|permission denied|insufficient privilege|not authenticated|jwt/i.test(message);

  if (isUnauthorized) {
    return new PersistenceError("unauthorized", message, { cause: error });
  }

  if (/unsupported unicode escape sequence|\\u0000 cannot be converted to text/i.test(`${message} ${details}`)) {
    return new PersistenceError(
      "unknown",
      "Prompt text contains unsupported characters. Please remove hidden control characters and try again.",
      { cause: error },
    );
  }

  if (error.code === "23505") {
    return new PersistenceError("conflict", message, { cause: error });
  }

  return new PersistenceError("unknown", message, { cause: error });
}

function toPersistenceError(error: unknown, fallback: string): PersistenceError {
  if (error instanceof PersistenceError) return error;
  if (isPostgrestError(error)) return mapPostgrestError(error, fallback);
  if (error instanceof Error) {
    if (/network|failed to fetch|fetch failed|connection/i.test(error.message)) {
      return new PersistenceError("network", error.message, { cause: error });
    }
    return new PersistenceError("unknown", error.message || fallback, { cause: error });
  }
  return new PersistenceError("unknown", fallback, { cause: error });
}

function ensureCloudPersistence(featureLabel = "Cloud persistence"): void {
  assertBackendConfigured(featureLabel);
}

function normalizeDescription(description?: string): string | undefined {
  if (description === undefined) return undefined;
  return sanitizePostgresText(description).trim().slice(0, 500);
}

function normalizeUseCase(useCase?: string): string | undefined {
  if (useCase === undefined) return undefined;
  return sanitizePostgresText(useCase).trim().slice(0, 1000);
}

function normalizeTargetModel(targetModel?: string): string | undefined {
  if (targetModel === undefined) return undefined;
  return sanitizePostgresText(targetModel).trim().slice(0, 80);
}

function normalizeRemixNote(remixNote?: string): string | undefined {
  if (remixNote === undefined) return undefined;
  return sanitizePostgresText(remixNote).trim().slice(0, 500);
}

function normalizePromptBody(prompt?: string): string | undefined {
  if (prompt === undefined) return undefined;
  return sanitizePostgresText(prompt);
}

function normalizeRemixDiff(remixDiff?: RemixDiff | null): Json | null | undefined {
  if (remixDiff === undefined) return undefined;
  if (remixDiff === null) return null;
  return sanitizePostgresJson(remixDiff as unknown as Json);
}

function toPresetName(value: string): string {
  const normalized = sanitizePostgresText(value).trim().slice(0, 200);
  return normalized || "Untitled Prompt";
}

function normalizePromptIds(ids: string[]): string[] {
  return Array.from(
    new Set(
      ids
        .map((id) => id.trim())
        .filter(Boolean),
    ),
  );
}

// ---------------------------------------------------------------------------
// Draft persistence
// ---------------------------------------------------------------------------

export async function loadDraft(userId: string | null): Promise<PromptConfig | null> {
  if (!userId) {
    try {
      const raw = localStorage.getItem(DRAFT_KEY);
      return raw ? hydrateConfigV1ToWorkingState(JSON.parse(raw)) : null;
    } catch {
      return null;
    }
  }

  ensureCloudPersistence("Cloud drafts");

  try {
    const { data, error } = await neon
      .from("drafts")
      .select("config")
      .eq("user_id", userId)
      .maybeSingle();

    if (error) throw mapPostgrestError(error, "Failed to load cloud draft.");
    if (!data) return null;
    return hydrateConfigV1ToWorkingState(data.config);
  } catch (error) {
    throw toPersistenceError(error, "Failed to load cloud draft.");
  }
}

export async function saveDraft(userId: string | null, config: PromptConfig): Promise<void> {
  const safeConfig = sanitizePostgresJson(config as unknown as Json) as unknown as PromptConfig;
  const normalizedConfig = serializeWorkingStateToV1(safeConfig, {
    includeV2Compat: builderRedesignFlags.builderRedesignPhase4,
    preserveSourceRawContent: true,
  });
  if (!userId) {
    try {
      localStorage.setItem(DRAFT_KEY, JSON.stringify(normalizedConfig));
    } catch {
      // quota errors are intentionally ignored to keep the UI responsive
    }
    return;
  }

  ensureCloudPersistence("Cloud drafts");

  try {
    const { error } = await neon.from("drafts").upsert(
      {
        user_id: userId,
        config: sanitizePostgresJson(normalizedConfig as unknown as Json),
      },
      { onConflict: "user_id" },
    );
    if (error) throw mapPostgrestError(error, "Failed to save cloud draft.");
  } catch (error) {
    throw toPersistenceError(error, "Failed to save cloud draft.");
  }
}

export function clearLocalDraft(): void {
  try {
    localStorage.removeItem(DRAFT_KEY);
  } catch {
    // ignore
  }
}

// ---------------------------------------------------------------------------
// Prompt persistence (saved_prompts)
// ---------------------------------------------------------------------------

export async function loadPrompts(userId: string | null): Promise<PromptSummary[]> {
  if (!userId) {
    return listLocalTemplates().map((template) => ({
      ...template,
      category: "general",
      isShared: false,
      communityPostId: null,
      targetModel: "",
      useCase: "",
      remixedFrom: null,
      builtPrompt: "",
      enhancedPrompt: "",
      upvoteCount: 0,
      verifiedCount: 0,
      remixCount: 0,
      commentCount: 0,
    }));
  }

  ensureCloudPersistence("Cloud prompts");

  try {
    const { data, error } = await neon
      .from("saved_prompts")
      .select(SAVED_PROMPT_LIST_SELECT_COLUMNS)
      .eq("user_id", userId)
      .order("updated_at", { ascending: false });

    if (error) throw mapPostgrestError(error, "Failed to load prompts.");
    if (!data) return [];

    const savedRows = data as SavedPromptListRow[];
    const promptIds = savedRows.map((row) => row.id);
    const metricsByPromptId = new Map<
      string,
      {
        community_post_id: string;
        upvote_count: number;
        verified_count: number;
        remix_count: number;
        comment_count: number;
      }
    >();

    if (promptIds.length > 0) {
      const { data: postMetrics, error: postMetricsError } = await neon
        .from("community_posts")
        .select("id, saved_prompt_id, upvote_count, verified_count, remix_count, comment_count")
        .in("saved_prompt_id", promptIds)
        .eq("is_public", true);

      if (!postMetricsError && postMetrics) {
        postMetrics.forEach((post) => {
          metricsByPromptId.set(post.saved_prompt_id, {
            community_post_id: post.id,
            upvote_count: post.upvote_count,
            verified_count: post.verified_count,
            remix_count: post.remix_count,
            comment_count: post.comment_count,
          });
        });
      }
    }

    return savedRows.map((savedRow) => {
      const metrics = metricsByPromptId.get(savedRow.id);
      const cfg = hydrateConfigV1ToWorkingState(savedRow.config ?? defaultConfig);
      return {
        id: savedRow.id,
        name: savedRow.title,
        description: savedRow.description,
        tags: savedRow.tags ?? [],
        starterPrompt: inferTemplateStarterPrompt(cfg),
        updatedAt: new Date(savedRow.updated_at).getTime(),
        createdAt: new Date(savedRow.created_at).getTime(),
        revision: savedRow.revision,
        schemaVersion: 2,
        sourceCount: cfg.contextConfig.sources.length,
        databaseCount: cfg.contextConfig.databaseConnections.length,
        ragEnabled: cfg.contextConfig.rag.enabled,
        category: savedRow.category,
        isShared: savedRow.is_shared,
        communityPostId: metrics?.community_post_id ?? null,
        targetModel: savedRow.target_model,
        useCase: savedRow.use_case,
        remixedFrom: savedRow.remixed_from,
        builtPrompt: "",
        enhancedPrompt: "",
        upvoteCount: metrics?.upvote_count ?? 0,
        verifiedCount: metrics?.verified_count ?? 0,
        remixCount: metrics?.remix_count ?? 0,
        commentCount: metrics?.comment_count ?? 0,
      } satisfies PromptSummary;
    });
  } catch (error) {
    throw toPersistenceError(error, "Failed to load prompts.");
  }
}

export async function loadPromptById(userId: string | null, id: string): Promise<TemplateLoadResult | null> {
  if (!userId) return loadLocalTemplate(id);

  ensureCloudPersistence("Cloud prompts");

  try {
    const { data, error } = await neon
      .from("saved_prompts")
      .select(SAVED_PROMPT_FULL_SELECT_COLUMNS)
      .eq("id", id)
      .eq("user_id", userId)
      .maybeSingle();

    if (error) throw mapPostgrestError(error, "Failed to load prompt.");
    if (!data) return null;

    const row = data as SavedPromptRow;
    const cfg = hydrateConfigV1ToWorkingState(row.config ?? defaultConfig);
    return {
      record: rowToRecord(row, cfg),
      warnings: collectTemplateWarnings(cfg),
    };
  } catch (error) {
    throw toPersistenceError(error, "Failed to load prompt.");
  }
}

function hasMetadataChanges(existing: SavedPromptRow, input: PromptSaveInput): boolean {
  const normalizedDescription = normalizeDescription(input.description);
  const normalizedTags = normalizePromptTagsOptional(input.tags);
  const normalizedCategory = normalizePromptCategory(input.category);
  const normalizedUseCase = normalizeUseCase(input.useCase);
  const normalizedTargetModel = normalizeTargetModel(input.targetModel);
  const normalizedRemixNote = normalizeRemixNote(input.remixNote);
  const normalizedBuiltPrompt = normalizePromptBody(input.builtPrompt);
  const normalizedEnhancedPrompt = normalizePromptBody(input.enhancedPrompt);
  const normalizedRemixDiff = normalizeRemixDiff(input.remixDiff);

  if (normalizedDescription !== undefined && normalizedDescription !== existing.description) return true;
  if (normalizedCategory !== undefined && normalizedCategory !== existing.category) return true;
  if (normalizedUseCase !== undefined && normalizedUseCase !== existing.use_case) return true;
  if (normalizedTargetModel !== undefined && normalizedTargetModel !== existing.target_model) return true;
  if (normalizedRemixNote !== undefined && normalizedRemixNote !== existing.remix_note) return true;

  if (normalizedTags !== undefined) {
    const existingTags = existing.tags ?? [];
    if (
      normalizedTags.length !== existingTags.length ||
      normalizedTags.some((tag, index) => tag !== existingTags[index])
    ) {
      return true;
    }
  }

  if (normalizedBuiltPrompt !== undefined && normalizedBuiltPrompt !== existing.built_prompt) return true;
  if (normalizedEnhancedPrompt !== undefined && normalizedEnhancedPrompt !== existing.enhanced_prompt) return true;
  if (input.isShared !== undefined && input.isShared !== existing.is_shared) return true;
  if (input.remixedFrom !== undefined && input.remixedFrom !== existing.remixed_from) return true;
  if (normalizedRemixDiff !== undefined && JSON.stringify(normalizedRemixDiff) !== JSON.stringify(existing.remix_diff)) {
    return true;
  }

  return false;
}

export async function savePrompt(userId: string | null, input: PromptSaveInput): Promise<SaveTemplateResult> {
  if (!userId) {
    return saveLocalTemplate({
      name: toPresetName(input.name || ""),
      description: input.description,
      tags: input.tags,
      config: input.config,
    });
  }

  ensureCloudPersistence("Cloud prompts");

  const name = toPresetName(input.name || "");
  if (!name) throw new PersistenceError("unknown", "Prompt title is required.");

  const safeConfig = sanitizePostgresJson(input.config as unknown as Json) as unknown as PromptConfig;
  const normalizedConfig = serializeWorkingStateToV1(safeConfig, {
    includeV2Compat: false,
  });
  const persistedConfig = serializeWorkingStateToV1(normalizedConfig, {
    includeV2Compat: builderRedesignFlags.builderRedesignPhase4,
  });
  const normalizedDescription = normalizeDescription(input.description);
  const normalizedCategory = normalizePromptCategory(input.category) ?? "general";
  const normalizedTargetModel = normalizeTargetModel(input.targetModel);
  const normalizedUseCase = normalizeUseCase(input.useCase);
  const normalizedRemixNote = normalizeRemixNote(input.remixNote);
  const normalizedBuiltPrompt = normalizePromptBody(input.builtPrompt);
  const normalizedEnhancedPrompt = normalizePromptBody(input.enhancedPrompt);
  const normalizedRemixDiff = normalizeRemixDiff(input.remixDiff);
  const fingerprint = computeTemplateFingerprint(normalizedConfig);
  const warnings = collectTemplateWarnings(normalizedConfig);
  const tags = normalizePromptTagsOptional(input.tags);
  const safePersistedConfig = sanitizePostgresJson(persistedConfig as unknown as Json);

  try {
    const { data: existingRows, error: lookupError } = await neon
      .from("saved_prompts")
      .select(SAVED_PROMPT_FULL_SELECT_COLUMNS)
      .eq("user_id", userId)
      .ilike("title", escapePostgrestLikePattern(name))
      .order("updated_at", { ascending: false })
      .limit(1);

    if (lookupError) throw mapPostgrestError(lookupError, "Failed to save prompt.");
    const existing = (existingRows?.[0] as SavedPromptRow | null) ?? null;

    if (existing?.fingerprint === fingerprint && !hasMetadataChanges(existing, input)) {
      return {
        outcome: "unchanged",
        record: rowToRecord(existing, normalizedConfig),
        warnings,
      };
    }

    if (existing) {
      const updatePayload: Record<string, unknown> = {
        title: name,
        tags: tags ?? existing.tags ?? [],
        config: safePersistedConfig,
        fingerprint,
        revision: existing.revision + 1,
      };
      if (normalizedDescription !== undefined) {
        updatePayload.description = normalizedDescription;
      }
      if (input.category !== undefined) {
        updatePayload.category = normalizedCategory;
      }
      if (normalizedBuiltPrompt !== undefined) {
        updatePayload.built_prompt = normalizedBuiltPrompt;
      }
      if (normalizedEnhancedPrompt !== undefined) {
        updatePayload.enhanced_prompt = normalizedEnhancedPrompt;
      }
      if (normalizedTargetModel !== undefined) {
        updatePayload.target_model = normalizedTargetModel;
      }
      if (normalizedUseCase !== undefined) {
        updatePayload.use_case = normalizedUseCase;
      }
      if (input.isShared !== undefined) {
        updatePayload.is_shared = input.isShared;
      }
      if (input.remixedFrom !== undefined) {
        updatePayload.remixed_from = input.remixedFrom;
      }
      if (normalizedRemixNote !== undefined) {
        updatePayload.remix_note = normalizedRemixNote;
      }
      if (normalizedRemixDiff !== undefined) {
        updatePayload.remix_diff = normalizedRemixDiff;
      }

      const { data: updated, error } = await neon
        .from("saved_prompts")
        .update(updatePayload)
        .eq("id", existing.id)
        .eq("user_id", userId)
        .eq("revision", existing.revision)
        .select(SAVED_PROMPT_FULL_SELECT_COLUMNS)
        .maybeSingle();

      if (error) throw mapPostgrestError(error, "Failed to update prompt.");
      if (!updated) {
        throw new PersistenceError("conflict", "Prompt was modified elsewhere. Please refresh and try again.");
      }
      return {
        outcome: "updated",
        record: rowToRecord(updated as SavedPromptRow, normalizedConfig),
        warnings,
      };
    }

    const { data: created, error: insertError } = await neon
      .from("saved_prompts")
      .insert({
        user_id: userId,
        title: name,
        description: normalizedDescription ?? "",
        category: normalizedCategory,
        tags: tags ?? [],
        config: safePersistedConfig,
        built_prompt: normalizedBuiltPrompt ?? "",
        enhanced_prompt: normalizedEnhancedPrompt ?? "",
        fingerprint,
        is_shared: input.isShared ?? false,
        target_model: normalizedTargetModel ?? "",
        use_case: normalizedUseCase ?? "",
        remixed_from: input.remixedFrom ?? null,
        remix_note: normalizedRemixNote ?? "",
        remix_diff: normalizedRemixDiff ?? null,
      })
      .select(SAVED_PROMPT_FULL_SELECT_COLUMNS)
      .single();

    if (insertError) {
      throw mapPostgrestError(insertError, "Failed to save prompt.");
    }
    if (!created) throw new PersistenceError("unknown", "Prompt save returned no data.");

    return {
      outcome: "created",
      record: rowToRecord(created as SavedPromptRow, normalizedConfig),
      warnings,
    };
  } catch (error) {
    throw toPersistenceError(error, "Failed to save prompt.");
  }
}

export async function sharePrompt(
  userId: string | null,
  id: string,
  input: PromptShareInput = {},
): Promise<ShareResult> {
  if (!userId) {
    throw new PersistenceError("unauthorized", "Sign in to share prompts.");
  }

  ensureCloudPersistence("Community sharing");

  try {
    const { data: existing, error: existingError } = await neon
      .from("saved_prompts")
      .select("id, use_case")
      .eq("id", id)
      .eq("user_id", userId)
      .maybeSingle();

    if (existingError) throw mapPostgrestError(existingError, "Failed to share prompt.");
    if (!existing) return { shared: false };

    const normalizedUseCaseInput = input.useCase !== undefined
      ? normalizeUseCase(input.useCase) ?? ""
      : undefined;
    const effectiveUseCase = (normalizedUseCaseInput ?? existing.use_case ?? "").trim();
    if (!effectiveUseCase) {
      throw new PersistenceError("unknown", "Use case is required before sharing.");
    }
    assertCommunityTextAllowed(effectiveUseCase, "Use case violates community safety rules.");
    if (input.title !== undefined) {
      assertCommunityTextAllowed(input.title, "Title violates community safety rules.");
    }
    if (input.description !== undefined) {
      assertCommunityTextAllowed(input.description, "Description violates community safety rules.");
    }

    const updatePayload: Record<string, unknown> = {
      is_shared: true,
      use_case: effectiveUseCase,
    };

    if (input.title !== undefined) updatePayload.title = toPresetName(input.title);
    if (input.description !== undefined) updatePayload.description = normalizeDescription(input.description) ?? "";
    if (input.category !== undefined) updatePayload.category = normalizePromptCategory(input.category) ?? "general";
    if (input.tags !== undefined) updatePayload.tags = normalizePromptTagsOptional(input.tags) ?? [];
    if (input.targetModel !== undefined) updatePayload.target_model = normalizeTargetModel(input.targetModel) ?? "";

    const { data, error } = await neon
      .from("saved_prompts")
      .update(updatePayload)
      .eq("id", id)
      .eq("user_id", userId)
      .select("id")
      .maybeSingle();

    if (error) throw mapPostgrestError(error, "Failed to share prompt.");
    if (!data) return { shared: false };

    // Look up the community post created by the DB trigger
    const { data: post } = await neon
      .from("community_posts")
      .select("id")
      .eq("saved_prompt_id", id)
      .maybeSingle();

    return { shared: true, postId: post?.id };
  } catch (error) {
    throw toPersistenceError(error, "Failed to share prompt.");
  }
}

export async function unsharePrompt(userId: string | null, id: string): Promise<boolean> {
  const [updatedId] = await unsharePrompts(userId, [id]);
  return Boolean(updatedId);
}

export async function unsharePrompts(userId: string | null, ids: string[]): Promise<string[]> {
  const normalizedIds = normalizePromptIds(ids);
  if (normalizedIds.length === 0) return [];
  if (!userId) {
    throw new PersistenceError("unauthorized", "Sign in to unshare prompts.");
  }

  ensureCloudPersistence("Community sharing");

  try {
    const { data, error } = await neon
      .from("saved_prompts")
      .update({ is_shared: false })
      .eq("user_id", userId)
      .eq("is_shared", true)
      .in("id", normalizedIds)
      .select("id");

    if (error) throw mapPostgrestError(error, "Failed to unshare prompts.");
    return (data ?? []).map((row) => row.id);
  } catch (error) {
    throw toPersistenceError(error, "Failed to unshare prompts.");
  }
}

export async function deletePrompt(userId: string | null, id: string): Promise<boolean> {
  const [deletedId] = await deletePrompts(userId, [id]);
  return Boolean(deletedId);
}

export async function deletePrompts(userId: string | null, ids: string[]): Promise<string[]> {
  const normalizedIds = normalizePromptIds(ids);
  if (normalizedIds.length === 0) return [];

  if (!userId) {
    const deletedIds: string[] = [];
    normalizedIds.forEach((id) => {
      if (deleteLocalTemplate(id)) deletedIds.push(id);
    });
    return deletedIds;
  }

  ensureCloudPersistence("Cloud prompts");

  try {
    if (normalizedIds.length === 1) {
      const { data, error } = await neon
        .from("saved_prompts")
        .delete()
        .eq("user_id", userId)
        .eq("id", normalizedIds[0])
        .select("id")
        .maybeSingle();

      if (error) throw mapPostgrestError(error, "Failed to delete prompts.");
      return data ? [data.id] : [];
    }

    const { data, error } = await neon
      .from("saved_prompts")
      .delete()
      .eq("user_id", userId)
      .in("id", normalizedIds)
      .select("id");

    if (error) throw mapPostgrestError(error, "Failed to delete prompts.");
    return (data ?? []).map((row) => row.id);
  } catch (error) {
    throw toPersistenceError(error, "Failed to delete prompts.");
  }
}

// ---------------------------------------------------------------------------
// Prompt versions
// ---------------------------------------------------------------------------

export interface PromptVersion {
  id: string;
  name: string;
  prompt: string;
  timestamp: number;
}

export async function loadVersions(userId: string | null): Promise<PromptVersion[]> {
  if (!userId) return [];

  ensureCloudPersistence("Version history");

  try {
    const { data, error } = await neon
      .from("prompt_versions")
      .select("id, name, prompt, created_at")
      .eq("user_id", userId)
      .order("created_at", { ascending: false })
      .limit(50);

    if (error) throw mapPostgrestError(error, "Failed to load version history.");
    if (!data) return [];

    return data.map((row) => ({
      id: row.id,
      name: row.name,
      prompt: row.prompt,
      timestamp: new Date(row.created_at).getTime(),
    }));
  } catch (error) {
    throw toPersistenceError(error, "Failed to load version history.");
  }
}

export async function saveVersion(
  userId: string | null,
  name: string,
  prompt: string,
): Promise<PromptVersion | null> {
  if (!userId) return null;

  ensureCloudPersistence("Version history");

  try {
    const safeName = sanitizePostgresText(name).trim().slice(0, 200) || "Version";
    const safePrompt = sanitizePostgresText(prompt);
    const { data, error } = await neon
      .from("prompt_versions")
      .insert({ user_id: userId, name: safeName, prompt: safePrompt })
      .select("id, name, prompt, created_at")
      .single();

    if (error) throw mapPostgrestError(error, "Failed to save version.");
    if (!data) throw new PersistenceError("unknown", "Version save returned no data.");

    return {
      id: data.id,
      name: data.name,
      prompt: data.prompt,
      timestamp: new Date(data.created_at).getTime(),
    };
  } catch (error) {
    throw toPersistenceError(error, "Failed to save version.");
  }
}

// ---------------------------------------------------------------------------
// Helpers
// ---------------------------------------------------------------------------

function rowToRecord(row: SavedPromptRow, normalizedConfig?: PromptConfig) {
  const cfg = normalizedConfig || hydrateConfigV1ToWorkingState(row.config ?? defaultConfig);
  return {
    metadata: {
      id: row.id,
      name: row.title,
      description: row.description,
      tags: row.tags ?? [],
      schemaVersion: 2,
      revision: row.revision,
      fingerprint: row.fingerprint ?? "",
      createdAt: new Date(row.created_at).getTime(),
      updatedAt: new Date(row.updated_at).getTime(),
      category: row.category,
      isShared: row.is_shared,
      targetModel: row.target_model,
      useCase: row.use_case,
      remixedFrom: row.remixed_from,
      builtPrompt: row.built_prompt,
      enhancedPrompt: row.enhanced_prompt,
    },
    state: {
      promptConfig: cfg,
      externalReferences: deriveExternalReferencesFromConfig(cfg),
    },
  };
}
````

## File: src/pages/Feed.tsx
````typescript
import { Navigate } from "react-router-dom";

const Feed = () => {
  return <Navigate to="/community?tab=following" replace />;
};

export default Feed;
````

## File: src/components/BuilderHeroInput.tsx
````typescript
import { Button } from "@/components/base/buttons/button";
import { Card } from "@/components/base/primitives/card";
import { Textarea } from "@/components/base/textarea";
import type { BuilderSuggestionChip } from "@/lib/builder-inference";
import { ArrowCounterClockwise as RotateCcw, Sparkle as Sparkles, SpinnerGap as Loader2 } from "@phosphor-icons/react";

interface BuilderHeroInputProps {
  value: string;
  onChange: (value: string) => void;
  onClear: () => void;
  phase3Enabled?: boolean;
  suggestionChips?: BuilderSuggestionChip[];
  isInferringSuggestions?: boolean;
  hasInferenceError?: boolean;
  onApplySuggestion?: (chip: BuilderSuggestionChip) => void;
  onResetInferred?: () => void;
  canResetInferred?: boolean;
}

export function BuilderHeroInput({
  value,
  onChange,
  onClear,
  phase3Enabled = false,
  suggestionChips = [],
  isInferringSuggestions = false,
  hasInferenceError = false,
  onApplySuggestion,
  onResetInferred,
  canResetInferred = false,
}: BuilderHeroInputProps) {
  const promptInputId = "builder-phase1-hero-prompt";
  const promptInputMetaId = "builder-phase1-hero-prompt-meta";

  return (
    <Card className="border-border/70 bg-card/80 p-3 sm:p-4">
      <div className="space-y-3">
        <div className="flex items-center justify-between gap-3">
          <label htmlFor={promptInputId} className="text-sm font-medium text-foreground">
            What should the model do?
          </label>
          <div className="flex items-center gap-2">
            <span id={promptInputMetaId} className="text-xs text-muted-foreground">
              {value.length} chars
            </span>
            {value && (
              <Button
                type="button"
                color="tertiary"
                size="sm"
                onClick={onClear}
                aria-label="Clear prompt text"
                className="interactive-chip h-11 gap-1 px-3 text-sm sm:h-9 sm:px-2 sm:text-sm"
              >
                <RotateCcw className="w-3 h-3" />
                Clear
              </Button>
            )}
          </div>
        </div>

        <Textarea
          id={promptInputId}
          value={value}
          onChange={(e) => onChange(e.target.value)}
          placeholder="Describe the task in 1-2 sentences. Example: Draft a concise project update for executives using these notes."
          className="min-h-28 resize-y text-foreground placeholder:text-muted-foreground sm:min-h-32"
          aria-describedby={promptInputMetaId}
        />

        <div className="rounded-md border border-dashed border-primary/40 bg-primary/5 px-3 py-2">
          <div className="flex items-center justify-between gap-2">
            <p className="flex items-center gap-1.5 text-sm font-medium text-primary">
              <Sparkles className="h-3.5 w-3.5" />
              Smart suggestions
            </p>
            {phase3Enabled && canResetInferred && onResetInferred && (
              <Button
                type="button"
                color="tertiary"
                size="sm"
                className="h-11 px-3 text-sm sm:h-9 sm:px-2 sm:text-sm"
                onClick={onResetInferred}
              >
                Reset AI details
              </Button>
            )}
          </div>

          {!phase3Enabled && (
            <p className="mt-1 text-sm text-muted-foreground">
              AI suggestion chips will appear here in Phase 3. For now, continue by adjusting details below.
            </p>
          )}

          {phase3Enabled && (
            <div className="mt-2 space-y-2">
              {isInferringSuggestions && (
                <p className="flex items-center gap-1.5 text-sm text-muted-foreground">
                  <Loader2 className="h-3.5 w-3.5 animate-spin" />
                  Generating suggestions...
                </p>
              )}

              {suggestionChips.length > 0 && (
                <div className="flex flex-wrap gap-2">
                  {suggestionChips.map((chip) => (
                    <Button
                      key={chip.id}
                      type="button"
                      color="secondary"
                      size="sm"
                      className="h-11 px-2 text-sm sm:h-9 sm:text-sm"
                      onClick={() => onApplySuggestion?.(chip)}
                    >
                      {chip.label}
                    </Button>
                  ))}
                </div>
              )}

              {!isInferringSuggestions && suggestionChips.length === 0 && (
                <p className="text-sm text-muted-foreground">
                  Keep typing to get AI-generated detail suggestions.
                </p>
              )}

              {hasInferenceError && (
                <p className="text-sm text-muted-foreground">
                  AI suggestions are temporarily unavailable. Local hints are shown when possible.
                </p>
              )}
            </div>
          )}
        </div>
      </div>
    </Card>
  );
}
````

## File: src/components/BuilderSourcesAdvanced.tsx
````typescript
import { useState } from "react";
import { ContextIntegrations } from "@/components/ContextIntegrations";
import { ContextSourceChips } from "@/components/ContextSourceChips";
import { ProjectNotes } from "@/components/ProjectNotes";
import { Badge } from "@/components/base/badges/badges";
import { Button } from "@/components/base/buttons/button";
import { Card } from "@/components/base/primitives/card";
import { Label } from "@/components/base/label";
import { Switch } from "@/components/base/primitives/switch";
import {
  CaretDown as ChevronDown,
  CaretRight as ChevronRight,
  Database,
  GearSix as Settings2,
  Stack as Layers3,
} from "@phosphor-icons/react";
import type {
  ContextConfig,
  ContextSource,
  DatabaseConnection,
  RagParameters,
} from "@/lib/context-types";

interface BuilderSourcesAdvancedProps {
  contextConfig: ContextConfig;
  isOpen: boolean;
  onOpenChange: (open: boolean) => void;
  onUpdateSources: (sources: ContextSource[]) => void;
  onUpdateDatabaseConnections: (connections: DatabaseConnection[]) => void;
  onUpdateRag: (updates: Partial<RagParameters>) => void;
  onUpdateProjectNotes: (notes: string) => void;
  onToggleDelimiters: (value: boolean) => void;
}

export function BuilderSourcesAdvanced({
  contextConfig,
  isOpen,
  onOpenChange,
  onUpdateSources,
  onUpdateDatabaseConnections,
  onUpdateRag,
  onUpdateProjectNotes,
  onToggleDelimiters,
}: BuilderSourcesAdvancedProps) {
  const sourceCount = contextConfig.sources.length;
  const hasAdvancedConfig =
    contextConfig.databaseConnections.length > 0 || contextConfig.rag.enabled || !contextConfig.useDelimiters;

  const [advancedVisibility, setAdvancedVisibility] = useState<"auto" | "shown" | "hidden">("auto");
  const showAdvanced = advancedVisibility === "auto" ? hasAdvancedConfig : advancedVisibility === "shown";

  const handleAddSource = (source: ContextSource) => {
    onUpdateSources([...contextConfig.sources, source]);
  };

  const handleRemoveSource = (id: string) => {
    onUpdateSources(contextConfig.sources.filter((source) => source.id !== id));
  };

  return (
    <Card id="builder-zone-3" className="border-border/70 bg-card/80 p-3 sm:p-4">
      <div className="space-y-3">
        <button
          type="button"
          className="flex w-full items-center justify-between gap-2 text-left"
          onClick={() => onOpenChange(!isOpen)}
          aria-expanded={isOpen}
          aria-controls="builder-zone-3-content"
        >
          <div>
            <p className="flex items-center gap-1.5 text-sm font-medium text-foreground">
              <Layers3 className="h-4 w-4 text-muted-foreground" />
              Add sources or advanced settings
            </p>
            <p className="text-sm text-muted-foreground">Optional references and integrations.</p>
          </div>
          <div className="flex items-center gap-2">
            {sourceCount > 0 && (
              <Badge type="modern" className="text-xs">
                {sourceCount} source{sourceCount === 1 ? "" : "s"}
              </Badge>
            )}
            {isOpen ? <ChevronDown className="h-4 w-4 text-muted-foreground" /> : <ChevronRight className="h-4 w-4 text-muted-foreground" />}
          </div>
        </button>

        {isOpen && (
          <div id="builder-zone-3-content" className="space-y-4 border-t border-border pt-3">
            <ContextSourceChips
              sources={contextConfig.sources}
              onAdd={handleAddSource}
              onRemove={handleRemoveSource}
            />

            <ProjectNotes value={contextConfig.projectNotes} onChange={onUpdateProjectNotes} />

            <div className="flex items-center justify-between border-t border-border pt-3">
              <div>
                <p className="text-sm font-medium text-foreground">Show advanced integrations</p>
                <p className="text-sm text-muted-foreground">Database + RAG and delimiter controls.</p>
              </div>
              <Button
                type="button"
                size="sm"
                color={showAdvanced ? "primary" : "secondary"}
                className="h-11 gap-1.5 text-sm sm:h-9 sm:text-sm"
                onClick={() =>
                  setAdvancedVisibility((previous) => {
                    const previousShown = previous === "auto" ? hasAdvancedConfig : previous === "shown";
                    return previousShown ? "hidden" : "shown";
                  })
                }
              >
                <Settings2 className="h-3.5 w-3.5" />
                {showAdvanced ? "Hide advanced" : "Show advanced"}
              </Button>
            </div>

            {showAdvanced && (
              <div className="space-y-4 rounded-lg border border-border/80 bg-background/60 p-3">
                <div className="flex items-center justify-between">
                  <Label className="flex items-center gap-1.5 text-sm font-medium text-foreground sm:text-base">
                    <Database className="h-3.5 w-3.5 text-muted-foreground" />
                    Integrations
                  </Label>
                </div>

                <ContextIntegrations
                  databaseConnections={contextConfig.databaseConnections}
                  rag={contextConfig.rag}
                  onUpdateDatabaseConnections={onUpdateDatabaseConnections}
                  onUpdateRag={onUpdateRag}
                />

                <div className="flex items-center justify-between border-t border-border pt-3">
                  <div>
                    <Label className="text-sm font-medium text-foreground sm:text-base">Use delimiters</Label>
                    <p className="text-sm text-muted-foreground">Wrap context blocks in tags for stricter parsing.</p>
                  </div>
                  <Switch
                    checked={contextConfig.useDelimiters}
                    onCheckedChange={onToggleDelimiters}
                  />
                </div>
              </div>
            )}
          </div>
        )}
      </div>
    </Card>
  );
}
````

## File: src/components/ContextSourceChips.tsx
````typescript
import { useState, useCallback } from "react";
import { Button } from "@/components/base/buttons/button";
import { Input } from "@/components/base/input/input";
import { Textarea } from "@/components/base/textarea";
import { Badge } from "@/components/base/badges/badges";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/components/base/dialog";
import type { ContextSource } from "@/lib/context-types";
import { summarizeSource } from "@/lib/context-types";
import { extractUrl } from "@/lib/ai-client";
import { normalizeHttpUrl } from "@/lib/url-utils";
import { toast } from "@/hooks/use-toast";
import {
  FileText,
  Globe,
  Link,
  Plus,
  SpinnerGap as Loader2,
  TextT as Type,
  UploadSimple as Upload,
  X,
} from "@phosphor-icons/react";

interface ContextSourceChipsProps {
  sources: ContextSource[];
  onAdd: (source: ContextSource) => void;
  onRemove: (id: string) => void;
}

type AddMode = "text" | "url" | null;

const ALLOWED_EXTENSIONS = [".txt", ".md", ".csv", ".json", ".xml", ".log", ".yaml", ".yml"];
const MAX_FILE_SIZE = 500 * 1024; // 500KB

export function ContextSourceChips({ sources, onAdd, onRemove }: ContextSourceChipsProps) {
  const [mode, setMode] = useState<AddMode>(null);
  const [title, setTitle] = useState("");
  const [content, setContent] = useState("");
  const [dialogOpen, setDialogOpen] = useState(false);
  const [isDragOver, setIsDragOver] = useState(false);
  const [isFetching, setIsFetching] = useState(false);
  const [urlInput, setUrlInput] = useState("");

  const handleAdd = () => {
    if (!content.trim()) return;
    const isUrl = mode === "url";
    const trimmedUrl = urlInput.trim();
    const normalizedUrl = isUrl ? normalizeHttpUrl(trimmedUrl) : null;
    if (isUrl && !normalizedUrl) {
      toast({
        title: "Invalid URL",
        description: "Enter a valid http(s) URL before saving this source.",
        variant: "destructive",
      });
      return;
    }
    const resolvedUrl = normalizedUrl ?? "";
    const source: ContextSource = {
      id: Date.now().toString(),
      type: isUrl ? "url" : "text",
      title:
        title.trim() ||
        (isUrl
          ? (() => {
              try {
                return new URL(resolvedUrl).hostname;
              } catch {
                return `Source ${sources.length + 1}`;
              }
            })()
          : `Snippet ${sources.length + 1}`),
      rawContent: content.trim(),
      summary: summarizeSource(content.trim()),
      addedAt: Date.now(),
      reference: isUrl
        ? {
            kind: "url",
            refId: `url:${resolvedUrl}`,
            locator: resolvedUrl,
            permissionScope: "public",
          }
        : undefined,
      validation: isUrl
        ? {
            status: "unknown",
            checkedAt: Date.now(),
          }
        : undefined,
    };
    onAdd(source);
    setTitle("");
    setContent("");
    setUrlInput("");
    setMode(null);
    setDialogOpen(false);
  };

  // --- Drag & Drop ---
  const handleDragOver = useCallback((e: React.DragEvent) => {
    e.preventDefault();
    e.stopPropagation();
    setIsDragOver(true);
  }, []);

  const handleDragLeave = useCallback((e: React.DragEvent) => {
    e.preventDefault();
    e.stopPropagation();
    setIsDragOver(false);
  }, []);

  const handleDrop = useCallback(
    (e: React.DragEvent) => {
      e.preventDefault();
      e.stopPropagation();
      setIsDragOver(false);

      const files = Array.from(e.dataTransfer.files);
      if (files.length === 0) return;

      files.forEach((file) => {
        const ext = "." + file.name.split(".").pop()?.toLowerCase();
        if (!ALLOWED_EXTENSIONS.includes(ext)) {
          toast({
            title: "Unsupported file type",
            description: `"${file.name}" is not supported. Use ${ALLOWED_EXTENSIONS.join(", ")}.`,
            variant: "destructive",
          });
          return;
        }

        if (file.size > MAX_FILE_SIZE) {
          toast({
            title: "File too large",
            description: `"${file.name}" exceeds the 500 KB limit.`,
            variant: "destructive",
          });
          return;
        }

        const reader = new FileReader();
        reader.onload = () => {
          const text = reader.result as string;
          const source: ContextSource = {
            id: `${Date.now()}-${file.name}`,
            type: "file",
            title: file.name,
            rawContent: text,
            summary: summarizeSource(text),
            addedAt: Date.now(),
            reference: {
              kind: "file",
              refId: `file:${file.name}:${file.lastModified}`,
              locator: file.name,
            },
            validation: {
              status: "unknown",
              checkedAt: Date.now(),
            },
          };
          onAdd(source);
          toast({ title: "File added", description: `"${file.name}" added as context source.` });
        };
        reader.onerror = () => {
          toast({
            title: "Read error",
            description: `Could not read "${file.name}".`,
            variant: "destructive",
          });
        };
        reader.readAsText(file);
      });
    },
    [onAdd]
  );

  // --- URL Fetch ---
  const handleFetchUrl = async () => {
    if (!urlInput.trim()) return;
    setIsFetching(true);
    try {
      const result = await extractUrl(urlInput.trim());
      setTitle(result.title);
      setContent(result.content);
      toast({ title: "Content extracted", description: "Key points extracted from the URL." });
    } catch (err) {
      toast({
        title: "Extraction failed",
        description: err instanceof Error ? err.message : "Could not fetch or extract content. You can still paste content manually.",
        variant: "destructive",
      });
    } finally {
      setIsFetching(false);
    }
  };

  const chipIcon = (type: ContextSource["type"]) => {
    if (type === "url") return <Link className="w-3 h-3" />;
    if (type === "file") return <FileText className="w-3 h-3" />;
    return <Type className="w-3 h-3" />;
  };

  return (
    <div className="space-y-2">
      {/* Drop zone — compact */}
      <div
        onDragOver={handleDragOver}
        onDragEnter={handleDragOver}
        onDragLeave={handleDragLeave}
        onDrop={handleDrop}
        className={`rounded-lg border-2 border-dashed transition-colors p-2 sm:p-3 text-center ${
          isDragOver
            ? "border-primary bg-primary/5"
            : "border-muted-foreground/20 hover:border-muted-foreground/40"
        }`}
      >
        <div className="flex items-center justify-center gap-1.5 text-sm text-muted-foreground">
          <Upload className="w-3 h-3 sm:w-3.5 sm:h-3.5" />
          <span>Drop files ({ALLOWED_EXTENSIONS.slice(0, 4).join(", ")}…)</span>
        </div>
      </div>

      <div className="flex items-center justify-between">
        <label className="text-sm font-medium text-foreground sm:text-base">Sources</label>
        <Dialog open={dialogOpen} onOpenChange={setDialogOpen}>
          <DialogTrigger asChild>
            <Button color="secondary" size="sm" className="h-11 gap-1 text-sm sm:h-9 sm:text-sm">
              <Plus className="w-3 h-3" />
              Add
            </Button>
          </DialogTrigger>
          <DialogContent className="sm:max-w-md">
            <DialogHeader>
              <DialogTitle>Add source material</DialogTitle>
              <DialogDescription>
                Paste text, fetch a public URL, or upload a file to provide context for prompt enhancement.
              </DialogDescription>
            </DialogHeader>

            {!mode ? (
              <div className="grid grid-cols-2 gap-3 py-4">
                <Button
                  color="secondary"
                  className="h-20 flex-col gap-2"
                  onClick={() => setMode("text")}
                >
                  <Type className="w-5 h-5" />
                  <span className="text-sm sm:text-base">Paste text</span>
                </Button>
                <Button
                  color="secondary"
                  className="h-20 flex-col gap-2"
                  onClick={() => setMode("url")}
                >
                  <Globe className="w-5 h-5" />
                  <span className="text-sm sm:text-base">Fetch from URL</span>
                </Button>
              </div>
            ) : (
              <div className="space-y-3 py-2">
                {mode === "url" && (
                  <div className="flex gap-2">
                    <Input
                      placeholder="https://example.com"
                      value={urlInput}
                      onChange={(e) => setUrlInput(e.target.value)}
                      className="bg-background flex-1"
                    />
                    <Button
                      size="sm"
                      color="secondary"
                      onClick={handleFetchUrl}
                      disabled={!urlInput.trim() || isFetching}
                      className="shrink-0 gap-1.5"
                    >
                      {isFetching ? (
                        <Loader2 className="w-3.5 h-3.5 animate-spin" />
                      ) : (
                        <Globe className="w-3.5 h-3.5" />
                      )}
                      {isFetching ? "Fetching…" : "Fetch"}
                    </Button>
                  </div>
                )}
                <Input
                  placeholder={mode === "url" ? "Page title (auto-filled on fetch)" : "Source title (optional)"}
                  value={title}
                  onChange={(e) => setTitle(e.target.value)}
                  className="bg-background"
                />
                <Textarea
                  placeholder={
                    mode === "url"
                      ? "Extracted content will appear here, or paste manually…"
                      : "Paste your text, notes, or data here…"
                  }
                  value={content}
                  onChange={(e) => setContent(e.target.value)}
                  className="min-h-24 bg-background sm:min-h-28"
                />
                <p className="text-sm text-muted-foreground">
                  Long content will be auto-summarized into compact bullet points.
                </p>
                <div className="flex gap-2 justify-end">
                  <Button
                    color="tertiary"
                    size="sm"
                    onClick={() => {
                      setMode(null);
                      setTitle("");
                      setContent("");
                      setUrlInput("");
                    }}
                  >
                    Back
                  </Button>
                  <Button size="sm" onClick={handleAdd} disabled={!content.trim()}>
                    Add source
                  </Button>
                </div>
              </div>
            )}
          </DialogContent>
        </Dialog>
      </div>

      {sources.length > 0 && (
        <div className="flex flex-wrap gap-1.5 sm:gap-2">
          {sources.map((source) => (
            <Badge
              key={source.id}
              type="modern"
              className="gap-1 sm:gap-1.5 pr-1 max-w-[180px] sm:max-w-[200px] group cursor-default"
              title={`${source.title}\n${source.summary}`}
            >
              {chipIcon(source.type)}
              <span className="type-wrap-safe text-xs">{source.title}</span>
              <button
                onClick={() => onRemove(source.id)}
                className="ml-0.5 rounded-full p-0.5 hover:bg-destructive/20 transition-colors"
                aria-label={`Remove ${source.title}`}
              >
                <X className="w-3 h-3" />
              </button>
            </Badge>
          ))}
        </div>
      )}

      {sources.length === 0 && (
        <p className="text-sm text-muted-foreground">
          No sources yet. Add text, fetch URLs, or drop files.
        </p>
      )}
    </div>
  );
}
````

## File: src/components/NotificationPanel.tsx
````typescript
import { formatDistanceToNow } from "date-fns";
import { Link } from "react-router-dom";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/base/primitives/avatar";
import { Button } from "@/components/base/buttons/button";
import { ScrollArea } from "@/components/base/primitives/scroll-area";
import { Skeleton } from "@/components/base/primitives/skeleton";
import { getInitials } from "@/lib/community-utils";
import type { Notification } from "@/lib/notifications";
import { cn } from "@/lib/utils";
import {
  ArrowUp,
  Bell,
  ChatCircle as MessageCircle,
  CheckCircle as CheckCircle2,
  GitBranch,
} from "@phosphor-icons/react";

interface NotificationPanelProps {
  notifications: Notification[];
  unreadCount: number;
  loading: boolean;
  onMarkAsRead: (notificationId: string) => Promise<void> | void;
  onMarkAllAsRead: () => Promise<void> | void;
  onRefresh?: () => Promise<void> | void;
  onNavigate?: () => void;
  className?: string;
}


function getTypeIcon(type: Notification["type"]) {
  if (type === "upvote") return <ArrowUp className="h-3.5 w-3.5 text-primary" />;
  if (type === "verified") return <CheckCircle2 className="h-3.5 w-3.5 text-primary" />;
  if (type === "remix") return <GitBranch className="h-3.5 w-3.5 text-primary" />;
  return <MessageCircle className="h-3.5 w-3.5 text-primary" />;
}

function getTypeLabel(type: Notification["type"]): string {
  if (type === "upvote") return "upvoted your post";
  if (type === "verified") return "verified your post";
  if (type === "remix") return "remixed your post";
  return "commented on your post";
}

export function NotificationPanel({
  notifications,
  unreadCount,
  loading,
  onMarkAsRead,
  onMarkAllAsRead,
  onRefresh,
  onNavigate,
  className,
}: NotificationPanelProps) {
  return (
    <div className={cn("w-[min(96vw,24rem)] rounded-md border border-border/80 bg-popover", className)}>
      <div className="flex items-center justify-between gap-2 border-b border-border/70 px-3 py-2">
        <div className="type-post-title flex items-center gap-2 text-foreground">
          <Bell className="h-4 w-4" />
          Notifications
        </div>
        <div className="flex items-center gap-1">
          {onRefresh && (
            <Button
              type="button"
              size="sm"
              color="tertiary"
              className="type-button-label h-11 px-3 sm:h-9 sm:px-2"
              onClick={onRefresh}
            >
              Refresh
            </Button>
          )}
          <Button
            type="button"
            size="sm"
            color="tertiary"
            className="type-button-label h-11 px-3 sm:h-9 sm:px-2"
            onClick={() => void onMarkAllAsRead()}
            disabled={unreadCount === 0 || loading}
          >
            Mark all as read
          </Button>
        </div>
      </div>

      {loading && (
        <div className="space-y-2 p-3">
          <Skeleton className="h-14 w-full" />
          <Skeleton className="h-14 w-full" />
          <Skeleton className="h-14 w-full" />
        </div>
      )}

      {!loading && notifications.length === 0 && (
        <div className="px-3 py-8 text-center">
          <span className="mx-auto inline-flex h-9 w-9 items-center justify-center rounded-full border border-border/60 bg-background/80 text-muted-foreground">
            <Bell className="h-4 w-4" />
          </span>
          <p className="type-post-title mt-2 text-foreground">No notifications yet</p>
          <p className="type-help mt-1 text-muted-foreground">
            You'll be notified when others interact with your prompts.
          </p>
        </div>
      )}

      {!loading && notifications.length > 0 && (
        <ScrollArea className="max-h-[65vh] sm:max-h-[22rem]">
          <div className="space-y-1 p-1.5">
            {notifications.map((notification) => {
              const createdAgo = formatDistanceToNow(new Date(notification.createdAt), { addSuffix: true });
              const itemContent = (
                <div className="flex items-start gap-2.5">
                  <div className="relative mt-0.5">
                    <Avatar className="h-8 w-8 border border-border/60">
                      <AvatarImage
                        src={notification.actorAvatarUrl ?? undefined}
                        alt={notification.actorDisplayName}
                      />
                      <AvatarFallback className="type-reply-label">
                        {getInitials(notification.actorDisplayName)}
                      </AvatarFallback>
                    </Avatar>
                    <span className="absolute -bottom-1 -right-1 rounded-full border border-background bg-background p-0.5">
                      {getTypeIcon(notification.type)}
                    </span>
                  </div>
                  <div className="min-w-0 flex-1">
                    <p className="type-post-body text-foreground">
                      <span className="type-post-title">{notification.actorDisplayName}</span>{" "}
                      {getTypeLabel(notification.type)}
                    </p>
                    <p className="type-post-body type-wrap-safe line-clamp-2 text-muted-foreground">{notification.postTitle}</p>
                    <p className="type-timestamp mt-1 text-muted-foreground">{createdAgo}</p>
                  </div>
                </div>
              );

              return (
                <div
                  key={notification.id}
                  className={cn(
                    "rounded-md border px-2.5 py-2.5 text-left transition-colors",
                    notification.readAt
                      ? "border-transparent bg-transparent hover:bg-accent/40"
                      : "border-primary/20 bg-primary/10",
                  )}
                >
                  {notification.postId ? (
                    <Link
                      to={`/community/${notification.postId}`}
                      className="block min-h-11 rounded-sm focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2"
                      onClick={() => {
                        void onMarkAsRead(notification.id);
                        onNavigate?.();
                      }}
                    >
                      {itemContent}
                    </Link>
                  ) : (
                    <button
                      type="button"
                      className="block min-h-11 w-full rounded-sm text-left focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2"
                      onClick={() => {
                        void onMarkAsRead(notification.id);
                      }}
                    >
                      {itemContent}
                    </button>
                  )}
                </div>
              );
            })}
          </div>
        </ScrollArea>
      )}
    </div>
  );
}
````

## File: src/pages/Presets.tsx
````typescript
import { useMemo, useState } from "react";
import { createSearchParams, useNavigate } from "react-router-dom";
import { PageHero, PageShell } from "@/components/PageShell";
import { Badge } from "@/components/base/badges/badges";
import { Button } from "@/components/base/buttons/button";
import { Card } from "@/components/base/primitives/card";
import { Input } from "@/components/base/input/input";
import {
  templates,
  categoryLabels,
  promptCategorySkins,
  type PromptTemplate,
  type PromptCategory,
} from "@/lib/templates";
import { cn } from "@/lib/utils";
import { MagnifyingGlass as Search } from "@phosphor-icons/react";

const categoryIcons: Record<string, string> = {
  general: "✦",
  frontend: "🖥",
  backend: "⚙",
  fullstack: "◇",
  devops: "☁",
  data: "📊",
  "ml-ai": "🧠",
  security: "🛡",
  testing: "🧪",
  api: "🔌",
  automation: "🤖",
  docs: "📝",
};

function PresetCard({ template }: { template: PromptTemplate }) {
  const navigate = useNavigate();
  const skin = promptCategorySkins[template.category] ?? promptCategorySkins.general;
  const presetSearch = createSearchParams({ preset: template.id }).toString();
  const fields = [
    template.role && `Role: ${template.role}`,
    template.tone && `Tone: ${template.tone}`,
    template.complexity && `Complexity: ${template.complexity}`,
    template.format.length > 0 && `Format: ${template.format.join(", ")}`,
  ].filter(Boolean) as string[];

  return (
    <Card className={cn("interactive-card pf-card group overflow-hidden border", skin.card)}>
      <div className="p-3 sm:p-4 space-y-2">
        <div className="flex items-start justify-between gap-2">
          <div className="flex items-center gap-2 flex-wrap min-w-0">
            <span className={cn("inline-flex h-8 w-8 items-center justify-center rounded-full text-sm", skin.iconWrap)}>
              {categoryIcons[template.category] ?? categoryIcons.general}
            </span>
            <h3 className="font-semibold text-sm text-foreground">{template.name}</h3>
            <Badge type="modern" className={cn("border border-border bg-background text-foreground text-xs capitalize", skin.badge)}>
              {categoryLabels[template.category]}
            </Badge>
          </div>
        </div>

        <p className="text-xs text-muted-foreground line-clamp-2">{template.description}</p>

        <p className="text-xs text-muted-foreground/90 line-clamp-2">
          <span className="font-medium text-foreground/80">Starter:</span> {template.starterPrompt}
        </p>

        <div className="flex flex-wrap gap-1">
          {fields.map((f) => (
            <Badge key={f} type="modern" className="text-xs">{f}</Badge>
          ))}
        </div>

        <div className="pt-1">
          <Button
            type="button"
            color="secondary"
            size="sm"
            className={cn("h-11 gap-1.5 text-sm sm:h-9 sm:text-sm", skin.action)}
            onClick={() => navigate({ pathname: "/", search: `?${presetSearch}` })}
          >
            Use preset
          </Button>
        </div>
      </div>
    </Card>
  );
}

const Presets = () => {
  const [query, setQuery] = useState("");
  const [activeCategory, setActiveCategory] = useState<string>("all");

  const categories = useMemo(() => {
    const used = new Set(templates.map((t) => t.category));
    return ["all", ...Array.from(used)] as string[];
  }, []);

  const filtered = useMemo(() => {
    let result = templates;
    if (activeCategory !== "all") {
      result = result.filter((t) => t.category === activeCategory);
    }
    if (query.trim()) {
      const q = query.toLowerCase();
      result = result.filter(
        (t) =>
          t.name.toLowerCase().includes(q) ||
          t.description.toLowerCase().includes(q) ||
          t.category.toLowerCase().includes(q) ||
          t.starterPrompt.toLowerCase().includes(q),
      );
    }
    return result;
  }, [activeCategory, query]);

  return (
    <PageShell>
      <PageHero
        title="Presets"
        subtitle="Starter templates that auto-populate the builder. Pick one and start enhancing."
        className="pf-gilded-frame pf-hero-surface"
      />

      <div className="mx-auto max-w-4xl space-y-4">
        <div className="relative">
          <Search className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" />
          <Input
            value={query}
            onChange={(e) => setQuery(e.target.value)}
            placeholder="Search presets..."
            aria-label="Search presets"
            className="h-11 pl-9 sm:h-10"
          />
        </div>

        <div className="flex flex-wrap gap-1.5" role="group" aria-label="Filter presets by category">
          {categories.map((cat) => (
            <Button
              key={cat}
              color={activeCategory === cat ? "primary" : "secondary"}
              size="sm"
              onClick={() => setActiveCategory(cat)}
              aria-pressed={activeCategory === cat}
              className="interactive-chip h-11 gap-1.5 text-sm capitalize sm:h-9 sm:text-sm"
            >
              {cat !== "all" && (
                <span className="text-sm">{categoryIcons[cat as PromptCategory] ?? ""}</span>
              )}
              {cat === "all" ? "All" : categoryLabels[cat as PromptCategory] ?? cat}
            </Button>
          ))}
        </div>

        {filtered.length === 0 ? (
          <Card className="pf-card border-dashed p-6 text-center">
            <p className="text-sm text-muted-foreground">No presets match.</p>
          </Card>
        ) : (
          <div className="grid grid-cols-1 gap-3 sm:grid-cols-2">
            {filtered.map((template) => (
              <PresetCard key={template.id} template={template} />
            ))}
          </div>
        )}
      </div>
    </PageShell>
  );
};

export default Presets;
````

## File: src/components/PageShell.tsx
````typescript
import type { ReactNode } from "react";
import { Link } from "react-router-dom";
import { BottomNav } from "@/components/BottomNav";
import { Header } from "@/components/Header";
import { useTheme } from "@/hooks/useTheme";
import { brandCopy } from "@/lib/brand-copy";
import { cn } from "@/lib/utils";

interface PageShellProps {
  children: ReactNode;
  mainClassName?: string;
}

export function PageShell({ children, mainClassName }: PageShellProps) {
  const { isDark, toggleTheme } = useTheme();

  return (
    <div
      className="pf-shell-backdrop flex min-h-screen flex-col bg-background pb-[calc(4.375rem+env(safe-area-inset-bottom))] sm:pb-0"
      data-testid="page-shell"
    >
      <Header isDark={isDark} onToggleTheme={toggleTheme} />
      <main
        className={cn("pf-shell-main container mx-auto flex-1 px-4 py-4 sm:py-6", mainClassName)}
        data-testid="page-shell-main"
      >
        {children}
      </main>
      <footer className="pf-shell-footer border-t border-border/70 bg-card/55">
        <div className="container mx-auto flex flex-col items-center justify-between gap-2 px-4 py-2 sm:flex-row sm:gap-4">
          <Link
            to="/"
            className="interactive-chip pf-nav-button inline-flex items-center rounded-md px-1 py-0.5"
            aria-label={brandCopy.appName}
          >
            <img
              src="/pf/promptforge-wordmark.png"
              alt=""
              decoding="async"
              className="h-7 w-auto object-contain"
              aria-hidden="true"
            />
          </Link>

          <div className="flex items-center justify-center gap-4 text-xs text-muted-foreground">
            <Link to="/privacy" className="pf-shell-footer-link hover:text-foreground">Privacy</Link>
            <Link to="/terms" className="pf-shell-footer-link hover:text-foreground">Terms</Link>
            <Link to="/contact" className="pf-shell-footer-link hover:text-foreground">Contact</Link>
          </div>
        </div>
      </footer>
      <BottomNav />
    </div>
  );
}

interface PageHeroProps {
  title: string;
  subtitle?: string;
  eyebrow?: string;
  className?: string;
}

export function PageHero({ title, subtitle, eyebrow, className }: PageHeroProps) {
  return (
    <div
      className={cn(
        "pf-gilded-frame pf-hero-surface mb-4 px-4 py-5 text-center sm:mb-6 sm:px-6 sm:py-7",
        className
      )}
    >
      <div className="mb-2 flex items-center justify-center">
        <img
          src="/pf/promptforge-wordmark.png"
          alt=""
          decoding="async"
          className="h-8 w-auto object-contain sm:h-9"
          aria-hidden="true"
        />
      </div>
      {eyebrow && <p className="ui-section-label text-primary">{eyebrow}</p>}
      <h1 className="page-hero-title type-screen-title pf-text-display text-2xl font-bold text-foreground sm:text-3xl">{title}</h1>
      {subtitle && (
        <p className="page-hero-subtitle type-screen-subtitle mx-auto mt-1 max-w-2xl text-sm text-muted-foreground sm:text-base">
          {subtitle}
        </p>
      )}
    </div>
  );
}
````

## File: src/pages/Profile.tsx
````typescript
import { useCallback, useEffect, useMemo, useRef, useState } from "react";
import { useNavigate, useParams } from "react-router-dom";
import { CommunityFeed } from "@/components/community/CommunityFeed";
import { ProfileHero, getBestRarityFromPosts } from "@/components/community/ProfileHero";
import { PageShell } from "@/components/PageShell";
import { Button } from "@/components/base/buttons/button";
import { StateCard } from "@/components/base/primitives/state-card";
import { Skeleton } from "@/components/base/primitives/skeleton";
import { useAuth } from "@/hooks/useAuth";
import { useToast } from "@/hooks/use-toast";
import {
  type CommunityPost,
  type CommunityProfile,
  type FollowStats,
  type ProfileActivityStats,
  type VoteState,
  type VoteType,
  computeNextPromptRatingSummary,
  followCommunityUser,
  isFollowingCommunityUser,
  loadFollowStats,
  loadMyRatings,
  loadMyVotes,
  loadPostsByAuthor,
  loadPostsByIds,
  loadProfileActivityStats,
  loadProfilesByIds,
  setPromptRating,
  toggleVote,
  unfollowCommunityUser,
} from "@/lib/community";
import { getCommunityPostRarity } from "@/lib/community-rarity";
import { toParentTitleMap, toProfileMap } from "@/lib/community-utils";
import { toCommunityErrorState, type CommunityErrorState } from "@/lib/community-errors";
import { copyTextToClipboard } from "@/lib/clipboard";

const PROFILE_PAGE_SIZE = 20;

const EMPTY_ACTIVITY_STATS: ProfileActivityStats = {
  totalPosts: 0,
  totalUpvotes: 0,
  totalVerified: 0,
  averageRating: 0,
};

const Profile = () => {
  const { userId: routeUserId } = useParams<{ userId: string }>();
  const navigate = useNavigate();
  const profileUserId = routeUserId?.trim() || "";
  const requestToken = useRef(0);
  const voteInFlightByPost = useRef<Set<string>>(new Set());
  const ratingInFlightByPost = useRef<Set<string>>(new Set());
  const { toast } = useToast();
  const { user } = useAuth();
  const [profile, setProfile] = useState<CommunityProfile | null>(null);
  const [profileStats, setProfileStats] = useState<FollowStats>({ followersCount: 0, followingCount: 0 });
  const [activityStats, setActivityStats] = useState<ProfileActivityStats>(EMPTY_ACTIVITY_STATS);
  const [posts, setPosts] = useState<CommunityPost[]>([]);
  const [authorById, setAuthorById] = useState<Record<string, CommunityProfile>>({});
  const [parentTitleById, setParentTitleById] = useState<Record<string, string>>({});
  const [voteStateByPost, setVoteStateByPost] = useState<Record<string, VoteState>>({});
  const [ratingByPost, setRatingByPost] = useState<Record<string, number | null>>({});
  const [isFollowing, setIsFollowing] = useState(false);
  const [followPending, setFollowPending] = useState(false);
  const [loading, setLoading] = useState(true);
  const [isLoadingMore, setIsLoadingMore] = useState(false);
  const [hasMore, setHasMore] = useState(false);
  const [page, setPage] = useState(0);
  const [errorState, setErrorState] = useState<CommunityErrorState | null>(null);
  const [retryNonce, setRetryNonce] = useState(0);

  const isOwnProfile = Boolean(user?.id && profileUserId && user.id === profileUserId);

  const bestRarity = useMemo(() => getBestRarityFromPosts(posts), [posts]);
  const memberSinceAt = useMemo(() => {
    if (profile?.createdAt) return profile.createdAt;
    if (posts.length === 0) return null;
    return posts.reduce((earliest, post) => Math.min(earliest, post.createdAt), posts[0].createdAt);
  }, [posts, profile?.createdAt]);
  const topPromptPostId = useMemo(() => {
    const epicOrLegendaryPosts = posts
      .filter((post) => {
        const rarity = getCommunityPostRarity(post);
        return rarity === "epic" || rarity === "legendary";
      })
      .sort((a, b) => {
        const aLegendary = getCommunityPostRarity(a) === "legendary" ? 1 : 0;
        const bLegendary = getCommunityPostRarity(b) === "legendary" ? 1 : 0;
        if (aLegendary !== bLegendary) return bLegendary - aLegendary;
        if (a.upvoteCount !== b.upvoteCount) return b.upvoteCount - a.upvoteCount;
        return b.createdAt - a.createdAt;
      });
    return epicOrLegendaryPosts[0]?.id ?? null;
  }, [posts]);
  const orderedPosts = useMemo(() => {
    if (!topPromptPostId) return posts;
    const topPrompt = posts.find((post) => post.id === topPromptPostId);
    if (!topPrompt) return posts;
    return [topPrompt, ...posts.filter((post) => post.id !== topPromptPostId)];
  }, [posts, topPromptPostId]);

  const hydratePostContext = useCallback(
    async (
      targetPosts: CommunityPost[],
      token: number,
      mode: "replace" | "merge" = "replace",
    ) => {
      const parentIds = Array.from(
        new Set(targetPosts.map((post) => post.remixedFrom).filter((value): value is string => !!value)),
      );

      const [parentPostsResult, voteStatesResult, ratingsResult] = await Promise.allSettled([
        loadPostsByIds(parentIds),
        loadMyVotes(targetPosts.map((post) => post.id)),
        loadMyRatings(targetPosts.map((post) => post.id)),
      ]);

      if (token !== requestToken.current) return;

      const parentPosts = parentPostsResult.status === "fulfilled" ? parentPostsResult.value : [];
      const voteStates = voteStatesResult.status === "fulfilled" ? voteStatesResult.value : {};
      const ratings = ratingsResult.status === "fulfilled" ? ratingsResult.value : {};
      const nextParentTitles = toParentTitleMap(parentPosts);

      if (mode === "merge") {
        setParentTitleById((previous) => ({ ...previous, ...nextParentTitles }));
        setVoteStateByPost((previous) => ({ ...previous, ...voteStates }));
        setRatingByPost((previous) => ({ ...previous, ...ratings }));
        return;
      }

      setParentTitleById(nextParentTitles);
      setVoteStateByPost(voteStates);
      setRatingByPost(ratings);
    },
    [],
  );

  useEffect(() => {
    const token = ++requestToken.current;

    if (!profileUserId) {
      setProfile(null);
      setProfileStats({ followersCount: 0, followingCount: 0 });
      setActivityStats(EMPTY_ACTIVITY_STATS);
      setPosts([]);
      setAuthorById({});
      setParentTitleById({});
      setVoteStateByPost({});
      setRatingByPost({});
      setHasMore(false);
      setPage(0);
      setIsFollowing(false);
      setFollowPending(false);
      setIsLoadingMore(false);
      setLoading(false);
      setErrorState({
        kind: "not_found",
        message: "This profile link is invalid.",
      });
      return;
    }

    setProfile(null);
    setProfileStats({ followersCount: 0, followingCount: 0 });
    setActivityStats(EMPTY_ACTIVITY_STATS);
    setPosts([]);
    setAuthorById({});
    setParentTitleById({});
    setVoteStateByPost({});
    setRatingByPost({});
    setHasMore(false);
    setPage(0);
    setIsFollowing(false);
    setFollowPending(false);
    setLoading(true);
    setIsLoadingMore(false);
    setErrorState(null);

    void (async () => {
      try {
        const [profiles, stats, activity, firstPage, following] = await Promise.all([
          loadProfilesByIds([profileUserId]),
          loadFollowStats(profileUserId),
          loadProfileActivityStats(profileUserId),
          loadPostsByAuthor(profileUserId, { limit: PROFILE_PAGE_SIZE, page: 0 }),
          user?.id && user.id !== profileUserId
            ? isFollowingCommunityUser(profileUserId)
            : Promise.resolve(false),
        ]);

        if (token !== requestToken.current) return;

        const loadedProfile = profiles[0] ?? null;
        if (!loadedProfile) {
          setProfile(null);
          setProfileStats({ followersCount: 0, followingCount: 0 });
          setActivityStats(EMPTY_ACTIVITY_STATS);
          setPosts([]);
          setAuthorById({});
          setParentTitleById({});
          setVoteStateByPost({});
          setRatingByPost({});
          setHasMore(false);
          setPage(0);
          setIsFollowing(false);
          setFollowPending(false);
          setErrorState({
            kind: "not_found",
            message: "This profile is unavailable.",
          });
          return;
        }

        setProfile(loadedProfile);
        setProfileStats(stats);
        setActivityStats(activity);
        setPosts(firstPage);
        setAuthorById(toProfileMap([loadedProfile]));
        setPage(0);
        setHasMore(firstPage.length === PROFILE_PAGE_SIZE);
        setIsFollowing(following);
        await hydratePostContext(firstPage, token);
      } catch (error) {
        if (token !== requestToken.current) return;
        setProfile(null);
        setProfileStats({ followersCount: 0, followingCount: 0 });
        setActivityStats(EMPTY_ACTIVITY_STATS);
        setPosts([]);
        setAuthorById({});
        setParentTitleById({});
        setVoteStateByPost({});
        setRatingByPost({});
        setHasMore(false);
        setPage(0);
        setIsFollowing(false);
        setFollowPending(false);
        setErrorState(toCommunityErrorState(error, "Failed to load profile."));
      } finally {
        if (token === requestToken.current) {
          setLoading(false);
        }
      }
    })();
  }, [hydratePostContext, profileUserId, retryNonce, user?.id]);

  const handleLoadMore = useCallback(() => {
    if (loading || isLoadingMore || !hasMore || !profileUserId) return;
    const token = requestToken.current;
    const nextPage = page + 1;
    setIsLoadingMore(true);

    void (async () => {
      try {
        const nextPagePosts = await loadPostsByAuthor(profileUserId, {
          limit: PROFILE_PAGE_SIZE,
          page: nextPage,
        });
        if (token !== requestToken.current) return;

        const seenIds = new Set(posts.map((post) => post.id));
        const dedupedNewPosts = nextPagePosts.filter((post) => !seenIds.has(post.id));

        setPosts((previous) => {
          const previousIds = new Set(previous.map((post) => post.id));
          const dedupedAgainstPrevious = nextPagePosts.filter((post) => !previousIds.has(post.id));
          return [...previous, ...dedupedAgainstPrevious];
        });
        setPage(nextPage);
        setHasMore(nextPagePosts.length === PROFILE_PAGE_SIZE);
        if (dedupedNewPosts.length > 0) {
          await hydratePostContext(dedupedNewPosts, token, "merge");
        }
      } catch (error) {
        if (token !== requestToken.current) return;
        toast({
          title: "Could not load more posts",
          description: error instanceof Error ? error.message : "Unexpected error while loading profile posts.",
          variant: "destructive",
        });
      } finally {
        if (token === requestToken.current) {
          setIsLoadingMore(false);
        }
      }
    })();
  }, [hasMore, hydratePostContext, isLoadingMore, loading, page, posts, profileUserId, toast]);

  const handleToggleFollow = useCallback(async () => {
    if (!profileUserId || isOwnProfile) return;

    if (!user) {
      toast({ title: "Sign in required", description: "Sign in to follow creators." });
      return;
    }

    setFollowPending(true);
    try {
      if (isFollowing) {
        await unfollowCommunityUser(profileUserId);
        setIsFollowing(false);
        setProfileStats((previous) => ({
          ...previous,
          followersCount: Math.max(0, previous.followersCount - 1),
        }));
      } else {
        await followCommunityUser(profileUserId);
        setIsFollowing(true);
        setProfileStats((previous) => ({
          ...previous,
          followersCount: previous.followersCount + 1,
        }));
      }
    } catch (error) {
      toast({
        title: "Follow action failed",
        description: error instanceof Error ? error.message : "Unexpected error",
        variant: "destructive",
      });
    } finally {
      setFollowPending(false);
    }
  }, [isFollowing, isOwnProfile, profileUserId, toast, user]);

  const handleCopyPrompt = useCallback(
    async (post: CommunityPost) => {
      try {
        await copyTextToClipboard(post.enhancedPrompt || post.starterPrompt);
        toast({
          title: "Prompt copied",
          description: "Prompt text copied with context-ready formatting.",
        });
      } catch {
        toast({
          title: "Copy failed",
          description: "Could not access clipboard in this browser context.",
          variant: "destructive",
        });
      }
    },
    [toast],
  );

  const handleToggleVote = useCallback(
    async (postId: string, voteType: VoteType) => {
      if (!user) {
        toast({ title: "Sign in required", description: "Create an account to vote." });
        return;
      }
      if (voteInFlightByPost.current.has(postId)) return;
      voteInFlightByPost.current.add(postId);
      try {
        const result = await toggleVote(postId, voteType);
        setVoteStateByPost((prev) => ({
          ...prev,
          [postId]: {
            upvote: voteType === "upvote" ? result.active : prev[postId]?.upvote ?? false,
            verified: voteType === "verified" ? result.active : prev[postId]?.verified ?? false,
          },
        }));
        setPosts((prev) =>
          prev.map((post) => {
            if (post.id !== postId) return post;
            const delta = result.active ? 1 : -1;
            if (voteType === "upvote") {
              return { ...post, upvoteCount: Math.max(0, post.upvoteCount + delta) };
            }
            return { ...post, verifiedCount: Math.max(0, post.verifiedCount + delta) };
          }),
        );
      } catch (error) {
        toast({
          title: "Vote failed",
          description: error instanceof Error ? error.message : "Unexpected error",
          variant: "destructive",
        });
      } finally {
        voteInFlightByPost.current.delete(postId);
      }
    },
    [toast, user],
  );

  const handleRatePrompt = useCallback(
    async (postId: string, rating: number | null) => {
      if (!user) {
        toast({ title: "Sign in required", description: "Create an account to rate prompts." });
        return;
      }
      if (ratingInFlightByPost.current.has(postId)) return;
      ratingInFlightByPost.current.add(postId);

      const previousRating = ratingByPost[postId] ?? null;

      try {
        const result = await setPromptRating(postId, rating);
        setRatingByPost((prev) => ({
          ...prev,
          [postId]: result.rating,
        }));
        setPosts((prev) =>
          prev.map((post) => {
            if (post.id !== postId) return post;
            const summary = computeNextPromptRatingSummary({
              currentCount: post.ratingCount ?? 0,
              currentAverage: post.ratingAverage ?? 0,
              previousRating,
              nextRating: result.rating,
            });
            return {
              ...post,
              ratingCount: summary.ratingCount,
              ratingAverage: summary.ratingAverage,
            };
          }),
        );
      } catch (error) {
        toast({
          title: "Rating failed",
          description: error instanceof Error ? error.message : "Unexpected error",
          variant: "destructive",
        });
      } finally {
        ratingInFlightByPost.current.delete(postId);
      }
    },
    [ratingByPost, toast, user],
  );

  const handleCommentAdded = useCallback((postId: string) => {
    setPosts((prev) =>
      prev.map((post) =>
        post.id === postId ? { ...post, commentCount: post.commentCount + 1 } : post,
      ),
    );
  }, []);

  const handleRetry = useCallback(() => {
    setRetryNonce((prev) => prev + 1);
  }, []);

  return (
    <PageShell>
      <div className="community-typography pf-community-page" data-density="comfortable">
        {!loading && errorState && (
          <StateCard
            variant="error"
            title={errorState.kind === "not_found" ? "Profile not found" : "Couldn't load profile"}
            description={errorState.message}
            primaryAction={{ label: "Retry", onClick: handleRetry }}
            secondaryAction={{ label: "Open Community", to: "/community" }}
          />
        )}

        {!errorState && loading && !profile && (
          <div className="space-y-3">
            {/* Loading skeleton for hero */}
            <div className="pf-gilded-frame rounded-2xl px-4 py-6 sm:px-6 sm:py-8">
              <div className="flex flex-col items-center gap-4 sm:flex-row sm:items-start sm:gap-5">
                <Skeleton className="h-20 w-20 rounded-full sm:h-24 sm:w-24" />
                <div className="flex flex-1 flex-col items-center gap-2 sm:items-start">
                  <Skeleton className="h-7 w-48" />
                  <Skeleton className="h-4 w-32" />
                  <Skeleton className="mt-1 h-9 w-24" />
                </div>
              </div>
            </div>
            <div className="grid grid-cols-2 gap-2 sm:grid-cols-4">
              {[0, 1, 2, 3].map((i) => (
                <Skeleton key={i} className="h-20 rounded-xl" />
              ))}
            </div>
          </div>
        )}

        {!errorState && profile && (
          <>
            <ProfileHero
              profile={profile}
              followStats={profileStats}
              activityStats={activityStats}
              bestRarity={bestRarity}
              memberSinceAt={memberSinceAt}
              isOwnProfile={isOwnProfile}
              isFollowing={isFollowing}
              followPending={followPending}
              onToggleFollow={() => void handleToggleFollow()}
            />

            <CommunityFeed
              posts={orderedPosts}
              loading={loading}
              errorMessage={errorState?.message}
              errorType={errorState?.kind}
              authorById={authorById}
              parentTitleById={parentTitleById}
              onCopyPrompt={handleCopyPrompt}
              onToggleVote={handleToggleVote}
              voteStateByPost={voteStateByPost}
              onCommentAdded={handleCommentAdded}
              canVote={Boolean(user)}
              canRate={Boolean(user)}
              ratingByPost={ratingByPost}
              onRatePrompt={handleRatePrompt}
              currentUserId={null}
              featuredPostId={topPromptPostId}
              featuredPostBadgeLabel={topPromptPostId ? "Top Prompt" : undefined}
              suppressAutoFeatured={Boolean(topPromptPostId)}
              hasMore={hasMore}
              isLoadingMore={isLoadingMore}
              onLoadMore={handleLoadMore}
              onRetry={handleRetry}
            />
          </>
        )}

        {!errorState && !profile && !loading && (
          <StateCard
            variant="empty"
            title="Profile not found"
            description="The requested profile is unavailable."
            primaryAction={{ label: "Open Community", to: "/community" }}
            secondaryAction={{ label: "Go to Builder", to: "/" }}
          />
        )}

        <div className="mt-4 flex justify-end">
          <Button
            type="button"
            color="tertiary"
            size="sm"
            className="type-button-label h-11 sm:h-9"
            onClick={() => navigate("/community")}
          >
            Back to community
          </Button>
        </div>
      </div>
    </PageShell>
  );
};

export default Profile;
````

## File: src/components/community/CommunityFeed.tsx
````typescript
import { useMemo } from "react";
import type { CommunityPost, CommunityProfile, VoteState, VoteType } from "@/lib/community";
import { Card } from "@/components/base/primitives/card";
import { Skeleton } from "@/components/base/primitives/skeleton";
import { CommunityPostCard } from "@/components/community/CommunityPostCard";
import { StateCard } from "@/components/base/primitives/state-card";
import { Button } from "@/components/base/buttons/button";
import { useIsMobile } from "@/hooks/use-mobile";
import { useIntersectionAutoLoad } from "@/hooks/useIntersectionAutoLoad";
import type { CommunityErrorKind } from "@/lib/community-errors";
import { SpinnerGap as Loader2 } from "@phosphor-icons/react";

interface CommunityFeedProps {
  posts: CommunityPost[];
  loading: boolean;
  errorMessage?: string | null;
  errorType?: CommunityErrorKind;
  authorById: Record<string, CommunityProfile>;
  parentTitleById: Record<string, string>;
  onCopyPrompt: (post: CommunityPost) => void;
  onToggleVote: (postId: string, voteType: VoteType) => void;
  voteStateByPost: Record<string, VoteState>;
  onCommentAdded: (postId: string) => void;
  onCommentThreadOpen?: (postId: string) => void;
  onSharePost?: (post: CommunityPost) => void;
  onSaveToLibrary?: (postId: string) => void;
  followingUserIds?: Set<string>;
  onToggleFollow?: (userId: string, isFollowing: boolean) => void;
  canVote: boolean;
  canRate?: boolean;
  ratingByPost?: Record<string, number | null>;
  onRatePrompt?: (postId: string, rating: number | null) => void;
  currentUserId?: string | null;
  blockedUserIds?: string[];
  onReportPost?: (post: CommunityPost) => void;
  onReportComment?: (commentId: string, userId: string, postId: string) => void;
  onBlockUser?: (userId: string) => void;
  onUnblockUser?: (userId: string) => void;
  onTagClick?: (tag: string) => void;
  featuredPostId?: string | null;
  featuredPostBadgeLabel?: string;
  suppressAutoFeatured?: boolean;
  hasMore?: boolean;
  isLoadingMore?: boolean;
  onLoadMore?: () => void;
  onRetry?: () => void;
}

function LoadingCard() {
  return (
    <Card className="pf-card space-y-3 border-border/80 bg-card/85 p-4">
      <div className="flex items-center gap-2">
        <Skeleton className="h-8 w-8 rounded-full" />
        <div className="space-y-1">
          <Skeleton className="h-3 w-28" />
          <Skeleton className="h-3 w-16" />
        </div>
      </div>
      <Skeleton className="h-4 w-3/4" />
      <Skeleton className="h-28 w-full rounded-md" />
      <div className="flex gap-2">
        <Skeleton className="h-7 w-16" />
        <Skeleton className="h-7 w-16" />
        <Skeleton className="h-7 w-20" />
      </div>
    </Card>
  );
}

export function CommunityFeed({
  posts,
  loading,
  errorMessage,
  errorType = "unknown",
  authorById,
  parentTitleById,
  onCopyPrompt,
  onToggleVote,
  voteStateByPost,
  onCommentAdded,
  onCommentThreadOpen,
  onSharePost,
  onSaveToLibrary,
  followingUserIds,
  onToggleFollow,
  canVote,
  canRate = false,
  ratingByPost = {},
  onRatePrompt,
  currentUserId,
  blockedUserIds = [],
  onReportPost,
  onReportComment,
  onBlockUser,
  onUnblockUser,
  onTagClick,
  featuredPostId,
  featuredPostBadgeLabel,
  suppressAutoFeatured = false,
  hasMore = false,
  isLoadingMore = false,
  onLoadMore,
  onRetry,
}: CommunityFeedProps) {
  const isMobile = useIsMobile();
  const renderedPosts = useMemo(
    () =>
      posts.map((post, index) => {
        const author = authorById[post.authorId];
        const authorName = author?.displayName || "Community member";
        const isFeatured = featuredPostId
          ? post.id === featuredPostId
          : !suppressAutoFeatured && !isMobile && index === 0;

        return (
          <CommunityPostCard
            key={post.id}
            post={post}
            isFeatured={isFeatured}
            animationDelayMs={Math.min(index, 8) * 40}
            authorName={authorName}
            authorAvatarUrl={author?.avatarUrl}
            parentPostTitle={post.remixedFrom ? parentTitleById[post.remixedFrom] : undefined}
            onCopyPrompt={onCopyPrompt}
            onToggleVote={onToggleVote}
            voteState={voteStateByPost[post.id]}
            onCommentAdded={onCommentAdded}
            onCommentThreadOpen={onCommentThreadOpen}
            onSharePost={onSharePost}
            onSaveToLibrary={onSaveToLibrary}
            followingUserIds={followingUserIds}
            currentUserId={currentUserId}
            onToggleFollow={onToggleFollow}
            canVote={canVote}
            canRate={canRate}
            ratingValue={ratingByPost[post.id] ?? null}
            onRatePrompt={onRatePrompt}
            canModerate={Boolean(currentUserId)}
            canBlockAuthor={currentUserId !== post.authorId}
            isAuthorBlocked={blockedUserIds.includes(post.authorId)}
            blockedUserIds={blockedUserIds}
            onReportPost={onReportPost}
            onReportComment={onReportComment}
            onBlockUser={onBlockUser}
            onUnblockUser={onUnblockUser}
            onTagClick={onTagClick}
            featuredBadgeLabel={featuredPostId && post.id === featuredPostId ? featuredPostBadgeLabel : undefined}
          />
        );
      }),
    [
      posts,
      authorById,
      parentTitleById,
      onCopyPrompt,
      onToggleVote,
      voteStateByPost,
      onCommentAdded,
      onCommentThreadOpen,
      onSharePost,
      onSaveToLibrary,
      followingUserIds,
      onToggleFollow,
      canVote,
      canRate,
      ratingByPost,
      onRatePrompt,
      currentUserId,
      blockedUserIds,
      onReportPost,
      onReportComment,
      onBlockUser,
      onUnblockUser,
      onTagClick,
      featuredPostId,
      featuredPostBadgeLabel,
      suppressAutoFeatured,
      isMobile,
    ],
  );

  const sentinelRef = useIntersectionAutoLoad({
    hasMore,
    isLoading: isLoadingMore,
    onLoadMore: onLoadMore ?? (() => {}),
  });

  if (loading) {
    return (
      <div className="grid grid-cols-1 gap-3 lg:grid-cols-2">
        <LoadingCard />
        <LoadingCard />
        <LoadingCard />
      </div>
    );
  }

  if (errorMessage) {
    const title =
      errorType === "auth"
        ? "Sign in to access this community view"
        : errorType === "not_found"
          ? "Community content could not be found"
          : errorType === "network"
            ? "Couldn’t reach community feed"
            : errorType === "backend_unconfigured"
              ? "Community backend is not configured"
              : "Couldn’t load community feed";
    const secondaryAction =
      errorType === "auth"
        ? { label: "Go to Builder and sign in", to: "/" }
        : errorType === "not_found"
          ? { label: "Return to community", to: "/community" }
          : { label: "Open Library", to: "/library" };

    return (
      <StateCard
        variant="error"
        title={title}
        description={errorMessage}
        primaryAction={onRetry ? { label: "Retry", onClick: onRetry } : { label: "Go to Builder", to: "/" }}
        secondaryAction={secondaryAction}
      />
    );
  }

  if (posts.length === 0) {
    return (
      <StateCard
        variant="empty"
        title="No posts match."
        description="Try another filter or share a prompt."
        primaryAction={{ label: "Share your first prompt", to: "/" }}
        secondaryAction={{ label: "Open Library", to: "/library" }}
      />
    );
  }

  return (
    <div className="community-feed-grid grid grid-cols-1 gap-3 lg:grid-cols-2">
      {renderedPosts}
      {hasMore && (
        <div className="space-y-2 py-2 lg:col-span-2">
          <div ref={sentinelRef} className="flex justify-center py-2" aria-hidden="true">
            {isLoadingMore && <Loader2 className="h-5 w-5 animate-spin text-muted-foreground" />}
          </div>
          {onLoadMore && (
            <div className="flex justify-center">
              <Button
                type="button"
                color="secondary"
                size="sm"
                className="type-button-label h-11 px-4 sm:h-9 sm:px-3"
                onClick={onLoadMore}
                disabled={isLoadingMore}
              >
                {isLoadingMore ? "Loading…" : "Load more"}
              </Button>
            </div>
          )}
        </div>
      )}
    </div>
  );
}
````

## File: src/components/PromptLibrary.tsx
````typescript
import { useMemo, useState } from "react";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/base/dialog";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/base/primitives/alert-dialog";
import {
  Drawer,
  DrawerContent,
  DrawerDescription,
  DrawerHeader,
  DrawerTitle,
} from "@/components/base/drawer";
import { Button } from "@/components/base/buttons/button";
import { Badge } from "@/components/base/badges/badges";
import { Card } from "@/components/base/primitives/card";
import { Checkbox } from "@/components/base/primitives/checkbox";
import { Input } from "@/components/base/input/input";
import { Label } from "@/components/base/label";
import { Textarea } from "@/components/base/textarea";
import { Select } from "@/components/base/select/select";
import { useIsMobile } from "@/hooks/use-mobile";
import { PROMPT_CATEGORY_OPTIONS } from "@/lib/prompt-categories";
import { cn } from "@/lib/utils";
import {
  templates,
  categoryLabels,
  promptCategorySkins,
  type PromptTemplate,
} from "@/lib/templates";
import type { PromptShareInput, PromptSummary } from "@/lib/persistence";
import {
  ArrowSquareOut as ExternalLink,
  ArrowsDownUp as ArrowDownUp,
  BookOpen,
  Brain,
  ChatCircle as MessageCircle,
  Cloud,
  Database,
  Flask as FlaskConical,
  GitBranch,
  HardDrives as Server,
  Layout,
  Lock,
  MagnifyingGlass as Search,
  PlugsConnected as Cable,
  Robot as Bot,
  ShareNetwork as Share2,
  Shield,
  Sparkle as Sparkles,
  Stack as Layers,
  Trash as Trash2,
} from "@phosphor-icons/react";

interface PromptLibraryProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  savedPrompts: PromptSummary[];
  canShareSavedPrompts: boolean;
  onSelectTemplate: (template: PromptTemplate) => void;
  onSelectSaved: (id: string) => void;
  onDeleteSaved: (id: string) => void;
  onShareSaved: (id: string, input?: PromptShareInput) => void | Promise<void>;
  onUnshareSaved: (id: string) => void | Promise<void>;
}

interface PromptLibraryContentProps {
  savedPrompts: PromptSummary[];
  canShareSavedPrompts: boolean;
  onSelectTemplate: (template: PromptTemplate) => void;
  onSelectSaved: (id: string) => void;
  onDeleteSaved: (id: string) => void;
  onShareSaved: (id: string, input?: PromptShareInput) => void | Promise<void>;
  onUnshareSaved: (id: string) => void | Promise<void>;
  onClose?: () => void;
}

type SavedPromptSort = "recent" | "name" | "revision";

const categoryIcons: Record<string, React.ReactNode> = {
  general: <Sparkles className="w-4 h-4" />,
  frontend: <Layout className="w-4 h-4" />,
  backend: <Server className="w-4 h-4" />,
  fullstack: <Layers className="w-4 h-4" />,
  devops: <Cloud className="w-4 h-4" />,
  data: <Database className="w-4 h-4" />,
  "ml-ai": <Brain className="w-4 h-4" />,
  security: <Shield className="w-4 h-4" />,
  testing: <FlaskConical className="w-4 h-4" />,
  api: <Cable className="w-4 h-4" />,
  automation: <Bot className="w-4 h-4" />,
  docs: <BookOpen className="w-4 h-4" />,
};

function formatUpdatedAt(timestamp: number): string {
  const date = new Date(timestamp);
  return date.toLocaleDateString(undefined, {
    year: "numeric",
    month: "short",
    day: "numeric",
  });
}

function parseTags(value: string): string[] | undefined {
  const tags = Array.from(
    new Set(
      value
        .split(",")
        .map((tag) => tag.trim().toLowerCase())
        .filter(Boolean),
    ),
  ).slice(0, 8);

  return tags.length > 0 ? tags : undefined;
}

const savedPromptActionButtonClass =
  "h-10 min-w-[84px] rounded-md px-2.5 text-xs font-medium tracking-tight sm:h-8 sm:min-w-[72px] sm:px-2";
const savedPromptIconButtonClass =
  "h-10 w-10 rounded-md text-muted-foreground transition-colors hover:bg-destructive/10 hover:text-destructive sm:h-8 sm:w-8";

function PromptList({
  activeCategory,
  setActiveCategory,
  query,
  onQueryChange,
  sortBy,
  onSortByChange,
  savedPrompts,
  canShareSavedPrompts,
  onSelectTemplate,
  onSelectSaved,
  onDeleteSaved,
  onShareSaved,
  onUnshareSaved,
  onClose,
}: {
  activeCategory: string;
  setActiveCategory: (c: string) => void;
  query: string;
  onQueryChange: (query: string) => void;
  sortBy: SavedPromptSort;
  onSortByChange: (sort: SavedPromptSort) => void;
  savedPrompts: PromptSummary[];
  canShareSavedPrompts: boolean;
  onSelectTemplate: (t: PromptTemplate) => void;
  onSelectSaved: (id: string) => void;
  onDeleteSaved: (id: string) => void;
  onShareSaved: (id: string, input?: PromptShareInput) => void | Promise<void>;
  onUnshareSaved: (id: string) => void | Promise<void>;
  onClose: () => void;
}) {
  const categories = ["all", ...Object.keys(categoryLabels)];
  const normalizedQuery = query.trim().toLowerCase();
  const [sharePrompt, setSharePrompt] = useState<PromptSummary | null>(null);
  const [shareName, setShareName] = useState("");
  const [shareDescription, setShareDescription] = useState("");
  const [shareTags, setShareTags] = useState("");
  const [shareCategory, setShareCategory] = useState("general");
  const [shareUseCase, setShareUseCase] = useState("");
  const [shareTargetModel, setShareTargetModel] = useState("");
  const [shareConfirmedSafe, setShareConfirmedSafe] = useState(false);
  const [pendingDeletePrompt, setPendingDeletePrompt] = useState<PromptSummary | null>(null);

  const handleOpenShareDialog = (prompt: PromptSummary) => {
    setSharePrompt(prompt);
    setShareName(prompt.name);
    setShareDescription(prompt.description);
    setShareTags(prompt.tags.join(", "));
    setShareCategory(prompt.category || "general");
    setShareUseCase(prompt.useCase || "");
    setShareTargetModel(prompt.targetModel || "");
    setShareConfirmedSafe(false);
  };

  const handleCloseShareDialog = () => {
    setSharePrompt(null);
    setShareConfirmedSafe(false);
  };

  const handleConfirmDelete = () => {
    if (!pendingDeletePrompt) return;
    onDeleteSaved(pendingDeletePrompt.id);
    setPendingDeletePrompt(null);
  };

  const handleShareSavedPrompt = async () => {
    if (!sharePrompt) return;
    if (!shareName.trim() || !shareUseCase.trim() || !shareConfirmedSafe) return;

    await Promise.resolve(
      onShareSaved(sharePrompt.id, {
        title: shareName.trim(),
        description: shareDescription.trim() || undefined,
        category: shareCategory,
        tags: parseTags(shareTags),
        targetModel: shareTargetModel.trim() || undefined,
        useCase: shareUseCase.trim(),
      }),
    );
    handleCloseShareDialog();
  };

  const filteredSaved = useMemo(() => {
    const matches = savedPrompts.filter((prompt) => {
      if (!normalizedQuery) return true;
      const haystack = [prompt.name, prompt.description, prompt.tags.join(" "), prompt.starterPrompt, prompt.category]
        .join(" ")
        .toLowerCase();
      return haystack.includes(normalizedQuery);
    });

    const sorted = [...matches];
    if (sortBy === "name") {
      sorted.sort((a, b) => a.name.localeCompare(b.name));
    } else if (sortBy === "revision") {
      sorted.sort((a, b) => b.revision - a.revision);
    } else {
      sorted.sort((a, b) => b.updatedAt - a.updatedAt);
    }
    return sorted;
  }, [savedPrompts, normalizedQuery, sortBy]);

  const filtered = useMemo(() => {
    const scoped =
      activeCategory === "all"
        ? templates
        : templates.filter((template) => template.category === activeCategory);

    return scoped.filter((template) => {
      if (!normalizedQuery) return true;
      const haystack = [
        template.name,
        template.description,
        template.starterPrompt,
        template.category,
        template.tone,
        template.complexity,
      ]
        .join(" ")
        .toLowerCase();
      return haystack.includes(normalizedQuery);
    });
  }, [activeCategory, normalizedQuery]);

  return (
    <>
      <div className="grid grid-cols-1 gap-2 border-b border-border/60 pb-2 sm:grid-cols-[1fr_auto]">
        <div className="relative">
          <label htmlFor="prompt-library-search" className="sr-only">
            Search saved prompts and templates
          </label>
          <Search className="absolute left-2.5 top-1/2 -translate-y-1/2 w-3.5 h-3.5 text-muted-foreground" />
          <Input
            id="prompt-library-search"
            value={query}
            onChange={onQueryChange}
            placeholder="Search prompts by name, description, tags, or starter text"
            wrapperClassName="h-11 bg-background sm:h-9"
            inputClassName="pl-8"
          />
        </div>
        <div className="flex items-center gap-1">
          <ArrowDownUp className="w-3.5 h-3.5 text-muted-foreground" />
          <Select
            selectedKey={sortBy}
            onSelectionChange={(value) => {
              if (value !== null) {
                onSortByChange(String(value) as SavedPromptSort);
              }
            }}
            aria-label="Sort saved prompts"
            className="min-w-[138px]"
            size="md"
          >
            <Select.Item id="recent">Most Recent</Select.Item>
            <Select.Item id="name">Name (A-Z)</Select.Item>
            <Select.Item id="revision">Revision (High)</Select.Item>
          </Select>
        </div>
      </div>

      <div className="space-y-2 pb-2 border-b border-border/60">
        <div className="flex items-center gap-2">
          <Database className="w-4 h-4 text-muted-foreground" />
          <h3 className="text-sm font-medium text-foreground">My Prompts</h3>
          <Badge type="modern" className="text-xs">
            {filteredSaved.length}
          </Badge>
        </div>

        {savedPrompts.length === 0 && (
          <Card className="border-dashed border-border/80 bg-muted/20 p-3">
            <p className="text-sm text-muted-foreground">
              No saved prompts yet. Create one in the Builder, then save it to your library.
            </p>
            <div className="mt-2">
              <Button size="sm" href="/" className="h-11 text-sm sm:h-8 sm:text-sm" onClick={onClose}>
                Go to Builder
              </Button>
            </div>
          </Card>
        )}

        {savedPrompts.length > 0 && filteredSaved.length === 0 && (
          <p className="text-sm text-muted-foreground">
            No saved prompts match this search.
          </p>
        )}

        {filteredSaved.map((prompt) => (
          <Card key={prompt.id} className="interactive-card group border-border/70 bg-card/90 p-3 hover:border-primary/45">
            <div className="flex items-start justify-between gap-2">
              <button
                type="button"
                className="min-w-0 flex-1 space-y-1.5 rounded-sm text-left focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring"
                onClick={() => {
                  onSelectSaved(prompt.id);
                  onClose();
                }}
              >
                <div className="flex items-center gap-2 flex-wrap">
                  <h4 className="text-sm font-semibold text-foreground group-hover:text-primary transition-colors">
                    {prompt.name}
                  </h4>
                  <Badge type="modern" className="border border-border bg-background text-foreground text-xs">
                    r{prompt.revision}
                  </Badge>
                  {prompt.isShared ? (
                    <Badge type="modern" className="text-xs gap-1">
                      <Share2 className="w-3 h-3" />
                      Shared
                    </Badge>
                  ) : (
                    <Badge type="modern" className="border border-border bg-background text-foreground text-xs gap-1">
                      <Lock className="w-3 h-3" />
                      Private
                    </Badge>
                  )}
                  {prompt.remixedFrom && (
                    <Badge type="modern" className="text-xs gap-1">
                      <GitBranch className="w-3 h-3" />
                      Remixed
                    </Badge>
                  )}
                </div>
                {prompt.description && (
                  <p className="text-sm text-muted-foreground line-clamp-2">{prompt.description}</p>
                )}
                <p className="text-sm text-muted-foreground/90 line-clamp-2">
                  <span className="font-medium text-foreground/80">Start:</span> {prompt.starterPrompt}
                </p>
                <div className="flex flex-wrap items-center gap-x-1.5 gap-y-0.5 text-xs text-muted-foreground">
                  <span className="capitalize">{prompt.category || "general"}</span>
                  <span>•</span>
                  <span>{formatUpdatedAt(prompt.updatedAt)}</span>
                  <span>•</span>
                  <span>{prompt.sourceCount} sources</span>
                  <span>•</span>
                  <span>{prompt.databaseCount} DB</span>
                </div>
                {prompt.tags.length > 0 && (
                  <div className="flex flex-wrap gap-1">
                    {prompt.tags.slice(0, 4).map((tag) => (
                      <Badge key={`${prompt.id}-${tag}`} type="modern" className="border border-border bg-background text-foreground text-xs">
                        #{tag}
                      </Badge>
                    ))}
                  </div>
                )}
                {prompt.isShared && (
                  <div className="flex items-center gap-2 text-xs text-muted-foreground">
                    <span>▲ {prompt.upvoteCount}</span>
                    <span>✓ {prompt.verifiedCount}</span>
                    <span>🔀 {prompt.remixCount}</span>
                    <span className="inline-flex items-center gap-1">
                      <MessageCircle className="w-3 h-3" />
                      {prompt.commentCount}
                    </span>
                  </div>
                )}
              </button>
              <div className="flex shrink-0 flex-col gap-1 rounded-md border border-border/70 bg-background/70 p-1">
                {prompt.isShared && prompt.communityPostId && (
                  <Button
                    color="tertiary"
                    size="sm"
                    className={cn(savedPromptActionButtonClass, "gap-1.5 text-muted-foreground hover:text-foreground")}
                    href={`/community/${prompt.communityPostId}`}
                    onClick={(event) => {
                      event.stopPropagation();
                    }}
                  >
                    Open
                    <ExternalLink className="w-3 h-3" />
                  </Button>
                )}
                {prompt.isShared ? (
                  <Button
                    color="secondary"
                    size="sm"
                    className={cn(savedPromptActionButtonClass, "border-border/70 bg-background/60")}
                    onClick={(event) => {
                      event.stopPropagation();
                      void onUnshareSaved(prompt.id);
                    }}
                  >
                    Unshare
                  </Button>
                ) : (
                  <Button
                    color="secondary"
                    size="sm"
                    className={cn(savedPromptActionButtonClass, "border-border/70 bg-background/60")}
                    isDisabled={!canShareSavedPrompts}
                    onClick={(event) => {
                      event.stopPropagation();
                      handleOpenShareDialog(prompt);
                    }}
                    title={!canShareSavedPrompts ? "Sign in to share prompts." : undefined}
                  >
                    Share
                  </Button>
                )}
                <Button
                  color="tertiary"
                  size="sm"
                  className={savedPromptIconButtonClass}
                  onClick={(event) => {
                    event.stopPropagation();
                    setPendingDeletePrompt(prompt);
                  }}
                  aria-label={`Delete ${prompt.name}`}
                >
                  <Trash2 className="w-3.5 h-3.5" />
                </Button>
              </div>
            </div>
          </Card>
        ))}
      </div>

      <div className="space-y-2">
        <div className="flex items-center gap-2">
          <h3 className="text-sm font-medium text-foreground">Starter Templates</h3>
        </div>

        <div className="flex flex-wrap gap-1.5 py-2">
          {categories.map((cat) => (
            <Button
              key={cat}
              color={activeCategory === cat ? "primary" : "secondary"}
              size="sm"
              onClick={() => setActiveCategory(cat)}
              className="interactive-chip h-10 gap-1.5 rounded-full px-3 text-xs font-medium capitalize tracking-tight sm:h-8 sm:px-2.5 sm:text-sm"
            >
              {cat !== "all" && categoryIcons[cat]}
              {cat === "all" ? "All" : categoryLabels[cat]}
            </Button>
          ))}
        </div>

        <div className="overflow-y-auto flex-1 space-y-2 sm:space-y-3 pr-1">
          {filtered.length === 0 && (
            <Card className="p-4 text-center border-dashed">
              <p className="text-sm text-muted-foreground">No starter templates match this search.</p>
            </Card>
          )}
          {filtered.map((template) => {
            const skin = promptCategorySkins[template.category] ?? promptCategorySkins.general;
            return (
              <Card
                key={template.id}
                className={cn(
                  "interactive-card group overflow-hidden border",
                  skin.card,
                )}
              >
                <button
                  type="button"
                  className="w-full rounded-sm p-3 text-left focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring sm:p-3.5"
                  onClick={() => {
                    onSelectTemplate(template);
                    onClose();
                  }}
                >
                  <div className="flex items-start justify-between gap-2 sm:gap-3">
                    <div className="space-y-1 flex-1 min-w-0">
                      <div className="flex items-center gap-2 flex-wrap">
                        <span
                          className={cn(
                            "inline-flex h-6 w-6 items-center justify-center rounded-full",
                            skin.iconWrap,
                          )}
                        >
                          {categoryIcons[template.category] ?? categoryIcons.general}
                        </span>
                        <h3 className="text-sm font-semibold text-foreground group-hover:text-primary transition-colors">
                          {template.name}
                        </h3>
                        <Badge
                          type="modern"
                          className={cn("border border-border bg-background text-foreground text-xs capitalize", skin.badge)}
                        >
                          {template.category}
                        </Badge>
                      </div>
                      <p className="text-sm text-muted-foreground line-clamp-2">{template.description}</p>
                      <p className="text-sm text-muted-foreground/90 line-clamp-2">
                        <span className="font-medium text-foreground/80">Start:</span> {template.starterPrompt}
                      </p>
                      <div className="mt-1.5 flex gap-1">
                        <Badge type="modern" className="text-xs">
                          {template.tone}
                        </Badge>
                        <Badge type="modern" className="text-xs">
                          {template.complexity}
                        </Badge>
                      </div>
                    </div>
                    <span
                      className={cn(
                        "type-label-caps hidden h-8 shrink-0 items-center rounded-md border px-2 text-xs font-medium opacity-70 transition-opacity group-hover:opacity-100 sm:inline-flex",
                        skin.action,
                      )}
                    >
                      Use
                    </span>
                  </div>
                </button>
              </Card>
            );
          })}
        </div>
      </div>

      <AlertDialog
        open={pendingDeletePrompt !== null}
        onOpenChange={(open) => {
          if (!open) {
            setPendingDeletePrompt(null);
          }
        }}
      >
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Delete saved prompt?</AlertDialogTitle>
            <AlertDialogDescription>
              {pendingDeletePrompt
                ? `This will permanently delete "${pendingDeletePrompt.name}".`
                : "This will permanently delete this saved prompt."}
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel>Cancel</AlertDialogCancel>
            <AlertDialogAction
              variant="brandDestructive"
              onClick={handleConfirmDelete}
            >
              Delete
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>

      <Dialog
        open={sharePrompt !== null}
        onOpenChange={(open) => {
          if (!open) handleCloseShareDialog();
        }}
      >
        <DialogContent className="sm:max-w-md max-h-[85vh] overflow-auto">
          <DialogHeader>
            <DialogTitle>Share Prompt</DialogTitle>
            <DialogDescription>Publish this saved prompt to the community feed.</DialogDescription>
          </DialogHeader>
          <div className="space-y-3">
            <Input
              value={shareName}
              onChange={setShareName}
              placeholder="Prompt title"
              wrapperClassName="bg-background"
              inputClassName="text-base"
            />
            <Select
              selectedKey={shareCategory}
              onSelectionChange={(value) => {
                if (value !== null) {
                  setShareCategory(String(value));
                }
              }}
              placeholder="Category"
              className="bg-background"
              aria-label="Category"
            >
              {PROMPT_CATEGORY_OPTIONS.map((category) => (
                <Select.Item key={category.value} id={category.value}>
                  {category.label}
                </Select.Item>
              ))}
            </Select>
            <Textarea
              value={shareDescription}
              onChange={(event) => setShareDescription(event.target.value)}
              placeholder="Description (optional)"
              className="min-h-[80px] bg-background"
            />
            <Input
              value={shareTags}
              onChange={setShareTags}
              placeholder="Tags (comma-separated, optional)"
              wrapperClassName="bg-background"
              inputClassName="text-base"
            />
            <Textarea
              value={shareUseCase}
              onChange={(event) => setShareUseCase(event.target.value)}
              placeholder="Use case (required)"
              className="min-h-[90px] bg-background"
            />
            <Input
              value={shareTargetModel}
              onChange={setShareTargetModel}
              placeholder="Target model (optional)"
              wrapperClassName="bg-background"
              inputClassName="text-base"
            />
            <div className="flex items-start gap-2">
              <Checkbox
                id="library-share-confirm-safe"
                checked={shareConfirmedSafe}
                onCheckedChange={(checked) => setShareConfirmedSafe(checked === true)}
                className="mt-0.5"
              />
              <Label
                htmlFor="library-share-confirm-safe"
                className="cursor-pointer text-sm leading-snug text-muted-foreground"
              >
                I confirm this prompt contains no secrets or private data.
              </Label>
            </div>
          </div>
          <DialogFooter>
            <Button color="secondary" onClick={handleCloseShareDialog}>
              Cancel
            </Button>
            <Button
              onClick={() => void handleShareSavedPrompt()}
              isDisabled={!shareName.trim() || !shareUseCase.trim() || !shareConfirmedSafe}
            >
              Share Prompt
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
    </>
  );
}

export function PromptLibrary({
  open,
  onOpenChange,
  savedPrompts,
  canShareSavedPrompts,
  onSelectTemplate,
  onSelectSaved,
  onDeleteSaved,
  onShareSaved,
  onUnshareSaved,
}: PromptLibraryProps) {
  const isMobile = useIsMobile();

  if (isMobile) {
    return (
      <Drawer open={open} onOpenChange={onOpenChange}>
        <DrawerContent className="max-h-[85vh]">
          <DrawerHeader>
            <DrawerTitle>Prompt Library</DrawerTitle>
            <DrawerDescription className="sr-only">
              Browse templates and saved prompts, then load one into the builder.
            </DrawerDescription>
          </DrawerHeader>
          <div className="px-4 pb-4 overflow-auto flex-1 flex flex-col">
            <PromptLibraryContent
              savedPrompts={savedPrompts}
              canShareSavedPrompts={canShareSavedPrompts}
              onSelectTemplate={onSelectTemplate}
              onSelectSaved={onSelectSaved}
              onDeleteSaved={onDeleteSaved}
              onShareSaved={onShareSaved}
              onUnshareSaved={onUnshareSaved}
              onClose={() => onOpenChange(false)}
            />
          </div>
        </DrawerContent>
      </Drawer>
    );
  }

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="sm:max-w-[700px] max-h-[80vh] overflow-hidden flex flex-col">
        <DialogHeader>
          <DialogTitle className="text-foreground">Prompt Library</DialogTitle>
          <DialogDescription>
            Browse templates and saved prompts, then load one into the builder.
          </DialogDescription>
        </DialogHeader>
        <PromptLibraryContent
          savedPrompts={savedPrompts}
          canShareSavedPrompts={canShareSavedPrompts}
          onSelectTemplate={onSelectTemplate}
          onSelectSaved={onSelectSaved}
          onDeleteSaved={onDeleteSaved}
          onShareSaved={onShareSaved}
          onUnshareSaved={onUnshareSaved}
          onClose={() => onOpenChange(false)}
        />
      </DialogContent>
    </Dialog>
  );
}

export function PromptLibraryContent({
  savedPrompts,
  canShareSavedPrompts,
  onSelectTemplate,
  onSelectSaved,
  onDeleteSaved,
  onShareSaved,
  onUnshareSaved,
  onClose,
}: PromptLibraryContentProps) {
  const [activeCategory, setActiveCategory] = useState<string>("all");
  const [query, setQuery] = useState("");
  const [sortBy, setSortBy] = useState<SavedPromptSort>("recent");
  const handleClose = onClose ?? (() => undefined);

  return (
    <PromptList
      activeCategory={activeCategory}
      setActiveCategory={setActiveCategory}
      query={query}
      onQueryChange={setQuery}
      sortBy={sortBy}
      onSortByChange={setSortBy}
      savedPrompts={savedPrompts}
      canShareSavedPrompts={canShareSavedPrompts}
      onSelectTemplate={onSelectTemplate}
      onSelectSaved={onSelectSaved}
      onDeleteSaved={onDeleteSaved}
      onShareSaved={onShareSaved}
      onUnshareSaved={onUnshareSaved}
      onClose={handleClose}
    />
  );
}
````

## File: src/lib/ai-client.ts
````typescript
import { neon } from "@/integrations/neon/client";

function normalizeEnvValue(value?: string): string | undefined {
  if (typeof value !== "string") return undefined;
  const trimmed = value.trim();
  if (!trimmed) return undefined;

  const hasDoubleQuotes = trimmed.startsWith("\"") && trimmed.endsWith("\"");
  const hasSingleQuotes = trimmed.startsWith("'") && trimmed.endsWith("'");
  if (hasDoubleQuotes || hasSingleQuotes) {
    const unquoted = trimmed.slice(1, -1).trim();
    return unquoted || undefined;
  }

  return trimmed;
}

function parsePositiveInteger(value?: string): number | null {
  if (typeof value !== "string") return null;
  const parsed = Number.parseInt(value, 10);
  if (!Number.isFinite(parsed) || parsed <= 0) return null;
  return parsed;
}

const AGENT_SERVICE_URL = normalizeEnvValue(import.meta.env.VITE_AGENT_SERVICE_URL);
const PUBLIC_FUNCTION_API_KEY =
  normalizeEnvValue(import.meta.env.VITE_NEON_PUBLISHABLE_KEY);
const configuredEnhanceRequestTimeoutMs = parsePositiveInteger(
  normalizeEnvValue(import.meta.env.VITE_ENHANCE_REQUEST_TIMEOUT_MS),
);
const configuredEnhanceTransport = normalizeEnvValue(import.meta.env.VITE_ENHANCE_TRANSPORT);
const configuredEnhanceWebSocketConnectTimeoutMs = parsePositiveInteger(
  normalizeEnvValue(import.meta.env.VITE_ENHANCE_WS_CONNECT_TIMEOUT_MS),
);

let bootstrapTokenPromise: Promise<string> | null = null;
const ACCESS_TOKEN_REFRESH_GRACE_SECONDS = 30;
const FUNCTION_NETWORK_RETRY_DELAY_MS = 250;
const DEFAULT_ENHANCE_REQUEST_TIMEOUT_MS = 90_000;
export const ENHANCE_REQUEST_TIMEOUT_MS =
  configuredEnhanceRequestTimeoutMs ?? DEFAULT_ENHANCE_REQUEST_TIMEOUT_MS;
const DEFAULT_ENHANCE_WS_CONNECT_TIMEOUT_MS = 3_500;
const ENHANCE_WS_CONNECT_TIMEOUT_MS =
  configuredEnhanceWebSocketConnectTimeoutMs ?? DEFAULT_ENHANCE_WS_CONNECT_TIMEOUT_MS;
const ENHANCE_WS_PROTOCOL = "promptforge.enhance.v1";

type EnhanceTransportMode = "auto" | "sse" | "ws";

function normalizeEnhanceTransportMode(value: string | undefined): EnhanceTransportMode {
  if (!value) return "auto";
  const normalized = value.trim().toLowerCase();
  if (normalized === "ws" || normalized === "websocket") return "ws";
  if (normalized === "sse" || normalized === "http") return "sse";
  return "auto";
}

const ENHANCE_TRANSPORT_MODE = normalizeEnhanceTransportMode(configuredEnhanceTransport);

export type AIClientErrorCode =
  | "unknown"
  | "network_unavailable"
  | "auth_required"
  | "auth_session_invalid"
  | "request_aborted"
  | "request_timeout"
  | "rate_limited"
  | "service_error"
  | "bad_response";

interface AIClientErrorInit {
  message: string;
  code: AIClientErrorCode;
  status?: number;
  retryable?: boolean;
  cause?: unknown;
}

export class AIClientError extends Error {
  readonly code: AIClientErrorCode;
  readonly status?: number;
  readonly retryable: boolean;

  constructor({ message, code, status, retryable = false, cause }: AIClientErrorInit) {
    super(message);
    this.name = "AIClientError";
    this.code = code;
    this.status = status;
    this.retryable = retryable;
    if (cause !== undefined) {
      Object.defineProperty(this, "cause", {
        value: cause,
        enumerable: false,
        configurable: true,
        writable: true,
      });
    }
  }
}

export function isAIClientError(error: unknown): error is AIClientError {
  return error instanceof AIClientError;
}

function sessionExpiresSoon(expiresAt: number | null | undefined): boolean {
  if (typeof expiresAt !== "number" || !Number.isFinite(expiresAt)) return false;
  const nowSeconds = Math.floor(Date.now() / 1000);
  return expiresAt <= nowSeconds + ACCESS_TOKEN_REFRESH_GRACE_SECONDS;
}

function isRetryableAuthSessionError(error: unknown): boolean {
  if (!error || typeof error !== "object") return false;
  const candidate = error as { message?: unknown; status?: unknown; code?: unknown; name?: unknown };
  const message = typeof candidate.message === "string" ? candidate.message.toLowerCase() : "";
  const code = typeof candidate.code === "string" ? candidate.code.toLowerCase() : "";
  const name = typeof candidate.name === "string" ? candidate.name.toLowerCase() : "";
  const status = typeof candidate.status === "number" ? candidate.status : null;

  if (status === 0) return true;
  if (name.includes("retryable") || name.includes("fetch")) return true;
  if (code.includes("retryable") || code.includes("fetch")) return true;

  return (
    message.includes("failed to fetch") ||
    message.includes("fetch failed") ||
    message.includes("network request failed") ||
    message.includes("networkerror") ||
    message.includes("load failed")
  );
}

function getAbortSignalReason(signal?: AbortSignal): unknown {
  if (!signal) return undefined;
  return (signal as AbortSignal & { reason?: unknown }).reason;
}

function isAbortError(error: unknown): boolean {
  if (!error || typeof error !== "object") return false;
  const name = (error as { name?: unknown }).name;
  return typeof name === "string" && name.toLowerCase().includes("abort");
}

function waitFor(ms: number, signal?: AbortSignal): Promise<void> {
  return new Promise((resolve, reject) => {
    if (signal?.aborted) {
      reject(getAbortSignalReason(signal) ?? new AIClientError({
        message: "Request was cancelled.",
        code: "request_aborted",
      }));
      return;
    }

    let timer: ReturnType<typeof globalThis.setTimeout> | null = null;

    const onAbort = () => {
      if (timer !== null) {
        globalThis.clearTimeout(timer);
      }
      signal?.removeEventListener("abort", onAbort);
      reject(getAbortSignalReason(signal) ?? new AIClientError({
        message: "Request was cancelled.",
        code: "request_aborted",
      }));
    };

    timer = globalThis.setTimeout(() => {
      signal?.removeEventListener("abort", onAbort);
      resolve();
    }, ms);

    signal?.addEventListener("abort", onAbort, { once: true });
  });
}

function isTimeoutLikeErrorMessage(message: string): boolean {
  const normalized = message.toLowerCase();
  return normalized.includes("timeout") || normalized.includes("timed out");
}

function isNetworkLikeErrorMessage(message: string): boolean {
  const normalized = message.toLowerCase();
  return (
    normalized.includes("failed to fetch") ||
    normalized.includes("fetch failed") ||
    normalized.includes("network request failed") ||
    normalized.includes("networkerror") ||
    normalized.includes("load failed") ||
    normalized.includes("connection") ||
    normalized.includes("offline") ||
    normalized.includes("timeout") ||
    normalized.includes("timed out")
  );
}

function isRetryableFunctionRequestError(error: unknown): boolean {
  if (isAIClientError(error)) {
    return error.retryable;
  }
  if (isRetryableAuthSessionError(error)) return true;
  if (!error || typeof error !== "object") return false;
  const candidate = error as { message?: unknown; name?: unknown };
  const message = typeof candidate.message === "string" ? candidate.message : "";
  const name = typeof candidate.name === "string" ? candidate.name.toLowerCase() : "";
  if (name.includes("abort")) return false;
  return isNetworkLikeErrorMessage(message);
}

function isLikelyLocalhostTarget(value: string): boolean {
  const normalized = value.toLowerCase();
  return (
    normalized.includes("://localhost") ||
    normalized.includes("://127.0.0.1") ||
    normalized.includes("://[::1]")
  );
}

function getConfiguredServiceOrigin(): string | null {
  if (!AGENT_SERVICE_URL) return null;
  try {
    return new URL(AGENT_SERVICE_URL).origin;
  } catch {
    return AGENT_SERVICE_URL;
  }
}

function buildNetworkHint(name: "enhance-prompt" | "extract-url" | "infer-builder-fields"): string | null {
  if (typeof window === "undefined" || !AGENT_SERVICE_URL) return null;
  const appProtocol = window.location.protocol.toLowerCase();
  const appHost = window.location.hostname.toLowerCase();
  const serviceValue = AGENT_SERVICE_URL.toLowerCase();

  if (appProtocol === "https:" && serviceValue.startsWith("http://")) {
    if (name === "enhance-prompt") {
      return "The app is loaded over HTTPS but the enhancement service URL is HTTP. Configure VITE_AGENT_SERVICE_URL with an HTTPS endpoint.";
    }
    if (name === "extract-url") {
      return "The app is loaded over HTTPS but the URL extraction service URL is HTTP. Configure VITE_AGENT_SERVICE_URL with an HTTPS endpoint.";
    }
    return "The app is loaded over HTTPS but the inference service URL is HTTP. Configure VITE_AGENT_SERVICE_URL with an HTTPS endpoint.";
  }

  if (!["localhost", "127.0.0.1", "::1"].includes(appHost) && isLikelyLocalhostTarget(serviceValue)) {
    if (name === "enhance-prompt") {
      return "The configured enhancement service points to localhost, which is not reachable from this deployed app.";
    }
    if (name === "extract-url") {
      return "The configured URL extraction service points to localhost, which is not reachable from this deployed app.";
    }
    return "The configured inference service points to localhost, which is not reachable from this deployed app.";
  }

  return null;
}

function serviceUnavailableMessage(name: "enhance-prompt" | "extract-url" | "infer-builder-fields"): string {
  const serviceOrigin = getConfiguredServiceOrigin();
  const destinationText = serviceOrigin ? ` at ${serviceOrigin}` : "";
  const hint = buildNetworkHint(name);

  if (name === "enhance-prompt") {
    return `Could not reach the enhancement service${destinationText}. ${hint || "Check your connection and try again."}`;
  }
  if (name === "extract-url") {
    return `Could not reach the URL extraction service${destinationText}. ${hint || "Check your connection and try again."}`;
  }
  return `Could not reach the inference service${destinationText}. ${hint || "Check your connection and try again."}`;
}

function timeoutMessage(name: "enhance-prompt" | "extract-url" | "infer-builder-fields"): string {
  if (name === "enhance-prompt") {
    return "Enhancement timed out. Please try again.";
  }
  if (name === "extract-url") {
    return "URL extraction timed out. Please try again.";
  }
  return "Inference timed out. Please try again.";
}

function errorCodeFromStatus(status: number | undefined): AIClientErrorCode {
  if (status === 401) return "auth_session_invalid";
  if (status === 429) return "rate_limited";
  if (status === 408 || status === 504) return "request_timeout";
  if (typeof status === "number" && status >= 500) return "service_error";
  return "bad_response";
}

function messageLooksLikeAuthError(message: string): boolean {
  const normalized = message.toLowerCase();
  return (
    normalized.includes("sign in required") ||
    normalized.includes("auth session") ||
    normalized.includes("invalid or expired auth session")
  );
}

function messageLooksLikeRateLimitError(message: string): boolean {
  const normalized = message.toLowerCase();
  return normalized.includes("rate limit") || normalized.includes("too many requests") || normalized.includes("429");
}

function messageLooksLikeServiceError(message: string): boolean {
  const normalized = message.toLowerCase();
  return normalized.includes("service unavailable") || normalized.includes("temporarily unavailable");
}

function normalizeClientError(
  name: "enhance-prompt" | "extract-url" | "infer-builder-fields",
  error: unknown,
  options: { status?: number; code?: AIClientErrorCode } = {},
): AIClientError {
  if (isAIClientError(error)) return error;

  if (isAbortError(error)) {
    return new AIClientError({
      message: "Request was cancelled.",
      code: "request_aborted",
      status: options.status,
      retryable: true,
      cause: error,
    });
  }

  const rawMessage = errorMessage(error);
  const message = rawMessage.trim() || "Unexpected error from AI service.";
  const status = options.status;

  if (options.code) {
    return new AIClientError({
      message,
      code: options.code,
      status,
      retryable: options.code === "network_unavailable" || options.code === "rate_limited" || options.code === "service_error" || options.code === "request_timeout",
      cause: error,
    });
  }

  if (messageLooksLikeAuthError(message)) {
    return new AIClientError({
      message,
      code: message.toLowerCase().includes("sign in required") ? "auth_required" : "auth_session_invalid",
      status,
      cause: error,
    });
  }

  if (messageLooksLikeRateLimitError(message) || status === 429) {
    return new AIClientError({
      message,
      code: "rate_limited",
      status,
      retryable: true,
      cause: error,
    });
  }

  if (isTimeoutLikeErrorMessage(message) || status === 408 || status === 504) {
    return new AIClientError({
      message: timeoutMessage(name),
      code: "request_timeout",
      status,
      retryable: true,
      cause: error,
    });
  }

  if (isNetworkLikeErrorMessage(message)) {
    return new AIClientError({
      message: serviceUnavailableMessage(name),
      code: "network_unavailable",
      status,
      retryable: true,
      cause: error,
    });
  }

  if (messageLooksLikeServiceError(message) || (typeof status === "number" && status >= 500)) {
    return new AIClientError({
      message,
      code: "service_error",
      status,
      retryable: true,
      cause: error,
    });
  }

  return new AIClientError({
    message,
    code: errorCodeFromStatus(status),
    status,
    retryable: typeof status === "number" && status >= 500,
    cause: error,
  });
}

function errorMessage(error: unknown): string {
  if (typeof error === "string" && error.trim()) {
    return error.trim();
  }

  if (error instanceof Error && typeof error.message === "string" && error.message.trim()) {
    return error.message.trim();
  }

  if (error && typeof error === "object") {
    const message = (error as { message?: unknown }).message;
    if (typeof message === "string" && message.trim()) {
      return message.trim();
    }
  }

  return "Unexpected error from AI service.";
}

function createErrorWithCause(message: string, cause: unknown): Error {
  const error = new Error(message);
  Object.defineProperty(error, "cause", {
    value: cause,
    enumerable: false,
    configurable: true,
    writable: true,
  });
  return error;
}

async function refreshSessionAccessToken(): Promise<string | null> {
  try {
    const {
      data: { session },
      error,
    } = await neon.auth.refreshSession();
    if (error) return null;
    return session?.access_token ?? null;
  } catch (error) {
    if (isRetryableAuthSessionError(error)) {
      await clearLocalSession();
    }
    return null;
  }
}

async function clearLocalSession(): Promise<void> {
  try {
    await neon.auth.signOut({ scope: "local" });
  } catch {
    // Ignore local sign-out failures and continue with fallback auth.
  }
}

function assertFunctionRuntimeEnv(): void {
  if (!AGENT_SERVICE_URL) {
    throw new Error(
      "Missing function runtime env. Set VITE_AGENT_SERVICE_URL.",
    );
  }
}

function functionUrl(name: "enhance-prompt" | "extract-url" | "infer-builder-fields"): string {
  assertFunctionRuntimeEnv();
  const base = (AGENT_SERVICE_URL as string).replace(/\/+$/, "");
  const route =
    name === "enhance-prompt"
      ? "enhance"
      : name;
  return `${base}/${route}`;
}

function enhanceWebSocketUrl(): string {
  const httpUrl = functionUrl("enhance-prompt");
  const parsed = new URL(httpUrl);
  if (parsed.protocol === "https:") {
    parsed.protocol = "wss:";
  } else if (parsed.protocol === "http:") {
    parsed.protocol = "ws:";
  }

  parsed.pathname = parsed.pathname.replace(/\/enhance$/, "/enhance/ws");
  return parsed.toString();
}

function buildEnhanceWebSocketProtocols(): string[] {
  return [ENHANCE_WS_PROTOCOL];
}

function buildEnhanceWebSocketStartMessage(
  payload: Record<string, unknown>,
  accessToken: string,
): Record<string, unknown> {
  return {
    type: "enhance.start",
    auth: {
      bearer_token: accessToken,
      ...(PUBLIC_FUNCTION_API_KEY ? { apikey: PUBLIC_FUNCTION_API_KEY } : {}),
    },
    payload,
  };
}

async function getAccessToken({
  forceRefresh = false,
  allowSessionToken = true,
}: {
  forceRefresh?: boolean;
  allowSessionToken?: boolean;
} = {}): Promise<string> {
  assertFunctionRuntimeEnv();

  if (forceRefresh) {
    const forcedToken = await refreshSessionAccessToken();
    if (forcedToken) return forcedToken;
  }

  let sessionResult!: {
    data: { session: { access_token?: string; expires_at?: number | null } | null };
    error: unknown;
  };

  try {
    sessionResult = await neon.auth.getSession();
  } catch (sessionError) {
    if (isRetryableAuthSessionError(sessionError)) {
      await clearLocalSession();
      if (PUBLIC_FUNCTION_API_KEY) return PUBLIC_FUNCTION_API_KEY;
      throw createErrorWithCause(`Could not read auth session: ${errorMessage(sessionError)}`, sessionError);
    }
    throw createErrorWithCause(`Could not read auth session: ${errorMessage(sessionError)}`, sessionError);
  }

  const {
    data: { session },
    error: sessionError,
  } = sessionResult;
  if (sessionError) {
    if (isRetryableAuthSessionError(sessionError)) {
      await clearLocalSession();
      if (PUBLIC_FUNCTION_API_KEY) return PUBLIC_FUNCTION_API_KEY;
      throw createErrorWithCause(`Could not read auth session: ${errorMessage(sessionError)}`, sessionError);
    }
    throw createErrorWithCause(`Could not read auth session: ${errorMessage(sessionError)}`, sessionError);
  }
  if (session?.access_token) {
    if (!allowSessionToken) {
      await clearLocalSession();
    } else {
      if (sessionExpiresSoon(session.expires_at)) {
        const refreshedToken = await refreshSessionAccessToken();
        if (refreshedToken) return refreshedToken;
      }
      return session.access_token;
    }
  }

  if (PUBLIC_FUNCTION_API_KEY) return PUBLIC_FUNCTION_API_KEY;
  throw new Error("Sign in required.");
}

async function getAccessTokenWithBootstrap({
  forceRefresh = false,
  allowSessionToken = true,
}: {
  forceRefresh?: boolean;
  allowSessionToken?: boolean;
} = {}): Promise<string> {
  if (forceRefresh || !allowSessionToken) {
    bootstrapTokenPromise = null;
    return getAccessToken({ forceRefresh, allowSessionToken });
  }

  if (!bootstrapTokenPromise) {
    bootstrapTokenPromise = getAccessToken().finally(() => {
      bootstrapTokenPromise = null;
    });
  }
  return bootstrapTokenPromise;
}

async function functionHeaders({
  forceRefresh = false,
  allowSessionToken = true,
}: {
  forceRefresh?: boolean;
  allowSessionToken?: boolean;
} = {}): Promise<Record<string, string>> {
  assertFunctionRuntimeEnv();
  const accessToken = await getAccessTokenWithBootstrap({ forceRefresh, allowSessionToken });
  return functionHeadersWithAccessToken(accessToken);
}

function functionHeadersWithAccessToken(accessToken: string): Record<string, string> {
  assertFunctionRuntimeEnv();
  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    Authorization: `Bearer ${accessToken}`,
  };
  if (PUBLIC_FUNCTION_API_KEY) {
    headers.apikey = PUBLIC_FUNCTION_API_KEY;
  }
  return headers;
}

function functionHeadersWithPublishableKey(): Record<string, string> {
  if (!PUBLIC_FUNCTION_API_KEY) {
    throw new Error("Sign in required.");
  }
  return functionHeadersWithAccessToken(PUBLIC_FUNCTION_API_KEY);
}

function normalizeServerErrorCode(code: unknown): AIClientErrorCode | undefined {
  if (typeof code !== "string" || !code.trim()) return undefined;
  const normalized = code.trim().toLowerCase().replace(/[/.\s-]/g, "_");
  if (normalized.includes("rate_limit") || normalized === "429") return "rate_limited";
  if (normalized.includes("timeout")) return "request_timeout";
  if (
    normalized === "auth_required"
    || normalized.includes("sign_in_required")
    || normalized.includes("missing_bearer")
    || normalized.includes("missing_token")
    || normalized.includes("unauthenticated")
  ) {
    return "auth_required";
  }
  if (normalized.includes("auth") || normalized.includes("session")) return "auth_session_invalid";
  if (normalized.includes("network")) return "network_unavailable";
  if (normalized.includes("service")) return "service_error";
  if (normalized.includes("bad") || normalized.includes("invalid")) return "bad_response";
  return undefined;
}

async function readFunctionError(resp: Response): Promise<{ message: string; code?: AIClientErrorCode }> {
  const fallbackMessage = `Request failed with status ${resp.status}.`;
  const errorData = await resp.json().catch(() => null);
  if (!errorData || typeof errorData !== "object") {
    return { message: fallbackMessage };
  }

  const normalizedCode = normalizeServerErrorCode((errorData as { code?: unknown }).code);

  const maybeError = (errorData as { error?: unknown }).error;
  if (typeof maybeError === "string" && maybeError.trim()) {
    return {
      message: maybeError.trim(),
      code: normalizedCode,
    };
  }

  const maybeDetail = (errorData as { detail?: unknown }).detail;
  if (typeof maybeDetail === "string" && maybeDetail.trim()) {
    return {
      message: maybeDetail.trim(),
      code: normalizedCode,
    };
  }

  return {
    message: fallbackMessage,
    code: normalizedCode,
  };
}

function isInvalidAuthSessionError(status: number, errorMessage: string): boolean {
  if (status !== 401) return false;
  const normalized = errorMessage.toLowerCase();
  return (
    normalized.includes("invalid or expired auth session") ||
    (normalized.includes("invalid") && normalized.includes("session")) ||
    (normalized.includes("expired") && normalized.includes("session"))
  );
}

function isRecoverableAuthServiceError(status: number, errorMessage: string): boolean {
  if (status !== 503) return false;
  const normalized = errorMessage.toLowerCase();
  return (
    normalized.includes("authentication service is unavailable because neon auth is not configured") ||
    normalized.includes("authentication service is temporarily unavailable")
  );
}

async function postFunctionWithAuthRecovery(
  name: "enhance-prompt" | "extract-url" | "infer-builder-fields",
  payload: Record<string, unknown>,
  options: { signal?: AbortSignal } = {},
): Promise<Response> {
  const request = (headers: Record<string, string>) =>
    fetch(functionUrl(name), {
      method: "POST",
      headers,
      body: JSON.stringify(payload),
      signal: options.signal,
    });
  const requestWithRetry = async (headers: Record<string, string>): Promise<Response> => {
    try {
      return await request(headers);
    } catch (firstError) {
      if (!isRetryableFunctionRequestError(firstError)) {
        throw firstError;
      }

      await waitFor(FUNCTION_NETWORK_RETRY_DELAY_MS, options.signal);
      return request(headers);
    }
  };

  try {
    let response = await requestWithRetry(await functionHeaders());
    if (response.ok) return response;

    let errorDetails = await readFunctionError(response);
    let errorMessage = errorDetails.message;
    const firstFailureWasAuth =
      response.status === 401
      || isInvalidAuthSessionError(response.status, errorMessage)
      || isRecoverableAuthServiceError(response.status, errorMessage);
    if (!firstFailureWasAuth) {
      throw normalizeClientError(name, errorMessage, {
        status: response.status,
        code: errorDetails.code,
      });
    }

    response = await requestWithRetry(await functionHeaders({ forceRefresh: true, allowSessionToken: false }));
    if (response.ok) return response;

    errorDetails = await readFunctionError(response);
    errorMessage = errorDetails.message;
    const secondFailureWasAuth =
      response.status === 401
      || isInvalidAuthSessionError(response.status, errorMessage)
      || isRecoverableAuthServiceError(response.status, errorMessage);
    if (!secondFailureWasAuth) {
      throw normalizeClientError(name, errorMessage, {
        status: response.status,
        code: errorDetails.code,
      });
    }

    // If refresh returned another unusable session token, force a deterministic API-key retry.
    await clearLocalSession();
    response = await requestWithRetry(functionHeadersWithPublishableKey());
    if (response.ok) return response;

    errorDetails = await readFunctionError(response);
    throw normalizeClientError(name, errorDetails.message, {
      status: response.status,
      code: errorDetails.code,
    });
  } catch (error) {
    throw normalizeClientError(name, error);
  }
}

function extractSseErrorDetails(payload: unknown): {
  message: string;
  code?: AIClientErrorCode;
  status?: number;
} | null {
  if (!payload || typeof payload !== "object") return null;
  const data = payload as { error?: unknown; code?: unknown; status?: unknown };

  if (typeof data.error === "string" && data.error.trim()) {
    const status = typeof data.status === "number" ? data.status : undefined;
    return {
      message: data.error.trim(),
      status,
      code: normalizeServerErrorCode(data.code),
    };
  }

  if (data.error && typeof data.error === "object") {
    const errObject = data.error as { message?: unknown; code?: unknown; status?: unknown };
    const message =
      typeof errObject.message === "string" && errObject.message.trim()
        ? errObject.message.trim()
        : null;
    if (!message) return null;

    const status =
      typeof errObject.status === "number"
        ? errObject.status
        : typeof data.status === "number"
          ? data.status
          : undefined;
    return {
      message,
      status,
      code: normalizeServerErrorCode(errObject.code ?? data.code),
    };
  }

  return null;
}

function extractTextValue(value: unknown): string | null {
  if (typeof value === "string" && value) return value;
  if (!value || typeof value !== "object") return null;
  const obj = value as { text?: unknown; content?: unknown; output_text?: unknown; delta?: unknown };
  if (typeof obj.text === "string" && obj.text) return obj.text;
  if (typeof obj.content === "string" && obj.content) return obj.content;
  if (typeof obj.output_text === "string" && obj.output_text) return obj.output_text;
  if (typeof obj.delta === "string" && obj.delta) return obj.delta;
  return null;
}

function isItemDeltaEventType(eventType: string | null): boolean {
  if (!eventType) return false;
  if (eventType === "item/delta" || eventType === "item.delta") return true;
  if (/^item\/[^/]+\/delta$/.test(eventType)) return true;
  if (/^item\.[^.]+\.delta$/.test(eventType)) return true;
  return false;
}

function isItemCompletedEventType(eventType: string | null): boolean {
  if (!eventType) return false;
  if (eventType === "item/completed" || eventType === "item.completed") return true;
  if (/^item\/[^/]+\/completed$/.test(eventType)) return true;
  if (/^item\.[^.]+\.completed$/.test(eventType)) return true;
  return false;
}

function isResponseOutputTextDelta(responseType: string | null): boolean {
  return responseType === "response.output_text.delta";
}

function isResponseOutputTextDone(responseType: string | null): boolean {
  return responseType === "response.output_text.done";
}

export interface EnhanceThreadOptions {
  modelReasoningEffort?: "minimal" | "low" | "medium" | "high" | "xhigh";
  webSearchEnabled?: boolean;
}

export interface EnhanceBuilderFields {
  role: string;
  context: string;
  task: string;
  outputFormat: string;
  examples: string;
  guardrails: string;
}

function isRenderableItemType(itemType: string | null): boolean {
  if (!itemType) return true;
  const normalized = itemType.trim().toLowerCase();
  if (!normalized) return true;

  return (
    normalized === "agent_message" ||
    normalized === "assistant_message" ||
    normalized === "enhancement" ||
    normalized === "output_text" ||
    normalized === "text" ||
    normalized === "message"
  );
}

function shouldEmitSseText(meta: {
  eventType: string | null;
  responseType: string | null;
  itemType: string | null;
}): boolean {
  if (isResponseOutputTextDelta(meta.responseType) || isResponseOutputTextDone(meta.responseType)) {
    return true;
  }

  if (isItemDeltaEventType(meta.eventType) || isItemCompletedEventType(meta.eventType)) {
    return isRenderableItemType(meta.itemType);
  }

  return true;
}

export function extractSseText(payload: unknown): string | null {
  if (!payload || typeof payload !== "object") return null;
  const data = payload as {
    choices?: Array<{ delta?: { content?: unknown } }>;
    event?: unknown;
    type?: unknown;
    delta?: unknown;
    output_text?: unknown;
    text?: unknown;
    payload?: unknown;
    item?: unknown;
  };

  const chatCompletionsDelta = data.choices?.[0]?.delta?.content;
  if (typeof chatCompletionsDelta === "string" && chatCompletionsDelta) {
    return chatCompletionsDelta;
  }

  // Codex-style turn/item streaming event shape.
  const eventType =
    typeof data.event === "string"
      ? data.event
      : typeof data.type === "string"
        ? data.type
        : null;
  const responseType = typeof data.type === "string" ? data.type : null;

  if (isItemDeltaEventType(eventType) || isResponseOutputTextDelta(responseType)) {
    return (
      extractTextValue(data.delta) ||
      extractTextValue((data.item as { delta?: unknown } | undefined)?.delta) ||
      extractTextValue((data.payload as { delta?: unknown } | undefined)?.delta) ||
      extractTextValue(data.item)
    );
  }

  if (isItemCompletedEventType(eventType) || isResponseOutputTextDone(responseType)) {
    return (
      extractTextValue(data.text) ||
      extractTextValue((data.payload as { text?: unknown; output_text?: unknown } | undefined)?.text) ||
      extractTextValue(
        (data.payload as { text?: unknown; output_text?: unknown } | undefined)?.output_text,
      ) ||
      extractTextValue((data.item as { text?: unknown; output_text?: unknown } | undefined)?.text) ||
      extractTextValue((data.item as { text?: unknown; output_text?: unknown } | undefined)?.output_text) ||
      extractTextValue(data.output_text)
    );
  }

  // Responses API streaming event shape.
  if (isResponseOutputTextDelta(responseType) && typeof data.delta === "string" && data.delta) {
    return data.delta;
  }

  // Fallback for any adapter that emits output_text directly.
  if (typeof data.output_text === "string" && data.output_text) {
    return data.output_text;
  }

  return null;
}

export function readSseEventMeta(payload: unknown): {
  eventType: string | null;
  responseType: string | null;
  threadId: string | null;
  turnId: string | null;
  itemId: string | null;
  itemType: string | null;
} {
  if (!payload || typeof payload !== "object") {
    return {
      eventType: null,
      responseType: null,
      threadId: null,
      turnId: null,
      itemId: null,
      itemType: null,
    };
  }

  const data = payload as {
    event?: unknown;
    type?: unknown;
    thread_id?: unknown;
    turn_id?: unknown;
    item_id?: unknown;
    item_type?: unknown;
    item?: unknown;
  };
  const responseType =
    typeof data.type === "string" && data.type.startsWith("response.") ? data.type : null;
  const eventType =
    typeof data.event === "string"
      ? data.event
      : responseType ||
      (typeof data.type === "string"
        ? data.type
        : null);

  const threadId = typeof data.thread_id === "string" ? data.thread_id : null;
  const turnId = typeof data.turn_id === "string" ? data.turn_id : null;

  const itemId =
    typeof data.item_id === "string"
      ? data.item_id
      : typeof (data.item as { id?: unknown } | undefined)?.id === "string"
        ? ((data.item as { id?: unknown } | undefined)?.id as string)
        : null;

  const itemType =
    typeof data.item_type === "string"
      ? data.item_type
      : typeof (data.item as { type?: unknown } | undefined)?.type === "string"
        ? ((data.item as { type?: unknown } | undefined)?.type as string)
        : null;

  return { eventType, responseType, threadId, turnId, itemId, itemType };
}

type WebSocketEnhanceOutcome =
  | { outcome: "completed" }
  | { outcome: "aborted" }
  | { outcome: "fallback" }
  | { outcome: "error"; error: AIClientError };

async function streamEnhanceViaWebSocket({
  payload,
  signal,
  didTimeout,
  connectTimeoutMs,
  onDelta,
  onEvent,
}: {
  payload: Record<string, unknown>;
  signal: AbortSignal;
  didTimeout: () => boolean;
  connectTimeoutMs: number;
  onDelta: (text: string) => void;
  onEvent?: (event: {
    eventType: string | null;
    responseType: string | null;
    threadId: string | null;
    turnId: string | null;
    itemId: string | null;
    itemType: string | null;
    payload: unknown;
  }) => void;
}): Promise<WebSocketEnhanceOutcome> {
  if (typeof globalThis.WebSocket !== "function") {
    return { outcome: "fallback" };
  }

  let accessToken: string;
  try {
    accessToken = await getAccessTokenWithBootstrap();
  } catch (error) {
    return {
      outcome: "error",
      error: normalizeClientError("enhance-prompt", error),
    };
  }

  const url = enhanceWebSocketUrl();
  const protocols = buildEnhanceWebSocketProtocols();
  const requestBody = buildEnhanceWebSocketStartMessage(payload, accessToken);

  return new Promise<WebSocketEnhanceOutcome>((resolve) => {
    let ws: WebSocket;
    try {
      ws = new WebSocket(url, protocols);
    } catch {
      resolve({ outcome: "fallback" });
      return;
    }

    let resolved = false;
    let sawPayload = false;
    let hasOpened = false;
    let streamDone = false;
    let terminalError: AIClientError | null = null;
    let connectTimeoutHandle: ReturnType<typeof globalThis.setTimeout> | null = null;
    const deltaItemIds = new Set<string>();

    const resolveOnce = (value: WebSocketEnhanceOutcome) => {
      if (resolved) return;
      resolved = true;
      signal.removeEventListener("abort", onAbort);
      if (connectTimeoutHandle !== null) {
        globalThis.clearTimeout(connectTimeoutHandle);
        connectTimeoutHandle = null;
      }
      resolve(value);
    };

    const onAbort = () => {
      const abortReason = getAbortSignalReason(signal);
      let abortOutcome: WebSocketEnhanceOutcome;

      if (
        (isAIClientError(abortReason) && abortReason.code === "request_timeout")
        || didTimeout()
      ) {
        const timeoutError = isAIClientError(abortReason)
          ? abortReason
          : new AIClientError({
            message: timeoutMessage("enhance-prompt"),
            code: "request_timeout",
            retryable: true,
          });
        abortOutcome = { outcome: "error", error: timeoutError };
      } else {
        abortOutcome = { outcome: "aborted" };
      }

      resolveOnce(abortOutcome);
      try {
        ws.close(1000, "client_abort");
      } catch {
        // Ignore close races.
      }
    };

    if (signal.aborted) {
      onAbort();
      return;
    }
    signal.addEventListener("abort", onAbort, { once: true });

    connectTimeoutHandle = globalThis.setTimeout(() => {
      if (resolved || hasOpened || sawPayload) return;
      resolveOnce({ outcome: "fallback" });
      try {
        ws.close(1000, "connect_timeout");
      } catch {
        // Ignore close races.
      }
    }, connectTimeoutMs);

    ws.addEventListener("open", () => {
      hasOpened = true;
      if (signal.aborted) {
        onAbort();
        return;
      }
      ws.send(JSON.stringify(requestBody));
    });

    ws.addEventListener("message", (event) => {
      sawPayload = true;
      const rawData = typeof event.data === "string" ? event.data : "";
      if (!rawData) return;

      let parsed: unknown;
      try {
        parsed = JSON.parse(rawData);
      } catch {
        return;
      }

      const streamType = (parsed as { type?: unknown }).type;
      if (streamType === "stream.done") {
        streamDone = true;
        try {
          ws.close(1000, "done");
        } catch {
          // Ignore close races.
        }
        return;
      }

      const parsedError = extractSseErrorDetails(parsed);
      if (parsedError) {
        terminalError = normalizeClientError("enhance-prompt", parsedError.message, {
          status: parsedError.status,
          code: parsedError.code,
        });
        try {
          ws.close(1011, "turn_error");
        } catch {
          // Ignore close races.
        }
        return;
      }

      const meta = readSseEventMeta(parsed);
      onEvent?.({ ...meta, payload: parsed });

      if (isItemDeltaEventType(meta.eventType) || isResponseOutputTextDelta(meta.responseType)) {
        if (meta.itemId) deltaItemIds.add(meta.itemId);
      }
      if (
        (isItemCompletedEventType(meta.eventType) || isResponseOutputTextDone(meta.responseType)) &&
        meta.itemId &&
        deltaItemIds.has(meta.itemId)
      ) {
        return;
      }

      if (!shouldEmitSseText(meta)) {
        return;
      }

      const content = extractSseText(parsed);
      if (content) onDelta(content);
    });

    ws.addEventListener("close", () => {
      if (signal.aborted) {
        resolveOnce({ outcome: "aborted" });
        return;
      }

      if (terminalError) {
        resolveOnce({ outcome: "error", error: terminalError });
        return;
      }

      if (streamDone) {
        resolveOnce({ outcome: "completed" });
        return;
      }

      if (!sawPayload) {
        resolveOnce({ outcome: "fallback" });
        return;
      }

      resolveOnce({
        outcome: "error",
        error: new AIClientError({
          message: serviceUnavailableMessage("enhance-prompt"),
          code: "network_unavailable",
          retryable: true,
        }),
      });
    });

    ws.addEventListener("error", () => {
      if (!sawPayload) {
        try {
          ws.close();
        } catch {
          // Ignore close races.
        }
      }
    });
  });
}


export async function streamEnhance({
  prompt,
  threadId,
  threadOptions,
  builderMode,
  builderFields,
  onDelta,
  onDone,
  onError,
  onEvent,
  signal,
  timeoutMs = ENHANCE_REQUEST_TIMEOUT_MS,
}: {
  prompt: string;
  threadId?: string;
  threadOptions?: EnhanceThreadOptions;
  builderMode?: "quick" | "guided" | "advanced";
  builderFields?: EnhanceBuilderFields;
  onDelta: (text: string) => void;
  onDone: () => void;
  onError: (error: AIClientError) => void;
  onEvent?: (event: {
    eventType: string | null;
    responseType: string | null;
    threadId: string | null;
    turnId: string | null;
    itemId: string | null;
    itemType: string | null;
    payload: unknown;
  }) => void;
  signal?: AbortSignal;
  timeoutMs?: number;
}) {
  const requestController = new AbortController();
  const linkSignalAbort = (sourceSignal?: AbortSignal) => {
    if (!sourceSignal) return () => undefined;
    if (sourceSignal.aborted) {
      requestController.abort(getAbortSignalReason(sourceSignal));
      return () => undefined;
    }

    const onAbort = () => {
      requestController.abort(getAbortSignalReason(sourceSignal));
    };
    sourceSignal.addEventListener("abort", onAbort, { once: true });
    return () => {
      sourceSignal.removeEventListener("abort", onAbort);
    };
  };

  const unlinkExternalSignal = linkSignalAbort(signal);
  let timeoutTriggered = false;
  let timeoutHandle: ReturnType<typeof globalThis.setTimeout> | null = null;
  if (typeof timeoutMs === "number" && Number.isFinite(timeoutMs) && timeoutMs > 0) {
    timeoutHandle = globalThis.setTimeout(() => {
      timeoutTriggered = true;
      requestController.abort(
        new AIClientError({
          message: timeoutMessage("enhance-prompt"),
          code: "request_timeout",
          retryable: true,
        }),
      );
    }, timeoutMs);
  }

  let reader: ReadableStreamDefaultReader<Uint8Array> | null = null;

  try {
    const payload: Record<string, unknown> = { prompt };
    const normalizedThreadId = typeof threadId === "string" ? threadId.trim() : "";
    if (normalizedThreadId) {
      payload.thread_id = normalizedThreadId;
    }
    if (threadOptions && typeof threadOptions === "object") {
      payload.thread_options = threadOptions;
    }
    if (builderMode) {
      payload.builder_mode = builderMode;
    }
    if (builderFields && typeof builderFields === "object") {
      payload.builder_fields = {
        role: typeof builderFields.role === "string" ? builderFields.role : "",
        context: typeof builderFields.context === "string" ? builderFields.context : "",
        task: typeof builderFields.task === "string" ? builderFields.task : "",
        output_format: typeof builderFields.outputFormat === "string" ? builderFields.outputFormat : "",
        examples: typeof builderFields.examples === "string" ? builderFields.examples : "",
        guardrails: typeof builderFields.guardrails === "string" ? builderFields.guardrails : "",
      };
    }

    const shouldTryWebSocket =
      ENHANCE_TRANSPORT_MODE !== "sse"
      && typeof globalThis.WebSocket === "function";
    if (shouldTryWebSocket) {
      const resolvedConnectTimeoutMs =
        typeof timeoutMs === "number" && Number.isFinite(timeoutMs) && timeoutMs > 0
          ? Math.max(250, Math.min(ENHANCE_WS_CONNECT_TIMEOUT_MS, Math.floor(timeoutMs * 0.35)))
          : ENHANCE_WS_CONNECT_TIMEOUT_MS;
      const wsResult = await streamEnhanceViaWebSocket({
        payload,
        signal: requestController.signal,
        didTimeout: () => timeoutTriggered,
        connectTimeoutMs: resolvedConnectTimeoutMs,
        onDelta,
        onEvent,
      });

      if (wsResult.outcome === "completed") {
        onDone();
        return;
      }
      if (wsResult.outcome === "aborted") {
        return;
      }
      if (wsResult.outcome === "error") {
        if (
          ENHANCE_TRANSPORT_MODE === "auto"
          && (
            (wsResult.error.retryable && wsResult.error.code !== "request_timeout")
            || wsResult.error.code === "auth_session_invalid"
            || wsResult.error.code === "auth_required"
          )
        ) {
          // Fall through to SSE transport as a compatibility fallback.
        } else {
          onError(wsResult.error);
          return;
        }
      } else if (wsResult.outcome === "fallback") {
        if (ENHANCE_TRANSPORT_MODE === "ws") {
          onError(new AIClientError({
            message: serviceUnavailableMessage("enhance-prompt"),
            code: "network_unavailable",
            retryable: true,
          }));
          return;
        }
      } else {
        return;
      }
    }

    const resp = await postFunctionWithAuthRecovery("enhance-prompt", payload, {
      signal: requestController.signal,
    });

    if (!resp.body) {
      onError(new AIClientError({
        message: "No response body from enhancement service.",
        code: "bad_response",
      }));
      return;
    }

    reader = resp.body.getReader();
    const decoder = new TextDecoder();
    let textBuffer = "";
    let streamDone = false;
    let terminalError: AIClientError | null = null;
    const deltaItemIds = new Set<string>();

    while (!streamDone) {
      const { done, value } = await reader.read();
      if (done) break;
      textBuffer += decoder.decode(value, { stream: true });

      let newlineIndex: number;
      while ((newlineIndex = textBuffer.indexOf("\n")) !== -1) {
        let line = textBuffer.slice(0, newlineIndex);
        textBuffer = textBuffer.slice(newlineIndex + 1);

        if (line.endsWith("\r")) line = line.slice(0, -1);
        if (line.startsWith(":") || line.trim() === "") continue;
        if (!line.startsWith("data: ")) continue;

        const jsonStr = line.slice(6).trim();
        if (jsonStr === "[DONE]") {
          streamDone = true;
          break;
        }

        try {
          const parsed = JSON.parse(jsonStr);
          const parsedError = extractSseErrorDetails(parsed);
          if (parsedError) {
            terminalError = normalizeClientError("enhance-prompt", parsedError.message, {
              status: parsedError.status,
              code: parsedError.code,
            });
            streamDone = true;
            break;
          }

          const meta = readSseEventMeta(parsed);
          onEvent?.({ ...meta, payload: parsed });

          if (isItemDeltaEventType(meta.eventType) || isResponseOutputTextDelta(meta.responseType)) {
            if (meta.itemId) deltaItemIds.add(meta.itemId);
          }
          if (
            (isItemCompletedEventType(meta.eventType) || isResponseOutputTextDone(meta.responseType)) &&
            meta.itemId &&
            deltaItemIds.has(meta.itemId)
          ) {
            continue;
          }

          if (!shouldEmitSseText(meta)) {
            continue;
          }

          const content = extractSseText(parsed);
          if (content) onDelta(content);
        } catch {
          textBuffer = line + "\n" + textBuffer;
          break;
        }
      }
    }

    if (terminalError) {
      onError(terminalError);
      return;
    }

    // Final flush
    if (textBuffer.trim()) {
      for (let raw of textBuffer.split("\n")) {
        if (!raw) continue;
        if (raw.endsWith("\r")) raw = raw.slice(0, -1);
        if (raw.startsWith(":") || raw.trim() === "") continue;
        if (!raw.startsWith("data: ")) continue;
        const jsonStr = raw.slice(6).trim();
        if (jsonStr === "[DONE]") continue;
        try {
          const parsed = JSON.parse(jsonStr);
          const parsedError = extractSseErrorDetails(parsed);
          if (parsedError) {
            terminalError = normalizeClientError("enhance-prompt", parsedError.message, {
              status: parsedError.status,
              code: parsedError.code,
            });
            break;
          }

          const meta = readSseEventMeta(parsed);
          onEvent?.({ ...meta, payload: parsed });

          if (isItemDeltaEventType(meta.eventType) || isResponseOutputTextDelta(meta.responseType)) {
            if (meta.itemId) deltaItemIds.add(meta.itemId);
          }
          if (
            (isItemCompletedEventType(meta.eventType) || isResponseOutputTextDone(meta.responseType)) &&
            meta.itemId &&
            deltaItemIds.has(meta.itemId)
          ) {
            continue;
          }

          if (!shouldEmitSseText(meta)) {
            continue;
          }

          const content = extractSseText(parsed);
          if (content) onDelta(content);
        } catch {
          /* ignore */
        }
      }
    }

    if (terminalError) {
      onError(terminalError);
      return;
    }

    onDone();
  } catch (e) {
    const abortReason = requestController.signal.aborted
      ? getAbortSignalReason(requestController.signal)
      : null;
    const normalizedError = normalizeClientError("enhance-prompt", abortReason ?? e);
    if (normalizedError.code === "request_aborted") {
      return;
    }

    console.error("Stream error:", normalizedError);
    onError(normalizedError);
  } finally {
    unlinkExternalSignal();
    if (timeoutHandle !== null) {
      globalThis.clearTimeout(timeoutHandle);
    }
    if (reader) {
      await reader.cancel().catch(() => undefined);
    }
  }
}

export async function extractUrl(url: string): Promise<{ title: string; content: string }> {
  const resp = await postFunctionWithAuthRecovery("extract-url", { url });

  return resp.json();
}

export interface InferBuilderFieldsInput {
  prompt: string;
  sourceSummaries?: string[];
  currentFields?: {
    role?: string;
    tone?: string;
    lengthPreference?: string;
    format?: string[];
    constraints?: string[];
  };
  lockMetadata?: Record<string, "ai" | "user" | "empty">;
}

export interface InferBuilderFieldsOutput {
  inferredUpdates?: {
    role?: string;
    tone?: string;
    lengthPreference?: string;
    format?: string[];
    constraints?: string[];
  };
  inferredFields?: string[];
  suggestionChips?: Array<{
    id?: string;
    label?: string;
    description?: string;
    action?: {
      type?: string;
      updates?: Record<string, unknown>;
      fields?: string[];
      text?: string;
    };
  }>;
  confidence?: Record<string, number>;
}

export async function inferBuilderFields(
  input: InferBuilderFieldsInput,
): Promise<InferBuilderFieldsOutput> {
  const prompt = input.prompt.trim();
  if (!prompt) {
    return {
      inferredUpdates: {},
      inferredFields: [],
      suggestionChips: [],
    };
  }

  const payload: Record<string, unknown> = {
    prompt,
  };

  if (Array.isArray(input.sourceSummaries) && input.sourceSummaries.length > 0) {
    payload.source_summaries = input.sourceSummaries;
  }
  if (input.currentFields && typeof input.currentFields === "object") {
    payload.current_fields = input.currentFields;
  }
  if (input.lockMetadata && typeof input.lockMetadata === "object") {
    payload.lock_metadata = input.lockMetadata;
  }

  const resp = await postFunctionWithAuthRecovery("infer-builder-fields", payload);
  const data = await resp.json().catch(() => ({}));

  return data && typeof data === "object"
    ? (data as InferBuilderFieldsOutput)
    : {
      inferredUpdates: {},
      inferredFields: [],
      suggestionChips: [],
    };
}
````

## File: src/lib/community.ts
````typescript
import { neon } from "@/integrations/neon/client";
import type { Json } from "@/integrations/neon/types";
import { assertBackendConfigured } from "@/lib/backend-config";
import { normalizePromptCategory } from "@/lib/prompt-categories";
import type { PromptConfig } from "@/lib/prompt-builder";
import { defaultConfig } from "@/lib/prompt-builder";
import {
  deletePrompt as deleteSavedPromptForUser,
  sharePrompt as shareSavedPromptForUser,
  unsharePrompt as unshareSavedPromptForUser,
} from "@/lib/persistence";
import {
  escapePostgrestLikePattern,
  isPostgrestError,
  normalizePromptTags,
  sanitizePostgresJson,
  sanitizePostgresText,
  type SavedPromptRow,
} from "@/lib/saved-prompt-shared";
import {
  collectTemplateWarnings,
  computeTemplateFingerprint,
  inferTemplateStarterPrompt,
  normalizeTemplateConfig,
} from "@/lib/template-store";
import { assertCommunityTextAllowed } from "@/lib/content-moderation";

const SAVED_PROMPT_SELECT_COLUMNS =
  "id, user_id, title, description, category, tags, config, built_prompt, enhanced_prompt, fingerprint, revision, is_shared, target_model, use_case, remixed_from, remix_note, remix_diff, created_at, updated_at";
const COMMUNITY_POST_SELECT_COLUMNS_BASE =
  "id, saved_prompt_id, author_id, title, enhanced_prompt, description, use_case, category, tags, target_model, is_public, public_config, starter_prompt, remixed_from, remix_note, remix_diff, upvote_count, verified_count, remix_count, comment_count, created_at, updated_at";
const COMMUNITY_POST_SELECT_COLUMNS =
  `${COMMUNITY_POST_SELECT_COLUMNS_BASE}, rating_count, rating_avg`;

export type PromptSort = "recent" | "name" | "revision";
export type CommunitySort = "new" | "popular" | "most_remixed" | "verified";
export type VoteType = "upvote" | "verified";
export interface VoteState {
  upvote: boolean;
  verified: boolean;
}

export interface SavedPromptSummary {
  id: string;
  title: string;
  description: string;
  category: string;
  tags: string[];
  starterPrompt: string;
  updatedAt: number;
  createdAt: number;
  revision: number;
  schemaVersion: number;
  sourceCount: number;
  databaseCount: number;
  ragEnabled: boolean;
  isShared: boolean;
  targetModel: string;
  useCase: string;
  remixedFrom: string | null;
}

export interface SavedPromptRecord {
  id: string;
  userId: string;
  title: string;
  description: string;
  category: string;
  tags: string[];
  config: PromptConfig;
  builtPrompt: string;
  enhancedPrompt: string;
  fingerprint: string;
  revision: number;
  isShared: boolean;
  targetModel: string;
  useCase: string;
  remixedFrom: string | null;
  remixNote: string;
  remixDiff: Json | null;
  createdAt: number;
  updatedAt: number;
}

export interface SavePromptInput {
  id?: string;
  title: string;
  description?: string;
  category?: string;
  tags?: string[];
  config: PromptConfig;
  builtPrompt?: string;
  enhancedPrompt?: string;
  targetModel?: string;
  useCase?: string;
  isShared?: boolean;
  remixedFrom?: string | null;
  remixNote?: string;
  remixDiff?: Json | null;
}

export interface SavePromptResult {
  outcome: "created" | "updated" | "unchanged";
  prompt: SavedPromptRecord;
  warnings: string[];
}

export interface ListMyPromptsInput {
  query?: string;
  category?: string;
  tag?: string;
  sort?: PromptSort;
  limit?: number;
}

export interface LoadFeedInput {
  sort?: CommunitySort;
  category?: string;
  search?: string;
  cursor?: string;
  page?: number;
  limit?: number;
}

export interface LoadCommentsInput {
  limit?: number;
  cursor?: string;
}

export interface CommunityPost {
  id: string;
  savedPromptId: string;
  authorId: string;
  title: string;
  enhancedPrompt: string;
  description: string;
  useCase: string;
  category: string;
  tags: string[];
  targetModel: string;
  isPublic: boolean;
  publicConfig: PromptConfig;
  starterPrompt: string;
  remixedFrom: string | null;
  remixNote: string;
  remixDiff: Json | null;
  upvoteCount: number;
  verifiedCount: number;
  remixCount: number;
  commentCount: number;
  ratingCount?: number;
  ratingAverage?: number;
  createdAt: number;
  updatedAt: number;
}

export interface CommunityComment {
  id: string;
  postId: string;
  userId: string;
  body: string;
  createdAt: number;
  updatedAt: number;
}

export interface CommunityProfile {
  id: string;
  displayName: string;
  avatarUrl: string | null;
  createdAt?: number | null;
}

export interface FollowStats {
  followersCount: number;
  followingCount: number;
}

export interface ProfileActivityStats {
  totalPosts: number;
  totalUpvotes: number;
  totalVerified: number;
  averageRating: number;
}

export interface RemixDiff {
  changes: Array<{
    field: string;
    from: string | string[];
    to: string | string[];
  }>;
  added_tags: string[];
  removed_tags: string[];
  category_changed: boolean;
}

interface CommunityPostRow {
  id: string;
  saved_prompt_id: string;
  author_id: string;
  title: string;
  enhanced_prompt: string;
  description: string;
  use_case: string;
  category: string;
  tags: string[] | null;
  target_model: string;
  is_public: boolean;
  public_config: Json;
  starter_prompt: string;
  remixed_from: string | null;
  remix_note: string;
  remix_diff: Json | null;
  upvote_count: number;
  verified_count: number;
  remix_count: number;
  comment_count: number;
  rating_count?: number | null;
  rating_avg?: number | null;
  created_at: string;
  updated_at: string;
}

interface CommunityCommentRow {
  id: string;
  post_id: string;
  user_id: string;
  body: string;
  created_at: string;
  updated_at: string;
}

interface CommunityProfileRow {
  id: string;
  display_name: string | null;
  avatar_url: string | null;
  created_at?: string | null;
}

function clampText(value: string | undefined, max: number): string {
  return sanitizePostgresText(value || "").trim().slice(0, max);
}

function clampTitle(value: string): string {
  const normalized = sanitizePostgresText(value).trim().slice(0, 200);
  return normalized || "Untitled Prompt";
}

function mapSavedPromptRow(row: SavedPromptRow): SavedPromptRecord {
  const cfg = normalizeTemplateConfig((row.config ?? defaultConfig) as unknown as PromptConfig);
  return {
    id: row.id,
    userId: row.user_id,
    title: row.title,
    description: row.description,
    category: row.category,
    tags: row.tags ?? [],
    config: cfg,
    builtPrompt: row.built_prompt,
    enhancedPrompt: row.enhanced_prompt,
    fingerprint: row.fingerprint ?? "",
    revision: row.revision,
    isShared: row.is_shared,
    targetModel: row.target_model,
    useCase: row.use_case,
    remixedFrom: row.remixed_from,
    remixNote: row.remix_note,
    remixDiff: row.remix_diff,
    createdAt: new Date(row.created_at).getTime(),
    updatedAt: new Date(row.updated_at).getTime(),
  };
}

function mapSavedPromptSummary(row: SavedPromptRow): SavedPromptSummary {
  const cfg = normalizeTemplateConfig((row.config ?? defaultConfig) as unknown as PromptConfig);
  return {
    id: row.id,
    title: row.title,
    description: row.description,
    category: row.category,
    tags: row.tags ?? [],
    starterPrompt: inferTemplateStarterPrompt(cfg),
    updatedAt: new Date(row.updated_at).getTime(),
    createdAt: new Date(row.created_at).getTime(),
    revision: row.revision,
    schemaVersion: 2,
    sourceCount: cfg.contextConfig.sources.length,
    databaseCount: cfg.contextConfig.databaseConnections.length,
    ragEnabled: cfg.contextConfig.rag.enabled,
    isShared: row.is_shared,
    targetModel: row.target_model,
    useCase: row.use_case,
    remixedFrom: row.remixed_from,
  };
}

function mapCommunityPost(row: CommunityPostRow): CommunityPost {
  return {
    id: row.id,
    savedPromptId: row.saved_prompt_id,
    authorId: row.author_id,
    title: row.title,
    enhancedPrompt: row.enhanced_prompt,
    description: row.description,
    useCase: row.use_case,
    category: row.category,
    tags: row.tags ?? [],
    targetModel: row.target_model,
    isPublic: row.is_public,
    publicConfig: normalizeTemplateConfig((row.public_config ?? defaultConfig) as unknown as PromptConfig),
    starterPrompt: row.starter_prompt,
    remixedFrom: row.remixed_from,
    remixNote: row.remix_note,
    remixDiff: row.remix_diff,
    upvoteCount: row.upvote_count,
    verifiedCount: row.verified_count,
    remixCount: row.remix_count,
    commentCount: row.comment_count,
    ratingCount: typeof row.rating_count === "number" ? row.rating_count : 0,
    ratingAverage: typeof row.rating_avg === "number" ? row.rating_avg : 0,
    createdAt: new Date(row.created_at).getTime(),
    updatedAt: new Date(row.updated_at).getTime(),
  };
}

function mapCommunityComment(row: CommunityCommentRow): CommunityComment {
  return {
    id: row.id,
    postId: row.post_id,
    userId: row.user_id,
    body: row.body,
    createdAt: new Date(row.created_at).getTime(),
    updatedAt: new Date(row.updated_at).getTime(),
  };
}

function mapCommunityProfile(row: CommunityProfileRow): CommunityProfile {
  return {
    id: row.id,
    displayName: row.display_name?.trim() || "Community member",
    avatarUrl: row.avatar_url?.trim() || null,
    createdAt: row.created_at ? new Date(row.created_at).getTime() : null,
  };
}

function toError(error: unknown, fallback: string): Error {
  if (error instanceof Error) return error;
  if (isPostgrestError(error)) {
    const detail = [error.message, error.details, error.hint].filter(Boolean).join(" ");
    if (/unsupported unicode escape sequence|\\u0000 cannot be converted to text/i.test(detail)) {
      return new Error("Prompt text contains unsupported characters. Please remove hidden control characters.");
    }
    return new Error(error.message || fallback);
  }
  return new Error(fallback);
}

function isInvalidUuidInputError(error: unknown): boolean {
  if (!isPostgrestError(error)) return false;
  if (error.code === "22P02") return true;
  return error.message.toLowerCase().includes("invalid input syntax for type uuid");
}

function isMissingCommunityRatingColumnsError(error: unknown): boolean {
  if (!isPostgrestError(error) || error.code !== "42703") return false;
  const detail = [error.message, error.details, error.hint].filter(Boolean).join(" ").toLowerCase();
  return detail.includes("rating_count") || detail.includes("rating_avg");
}

async function runCommunityPostsSelect<T>(
  execute: (selectColumns: string) => PromiseLike<{ data: T; error: unknown | null }>,
): Promise<{ data: T; error: unknown | null }> {
  const primary = await execute(COMMUNITY_POST_SELECT_COLUMNS);
  if (!primary.error || !isMissingCommunityRatingColumnsError(primary.error)) {
    return primary;
  }
  return execute(COMMUNITY_POST_SELECT_COLUMNS_BASE);
}

function ensureCommunityBackend(featureLabel = "Community features"): void {
  assertBackendConfigured(featureLabel);
}

async function requireUserId(): Promise<string> {
  ensureCommunityBackend("Community account actions");
  const { data, error } = await neon.auth.getUser();
  if (error) throw toError(error, "Authentication failed.");
  const user = data.user;
  if (!user?.id) {
    throw new Error("Sign in required.");
  }
  return user.id;
}

export async function listMyPrompts(input: ListMyPromptsInput = {}): Promise<SavedPromptSummary[]> {
  ensureCommunityBackend("Community prompts");
  const { query, category, tag, sort = "recent", limit = 100 } = input;
  const userId = await requireUserId();

  try {
    let builder = neon
      .from("saved_prompts")
      .select(SAVED_PROMPT_SELECT_COLUMNS)
      .eq("user_id", userId)
      .limit(Math.min(Math.max(limit, 1), 200));

    if (category && category !== "all") {
      builder = builder.eq("category", category);
    }

    if (tag) {
      builder = builder.contains("tags", [tag.toLowerCase()]);
    }

    if (query?.trim()) {
      const escaped = escapePostgrestLikePattern(query.trim());
      builder = builder.or(
        `title.ilike.%${escaped}%,description.ilike.%${escaped}%,use_case.ilike.%${escaped}%`,
      );
    }

    if (sort === "name") {
      builder = builder.order("title", { ascending: true });
    } else if (sort === "revision") {
      builder = builder.order("revision", { ascending: false }).order("updated_at", { ascending: false });
    } else {
      builder = builder.order("updated_at", { ascending: false });
    }

    const { data, error } = await builder;
    if (error) throw error;
    return (data || []).map((row) => mapSavedPromptSummary(row as SavedPromptRow));
  } catch (error) {
    throw toError(error, "Failed to load your prompts.");
  }
}

export async function loadMyPromptById(id: string): Promise<SavedPromptRecord | null> {
  ensureCommunityBackend("Community prompts");
  const userId = await requireUserId();

  try {
    const { data, error } = await neon
      .from("saved_prompts")
      .select(SAVED_PROMPT_SELECT_COLUMNS)
      .eq("id", id)
      .eq("user_id", userId)
      .maybeSingle();

    if (error) throw error;
    if (!data) return null;
    return mapSavedPromptRow(data as SavedPromptRow);
  } catch (error) {
    throw toError(error, "Failed to load prompt.");
  }
}

export async function savePrompt(input: SavePromptInput): Promise<SavePromptResult> {
  ensureCommunityBackend("Community prompts");
  const userId = await requireUserId();
  const title = clampTitle(input.title);
  const safeConfig = sanitizePostgresJson(input.config as unknown as Json) as unknown as PromptConfig;
  const normalizedConfig = normalizeTemplateConfig(safeConfig);
  const normalizedDescription = clampText(input.description, 500);
  const normalizedCategory = normalizePromptCategory(input.category) ?? "general";
  const normalizedTags = normalizePromptTags(input.tags);
  const normalizedTargetModel = clampText(input.targetModel, 80);
  const normalizedUseCase = clampText(input.useCase, 1000);
  const normalizedBuiltPrompt = sanitizePostgresText(input.builtPrompt || "");
  const normalizedEnhancedPrompt = sanitizePostgresText(input.enhancedPrompt || "");
  const normalizedRemixNote = clampText(input.remixNote, 500);
  const normalizedRemixDiff = sanitizePostgresJson((input.remixDiff ?? null) as Json);
  const fingerprint = computeTemplateFingerprint(normalizedConfig);
  const warnings = collectTemplateWarnings(normalizedConfig);
  const persistedConfig = sanitizePostgresJson(normalizedConfig as unknown as Json);

  try {
    let existing: SavedPromptRow | null = null;

    if (input.id) {
      const { data: byId, error: byIdError } = await neon
        .from("saved_prompts")
        .select(SAVED_PROMPT_SELECT_COLUMNS)
        .eq("id", input.id)
        .eq("user_id", userId)
        .maybeSingle();
      if (byIdError) throw byIdError;
      existing = (byId as SavedPromptRow | null) || null;
    } else {
      const { data: byTitle, error: lookupError } = await neon
        .from("saved_prompts")
        .select(SAVED_PROMPT_SELECT_COLUMNS)
        .eq("user_id", userId)
        .ilike("title", escapePostgrestLikePattern(title))
        .order("updated_at", { ascending: false })
        .limit(1);

      if (lookupError) throw lookupError;
      existing = ((byTitle && byTitle[0]) as SavedPromptRow | undefined) || null;
    }

    if (existing?.fingerprint === fingerprint) {
      if (existing.is_shared !== !!input.isShared) {
        const { data: sharedRow, error: shareError } = await neon
          .from("saved_prompts")
          .update({ is_shared: !!input.isShared })
          .eq("id", existing.id)
          .eq("user_id", userId)
          .eq("revision", existing.revision)
          .select(SAVED_PROMPT_SELECT_COLUMNS)
          .maybeSingle();

        if (shareError) throw shareError;
        if (sharedRow) {
          return {
            outcome: "updated",
            prompt: mapSavedPromptRow(sharedRow as SavedPromptRow),
            warnings,
          };
        }
      }

      return {
        outcome: "unchanged",
        prompt: mapSavedPromptRow(existing),
        warnings,
      };
    }

    if (existing) {
      const updatePayload: Record<string, unknown> = {
        title,
        description: normalizedDescription,
        category: normalizedCategory,
        tags: normalizedTags,
        config: persistedConfig,
        built_prompt: normalizedBuiltPrompt,
        enhanced_prompt: normalizedEnhancedPrompt,
        fingerprint,
        revision: existing.revision + 1,
        is_shared: input.isShared ?? existing.is_shared,
        target_model: normalizedTargetModel,
        use_case: normalizedUseCase,
        remixed_from: input.remixedFrom ?? existing.remixed_from,
        remix_note: normalizedRemixNote,
        remix_diff: normalizedRemixDiff,
      };

      const { data: updated, error } = await neon
        .from("saved_prompts")
        .update(updatePayload)
        .eq("id", existing.id)
        .eq("user_id", userId)
        .eq("revision", existing.revision)
        .select(SAVED_PROMPT_SELECT_COLUMNS)
        .maybeSingle();

      if (error) throw error;
      if (!updated) {
        throw new Error("Prompt was modified elsewhere. Please refresh and try again.");
      }

      return {
        outcome: "updated",
        prompt: mapSavedPromptRow(updated as SavedPromptRow),
        warnings,
      };
    }

    const { data: created, error: insertError } = await neon
      .from("saved_prompts")
      .insert({
        user_id: userId,
        title,
        description: normalizedDescription,
        category: normalizedCategory,
        tags: normalizedTags,
        config: persistedConfig,
        built_prompt: normalizedBuiltPrompt,
        enhanced_prompt: normalizedEnhancedPrompt,
        fingerprint,
        is_shared: !!input.isShared,
        target_model: normalizedTargetModel,
        use_case: normalizedUseCase,
        remixed_from: input.remixedFrom ?? null,
        remix_note: normalizedRemixNote,
        remix_diff: normalizedRemixDiff,
      })
      .select(SAVED_PROMPT_SELECT_COLUMNS)
      .single();

    if (insertError) throw insertError;
    if (!created) throw new Error("Prompt save returned no data.");

    return {
      outcome: "created",
      prompt: mapSavedPromptRow(created as SavedPromptRow),
      warnings,
    };
  } catch (error) {
    throw toError(error, "Failed to save prompt.");
  }
}

export async function deletePrompt(id: string): Promise<boolean> {
  ensureCommunityBackend("Community prompts");
  const userId = await requireUserId();

  try {
    return await deleteSavedPromptForUser(userId, id);
  } catch (error) {
    throw toError(error, "Failed to delete prompt.");
  }
}

export async function sharePrompt(
  savedPromptId: string,
  shareMeta?: {
    useCase?: string;
    targetModel?: string;
    category?: string;
    tags?: string[];
    title?: string;
    description?: string;
  },
): Promise<boolean> {
  ensureCommunityBackend("Community sharing");
  const userId = await requireUserId();

  try {
    const result = await shareSavedPromptForUser(userId, savedPromptId, {
      useCase: shareMeta?.useCase,
      targetModel: shareMeta?.targetModel,
      category: shareMeta?.category,
      tags: shareMeta?.tags,
      title: shareMeta?.title,
      description: shareMeta?.description,
    });
    return result.shared;
  } catch (error) {
    throw toError(error, "Failed to share prompt.");
  }
}

export async function unsharePrompt(savedPromptId: string): Promise<boolean> {
  ensureCommunityBackend("Community sharing");
  const userId = await requireUserId();

  try {
    return await unshareSavedPromptForUser(userId, savedPromptId);
  } catch (error) {
    throw toError(error, "Failed to unshare prompt.");
  }
}

export async function loadFeed(input: LoadFeedInput = {}): Promise<CommunityPost[]> {
  ensureCommunityBackend("Community feed");
  const { sort = "new", category, search, cursor, page = 0, limit = 25 } = input;
  const normalizedLimit = Math.min(Math.max(limit, 1), 100);
  const normalizedPage = Math.max(page, 0);

  try {
    const { data, error } = await runCommunityPostsSelect((selectColumns) => {
      let builder = neon
        .from("community_posts")
        .select(selectColumns)
        .eq("is_public", true)
        .limit(normalizedLimit);

      if (category && category !== "all") {
        builder = builder.eq("category", category);
      }

      if (search?.trim()) {
        const escaped = escapePostgrestLikePattern(search.trim());
        builder = builder.or(`title.ilike.%${escaped}%,use_case.ilike.%${escaped}%`);
      }

      if (cursor) {
        builder = builder.lt("created_at", cursor);
      } else if (normalizedPage > 0) {
        const start = normalizedPage * normalizedLimit;
        builder = builder.range(start, start + normalizedLimit - 1);
      }

      if (sort === "popular") {
        builder = builder.order("upvote_count", { ascending: false }).order("created_at", { ascending: false });
      } else if (sort === "most_remixed") {
        builder = builder.order("remix_count", { ascending: false }).order("created_at", { ascending: false });
      } else if (sort === "verified") {
        builder = builder.order("verified_count", { ascending: false }).order("created_at", { ascending: false });
      } else {
        builder = builder.order("created_at", { ascending: false });
      }

      return builder;
    });
    if (error) throw error;
    return (data || []).map((row) => mapCommunityPost(row as unknown as CommunityPostRow));
  } catch (error) {
    throw toError(error, "Failed to load community feed.");
  }
}

export async function loadPostsByAuthor(
  authorId: string,
  options: { page?: number; limit?: number } = {},
): Promise<CommunityPost[]> {
  ensureCommunityBackend("Community profiles");
  const { page = 0, limit = 25 } = options;
  const normalizedLimit = Math.min(Math.max(limit, 1), 100);
  const normalizedPage = Math.max(page, 0);

  try {
    const { data, error } = await runCommunityPostsSelect((selectColumns) => {
      let builder = neon
        .from("community_posts")
        .select(selectColumns)
        .eq("author_id", authorId)
        .eq("is_public", true)
        .order("created_at", { ascending: false })
        .limit(normalizedLimit);

      if (normalizedPage > 0) {
        const start = normalizedPage * normalizedLimit;
        builder = builder.range(start, start + normalizedLimit - 1);
      }

      return builder;
    });
    if (error) throw error;
    return (data || []).map((row) => mapCommunityPost(row as unknown as CommunityPostRow));
  } catch (error) {
    throw toError(error, "Failed to load profile posts.");
  }
}

export async function loadFollowingUserIds(): Promise<string[]> {
  ensureCommunityBackend("Community follows");
  const userId = await requireUserId();

  try {
    const { data, error } = await neon
      .from("community_user_follows")
      .select("followed_user_id")
      .eq("follower_id", userId);

    if (error) throw error;
    return (data || [])
      .map((row) => row.followed_user_id)
      .filter((value): value is string => Boolean(value));
  } catch (error) {
    throw toError(error, "Failed to load follow list.");
  }
}

export async function loadPersonalFeed(options: { page?: number; limit?: number } = {}): Promise<CommunityPost[]> {
  ensureCommunityBackend("Personal feed");
  const userId = await requireUserId();
  const { page = 0, limit = 25 } = options;
  const normalizedLimit = Math.min(Math.max(limit, 1), 100);
  const normalizedPage = Math.max(page, 0);

  try {
    const followedUserIds = await loadFollowingUserIds();
    const authorIds = Array.from(new Set([userId, ...followedUserIds]));
    if (authorIds.length === 0) return [];

    const { data, error } = await runCommunityPostsSelect((selectColumns) => {
      let builder = neon
        .from("community_posts")
        .select(selectColumns)
        .eq("is_public", true)
        .in("author_id", authorIds)
        .order("created_at", { ascending: false })
        .limit(normalizedLimit);

      if (normalizedPage > 0) {
        const start = normalizedPage * normalizedLimit;
        builder = builder.range(start, start + normalizedLimit - 1);
      }

      return builder;
    });
    if (error) throw error;
    return (data || []).map((row) => mapCommunityPost(row as unknown as CommunityPostRow));
  } catch (error) {
    throw toError(error, "Failed to load personal feed.");
  }
}

export async function loadPost(postId: string): Promise<CommunityPost | null> {
  ensureCommunityBackend("Community posts");
  try {
    const { data, error } = await runCommunityPostsSelect((selectColumns) =>
      neon.from("community_posts").select(selectColumns).eq("id", postId).eq("is_public", true).maybeSingle(),
    );

    if (error) throw error;
    if (!data) return null;
    return mapCommunityPost(data as unknown as CommunityPostRow);
  } catch (error) {
    if (isInvalidUuidInputError(error)) {
      throw new Error("This link is invalid or expired.");
    }
    throw toError(error, "Failed to load community post.");
  }
}

export async function loadPostsByIds(postIds: string[]): Promise<CommunityPost[]> {
  ensureCommunityBackend("Community posts");
  const uniqueIds = Array.from(new Set(postIds.filter(Boolean)));
  if (uniqueIds.length === 0) return [];

  try {
    const { data, error } = await runCommunityPostsSelect((selectColumns) =>
      neon.from("community_posts").select(selectColumns).in("id", uniqueIds).eq("is_public", true),
    );

    if (error) throw error;
    return (data || []).map((row) => mapCommunityPost(row as unknown as CommunityPostRow));
  } catch (error) {
    throw toError(error, "Failed to load related community posts.");
  }
}

export async function loadProfilesByIds(userIds: string[]): Promise<CommunityProfile[]> {
  ensureCommunityBackend("Community profiles");
  const uniqueIds = Array.from(new Set(userIds.filter(Boolean)));
  if (uniqueIds.length === 0) return [];

  try {
    const { data, error } = await neon.rpc("community_profiles_by_ids", {
      input_ids: uniqueIds,
    });

    if (error) throw error;
    return (data || []).map((row) => mapCommunityProfile(row as CommunityProfileRow));
  } catch (error) {
    throw toError(error, "Failed to load community profiles.");
  }
}

export async function loadFollowStats(userId: string): Promise<FollowStats> {
  ensureCommunityBackend("Community follows");
  if (!userId) {
    return { followersCount: 0, followingCount: 0 };
  }

  try {
    const [followersResult, followingResult] = await Promise.all([
      neon
        .from("community_user_follows")
        .select("id", { count: "exact", head: true })
        .eq("followed_user_id", userId),
      neon
        .from("community_user_follows")
        .select("id", { count: "exact", head: true })
        .eq("follower_id", userId),
    ]);

    if (followersResult.error) throw followersResult.error;
    if (followingResult.error) throw followingResult.error;

    return {
      followersCount: followersResult.count ?? 0,
      followingCount: followingResult.count ?? 0,
    };
  } catch (error) {
    throw toError(error, "Failed to load follow stats.");
  }
}

export async function loadProfileActivityStats(userId: string): Promise<ProfileActivityStats> {
  ensureCommunityBackend("Profile activity stats");
  if (!userId) {
    return { totalPosts: 0, totalUpvotes: 0, totalVerified: 0, averageRating: 0 };
  }

  try {
    const primary = await neon
      .from("community_posts")
      .select("upvote_count, verified_count, rating_avg, rating_count")
      .eq("author_id", userId)
      .eq("is_public", true);

    const fallback = isMissingCommunityRatingColumnsError(primary.error)
      ? await neon
          .from("community_posts")
          .select("upvote_count, verified_count")
          .eq("author_id", userId)
          .eq("is_public", true)
      : null;

    const data = fallback?.data ?? primary.data;
    const error = fallback?.error ?? primary.error;

    if (error) throw error;

    const rows = (data ?? []) as Array<{
      upvote_count?: number | null;
      verified_count?: number | null;
      rating_avg?: number | null;
      rating_count?: number | null;
    }>;
    const totalPosts = rows.length;
    const totalUpvotes = rows.reduce((sum, row) => sum + (row.upvote_count ?? 0), 0);
    const totalVerified = rows.reduce((sum, row) => sum + (row.verified_count ?? 0), 0);

    let averageRating = 0;
    const ratedRows = rows.filter((row) => (row.rating_count ?? 0) > 0 && typeof row.rating_avg === "number");
    if (ratedRows.length > 0) {
      const weightedSum = ratedRows.reduce(
        (sum, row) => sum + (row.rating_avg ?? 0) * (row.rating_count ?? 0),
        0,
      );
      const totalRatings = ratedRows.reduce((sum, row) => sum + (row.rating_count ?? 0), 0);
      averageRating = totalRatings > 0 ? weightedSum / totalRatings : 0;
    }

    return { totalPosts, totalUpvotes, totalVerified, averageRating };
  } catch (error) {
    throw toError(error, "Failed to load profile activity stats.");
  }
}

export async function isFollowingCommunityUser(targetUserId: string): Promise<boolean> {
  ensureCommunityBackend("Community follows");
  if (!targetUserId) return false;
  const { data: userData, error: userError } = await neon.auth.getUser();
  if (userError || !userData.user?.id) return false;
  if (userData.user.id === targetUserId) return false;

  try {
    const { data, error } = await neon
      .from("community_user_follows")
      .select("id")
      .eq("follower_id", userData.user.id)
      .eq("followed_user_id", targetUserId)
      .maybeSingle();
    if (error) throw error;
    return Boolean(data?.id);
  } catch {
    return false;
  }
}

export async function followCommunityUser(targetUserId: string): Promise<boolean> {
  ensureCommunityBackend("Community follows");
  const userId = await requireUserId();
  if (!targetUserId || targetUserId === userId) {
    throw new Error("You cannot follow your own account.");
  }

  try {
    const { data, error } = await neon
      .from("community_user_follows")
      .upsert(
        {
          follower_id: userId,
          followed_user_id: targetUserId,
        },
        {
          onConflict: "follower_id,followed_user_id",
          ignoreDuplicates: true,
        },
      )
      .select("id")
      .maybeSingle();

    if (error) throw error;
    if (data?.id) return true;

    const { data: existing, error: lookupError } = await neon
      .from("community_user_follows")
      .select("id")
      .eq("follower_id", userId)
      .eq("followed_user_id", targetUserId)
      .maybeSingle();

    if (lookupError) throw lookupError;
    return Boolean(existing?.id);
  } catch (error) {
    throw toError(error, "Failed to follow user.");
  }
}

export async function unfollowCommunityUser(targetUserId: string): Promise<boolean> {
  ensureCommunityBackend("Community follows");
  const userId = await requireUserId();

  try {
    const { data, error } = await neon
      .from("community_user_follows")
      .delete()
      .eq("follower_id", userId)
      .eq("followed_user_id", targetUserId)
      .select("id")
      .maybeSingle();

    if (error) throw error;
    return Boolean(data?.id);
  } catch (error) {
    throw toError(error, "Failed to unfollow user.");
  }
}

export async function loadRemixes(postId: string): Promise<CommunityPost[]> {
  ensureCommunityBackend("Community remixes");
  try {
    const { data, error } = await runCommunityPostsSelect((selectColumns) =>
      neon
        .from("community_posts")
        .select(selectColumns)
        .eq("remixed_from", postId)
        .eq("is_public", true)
        .order("created_at", { ascending: false }),
    );

    if (error) throw error;
    return (data || []).map((row) => mapCommunityPost(row as unknown as CommunityPostRow));
  } catch (error) {
    throw toError(error, "Failed to load remixes.");
  }
}

export async function loadMyVotes(postIds: string[]): Promise<Record<string, VoteState>> {
  ensureCommunityBackend("Community reactions");
  const uniqueIds = Array.from(new Set(postIds.filter(Boolean)));
  if (uniqueIds.length === 0) return {};

  const { data: userData, error: userError } = await neon.auth.getUser();
  if (userError) {
    return {};
  }
  if (!userData.user) {
    return {};
  }

  try {
    const { data, error } = await neon
      .from("community_votes")
      .select("post_id, vote_type")
      .eq("user_id", userData.user.id)
      .in("post_id", uniqueIds);

    if (error) throw error;
    const voteState: Record<string, VoteState> = {};
    uniqueIds.forEach((id) => {
      voteState[id] = { upvote: false, verified: false };
    });
    (data || []).forEach((row) => {
      const entry = voteState[row.post_id] ?? { upvote: false, verified: false };
      if (row.vote_type === "upvote") entry.upvote = true;
      if (row.vote_type === "verified") entry.verified = true;
      voteState[row.post_id] = entry;
    });
    return voteState;
  } catch {
    return {};
  }
}

export async function loadMyRatings(postIds: string[]): Promise<Record<string, number>> {
  ensureCommunityBackend("Community ratings");
  const uniqueIds = Array.from(new Set(postIds.filter(Boolean)));
  if (uniqueIds.length === 0) return {};

  const { data: userData, error: userError } = await neon.auth.getUser();
  if (userError || !userData.user?.id) {
    return {};
  }

  try {
    const { data, error } = await neon
      .from("community_prompt_ratings")
      .select("post_id, rating")
      .eq("user_id", userData.user.id)
      .in("post_id", uniqueIds);

    if (error) throw error;
    const ratingByPost: Record<string, number> = {};
    (data || []).forEach((row) => {
      if (typeof row.post_id === "string" && typeof row.rating === "number") {
        ratingByPost[row.post_id] = row.rating;
      }
    });
    return ratingByPost;
  } catch {
    return {};
  }
}

export async function setPromptRating(
  postId: string,
  rating: number | null,
): Promise<{ rating: number | null }> {
  ensureCommunityBackend("Community ratings");
  const userId = await requireUserId();

  if (!postId) {
    throw new Error("Prompt ID is required.");
  }

  if (rating === null) {
    try {
      const { error } = await neon
        .from("community_prompt_ratings")
        .delete()
        .eq("post_id", postId)
        .eq("user_id", userId);
      if (error) throw error;
      return { rating: null };
    } catch (error) {
      throw toError(error, "Failed to clear rating.");
    }
  }

  if (!Number.isInteger(rating) || rating < 1 || rating > 5) {
    throw new Error("Rating must be between 1 and 5.");
  }

  try {
    const { data, error } = await neon
      .from("community_prompt_ratings")
      .upsert(
        {
          post_id: postId,
          user_id: userId,
          rating,
        },
        {
          onConflict: "post_id,user_id",
        },
      )
      .select("rating")
      .maybeSingle();
    if (error) throw error;
    return { rating: typeof data?.rating === "number" ? data.rating : rating };
  } catch (error) {
    throw toError(error, "Failed to save rating.");
  }
}

export function computeNextPromptRatingSummary(input: {
  currentCount: number;
  currentAverage: number;
  previousRating: number | null;
  nextRating: number | null;
}): { ratingCount: number; ratingAverage: number } {
  const normalizedCurrentCount = Math.max(0, Math.floor(input.currentCount));
  const normalizedCurrentAverage = Number.isFinite(input.currentAverage)
    ? Math.max(0, input.currentAverage)
    : 0;
  const currentSum = normalizedCurrentAverage * normalizedCurrentCount;

  let nextCount = normalizedCurrentCount;
  let nextSum = currentSum;

  if (typeof input.previousRating === "number" && input.previousRating >= 1 && input.previousRating <= 5) {
    nextCount = Math.max(0, nextCount - 1);
    nextSum -= input.previousRating;
  }

  if (typeof input.nextRating === "number" && input.nextRating >= 1 && input.nextRating <= 5) {
    nextCount += 1;
    nextSum += input.nextRating;
  }

  if (nextCount === 0) {
    return {
      ratingCount: 0,
      ratingAverage: 0,
    };
  }

  return {
    ratingCount: nextCount,
    ratingAverage: Number((nextSum / nextCount).toFixed(2)),
  };
}

export async function toggleVote(
  postId: string,
  voteType: VoteType,
): Promise<{ active: boolean; rowId: string | null }> {
  ensureCommunityBackend("Community reactions");
  const userId = await requireUserId();

  try {
    const { data: removed, error: deleteError } = await neon
      .from("community_votes")
      .delete()
      .eq("post_id", postId)
      .eq("user_id", userId)
      .eq("vote_type", voteType)
      .select("id")
      .maybeSingle();

    if (deleteError) throw deleteError;
    if (removed?.id) {
      return { active: false, rowId: null };
    }

    const { data: upserted, error: upsertError } = await neon
      .from("community_votes")
      .upsert(
        {
          post_id: postId,
          user_id: userId,
          vote_type: voteType,
        },
        {
          onConflict: "post_id,user_id,vote_type",
          ignoreDuplicates: true,
        },
      )
      .select("id")
      .maybeSingle();

    if (upsertError) throw upsertError;
    if (upserted?.id) {
      return { active: true, rowId: upserted.id };
    }

    const { data: existing, error: lookupError } = await neon
      .from("community_votes")
      .select("id")
      .eq("post_id", postId)
      .eq("user_id", userId)
      .eq("vote_type", voteType)
      .maybeSingle();

    if (lookupError) throw lookupError;
    return { active: true, rowId: existing?.id ?? null };
  } catch (error) {
    throw toError(error, "Failed to submit vote.");
  }
}

export async function addComment(postId: string, body: string): Promise<CommunityComment> {
  ensureCommunityBackend("Community comments");
  const userId = await requireUserId();
  const content = sanitizePostgresText(body).trim();
  if (!content) throw new Error("Comment is required.");
  assertCommunityTextAllowed(content, "This comment violates community safety rules.");

  try {
    const { data, error } = await neon
      .from("community_comments")
      .insert({
        post_id: postId,
        user_id: userId,
        body: content,
      })
      .select("id, post_id, user_id, body, created_at, updated_at")
      .single();

    if (error) throw error;
    if (!data) throw new Error("Comment creation returned no data.");
    return mapCommunityComment(data as CommunityCommentRow);
  } catch (error) {
    throw toError(error, "Failed to add comment.");
  }
}

export async function loadComments(postId: string, options: LoadCommentsInput = {}): Promise<CommunityComment[]> {
  ensureCommunityBackend("Community comments");
  const { limit = 25, cursor } = options;

  try {
    const { data: visiblePost, error: postError } = await neon
      .from("community_posts")
      .select("id")
      .eq("id", postId)
      .eq("is_public", true)
      .maybeSingle();

    if (postError) throw postError;
    if (!visiblePost) return [];

    let builder = neon
      .from("community_comments")
      .select("id, post_id, user_id, body, created_at, updated_at")
      .eq("post_id", postId)
      .order("created_at", { ascending: false })
      .limit(Math.min(Math.max(limit, 1), 200));

    if (cursor) {
      builder = builder.lt("created_at", cursor);
    }

    const { data, error } = await builder;
    if (error) throw error;
    return (data || []).map((row) => mapCommunityComment(row as CommunityCommentRow));
  } catch (error) {
    throw toError(error, "Failed to load comments.");
  }
}

export async function remixToLibrary(
  postId: string,
  options?: { title?: string; remixNote?: string },
): Promise<SavedPromptRecord> {
  ensureCommunityBackend("Community remixes");
  const userId = await requireUserId();

  try {
    const { data: postRow, error: postError } = await runCommunityPostsSelect((selectColumns) =>
      neon.from("community_posts").select(selectColumns).eq("id", postId).eq("is_public", true).single(),
    );

    if (postError) throw postError;
    const post = mapCommunityPost(postRow as unknown as CommunityPostRow);
    const title = clampTitle(options?.title || `Remix of ${post.title}`);
    const config = normalizeTemplateConfig(
      sanitizePostgresJson(post.publicConfig as unknown as Json) as unknown as PromptConfig,
    );

    const { data: created, error: insertError } = await neon
      .from("saved_prompts")
      .insert({
        user_id: userId,
        title,
        description: clampText(post.description, 500),
        category: post.category,
        tags: normalizePromptTags(post.tags),
        config: sanitizePostgresJson(config as unknown as Json),
        built_prompt: sanitizePostgresText(post.starterPrompt),
        enhanced_prompt: sanitizePostgresText(post.enhancedPrompt),
        fingerprint: computeTemplateFingerprint(config),
        is_shared: false,
        target_model: clampText(post.targetModel, 80),
        use_case: clampText(post.useCase, 1000),
        remixed_from: post.id,
        remix_note: clampText(options?.remixNote, 500),
        remix_diff: null,
      })
      .select(SAVED_PROMPT_SELECT_COLUMNS)
      .single();

    if (insertError) throw insertError;
    if (!created) throw new Error("Failed to create remixed prompt.");
    return mapSavedPromptRow(created as SavedPromptRow);
  } catch (error) {
    throw toError(error, "Failed to remix prompt to your library.");
  }
}

function toComparableValue(value: unknown): string | string[] {
  if (Array.isArray(value)) {
    return value.map((entry) => String(entry));
  }
  return value == null ? "" : String(value);
}

function shallowEqualValue(a: string | string[], b: string | string[]): boolean {
  if (Array.isArray(a) || Array.isArray(b)) {
    if (!Array.isArray(a) || !Array.isArray(b)) return false;
    if (a.length !== b.length) return false;
    return a.every((entry, index) => entry === b[index]);
  }
  return a === b;
}

export function computeRemixDiff(
  parentConfig: PromptConfig,
  childConfig: PromptConfig,
  options?: {
    parentTags?: string[];
    childTags?: string[];
    parentCategory?: string;
    childCategory?: string;
  },
): RemixDiff {
  const parent = normalizeTemplateConfig(parentConfig);
  const child = normalizeTemplateConfig(childConfig);

  const fields: Array<keyof PromptConfig> = [
    "originalPrompt",
    "role",
    "task",
    "tone",
    "complexity",
    "lengthPreference",
    "format",
    "constraints",
    "examples",
  ];

  const changes: RemixDiff["changes"] = [];

  fields.forEach((field) => {
    const from = toComparableValue(parent[field]);
    const to = toComparableValue(child[field]);
    if (!shallowEqualValue(from, to)) {
      changes.push({ field, from, to });
    }
  });

  const parentTags = normalizePromptTags(options?.parentTags);
  const childTags = normalizePromptTags(options?.childTags);

  const addedTags = childTags.filter((tag) => !parentTags.includes(tag));
  const removedTags = parentTags.filter((tag) => !childTags.includes(tag));

  return {
    changes,
    added_tags: addedTags,
    removed_tags: removedTags,
    category_changed:
      (options?.parentCategory || "general").trim().toLowerCase() !==
      (options?.childCategory || "general").trim().toLowerCase(),
  };
}
````

## File: agent_service/codex_service.mjs
````javascript
import { createHash, randomUUID } from "node:crypto";
import { createServer } from "node:http";
import process from "node:process";
import { Codex } from "@openai/codex-sdk";
import { createRemoteJWKSet, jwtVerify } from "jose";
import { WebSocketServer } from "ws";
import {
  buildEnhancementMetaPrompt,
  detectEnhancementContext,
  parseEnhancementRequestBuilderFields,
  parseEnhancementRequestMode,
  pickPrimaryAgentMessageText,
  postProcessEnhancementResponse,
} from "./enhancement-pipeline.mjs";
import { extractThreadOptions } from "./thread-options.mjs";
import {
  loadCodexConfig,
  resolveApiKey,
  isAzureProvider,
  resolveProviderConfig,
} from "./codex-config.mjs";

// ---------------------------------------------------------------------------
// Resolve provider from ~/.codex/config.toml (preferred) or CODEX_CONFIG_JSON.
// ---------------------------------------------------------------------------
const CODEX_CONFIG_OVERRIDES = parseJsonObjectEnv("CODEX_CONFIG_JSON") || {};
const CODEX_CONFIG_FROM_TOML = await loadCodexConfig();
const CODEX_CONFIG_FROM_ENV = resolveProviderConfig(CODEX_CONFIG_OVERRIDES);
const CODEX_CONFIG = CODEX_CONFIG_FROM_TOML || CODEX_CONFIG_FROM_ENV;
const CODEX_CONFIG_SOURCE = CODEX_CONFIG_FROM_TOML
  ? "config_toml"
  : (CODEX_CONFIG_FROM_ENV ? "codex_config_json" : "fallback");
const IS_AZURE_PROVIDER = isAzureProvider(CODEX_CONFIG);
const RESOLVED_API_KEY = CODEX_CONFIG ? resolveApiKey(CODEX_CONFIG) : null;
const REQUIRE_PROVIDER_CONFIG = normalizeBool(process.env.REQUIRE_PROVIDER_CONFIG, false);
const RESOLVED_CODEX_MODEL = resolveConfiguredCodexModel();
const HAS_MISSING_AZURE_MODEL = IS_AZURE_PROVIDER && !RESOLVED_CODEX_MODEL;

if (CODEX_CONFIG) {
  console.log(JSON.stringify({
    timestamp: new Date().toISOString(),
    level: "info",
    event: "provider_config_resolved",
    service: "ai-prompt-pro-codex-service",
    config_source: CODEX_CONFIG_SOURCE,
    provider: CODEX_CONFIG.provider,
    provider_name: CODEX_CONFIG.name,
    base_url: CODEX_CONFIG.baseUrl,
    env_key: CODEX_CONFIG.envKey,
    api_key_resolved: !!RESOLVED_API_KEY,
    is_azure: IS_AZURE_PROVIDER,
  }));
} else {
  console.log(JSON.stringify({
    timestamp: new Date().toISOString(),
    level: "warn",
    event: "provider_config_not_found",
    service: "ai-prompt-pro-codex-service",
    message: "No model provider config found in ~/.codex/config.toml or CODEX_CONFIG_JSON. Falling back to OPENAI_API_KEY.",
    codex_config_json_set: Object.keys(CODEX_CONFIG_OVERRIDES).length > 0,
    openai_api_key_set: !!process.env.OPENAI_API_KEY,
  }));
}

if (REQUIRE_PROVIDER_CONFIG && !CODEX_CONFIG) {
  throw new Error(
    "REQUIRE_PROVIDER_CONFIG is true, but no provider config was found in ~/.codex/config.toml or CODEX_CONFIG_JSON.",
  );
}

const MAX_PROMPT_CHARS = Number.parseInt(process.env.MAX_PROMPT_CHARS || "16000", 10);
if (!Number.isFinite(MAX_PROMPT_CHARS) || MAX_PROMPT_CHARS <= 0) {
  throw new Error("MAX_PROMPT_CHARS must be a positive integer.");
}

const MAX_INFERENCE_PROMPT_CHARS = Number.parseInt(process.env.MAX_INFERENCE_PROMPT_CHARS || "12000", 10);
if (!Number.isFinite(MAX_INFERENCE_PROMPT_CHARS) || MAX_INFERENCE_PROMPT_CHARS <= 0) {
  throw new Error("MAX_INFERENCE_PROMPT_CHARS must be a positive integer.");
}

const MAX_URL_CHARS = Number.parseInt(process.env.MAX_URL_CHARS || "2048", 10);
if (!Number.isFinite(MAX_URL_CHARS) || MAX_URL_CHARS <= 0) {
  throw new Error("MAX_URL_CHARS must be a positive integer.");
}

const FETCH_TIMEOUT_MS = Number.parseInt(process.env.EXTRACT_FETCH_TIMEOUT_MS || "15000", 10);
if (!Number.isFinite(FETCH_TIMEOUT_MS) || FETCH_TIMEOUT_MS <= 0) {
  throw new Error("EXTRACT_FETCH_TIMEOUT_MS must be a positive integer.");
}

const MAX_RESPONSE_BYTES = Number.parseInt(
  process.env.EXTRACT_MAX_RESPONSE_BYTES || String(1024 * 1024),
  10,
);
if (!Number.isFinite(MAX_RESPONSE_BYTES) || MAX_RESPONSE_BYTES <= 0) {
  throw new Error("EXTRACT_MAX_RESPONSE_BYTES must be a positive integer.");
}

const ENHANCE_PER_MINUTE = Number.parseInt(process.env.ENHANCE_PER_MINUTE || "12", 10);
const ENHANCE_PER_DAY = Number.parseInt(process.env.ENHANCE_PER_DAY || "300", 10);
const EXTRACT_PER_MINUTE = Number.parseInt(process.env.EXTRACT_PER_MINUTE || "6", 10);
const EXTRACT_PER_DAY = Number.parseInt(process.env.EXTRACT_PER_DAY || "120", 10);
const INFER_PER_MINUTE = Number.parseInt(process.env.INFER_PER_MINUTE || "15", 10);
const INFER_PER_DAY = Number.parseInt(process.env.INFER_PER_DAY || "400", 10);
const ENHANCE_WS_INITIAL_MESSAGE_TIMEOUT_MS = parsePositiveIntegerEnv(
  "ENHANCE_WS_INITIAL_MESSAGE_TIMEOUT_MS",
  5000,
);
const ENHANCE_WS_MAX_PAYLOAD_BYTES = parsePositiveIntegerEnv(
  "ENHANCE_WS_MAX_PAYLOAD_BYTES",
  64 * 1024,
);
const ENHANCE_WS_MAX_CONNECTIONS_PER_IP = parsePositiveIntegerEnv(
  "ENHANCE_WS_MAX_CONNECTIONS_PER_IP",
  10,
);

const OPENAI_API_BASE_URL = (CODEX_CONFIG?.baseUrl ? CODEX_CONFIG.baseUrl.replace(/\/+$/, "") : null)
  || process.env.OPENAI_BASE_URL?.trim()
  || "https://api.openai.com/v1";
const EXTRACT_MODEL = normalizeEnvValue("EXTRACT_MODEL")
  || RESOLVED_CODEX_MODEL
  || (!IS_AZURE_PROVIDER ? "gpt-4.1-mini" : undefined);

// ---------------------------------------------------------------------------
// 429 retry configuration
// ---------------------------------------------------------------------------
const CODEX_429_MAX_RETRIES = (() => {
  const raw = process.env.CODEX_429_MAX_RETRIES;
  if (!raw) return 2;
  const parsed = Number.parseInt(raw, 10);
  if (!Number.isFinite(parsed) || parsed < 0) {
    throw new Error("CODEX_429_MAX_RETRIES must be a non-negative integer.");
  }
  return parsed;
})();

const CODEX_429_BACKOFF_BASE_SECONDS = (() => {
  const raw = process.env.CODEX_429_BACKOFF_BASE_SECONDS;
  if (!raw) return 1.0;
  const parsed = Number.parseFloat(raw);
  if (!Number.isFinite(parsed) || parsed < 0) {
    throw new Error("CODEX_429_BACKOFF_BASE_SECONDS must be a non-negative number.");
  }
  return parsed;
})();

const CODEX_429_BACKOFF_MAX_SECONDS = (() => {
  const raw = process.env.CODEX_429_BACKOFF_MAX_SECONDS;
  if (!raw) return 20.0;
  const parsed = Number.parseFloat(raw);
  if (!Number.isFinite(parsed) || parsed < 0) {
    throw new Error("CODEX_429_BACKOFF_MAX_SECONDS must be a non-negative number.");
  }
  return parsed;
})();

const SANDBOX_MODES = new Set(["read-only", "workspace-write", "danger-full-access"]);
const REASONING_EFFORTS = new Set(["minimal", "low", "medium", "high", "xhigh"]);
const REASONING_SUMMARIES = new Set(["auto", "concise", "detailed"]);
const WEB_SEARCH_MODES = new Set(["disabled", "cached", "live"]);
const APPROVAL_POLICIES = new Set(["never", "on-request", "on-failure", "untrusted"]);
const SERVICE_NAME = "ai-prompt-pro-codex-service";

if (HAS_MISSING_AZURE_MODEL) {
  logEvent("warn", "provider_model_not_set", {
    error_code: "provider_model_not_set",
    message:
      "Azure provider is configured but no model deployment name was resolved. "
      + "Set CODEX_MODEL (or AZURE_OPENAI_DEPLOYMENT) to a valid Azure deployment name.",
    provider: CODEX_CONFIG?.provider,
    config_source: CODEX_CONFIG_SOURCE,
  });
}

function cleanLogFields(fields) {
  const entries = Object.entries(fields || {});
  return Object.fromEntries(entries.filter(([, value]) => value !== undefined));
}

function logEvent(level, event, fields = {}) {
  const payload = cleanLogFields({
    timestamp: new Date().toISOString(),
    level,
    event,
    service: SERVICE_NAME,
    ...fields,
  });
  const serialized = JSON.stringify(payload);
  if (level === "error") {
    console.error(serialized);
    return;
  }
  if (level === "warn") {
    console.warn(serialized);
    return;
  }
  console.log(serialized);
}

function toFiniteNumber(value) {
  if (typeof value === "number" && Number.isFinite(value)) return value;
  if (typeof value === "string" && value.trim()) {
    const parsed = Number(value);
    if (Number.isFinite(parsed)) return parsed;
  }
  return undefined;
}

function hashUserIdentifier(userId) {
  if (typeof userId !== "string") return undefined;
  const normalized = userId.trim();
  if (!normalized) return undefined;
  return createHash("sha256").update(normalized).digest("hex").slice(0, 16);
}

function inferErrorCodeFromStatus(statusCode) {
  if (!Number.isFinite(statusCode)) return undefined;
  if (statusCode === 401) return "auth_session_invalid";
  if (statusCode === 403) return "forbidden";
  if (statusCode === 404) return "not_found";
  if (statusCode === 405) return "method_not_allowed";
  if (statusCode === 408 || statusCode === 504) return "request_timeout";
  if (statusCode === 413) return "payload_too_large";
  if (statusCode === 422) return "bad_response";
  if (statusCode === 429) return "rate_limited";
  if (statusCode === 499) return "request_aborted";
  if (statusCode === 503) return "service_unavailable";
  if (statusCode >= 500) return "service_error";
  if (statusCode >= 400) return "bad_request";
  return undefined;
}

function createRequestContext(requestId, endpoint, method, transport) {
  return {
    requestId,
    endpoint,
    method,
    transport,
    startedAt: Date.now(),
    retryCount: 0,
    circuitState: "closed",
    userIdHash: undefined,
    usageInputTokens: undefined,
    usageOutputTokens: undefined,
    errorCode: undefined,
    errorMessage: undefined,
    statusCode: undefined,
    completed: false,
  };
}

function setRequestError(requestContext, errorCode, errorMessage, statusCode) {
  if (!requestContext) return;
  if (typeof errorCode === "string" && errorCode.trim()) {
    requestContext.errorCode = errorCode.trim();
  }
  if (typeof errorMessage === "string" && errorMessage.trim()) {
    requestContext.errorMessage = errorMessage.trim().slice(0, 400);
  }
  if (Number.isFinite(statusCode)) {
    requestContext.statusCode = statusCode;
  }
}

function completeRequestContext(requestContext, statusCode) {
  if (!requestContext || requestContext.completed) return;
  requestContext.completed = true;
  const durationMs = Math.max(0, Date.now() - requestContext.startedAt);
  const resolvedStatus = Number.isFinite(statusCode)
    ? statusCode
    : Number.isFinite(requestContext.statusCode)
      ? requestContext.statusCode
      : 500;
  const resolvedErrorCode = requestContext.errorCode || inferErrorCodeFromStatus(resolvedStatus);
  const basePayload = cleanLogFields({
    request_id: requestContext.requestId,
    endpoint: requestContext.endpoint,
    method: requestContext.method,
    transport: requestContext.transport,
    status_code: resolvedStatus,
    duration_ms: durationMs,
    retry_count: requestContext.retryCount,
    circuit_state: requestContext.circuitState,
    error_code: resolvedErrorCode,
    error_message: requestContext.errorMessage,
    user_id_hash: requestContext.userIdHash,
    usage_input_tokens: requestContext.usageInputTokens,
    usage_output_tokens: requestContext.usageOutputTokens,
  });

  if (resolvedErrorCode) {
    const level = resolvedStatus >= 500 ? "error" : "warn";
    logEvent(level, "request_error", basePayload);
  }
  const endLevel = resolvedStatus >= 500 ? "error" : resolvedStatus >= 400 ? "warn" : "info";
  logEvent(endLevel, "request_end", basePayload);
}

function attachHttpRequestLifecycleLogging(res, requestContext) {
  res.on("finish", () => {
    completeRequestContext(requestContext, res.statusCode);
  });
  res.on("close", () => {
    if (requestContext?.completed) return;
    const closedBeforeFinish = !res.writableEnded;
    if (closedBeforeFinish && !requestContext.errorCode) {
      setRequestError(requestContext, "request_aborted", "Client disconnected before response completed.");
    }
    const statusCode = closedBeforeFinish ? 499 : res.statusCode;
    completeRequestContext(requestContext, statusCode);
  });
}

function transportForEndpoint(endpoint) {
  if (endpoint === "/enhance") return "sse";
  if (endpoint === ENHANCE_WS_PATH) return "ws";
  return "http";
}

function captureUsageMetrics(requestContext, usage) {
  if (!requestContext || !usage || typeof usage !== "object") return;
  const inputTokens = toFiniteNumber(
    usage.input_tokens
      ?? usage.inputTokens
      ?? usage.prompt_tokens
      ?? usage.promptTokens,
  );
  const outputTokens = toFiniteNumber(
    usage.output_tokens
      ?? usage.outputTokens
      ?? usage.completion_tokens
      ?? usage.completionTokens,
  );
  if (inputTokens !== undefined) requestContext.usageInputTokens = inputTokens;
  if (outputTokens !== undefined) requestContext.usageOutputTokens = outputTokens;
}

function normalizeEnvValue(name) {
  const value = process.env[name];
  if (typeof value !== "string") return undefined;
  const trimmed = value.trim();
  return trimmed ? trimmed : undefined;
}

function normalizeBool(value, defaultValue = false) {
  if (typeof value !== "string") return defaultValue;
  const normalized = value.trim().toLowerCase();
  if (!normalized) return defaultValue;
  if (["1", "true", "yes", "on"].includes(normalized)) return true;
  if (["0", "false", "no", "off"].includes(normalized)) return false;
  throw new Error(`Invalid boolean value "${value}".`);
}

function parseJsonObjectEnv(name) {
  const raw = normalizeEnvValue(name);
  if (!raw) return undefined;
  let parsed;
  try {
    parsed = JSON.parse(raw);
  } catch (error) {
    throw new Error(`${name} must be valid JSON.`, { cause: error });
  }
  if (!parsed || Array.isArray(parsed) || typeof parsed !== "object") {
    throw new Error(`${name} must be a JSON object.`);
  }
  return parsed;
}

function parseStringArrayEnv(name) {
  const raw = normalizeEnvValue(name);
  if (!raw) return undefined;

  if (raw.startsWith("[")) {
    let parsed;
    try {
      parsed = JSON.parse(raw);
    } catch (error) {
      throw new Error(`${name} must be a JSON array of strings.`, { cause: error });
    }
    if (!Array.isArray(parsed) || !parsed.every((entry) => typeof entry === "string")) {
      throw new Error(`${name} must be a JSON array of strings.`);
    }
    const normalized = parsed.map((entry) => entry.trim()).filter(Boolean);
    return normalized.length > 0 ? normalized : undefined;
  }

  const normalized = raw
    .split(",")
    .map((entry) => entry.trim())
    .filter(Boolean);
  return normalized.length > 0 ? normalized : undefined;
}

function parseEnumEnv(name, allowedValues) {
  const raw = normalizeEnvValue(name);
  if (!raw) return undefined;
  if (!allowedValues.has(raw)) {
    throw new Error(`${name} has invalid value "${raw}".`);
  }
  return raw;
}

function parsePositiveIntegerEnv(name, defaultValue) {
  const raw = normalizeEnvValue(name);
  if (!raw) return defaultValue;
  const parsed = Number.parseInt(raw, 10);
  if (!Number.isFinite(parsed) || parsed <= 0) {
    throw new Error(`${name} must be a positive integer.`);
  }
  return parsed;
}

function resolveConfiguredCodexModel() {
  const explicitModel = normalizeEnvValue("CODEX_MODEL")
    || normalizeEnvValue("AZURE_OPENAI_DEPLOYMENT")
    || normalizeEnvValue("AZURE_OPENAI_DEPLOYMENT_NAME");
  if (explicitModel) return explicitModel;

  const providerModel = typeof CODEX_CONFIG?.model === "string" ? CODEX_CONFIG.model.trim() : "";
  if (providerModel) return providerModel;

  // Use a default model only for non-Azure providers.
  if (!IS_AZURE_PROVIDER) return "gpt-5.2";
  return undefined;
}

function normalizeNeonAuthUrl(rawValue) {
  const raw = typeof rawValue === "string" ? rawValue.trim() : "";
  if (!raw) return undefined;

  const trimmed = raw.replace(/\/+$/, "");
  if (trimmed.endsWith("/auth/v1")) {
    return trimmed.slice(0, -"/v1".length);
  }
  return trimmed;
}

function sanitizeCodexExecErrorMessage(message) {
  if (typeof message !== "string") return "Unexpected error from Codex service.";
  const trimmed = message.trim();
  if (!trimmed) return "Unexpected error from Codex service.";
  if (!trimmed.includes("Codex Exec exited with")) {
    return trimmed;
  }

  const stderrSection = trimmed.split(":").slice(1).join(":").trim();
  const lines = stderrSection
    .split(/\r?\n/)
    .map((line) => line.trim())
    .filter(Boolean);
  const meaningfulLines = lines.filter((line) => {
    if (/^reading prompt from stdin/i.test(line)) return false;
    if (/^\{"type":/.test(line)) return false;
    if (/^\d{4}-\d{2}-\d{2}t/i.test(line.toLowerCase())) return false;
    return true;
  });

  const deploymentMissingLine = meaningfulLines.find((line) =>
    /api deployment .* does not exist|deployment .* does not exist/i.test(line));
  if (deploymentMissingLine) {
    return (
      "Codex CLI failed because the configured Azure model deployment was not found. "
      + "Set CODEX_MODEL (or AZURE_OPENAI_DEPLOYMENT) to a valid deployment name."
    );
  }

  const missingApiKeyLine = meaningfulLines.find((line) =>
    /no api key|api key.+(missing|not set|invalid)/i.test(line));
  if (missingApiKeyLine) {
    return (
      "Codex CLI failed because provider credentials are missing or invalid. "
      + "Verify AZURE_OPENAI_API_KEY or OPENAI_API_KEY."
    );
  }

  const fallbackLine = meaningfulLines[meaningfulLines.length - 1];
  if (fallbackLine) {
    return `Codex CLI failed: ${fallbackLine}`;
  }

  return (
    "Codex CLI exited before producing a response. "
    + "Verify CODEX_MODEL, provider endpoint, and API key configuration."
  );
}

function normalizeStringRecord(value) {
  if (!value || typeof value !== "object" || Array.isArray(value)) return undefined;
  const record = {};
  for (const [key, raw] of Object.entries(value)) {
    if (typeof raw !== "string") {
      throw new Error("CODEX_ENV_JSON must contain only string values.");
    }
    record[key] = raw;
  }
  return Object.keys(record).length > 0 ? record : undefined;
}

const SERVICE_CONFIG = (() => {
  const host = normalizeEnvValue("HOST") || "0.0.0.0";
  const portRaw = normalizeEnvValue("PORT") || "8001";
  const port = Number.parseInt(portRaw, 10);
  if (!Number.isFinite(port) || port <= 0) {
    throw new Error(`PORT must be a positive integer. Received "${portRaw}".`);
  }

  return {
    host,
    port,
    token: normalizeEnvValue("AGENT_SERVICE_TOKEN"),
  };
})();

const CORS_CONFIG = (() => {
  const configured = normalizeEnvValue("ALLOWED_ORIGINS");
  if (!configured || configured === "*" || configured.toLowerCase() === "any") {
    return { mode: "any", origins: new Set() };
  }

  const origins = new Set(
    configured
      .split(",")
      .map((origin) => origin.trim())
      .filter(Boolean),
  );

  if (origins.size === 0) {
    return { mode: "any", origins };
  }

  return { mode: "set", origins };
})();

const AUTH_CONFIG = (() => {
  const neonAuthUrl = normalizeNeonAuthUrl(normalizeEnvValue("NEON_AUTH_URL"));
  const neonJwksUrl = normalizeEnvValue("NEON_JWKS_URL")
    || (neonAuthUrl ? `${neonAuthUrl}/.well-known/jwks.json` : undefined);

  const configuredKeyValues = [
    normalizeEnvValue("FUNCTION_PUBLIC_API_KEY"),
    normalizeEnvValue("NEON_PUBLISHABLE_KEY"),
    normalizeEnvValue("VITE_NEON_PUBLISHABLE_KEY"),
  ].filter((value) => typeof value === "string" && value.length > 0);
  const configuredKeys = new Set(configuredKeyValues);
  const authValidationApiKey = configuredKeyValues[0];

  return {
    neonAuthUrl,
    neonJwksUrl,
    neonAuthUserUrl: neonAuthUrl ? `${neonAuthUrl}/v1/user` : undefined,
    authValidationApiKey,
    configuredKeys,
  };
})();

const TEXTUAL_CONTENT_TYPES = new Set([
  "application/xhtml+xml",
  "application/xml",
  "text/xml",
  "application/json",
  "application/ld+json",
  "application/rss+xml",
  "application/atom+xml",
  "application/javascript",
  "application/x-javascript",
  "application/ecmascript",
]);

const INFERENCE_FIELD_LABELS = {
  role: "Set AI persona",
  tone: "Adjust tone",
  lengthPreference: "Tune response length",
  format: "Choose output format",
  constraints: "Add guidance constraints",
};

const INFERENCE_FIELD_CONFIDENCE = {
  role: 0.78,
  tone: 0.72,
  lengthPreference: 0.66,
  format: 0.7,
  constraints: 0.64,
};

const ENHANCE_WS_PATH = "/enhance/ws";
const ENHANCE_WS_PROTOCOL = "promptforge.enhance.v1";
const ENHANCE_WS_BEARER_PROTOCOL_PREFIX = "auth.bearer.";
const ENHANCE_WS_APIKEY_PROTOCOL_PREFIX = "auth.apikey.";
const ENHANCE_WS_SERVICE_PROTOCOL_PREFIX = "auth.service.";

const rateLimitStores = new Map();
const activeEnhanceWebSocketConnectionsByIp = new Map();

let neonJwksResolver = null;
let hasLoggedAuthConfigWarning = false;
let hasLoggedJwtFallbackWarning = false;
let hasLoggedJwtFallbackProductionWarning = false;

function headerValue(req, headerName) {
  const rawValue = req.headers[headerName.toLowerCase()];
  if (typeof rawValue === "string") return rawValue;
  if (Array.isArray(rawValue)) return rawValue[0];
  return undefined;
}

function decodeBase64UrlValue(value) {
  if (typeof value !== "string" || !value.trim()) return undefined;
  try {
    return Buffer.from(value.trim(), "base64url").toString("utf8").trim() || undefined;
  } catch {
    return undefined;
  }
}

function parseWebSocketProtocols(req) {
  const raw = headerValue(req, "sec-websocket-protocol") || "";
  return raw
    .split(",")
    .map((entry) => entry.trim())
    .filter(Boolean);
}

function extractWebSocketAuthHeadersFromProtocols(req) {
  const protocols = parseWebSocketProtocols(req);
  const authHeaders = {};

  for (const protocol of protocols) {
    if (protocol.startsWith(ENHANCE_WS_BEARER_PROTOCOL_PREFIX)) {
      const encodedToken = protocol.slice(ENHANCE_WS_BEARER_PROTOCOL_PREFIX.length);
      const token = decodeBase64UrlValue(encodedToken);
      if (token) {
        authHeaders.authorization = `Bearer ${token}`;
      }
      continue;
    }

    if (protocol.startsWith(ENHANCE_WS_APIKEY_PROTOCOL_PREFIX)) {
      const encodedToken = protocol.slice(ENHANCE_WS_APIKEY_PROTOCOL_PREFIX.length);
      const apiKey = decodeBase64UrlValue(encodedToken);
      if (apiKey) {
        authHeaders.apikey = apiKey;
      }
      continue;
    }

    if (protocol.startsWith(ENHANCE_WS_SERVICE_PROTOCOL_PREFIX)) {
      const encodedToken = protocol.slice(ENHANCE_WS_SERVICE_PROTOCOL_PREFIX.length);
      const serviceToken = decodeBase64UrlValue(encodedToken);
      if (serviceToken) {
        authHeaders["x-agent-token"] = serviceToken;
      }
    }
  }

  return authHeaders;
}

function extractWebSocketAuthHeadersFromPayload(rawAuth) {
  if (!rawAuth || typeof rawAuth !== "object" || Array.isArray(rawAuth)) {
    return {};
  }

  const auth = rawAuth;
  const authHeaders = {};

  const bearerToken =
    asNonEmptyString(auth.bearer_token)
    || asNonEmptyString(auth.bearerToken)
    || asNonEmptyString(auth.access_token)
    || asNonEmptyString(auth.accessToken);
  if (bearerToken) {
    authHeaders.authorization = `Bearer ${bearerToken}`;
  }

  const apiKey =
    asNonEmptyString(auth.apikey)
    || asNonEmptyString(auth.api_key)
    || asNonEmptyString(auth.apiKey);
  if (apiKey) {
    authHeaders.apikey = apiKey;
  }

  const serviceToken =
    asNonEmptyString(auth.service_token)
    || asNonEmptyString(auth.serviceToken);
  if (serviceToken) {
    authHeaders["x-agent-token"] = serviceToken;
  }

  return authHeaders;
}

function createWebSocketRequestView(req, overrideHeaders = {}) {
  return {
    socket: req.socket,
    headers: {
      ...req.headers,
      ...extractWebSocketAuthHeadersFromProtocols(req),
      ...overrideHeaders,
    },
  };
}

function rejectWebSocketUpgrade(socket, status, payload, requestContext) {
  setRequestError(
    requestContext,
    inferErrorCodeFromStatus(status),
    typeof payload?.error === "string" ? payload.error : undefined,
  );
  const body = JSON.stringify(payload);
  const statusText =
    status === 400
      ? "Bad Request"
      : status === 401
        ? "Unauthorized"
        : status === 403
          ? "Forbidden"
          : status === 405
            ? "Method Not Allowed"
            : status === 429
              ? "Too Many Requests"
              : "Internal Server Error";
  const response =
    `HTTP/1.1 ${status} ${statusText}\r\n`
    + "Connection: close\r\n"
    + "Content-Type: application/json; charset=utf-8\r\n"
    + `Content-Length: ${Buffer.byteLength(body)}\r\n`
    + "\r\n"
    + body;

  socket.write(response);
  socket.destroy();
  completeRequestContext(requestContext, status);
}

function baseCorsHeaders(origin) {
  return {
    "Access-Control-Allow-Origin": origin,
    "Access-Control-Allow-Headers":
      "authorization, x-client-info, apikey, content-type, x-agent-token, x-supabase-client-platform, x-supabase-client-platform-version, x-supabase-client-runtime, x-supabase-client-runtime-version",
    "Access-Control-Allow-Methods": "POST, OPTIONS",
    "Access-Control-Max-Age": "86400",
    Vary: "Origin",
  };
}

function resolveCors(req) {
  const origin = (headerValue(req, "origin") || "").trim();
  if (!origin) {
    return { ok: true, headers: baseCorsHeaders("null"), origin: "null" };
  }

  if (CORS_CONFIG.mode === "set" && !CORS_CONFIG.origins.has(origin)) {
    return {
      ok: false,
      status: 403,
      error: "Origin is not allowed.",
      headers: baseCorsHeaders("null"),
    };
  }

  return { ok: true, headers: baseCorsHeaders(origin), origin };
}

function getClientIp(req) {
  const forwardedFor = headerValue(req, "x-forwarded-for");
  if (forwardedFor) {
    const [firstHop] = forwardedFor.split(",");
    if (firstHop?.trim()) return firstHop.trim();
  }

  const realIp = headerValue(req, "x-real-ip");
  if (realIp?.trim()) return realIp.trim();
  return "unknown";
}

function parseBearerToken(req) {
  const authHeader = headerValue(req, "authorization") || "";
  const match = authHeader.match(/^Bearer\s+(.+)$/i);
  return match?.[1]?.trim();
}

function isPublishableKeyLike(value) {
  if (typeof value !== "string") return false;
  const trimmed = value.trim();
  if (!trimmed) return false;
  if (trimmed.startsWith("sb_publishable_")) return true;
  if (trimmed.startsWith("pk_live_") || trimmed.startsWith("pk_test_")) return true;
  return false;
}

function isConfiguredPublicApiKey(value) {
  if (typeof value !== "string") return false;
  const trimmed = value.trim();
  if (!trimmed) return false;
  if (AUTH_CONFIG.configuredKeys.has(trimmed)) return true;
  return AUTH_CONFIG.configuredKeys.size === 0 && isPublishableKeyLike(trimmed);
}

function looksLikeJwt(value) {
  return typeof value === "string" && value.split(".").length === 3;
}

function isTruthyEnv(name) {
  return normalizeBool(process.env[name], false);
}

function isProductionEnvironment() {
  if (normalizeEnvValue("DENO_DEPLOYMENT_ID")) return true;

  const envValue = (
    normalizeEnvValue("APP_ENV")
    || normalizeEnvValue("ENVIRONMENT")
    || normalizeEnvValue("NODE_ENV")
    || ""
  )
    .trim()
    .toLowerCase();

  return envValue === "prod" || envValue === "production";
}

function allowUnverifiedJwtFallback() {
  if (!isTruthyEnv("ALLOW_UNVERIFIED_JWT_FALLBACK")) {
    return false;
  }

  if (!isProductionEnvironment()) {
    return true;
  }

  if (isTruthyEnv("ALLOW_UNVERIFIED_JWT_FALLBACK_IN_PRODUCTION")) {
    return true;
  }

  if (!hasLoggedJwtFallbackProductionWarning) {
    hasLoggedJwtFallbackProductionWarning = true;
    logEvent("error", "auth_config_warning", {
      error_code: "auth_config_invalid",
      message:
        "ALLOW_UNVERIFIED_JWT_FALLBACK is ignored in production by default. "
        + "Set ALLOW_UNVERIFIED_JWT_FALLBACK_IN_PRODUCTION=true only for emergency recovery scenarios.",
    });
  }

  return false;
}

function decodeJwtPayload(token) {
  const parts = token.split(".");
  if (parts.length !== 3) return null;

  try {
    const decoded = Buffer.from(parts[1], "base64url").toString("utf8");
    const parsed = JSON.parse(decoded);
    if (!parsed || typeof parsed !== "object" || Array.isArray(parsed)) return null;
    return parsed;
  } catch {
    return null;
  }
}

function numericClaim(value) {
  if (typeof value === "number" && Number.isFinite(value)) return value;
  if (typeof value !== "string") return null;
  const parsed = Number(value);
  return Number.isFinite(parsed) ? parsed : null;
}

function objectBooleanFlag(source, key) {
  if (!source || typeof source !== "object" || Array.isArray(source)) return false;
  return source[key] === true;
}

function decodeUserFromJwt(token) {
  const claims = decodeJwtPayload(token.trim());
  if (!claims) return null;

  const subject = typeof claims.sub === "string" ? claims.sub.trim() : "";
  if (!subject) return null;

  const exp = numericClaim(claims.exp);
  if (exp !== null && Date.now() >= exp * 1000) return null;

  const isAnonymous = (
    claims.role === "anon"
    || claims.is_anonymous === true
    || objectBooleanFlag(claims.app_metadata, "is_anonymous")
    || objectBooleanFlag(claims.user_metadata, "is_anonymous")
  );

  return {
    id: subject,
    isAnonymous,
  };
}

function tryDecodeUserFromJwtFallback(bearerToken, reason) {
  if (!allowUnverifiedJwtFallback()) return null;
  const decodedUser = decodeUserFromJwt(bearerToken);
  if (!decodedUser) return null;

  if (!hasLoggedJwtFallbackWarning) {
    hasLoggedJwtFallbackWarning = true;
    logEvent("warn", "auth_fallback_enabled", {
      error_code: "auth_fallback_unverified_jwt",
      reason,
      message:
        `ALLOW_UNVERIFIED_JWT_FALLBACK is enabled; accepting decoded JWT claims without signature verification (${reason}).`,
    });
  }

  return decodedUser;
}

function getNeonJwksResolver() {
  if (!AUTH_CONFIG.neonJwksUrl) return null;
  if (!neonJwksResolver) {
    neonJwksResolver = createRemoteJWKSet(new URL(AUTH_CONFIG.neonJwksUrl));
  }
  return neonJwksResolver;
}

async function verifyNeonJwt(token) {
  const jwks = getNeonJwksResolver();
  if (!jwks) {
    return { ok: false, reason: "config" };
  }

  try {
    const verifyOptions = {};
    if (AUTH_CONFIG.neonAuthUrl) {
      verifyOptions.issuer = AUTH_CONFIG.neonAuthUrl;
    }
    const { payload } = await jwtVerify(token, jwks, verifyOptions);
    const userId = typeof payload.sub === "string" ? payload.sub.trim() : "";
    if (!userId) {
      return { ok: false, reason: "invalid" };
    }

    return { ok: true, userId };
  } catch (error) {
    const message = toErrorMessage(error).toLowerCase();
    if (message.includes("failed to fetch") || message.includes("network")) {
      return { ok: false, reason: "unavailable" };
    }
    return { ok: false, reason: "invalid" };
  }
}

async function verifyNeonSessionWithAuthApi(token) {
  if (!AUTH_CONFIG.neonAuthUserUrl || !AUTH_CONFIG.authValidationApiKey) {
    return { ok: false, reason: "config" };
  }

  try {
    const response = await fetch(AUTH_CONFIG.neonAuthUserUrl, {
      headers: {
        Authorization: `Bearer ${token}`,
        apikey: AUTH_CONFIG.authValidationApiKey,
      },
    });

    if (response.status === 401 || response.status === 403) {
      return { ok: false, reason: "invalid" };
    }
    if (!response.ok) {
      return { ok: false, reason: "unavailable" };
    }

    const data = await response.json().catch(() => null);
    const userId = typeof data?.id === "string" ? data.id.trim() : "";
    if (!userId) {
      return { ok: false, reason: "invalid" };
    }
    return { ok: true, userId };
  } catch {
    return { ok: false, reason: "unavailable" };
  }
}

function buildAuthenticatedUserResult(userId) {
  return {
    ok: true,
    userId,
    isPublicKey: false,
    rateKey: userId,
  };
}

function buildPublicApiKeyAuthResult(apiKey, clientIp) {
  if (!isConfiguredPublicApiKey(apiKey)) return null;
  return {
    ok: true,
    userId: null,
    isPublicKey: true,
    rateKey: `public:${clientIp}`,
  };
}

function authConfigUnavailableResult(apiKey, clientIp, bearerToken) {
  const publicApiResult = buildPublicApiKeyAuthResult(apiKey, clientIp);
  if (publicApiResult) return publicApiResult;

  const fallbackUser = tryDecodeUserFromJwtFallback(bearerToken, "missing_config");
  if (fallbackUser) {
    return buildAuthenticatedUserResult(fallbackUser.id);
  }

  if (!hasLoggedAuthConfigWarning) {
    hasLoggedAuthConfigWarning = true;
    logEvent("error", "auth_config_warning", {
      error_code: "auth_config_missing",
      message:
        "NEON_AUTH_URL or NEON_JWKS_URL is required to validate bearer tokens. "
        + "Set one of those env vars, provide FUNCTION_PUBLIC_API_KEY for anonymous fallback, "
        + "or enable ALLOW_UNVERIFIED_JWT_FALLBACK for local development only.",
    });
  }

  return {
    ok: false,
    status: 503,
    error: "Authentication service is unavailable because Neon auth is not configured.",
  };
}

function authTemporarilyUnavailableResult(apiKey, clientIp, bearerToken) {
  const publicApiResult = buildPublicApiKeyAuthResult(apiKey, clientIp);
  if (publicApiResult) return publicApiResult;

  const fallbackUser = tryDecodeUserFromJwtFallback(bearerToken, "auth_unavailable");
  if (fallbackUser) {
    return buildAuthenticatedUserResult(fallbackUser.id);
  }

  return {
    ok: false,
    status: 503,
    error: "Authentication service is temporarily unavailable. Please try again.",
  };
}

async function requireAuthenticatedUser(req) {
  const bearerToken = parseBearerToken(req);
  const apiKey = (headerValue(req, "apikey") || "").trim();
  const clientIp = getClientIp(req);

  if (!bearerToken) {
    const publicApiResult = buildPublicApiKeyAuthResult(apiKey, clientIp);
    if (publicApiResult) return publicApiResult;
    return {
      ok: false,
      status: 401,
      error: "Missing bearer token.",
    };
  }

  if (
    isConfiguredPublicApiKey(bearerToken) ||
    (apiKey && apiKey === bearerToken && isConfiguredPublicApiKey(apiKey))
  ) {
    return {
      ok: true,
      userId: null,
      isPublicKey: true,
      rateKey: `public:${clientIp}`,
    };
  }

  if (!looksLikeJwt(bearerToken)) {
    const authApiVerification = await verifyNeonSessionWithAuthApi(bearerToken);
    if (authApiVerification.ok) {
      return buildAuthenticatedUserResult(authApiVerification.userId);
    }
    if (authApiVerification.reason === "config") {
      return authConfigUnavailableResult(apiKey, clientIp, bearerToken);
    }
    if (authApiVerification.reason === "unavailable") {
      return authTemporarilyUnavailableResult(apiKey, clientIp, bearerToken);
    }

    return {
      ok: false,
      status: 401,
      error: "Invalid or expired auth session.",
    };
  }

  const verified = await verifyNeonJwt(bearerToken);
  if (verified.ok) {
    return buildAuthenticatedUserResult(verified.userId);
  }

  const authApiVerification = await verifyNeonSessionWithAuthApi(bearerToken);
  if (authApiVerification.ok) {
    return buildAuthenticatedUserResult(authApiVerification.userId);
  }

  if (verified.reason === "invalid" || authApiVerification.reason === "invalid") {
    return {
      ok: false,
      status: 401,
      error: "Invalid or expired auth session.",
    };
  }

  if (verified.reason === "unavailable" || authApiVerification.reason === "unavailable") {
    return authTemporarilyUnavailableResult(apiKey, clientIp, bearerToken);
  }

  if (verified.reason === "config" || authApiVerification.reason === "config") {
    return authConfigUnavailableResult(apiKey, clientIp, bearerToken);
  }

  return {
    ok: false,
    status: 401,
    error: "Invalid or expired auth session.",
  };
}

async function authenticateRequestContext(req) {
  const providedServiceToken = (headerValue(req, "x-agent-token") || "").trim();
  if (providedServiceToken) {
    if (!SERVICE_CONFIG.token || providedServiceToken !== SERVICE_CONFIG.token) {
      return {
        ok: false,
        status: 401,
        error: "Invalid or missing service token.",
      };
    }
    return {
      ok: true,
      userId: "service",
      isPublicKey: false,
      rateKey: `service:${getClientIp(req)}`,
    };
  }

  return requireAuthenticatedUser(req);
}

function acquireEnhanceWebSocketConnectionSlot(clientIp) {
  const key = clientIp || "unknown";
  const current = activeEnhanceWebSocketConnectionsByIp.get(key) || 0;
  if (current >= ENHANCE_WS_MAX_CONNECTIONS_PER_IP) {
    return false;
  }
  activeEnhanceWebSocketConnectionsByIp.set(key, current + 1);
  return true;
}

function releaseEnhanceWebSocketConnectionSlot(clientIp) {
  const key = clientIp || "unknown";
  const current = activeEnhanceWebSocketConnectionsByIp.get(key) || 0;
  if (current <= 1) {
    activeEnhanceWebSocketConnectionsByIp.delete(key);
    return;
  }
  activeEnhanceWebSocketConnectionsByIp.set(key, current - 1);
}

function getStore(scope) {
  const existing = rateLimitStores.get(scope);
  if (existing) return existing;
  const created = new Map();
  rateLimitStores.set(scope, created);
  return created;
}

function pruneStore(store, now) {
  for (const [key, state] of store.entries()) {
    if (state.resetAt <= now) {
      store.delete(key);
    }
  }
}

function applyRateLimit(options) {
  const { scope, key, limit, windowMs } = options;
  const store = getStore(scope);
  const now = Date.now();

  if (store.size > 5000) {
    pruneStore(store, now);
  }

  const current = store.get(key);
  if (!current || current.resetAt <= now) {
    const resetAt = now + windowMs;
    store.set(key, { count: 1, resetAt });
    return { ok: true, remaining: Math.max(0, limit - 1), resetAt };
  }

  if (current.count >= limit) {
    return {
      ok: false,
      retryAfterSeconds: Math.max(1, Math.ceil((current.resetAt - now) / 1000)),
      resetAt: current.resetAt,
    };
  }

  current.count += 1;
  store.set(key, current);
  return { ok: true, remaining: Math.max(0, limit - current.count), resetAt: current.resetAt };
}

const DEFAULT_THREAD_OPTIONS = (() => {
  const options = {};
  if (RESOLVED_CODEX_MODEL) {
    options.model = RESOLVED_CODEX_MODEL;
  }

  const sandboxMode = parseEnumEnv("CODEX_SANDBOX_MODE", SANDBOX_MODES);
  if (sandboxMode) options.sandboxMode = sandboxMode;

  const workingDirectory = normalizeEnvValue("CODEX_WORKING_DIRECTORY");
  if (workingDirectory) options.workingDirectory = workingDirectory;

  const skipGitRepoCheckRaw = normalizeEnvValue("CODEX_SKIP_GIT_REPO_CHECK");
  if (skipGitRepoCheckRaw) {
    options.skipGitRepoCheck = normalizeBool(skipGitRepoCheckRaw, false);
  }

  options.modelReasoningEffort =
    parseEnumEnv("CODEX_MODEL_REASONING_EFFORT", REASONING_EFFORTS) || "high";

  const networkAccessEnabledRaw = normalizeEnvValue("CODEX_NETWORK_ACCESS_ENABLED");
  if (networkAccessEnabledRaw) {
    options.networkAccessEnabled = normalizeBool(networkAccessEnabledRaw, false);
  }

  const webSearchMode = parseEnumEnv("CODEX_WEB_SEARCH_MODE", WEB_SEARCH_MODES);
  if (webSearchMode) options.webSearchMode = webSearchMode;

  const webSearchEnabledRaw = normalizeEnvValue("CODEX_WEB_SEARCH_ENABLED");
  if (webSearchEnabledRaw) {
    options.webSearchEnabled = normalizeBool(webSearchEnabledRaw, false);
  }

  const approvalPolicy = parseEnumEnv("CODEX_APPROVAL_POLICY", APPROVAL_POLICIES);
  if (approvalPolicy) options.approvalPolicy = approvalPolicy;

  const additionalDirectories = parseStringArrayEnv("CODEX_ADDITIONAL_DIRECTORIES");
  if (additionalDirectories) options.additionalDirectories = additionalDirectories;

  return options;
})();

const DEFAULT_CODEX_OPTIONS = (() => {
  const options = {};

  // When a provider config is resolved (config.toml or CODEX_CONFIG_JSON),
  // do NOT pass baseUrl/apiKey directly. Let the Codex CLI resolve provider
  // settings and credentials from its config chain.
  if (!CODEX_CONFIG) {
    const baseUrl = normalizeEnvValue("OPENAI_BASE_URL") || normalizeEnvValue("CODEX_BASE_URL");
    if (baseUrl) options.baseUrl = baseUrl;

    const apiKey = normalizeEnvValue("CODEX_API_KEY") || normalizeEnvValue("OPENAI_API_KEY");
    if (apiKey) options.apiKey = apiKey;
  }

  const codexPathOverride = normalizeEnvValue("CODEX_PATH_OVERRIDE");
  if (codexPathOverride) options.codexPathOverride = codexPathOverride;

  const config = { ...CODEX_CONFIG_OVERRIDES };

  // Forward the provider from config.toml so the CLI subprocess gets it as a
  // --config flag in addition to reading its own config.toml.
  if (CODEX_CONFIG?.provider) {
    config.model_provider = CODEX_CONFIG.provider;
  }

  // Reasoning summary format: auto | concise | detailed
  config.model_reasoning_summary =
    parseEnumEnv("CODEX_MODEL_REASONING_SUMMARY", REASONING_SUMMARIES) || "detailed";

  const maxOutputTokensRaw = normalizeEnvValue("CODEX_MAX_OUTPUT_TOKENS");
  if (maxOutputTokensRaw) {
    const parsed = Number.parseInt(maxOutputTokensRaw, 10);
    if (!Number.isFinite(parsed) || parsed <= 0) {
      throw new Error("CODEX_MAX_OUTPUT_TOKENS must be a positive integer.");
    }
    config.max_output_tokens = parsed;
  }
  if (Object.keys(config).length > 0) options.config = config;

  const envConfig = parseJsonObjectEnv("CODEX_ENV_JSON");
  const normalizedEnv = normalizeStringRecord(envConfig);
  if (normalizedEnv) options.env = normalizedEnv;

  return options;
})();

let codexClient = null;

function getCodexClient() {
  if (!codexClient) {
    codexClient = new Codex(DEFAULT_CODEX_OPTIONS);
  }
  return codexClient;
}

function json(res, status, payload, headers = {}) {
  const body = JSON.stringify(payload);
  res.writeHead(status, {
    "Content-Type": "application/json; charset=utf-8",
    "Content-Length": Buffer.byteLength(body),
    ...headers,
  });
  res.end(body);
}

function beginSse(res, headers = {}) {
  res.writeHead(200, {
    "Content-Type": "text/event-stream; charset=utf-8",
    "Cache-Control": "no-cache",
    Connection: "keep-alive",
    "X-Accel-Buffering": "no",
    ...headers,
  });
}

function writeSse(res, payload) {
  if (res.writableEnded) return;
  res.write(`data: ${JSON.stringify(payload)}\n\n`);
}

function endSse(res) {
  if (res.writableEnded) return;
  res.write("data: [DONE]\n\n");
  res.end();
}

function readBodyJson(req) {
  return new Promise((resolve, reject) => {
    const chunks = [];
    req.on("data", (chunk) => {
      chunks.push(chunk);
    });
    req.on("error", reject);
    req.on("end", () => {
      const body = Buffer.concat(chunks).toString("utf8").trim();
      if (!body) {
        resolve({});
        return;
      }
      try {
        resolve(JSON.parse(body));
      } catch (error) {
        reject(new Error("Invalid JSON body.", { cause: error }));
      }
    });
  });
}

function asNonEmptyString(value) {
  if (typeof value !== "string") return undefined;
  const trimmed = value.trim();
  return trimmed ? trimmed : undefined;
}

function textFromItem(item) {
  if (!item || typeof item !== "object") return "";
  if (typeof item.text === "string") return item.text;
  return "";
}

function idFromItem(item) {
  if (!item || typeof item !== "object") return undefined;
  return typeof item.id === "string" ? item.id : undefined;
}

function typeFromItem(item) {
  if (!item || typeof item !== "object") return undefined;
  return typeof item.type === "string" ? item.type : undefined;
}

function normalizeItemType(itemType) {
  return typeof itemType === "string" ? itemType.trim().toLowerCase() : "";
}

function isReasoningItemType(itemType) {
  const normalized = normalizeItemType(itemType);
  if (!normalized) return false;
  return normalized === "reasoning" || /(^|[./_-])reasoning([./_-]|$)/.test(normalized);
}

function isAgentMessageItemType(itemType) {
  const normalized = normalizeItemType(itemType);
  if (!normalized) return false;
  return normalized === "agent_message" || normalized === "assistant_message";
}

function isStreamedTextItemType(itemType) {
  return isAgentMessageItemType(itemType) || isReasoningItemType(itemType);
}

function toItemDeltaEventType(itemType) {
  if (isReasoningItemType(itemType)) {
    return {
      event: "item/reasoning/delta",
      type: "response.reasoning_summary_text.delta",
    };
  }
  return {
    event: "item/agent_message/delta",
    type: "response.output_text.delta",
  };
}

function toItemDoneEventType(itemType) {
  if (isReasoningItemType(itemType)) {
    return {
      event: "item/completed",
      type: "response.reasoning_summary_text.done",
    };
  }
  return {
    event: "item/completed",
    type: "response.output_text.done",
  };
}

function toErrorMessage(error) {
  const rawMessage =
    (error instanceof Error && typeof error.message === "string")
      ? error.message
      : String(error);
  return sanitizeCodexExecErrorMessage(rawMessage);
}

function hasText(value) {
  return typeof value === "string" && value.trim().length > 0;
}

function hasListValue(values) {
  return Array.isArray(values) && values.some((value) => hasText(value));
}

function isLockedToUser(lockMetadata, field) {
  return lockMetadata[field] === "user";
}

function createSuggestionChip(field, updates) {
  return {
    id: `set-${field}`,
    label: INFERENCE_FIELD_LABELS[field],
    description: "Apply AI-inferred details",
    action: {
      type: "set_fields",
      updates,
      fields: [field],
    },
  };
}

function normalizePromptForInference(prompt) {
  return prompt.trim().toLowerCase();
}

function chooseRole(prompt) {
  const normalized = normalizePromptForInference(prompt);
  if (/(code|debug|refactor|typescript|javascript|react|python|api)\b/.test(normalized)) {
    return "Software Developer";
  }
  if (/(analy[sz]e|dashboard|metrics|kpi|sql|cohort|forecast)\b/.test(normalized)) {
    return "Data Analyst";
  }
  if (/(email|announcement|campaign|copy|headline|landing page)\b/.test(normalized)) {
    return "Expert Copywriter";
  }
  if (/(lesson|teach|syllabus|quiz|curriculum)\b/.test(normalized)) {
    return "Teacher";
  }
  return null;
}

function chooseTone(prompt) {
  const normalized = normalizePromptForInference(prompt);
  if (/(friendly|casual|informal|conversational)\b/.test(normalized)) return "Casual";
  if (/(technical|architecture|spec|implementation)\b/.test(normalized)) return "Technical";
  if (/(creative|story|brainstorm|campaign)\b/.test(normalized)) return "Creative";
  if (/(academic|citation|research)\b/.test(normalized)) return "Academic";
  if (/(executive|stakeholder|board|client)\b/.test(normalized)) return "Professional";
  return null;
}

function chooseLengthPreference(prompt) {
  const normalized = normalizePromptForInference(prompt);
  if (/(brief|short|tl;dr|concise|summary)\b/.test(normalized)) return "brief";
  if (/(detailed|deep dive|comprehensive|thorough)\b/.test(normalized)) return "detailed";
  return null;
}

function chooseFormat(prompt) {
  const normalized = normalizePromptForInference(prompt);
  if (/(json)\b/.test(normalized)) return ["JSON"];
  if (/(table|tabular)\b/.test(normalized)) return ["Table"];
  if (/(bullet|bulleted|list|checklist|steps)\b/.test(normalized)) return ["Bullet points"];
  if (/(markdown)\b/.test(normalized)) return ["Markdown"];
  return [];
}

function chooseConstraints(prompt) {
  const normalized = normalizePromptForInference(prompt);
  const values = [];
  if (/(cite|citation|source)\b/.test(normalized)) values.push("Include citations");
  if (/(plain language|simple wording|no jargon)\b/.test(normalized)) values.push("Avoid jargon");
  return values;
}

function inferBuilderFieldUpdates(prompt, currentFields, lockMetadata) {
  const normalizedPrompt = prompt.toLowerCase();
  const inferredUpdates = {};
  const inferredFields = [];
  const suggestionChips = [];
  const confidence = {};

  const role = chooseRole(normalizedPrompt);
  if (role && !hasText(currentFields.role) && !isLockedToUser(lockMetadata, "role")) {
    inferredUpdates.role = role;
    inferredFields.push("role");
    suggestionChips.push(createSuggestionChip("role", { role }));
    confidence.role = INFERENCE_FIELD_CONFIDENCE.role;
  }

  const tone = chooseTone(normalizedPrompt);
  if (tone && !hasText(currentFields.tone) && !isLockedToUser(lockMetadata, "tone")) {
    inferredUpdates.tone = tone;
    inferredFields.push("tone");
    suggestionChips.push(createSuggestionChip("tone", { tone }));
    confidence.tone = INFERENCE_FIELD_CONFIDENCE.tone;
  }

  const lengthPreference = chooseLengthPreference(normalizedPrompt);
  if (
    lengthPreference &&
    !hasText(currentFields.lengthPreference) &&
    !isLockedToUser(lockMetadata, "lengthPreference")
  ) {
    inferredUpdates.lengthPreference = lengthPreference;
    inferredFields.push("lengthPreference");
    suggestionChips.push(createSuggestionChip("lengthPreference", { lengthPreference }));
    confidence.lengthPreference = INFERENCE_FIELD_CONFIDENCE.lengthPreference;
  }

  const format = chooseFormat(normalizedPrompt);
  if (format.length > 0 && !hasListValue(currentFields.format) && !isLockedToUser(lockMetadata, "format")) {
    inferredUpdates.format = format;
    inferredFields.push("format");
    suggestionChips.push(createSuggestionChip("format", { format }));
    confidence.format = INFERENCE_FIELD_CONFIDENCE.format;
  }

  const constraints = chooseConstraints(normalizedPrompt);
  if (
    constraints.length > 0 &&
    !hasListValue(currentFields.constraints) &&
    !isLockedToUser(lockMetadata, "constraints")
  ) {
    inferredUpdates.constraints = constraints;
    inferredFields.push("constraints");
    suggestionChips.push(createSuggestionChip("constraints", { constraints }));
    confidence.constraints = INFERENCE_FIELD_CONFIDENCE.constraints;
  }

  if (suggestionChips.length === 0 && normalizedPrompt.length > 20) {
    suggestionChips.push({
      id: "append-audience",
      label: "Add audience details",
      description: "Append audience and success criteria hints.",
      action: {
        type: "append_prompt",
        text: "\nAudience: [who this is for]\nDesired outcome: [what success looks like]",
      },
    });
  }

  return { inferredUpdates, inferredFields, suggestionChips, confidence };
}

function isPrivateHost(hostname) {
  if (
    hostname === "metadata.google.internal"
    || hostname === "metadata.google"
    || hostname.endsWith(".internal")
  ) {
    return true;
  }

  const bare = hostname.startsWith("[") && hostname.endsWith("]")
    ? hostname.slice(1, -1)
    : hostname;
  if (
    bare === "::1"
    || bare === "::"
    || bare.startsWith("fe80:")
    || bare.startsWith("fc00:")
    || bare.startsWith("fd")
  ) {
    return true;
  }

  const ipv4Match = bare.match(/^(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3})$/);
  if (ipv4Match) {
    const [, a, b] = ipv4Match.map(Number);
    if (a === 127) return true;
    if (a === 10) return true;
    if (a === 172 && b >= 16 && b <= 31) return true;
    if (a === 192 && b === 168) return true;
    if (a === 169 && b === 254) return true;
    if (a === 0) return true;
    return false;
  }

  if (hostname === "localhost" || hostname.endsWith(".localhost")) {
    return true;
  }

  return false;
}

function responseMimeType(resp) {
  const ct = resp.headers.get("content-type") || "";
  return ct.split(";")[0].trim().toLowerCase();
}

function isTextLikeContentType(mimeType) {
  if (!mimeType) return true;
  if (mimeType.startsWith("text/")) return true;
  return TEXTUAL_CONTENT_TYPES.has(mimeType);
}

function isHtmlLikeMimeType(mimeType) {
  return (
    !mimeType
    || mimeType === "text/html"
    || mimeType === "application/xhtml+xml"
    || mimeType === "application/xml"
    || mimeType === "text/xml"
  );
}

function looksLikeBinaryPayload(payload) {
  if (!payload) return true;
  const sample = payload.slice(0, 4096);
  if (sample.includes("\u0000")) return true;

  let suspicious = 0;
  for (let i = 0; i < sample.length; i += 1) {
    const code = sample.charCodeAt(i);
    const isAllowedControl = code === 9 || code === 10 || code === 13;
    if (code < 32 && !isAllowedControl) suspicious += 1;
  }

  if (sample.length === 0) return false;
  return suspicious / sample.length > 0.12;
}

async function readBodyWithLimit(resp, maxBytes) {
  if (!resp.body) return "";

  const contentLength = resp.headers.get("content-length");
  if (contentLength && Number(contentLength) > maxBytes) {
    await resp.body.cancel();
    throw new Error(`Response too large (${contentLength} bytes).`);
  }

  const reader = resp.body.getReader();
  const chunks = [];
  let totalBytes = 0;

  while (true) {
    const { done, value } = await reader.read();
    if (done) break;
    totalBytes += value.byteLength;
    if (totalBytes > maxBytes) {
      await reader.cancel();
      throw new Error("Response too large.");
    }
    chunks.push(value);
  }

  const decoder = new TextDecoder();
  return chunks.map((chunk) => decoder.decode(chunk, { stream: true })).join("") + decoder.decode();
}

function stripHtml(html) {
  let text = html.replace(/<script[\s\S]*?<\/script>/gi, "");
  text = text.replace(/<style[\s\S]*?<\/style>/gi, "");
  text = text.replace(/<[^>]+>/g, " ");
  text = text.replace(/&amp;/g, "&")
    .replace(/&lt;/g, "<")
    .replace(/&gt;/g, ">")
    .replace(/&quot;/g, "\"")
    .replace(/&#39;/g, "'")
    .replace(/&nbsp;/g, " ");
  text = text.replace(/\s+/g, " ").trim();
  return text;
}

function extractMetaContent(html, matcher) {
  const metaTags = html.match(/<meta\b[^>]*>/gi) || [];
  for (const tag of metaTags) {
    if (!matcher.test(tag)) continue;
    const contentMatch = tag.match(/\bcontent=(["'])([\s\S]*?)\1/i);
    if (contentMatch?.[2]) {
      const value = contentMatch[2].replace(/\s+/g, " ").trim();
      if (value) return value;
    }
  }
  return "";
}

function extractTitle(html, url) {
  const titleMatch = html.match(/<title[^>]*>([\s\S]*?)<\/title>/i);
  if (titleMatch?.[1]) {
    return titleMatch[1].replace(/\s+/g, " ").trim().slice(0, 120);
  }
  const ogTitle = extractMetaContent(html, /\bproperty=["']og:title["']/i);
  if (ogTitle) return ogTitle.slice(0, 120);
  const twitterTitle = extractMetaContent(html, /\bname=["']twitter:title["']/i);
  if (twitterTitle) return twitterTitle.slice(0, 120);
  try {
    return new URL(url).hostname;
  } catch {
    return "Extracted content";
  }
}

function extractMetadataText(html) {
  const values = [
    extractMetaContent(html, /\bname=["']description["']/i),
    extractMetaContent(html, /\bproperty=["']og:description["']/i),
    extractMetaContent(html, /\bname=["']twitter:description["']/i),
  ].filter(Boolean);
  return values.join(" ").trim();
}

function normalizeExtractableText(rawBody, mimeType) {
  if (!rawBody) return "";
  if (isHtmlLikeMimeType(mimeType)) {
    const htmlText = stripHtml(rawBody);
    const metadataText = extractMetadataText(rawBody);
    return [htmlText, metadataText].filter(Boolean).join(" ").replace(/\s+/g, " ").trim();
  }
  return rawBody.replace(/\s+/g, " ").trim();
}

function clampExtractText(text, maxChars = 8000) {
  if (text.length <= maxChars) return text;
  return `${text.slice(0, maxChars)}…`;
}

function buildPrimaryFetchHeaders() {
  return {
    "User-Agent": "Mozilla/5.0 (compatible; PromptForge/1.0; +https://promptforge.app)",
    Accept: "text/html,application/xhtml+xml,application/xml,text/plain,application/json;q=0.9,*/*;q=0.8",
    "Accept-Language": "en-US,en;q=0.9",
    "Cache-Control": "no-cache",
    Pragma: "no-cache",
  };
}

function buildRetryFetchHeaders() {
  return {
    "User-Agent":
      "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.0.0 Safari/537.36",
    Accept:
      "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8",
    "Accept-Language": "en-US,en;q=0.9",
    "Upgrade-Insecure-Requests": "1",
    "Cache-Control": "max-age=0",
  };
}

async function fetchPageWithHeaderFallback(url, timeoutMs) {
  const attempts = [buildPrimaryFetchHeaders(), buildRetryFetchHeaders()];
  let lastResponse = null;
  let lastError = null;

  for (const headers of attempts) {
    try {
      const response = await fetchWithTimeout(
        url,
        {
          headers,
          redirect: "follow",
        },
        timeoutMs,
      );
      if (response.ok) {
        return response;
      }
      lastResponse = response;
    } catch (error) {
      lastError = error;
      if (isTimeoutError(error)) {
        throw error;
      }
    }
  }

  if (lastResponse) return lastResponse;
  throw lastError || new Error("Failed to fetch URL.");
}

function parseInputUrl(input) {
  if (!input.trim()) return null;
  const candidate = /^https?:\/\//i.test(input.trim()) ? input.trim() : `https://${input.trim()}`;

  try {
    const parsed = new URL(candidate);
    if (parsed.protocol !== "http:" && parsed.protocol !== "https:") {
      return null;
    }
    return parsed;
  } catch {
    return null;
  }
}

function isTimeoutError(error) {
  if (!(error instanceof Error)) return false;
  return error.name === "AbortError" || error.name === "TimeoutError" || error.message.toLowerCase().includes("timed out");
}

async function fetchWithTimeout(url, options, timeoutMs) {
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), timeoutMs);
  try {
    return await fetch(url, {
      ...options,
      signal: controller.signal,
    });
  } finally {
    clearTimeout(timeoutId);
  }
}

function extractTextFromOpenAiContent(content) {
  if (typeof content === "string") return content.trim();
  if (!Array.isArray(content)) return "";
  const joined = content
    .map((entry) => {
      if (!entry || typeof entry !== "object") return "";
      if (typeof entry.text === "string") return entry.text;
      return "";
    })
    .filter(Boolean)
    .join("\n");
  return joined.trim();
}

async function summarizeExtractedText(plainText) {
  if (!EXTRACT_MODEL) {
    throw new Error(
      "No extract model configured for Azure provider. Set EXTRACT_MODEL, CODEX_MODEL, or AZURE_OPENAI_DEPLOYMENT.",
    );
  }

  const apiKey = CODEX_CONFIG
    ? RESOLVED_API_KEY
    : (normalizeEnvValue("OPENAI_API_KEY") || normalizeEnvValue("CODEX_API_KEY"));
  if (!apiKey) {
    if (CODEX_CONFIG?.envKey) {
      throw new Error(`No API key configured for provider '${CODEX_CONFIG.provider}'. Set ${CODEX_CONFIG.envKey}.`);
    }
    throw new Error("No API key configured. Set AZURE_OPENAI_API_KEY (via provider config) or OPENAI_API_KEY.");
  }

  // Azure OpenAI uses `api-key` header; standard OpenAI uses `Authorization: Bearer`.
  const headers = IS_AZURE_PROVIDER
    ? { "api-key": apiKey, "Content-Type": "application/json" }
    : { Authorization: `Bearer ${apiKey}`, "Content-Type": "application/json" };

  const response = await fetchWithTimeout(`${OPENAI_API_BASE_URL.replace(/\/+$/, "")}/chat/completions`, {
    method: "POST",
    headers,
    body: JSON.stringify({
      model: EXTRACT_MODEL,
      messages: [
        {
          role: "system",
          content:
            "You are a content extractor. Given raw text from a web page, extract the 5-10 most important and relevant points as concise bullet points. Focus on facts, data, and key claims. Omit navigation text, ads, and boilerplate. Return only bullet points, one per line, prefixed with a bullet character (•).",
        },
        {
          role: "user",
          content: `Extract the key points from this page:\n\n${plainText}`,
        },
      ],
      stream: false,
    }),
  }, FETCH_TIMEOUT_MS);

  if (!response.ok) {
    return { ok: false, status: response.status, errorBody: await response.text() };
  }

  const data = await response.json().catch(() => ({}));
  const content = extractTextFromOpenAiContent(data?.choices?.[0]?.message?.content);
  return { ok: true, content };
}

function parseCurrentFields(value) {
  if (!value || typeof value !== "object" || Array.isArray(value)) return {};
  return value;
}

// ---------------------------------------------------------------------------
// 429 rate-limit retry helpers
// ---------------------------------------------------------------------------
function isRateLimitError(err) {
  if (!err) return false;
  const status = err.status ?? err.statusCode ?? err.response?.status ?? err.cause?.status ?? err.cause?.statusCode ?? err.cause?.response?.status;
  if (status === 429) return true;

  const code = err.code ?? err.cause?.code;
  if (code === 429 || code === "rate_limit_exceeded") return true;

  const msg = String(err.message ?? err.cause?.message ?? "");
  return /(^|\b)429(\b|$)|rate.limit|too many requests|throttl/i.test(msg);
}

function isRateLimitTurnFailure(event) {
  if (event?.type !== "turn.failed") return false;
  const msg = event.error?.message ?? "";
  return /(^|\b)429(\b|$)|rate.limit|too many requests|throttl/i.test(msg);
}

function sleep(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

async function runStreamedWithRetry(thread, input, turnOptions, telemetry = {}) {
  const requestContext = telemetry.requestContext;
  let attempt = 0;
  while (true) {
    let sawAnyEvent = false;
    try {
      const { events } = await thread.runStreamed(input, turnOptions);
      const iterator = events[Symbol.asyncIterator]();
      const first = await iterator.next();
      sawAnyEvent = !first.done;

      if (!first.done && isRateLimitTurnFailure(first.value) && attempt < CODEX_429_MAX_RETRIES) {
        const backoff = CODEX_429_BACKOFF_BASE_SECONDS * (2 ** attempt);
        const delay = Math.min(Math.random() * backoff, CODEX_429_BACKOFF_MAX_SECONDS) * 1000;
        if (requestContext) {
          requestContext.retryCount = attempt + 1;
        }
        logEvent("warn", "retry_attempt", cleanLogFields({
          request_id: requestContext?.requestId,
          endpoint: requestContext?.endpoint,
          method: requestContext?.method,
          transport: requestContext?.transport,
          retry_count: attempt + 1,
          max_retries: CODEX_429_MAX_RETRIES,
          error_code: "rate_limited",
          backoff_ms: Math.round(delay),
          source: "codex_turn_failed",
        }));
        await sleep(delay);
        attempt++;
        continue;
      }

      // Return a generator that yields the first event then the rest
      async function* replayEvents() {
        if (!first.done) {
          yield first.value;
          while (true) {
            const next = await iterator.next();
            if (next.done) break;
            yield next.value;
          }
        }
      }
      return { events: replayEvents() };
    } catch (err) {
      if (sawAnyEvent || !isRateLimitError(err) || attempt >= CODEX_429_MAX_RETRIES) {
        throw err;
      }
      const backoff = CODEX_429_BACKOFF_BASE_SECONDS * (2 ** attempt);
      const delay = Math.min(Math.random() * backoff, CODEX_429_BACKOFF_MAX_SECONDS) * 1000;
      if (requestContext) {
        requestContext.retryCount = attempt + 1;
      }
      logEvent("warn", "retry_attempt", cleanLogFields({
        request_id: requestContext?.requestId,
        endpoint: requestContext?.endpoint,
        method: requestContext?.method,
        transport: requestContext?.transport,
        retry_count: attempt + 1,
        max_retries: CODEX_429_MAX_RETRIES,
        error_code: "rate_limited",
        backoff_ms: Math.round(delay),
        source: "codex_exception",
      }));
      await sleep(delay);
      attempt++;
    }
  }
}

function buildEnhanceStreamRequest(body) {
  const requestBody = body && typeof body === "object" && !Array.isArray(body)
    ? body
    : {};

  const prompt = asNonEmptyString(requestBody.prompt);
  if (!prompt) {
    return {
      ok: false,
      status: 400,
      detail: "Prompt is required.",
    };
  }
  if (prompt.length > MAX_PROMPT_CHARS) {
    return {
      ok: false,
      status: 413,
      detail: `Prompt is too large. Maximum ${MAX_PROMPT_CHARS} characters.`,
    };
  }

  const hasThreadIdField = Object.prototype.hasOwnProperty.call(requestBody, "thread_id")
    || Object.prototype.hasOwnProperty.call(requestBody, "threadId");
  const requestedThreadId = asNonEmptyString(requestBody.thread_id) || asNonEmptyString(requestBody.threadId);
  if (hasThreadIdField && !requestedThreadId) {
    return {
      ok: false,
      status: 400,
      detail: "thread_id must be a non-empty string when provided.",
    };
  }

  const requestThreadOptions = extractThreadOptions(requestBody.thread_options || requestBody.threadOptions);
  const threadOptions = { ...DEFAULT_THREAD_OPTIONS, ...requestThreadOptions };
  const builderMode = parseEnhancementRequestMode(requestBody);
  const builderFields = parseEnhancementRequestBuilderFields(requestBody);
  const enhancementContext = detectEnhancementContext(prompt, {
    builderMode,
    builderFields,
  });
  const enhancementInput = buildEnhancementMetaPrompt(prompt, enhancementContext);

  return {
    ok: true,
    requestData: {
      prompt,
      requestedThreadId,
      threadOptions,
      enhancementContext,
      enhancementInput,
      turnId: `turn_${randomUUID().replaceAll("-", "")}`,
    },
  };
}

async function runEnhanceTurnStream(requestData, options) {
  const {
    prompt,
    requestedThreadId,
    threadOptions,
    enhancementContext,
    enhancementInput,
    turnId,
  } = requestData;
  const {
    signal,
    emit,
    isClosed,
    requestContext,
  } = options;

  const stateByItemId = new Map();
  const agentMessageByItemId = new Map();
  const agentMessageItemOrder = [];

  try {
    const codex = getCodexClient();
    const thread = requestedThreadId
      ? codex.resumeThread(requestedThreadId, threadOptions)
      : codex.startThread(threadOptions);
    const { events } = await runStreamedWithRetry(
      thread,
      enhancementInput,
      { signal },
      { requestContext },
    );

    let activeThreadId = requestedThreadId || null;
    let turnFailed = false;
    let turnError = false;

    for await (const event of events) {
      if (signal.aborted || isClosed()) break;

      if (event.type === "thread.started") {
        activeThreadId = event.thread_id;
        emit({
          event: "thread.started",
          type: "thread.started",
          thread_id: activeThreadId,
        });
        continue;
      }

      if (event.type === "turn.started") {
        emit({
          event: "turn.started",
          type: "response.created",
          turn_id: turnId,
          thread_id: activeThreadId,
          kind: "enhance",
        });
        continue;
      }

      if (event.type === "turn.completed") {
        captureUsageMetrics(requestContext, event.usage);
        emit({
          event: "turn.completed",
          type: "response.completed",
          turn_id: turnId,
          thread_id: activeThreadId,
          usage: event.usage,
          response: {
            id: turnId,
            status: "completed",
          },
        });
        continue;
      }

      if (event.type === "turn.failed") {
        turnFailed = true;
        const failureMessage = toErrorMessage(event.error);
        const failureCode = /(^|\b)429(\b|$)|rate.limit|too many requests|throttl/i.test(failureMessage.toLowerCase())
          ? "rate_limited"
          : "service_error";
        setRequestError(requestContext, failureCode, failureMessage);
        emit({
          event: "turn.failed",
          type: "turn.failed",
          turn_id: turnId,
          thread_id: activeThreadId,
          error: event.error,
        });
        continue;
      }

      if (event.type === "error") {
        turnError = true;
        setRequestError(requestContext, "service_error", toErrorMessage(event.message));
        emit({
          event: "thread.error",
          type: "error",
          turn_id: turnId,
          thread_id: activeThreadId,
          error: event.message,
        });
        continue;
      }

      if (event.type === "item.started") {
        const itemId = idFromItem(event.item);
        const itemType = typeFromItem(event.item);
        emit({
          event: "item.started",
          type: "response.output_item.added",
          turn_id: turnId,
          thread_id: activeThreadId,
          item_id: itemId,
          item_type: itemType,
          item: event.item,
        });
        continue;
      }

      if (event.type === "item.updated") {
        const itemId = idFromItem(event.item);
        const itemType = typeFromItem(event.item);

        if (isStreamedTextItemType(itemType)) {
          const previousText = itemId ? stateByItemId.get(itemId) || "" : "";
          const currentText = textFromItem(event.item);
          let delta = "";

          if (currentText && currentText.startsWith(previousText)) {
            delta = currentText.slice(previousText.length);
          } else if (currentText && currentText !== previousText) {
            delta = currentText;
          }

          if (itemId) {
            stateByItemId.set(itemId, currentText);
          }

          if (isAgentMessageItemType(itemType)) {
            const agentItemKey = itemId || "__agent_message__";
            if (!agentMessageByItemId.has(agentItemKey)) {
              agentMessageItemOrder.push(agentItemKey);
            }
            agentMessageByItemId.set(agentItemKey, currentText);
          }

          if (delta) {
            const eventShape = toItemDeltaEventType(itemType);
            emit({
              event: eventShape.event,
              type: eventShape.type,
              turn_id: turnId,
              thread_id: activeThreadId,
              item_id: itemId,
              item_type: itemType,
              delta,
              ...(isAgentMessageItemType(itemType) ? { choices: [{ delta: { content: delta } }] } : {}),
              item: event.item,
            });
          }
          continue;
        }

        emit({
          event: "item.updated",
          type: "response.output_item.updated",
          turn_id: turnId,
          thread_id: activeThreadId,
          item_id: itemId,
          item_type: itemType,
          item: event.item,
        });
        continue;
      }

      if (event.type === "item.completed") {
        const itemId = idFromItem(event.item);
        const itemType = typeFromItem(event.item);

        if (isStreamedTextItemType(itemType)) {
          const text = textFromItem(event.item);
          if (itemId) {
            stateByItemId.set(itemId, text);
          }

          if (isAgentMessageItemType(itemType)) {
            const agentItemKey = itemId || "__agent_message__";
            if (!agentMessageByItemId.has(agentItemKey)) {
              agentMessageItemOrder.push(agentItemKey);
            }
            agentMessageByItemId.set(agentItemKey, text);
          }

          const eventShape = toItemDoneEventType(itemType);
          emit({
            event: eventShape.event,
            type: eventShape.type,
            turn_id: turnId,
            thread_id: activeThreadId,
            item_id: itemId,
            item_type: itemType,
            payload: { text },
            text,
            output_text: text,
            item: event.item,
          });
          continue;
        }

        emit({
          event: "item.completed",
          type: "response.output_item.done",
          turn_id: turnId,
          thread_id: activeThreadId,
          item_id: itemId,
          item_type: itemType,
          item: event.item,
        });
      }
    }

    if (!signal.aborted && !isClosed() && !turnFailed && !turnError) {
      const rawEnhancerOutput = pickPrimaryAgentMessageText(agentMessageByItemId, agentMessageItemOrder);
      const postProcessed = postProcessEnhancementResponse({
        llmResponseText: rawEnhancerOutput,
        userInput: prompt,
        context: enhancementContext,
      });
      const finalEnhancedPrompt = postProcessed.enhanced_prompt?.trim() || rawEnhancerOutput.trim();

      if (finalEnhancedPrompt) {
        const syntheticItemId = `item_enhanced_${randomUUID().replaceAll("-", "")}`;
        emit({
          event: "item/agent_message/delta",
          type: "response.output_text.delta",
          turn_id: turnId,
          thread_id: activeThreadId,
          item_id: syntheticItemId,
          item_type: "agent_message",
          delta: finalEnhancedPrompt,
          choices: [{ delta: { content: finalEnhancedPrompt } }],
          item: { id: syntheticItemId, type: "agent_message", delta: finalEnhancedPrompt },
        });
        emit({
          event: "item/completed",
          type: "response.output_text.done",
          turn_id: turnId,
          thread_id: activeThreadId,
          item_id: syntheticItemId,
          item_type: "agent_message",
          payload: { text: finalEnhancedPrompt },
          text: finalEnhancedPrompt,
          output_text: finalEnhancedPrompt,
          item: { id: syntheticItemId, type: "agent_message", text: finalEnhancedPrompt },
        });
      }

      emit({
        event: "enhance/metadata",
        type: "enhance.metadata",
        turn_id: turnId,
        thread_id: activeThreadId,
        payload: postProcessed,
      });
    }
  } catch (error) {
    setRequestError(requestContext, "service_error", toErrorMessage(error), 500);
    if (!isClosed()) {
      const message = toErrorMessage(error);
      emit({
        event: "turn/error",
        type: "turn/error",
        turn_id: turnId,
        error: message,
        code: "service_error",
      });
    }
  }
}

async function streamWithCodex(req, res, body, corsHeaders, requestContext) {
  const preparedRequest = buildEnhanceStreamRequest(body);
  if (!preparedRequest.ok) {
    setRequestError(
      requestContext,
      inferErrorCodeFromStatus(preparedRequest.status),
      preparedRequest.detail,
      preparedRequest.status,
    );
    json(res, preparedRequest.status, { detail: preparedRequest.detail }, corsHeaders);
    return;
  }

  const controller = new AbortController();
  req.on("aborted", () => {
    setRequestError(requestContext, "request_aborted", "Client disconnected.", 499);
    controller.abort("Client disconnected");
  });
  res.on("close", () => {
    if (!res.writableEnded) {
      setRequestError(requestContext, "request_aborted", "Client disconnected.", 499);
      controller.abort("Client disconnected");
    }
  });

  beginSse(res, corsHeaders);
  await runEnhanceTurnStream(preparedRequest.requestData, {
    signal: controller.signal,
    emit: (payload) => writeSse(res, payload),
    isClosed: () => res.writableEnded,
    requestContext,
  });
  endSse(res);
}

function isWebSocketOpen(ws) {
  return ws && ws.readyState === 1;
}

function writeWebSocketEvent(ws, payload) {
  if (!isWebSocketOpen(ws)) return;
  ws.send(JSON.stringify(payload));
}

function closeWebSocket(ws, code = 1000, reason = "done") {
  if (typeof ws.readyState === "number" && ws.readyState >= 2) return;
  ws.close(code, reason);
}

function writeWebSocketError(ws, options) {
  const {
    message,
    status,
    code,
    retryAfterSeconds,
  } = options;
  writeWebSocketEvent(ws, {
    event: "turn/error",
    type: "turn/error",
    error: message,
    ...(typeof status === "number" ? { status } : {}),
    ...(typeof code === "string" ? { code } : {}),
    ...(typeof retryAfterSeconds === "number" ? { retry_after_seconds: retryAfterSeconds } : {}),
  });
}

function classifyWebSocketAuthErrorCode(status, message) {
  if (status !== 401) return "service_error";
  const normalized = typeof message === "string" ? message.toLowerCase() : "";
  if (
    normalized.includes("missing bearer token")
    || normalized.includes("missing token")
    || normalized.includes("sign in required")
  ) {
    return "auth_required";
  }
  return "auth_session_invalid";
}

function classifyHttpAuthErrorCode(status, message) {
  if (status === 401) {
    return classifyWebSocketAuthErrorCode(status, message);
  }
  if (status === 503) return "service_unavailable";
  return "service_error";
}

async function handleEnhanceWebSocketConnection(ws, request, requestContext) {
  const clientIp = getClientIp(request);
  if (!acquireEnhanceWebSocketConnectionSlot(clientIp)) {
    setRequestError(
      requestContext,
      "rate_limited",
      "Too many concurrent websocket connections.",
      429,
    );
    writeWebSocketError(ws, {
      message: "Too many concurrent websocket connections. Please retry shortly.",
      status: 429,
      code: "rate_limited",
    });
    closeWebSocket(ws, 1008, "too_many_connections");
    completeRequestContext(requestContext, 429);
    return;
  }

  let releasedConnectionSlot = false;
  const releaseConnectionSlot = () => {
    if (releasedConnectionSlot) return;
    releasedConnectionSlot = true;
    releaseEnhanceWebSocketConnectionSlot(clientIp);
  };
  ws.on("close", releaseConnectionSlot);

  try {
    const controller = new AbortController();
    let receivedStartMessage = false;
    const firstMessageTimeoutHandle = globalThis.setTimeout(() => {
      if (receivedStartMessage || !isWebSocketOpen(ws)) return;
      setRequestError(
        requestContext,
        "request_timeout",
        "Timed out waiting for websocket start payload.",
        408,
      );
      writeWebSocketError(ws, {
        message: "Timed out waiting for websocket start payload.",
        status: 408,
        code: "request_timeout",
      });
      closeWebSocket(ws, 1008, "start_timeout");
    }, ENHANCE_WS_INITIAL_MESSAGE_TIMEOUT_MS);

    ws.on("close", () => {
      globalThis.clearTimeout(firstMessageTimeoutHandle);
      if (!controller.signal.aborted) {
        controller.abort("Client disconnected");
      }
      const closeStatus = Number.isFinite(requestContext?.statusCode)
        ? requestContext.statusCode
        : requestContext?.errorCode
          ? 400
          : 200;
      completeRequestContext(requestContext, closeStatus);
    });

    ws.once("message", (rawData, isBinary) => {
      receivedStartMessage = true;
      globalThis.clearTimeout(firstMessageTimeoutHandle);
      void (async () => {
        if (isBinary) {
          setRequestError(requestContext, "bad_response", "Invalid websocket payload.", 400);
          writeWebSocketError(ws, {
            message: "Invalid websocket payload.",
            status: 400,
            code: "bad_response",
          });
          closeWebSocket(ws, 1003, "invalid_payload");
          return;
        }

        const rawText = typeof rawData === "string"
          ? rawData
          : Buffer.from(rawData).toString("utf8");

        let messageBody;
        try {
          messageBody = JSON.parse(rawText);
        } catch {
          setRequestError(requestContext, "bad_response", "Invalid JSON body.", 400);
          writeWebSocketError(ws, {
            message: "Invalid JSON body.",
            status: 400,
            code: "bad_response",
          });
          closeWebSocket(ws, 1003, "invalid_json");
          return;
        }

        const hasStartEnvelope =
          messageBody
          && typeof messageBody === "object"
          && !Array.isArray(messageBody)
          && messageBody.type === "enhance.start";
        const payload =
          hasStartEnvelope
            ? messageBody.payload
            : messageBody;
        const rawAuthPayload =
          hasStartEnvelope
            ? messageBody.auth
            : (
              messageBody
              && typeof messageBody === "object"
              && !Array.isArray(messageBody)
            )
              ? (messageBody.auth ?? messageBody.authentication)
              : undefined;

        const req = createWebSocketRequestView(
          request,
          extractWebSocketAuthHeadersFromPayload(rawAuthPayload),
        );
        const auth = await authenticateRequestContext(req);
        if (!auth.ok) {
          setRequestError(
            requestContext,
            classifyHttpAuthErrorCode(auth.status, auth.error),
            auth.error,
            auth.status,
          );
          writeWebSocketError(ws, {
            message: auth.error,
            status: auth.status,
            code: classifyWebSocketAuthErrorCode(auth.status, auth.error),
          });
          closeWebSocket(ws, 1008, "auth_failed");
          return;
        }
        if (requestContext) {
          requestContext.userIdHash = hashUserIdentifier(auth.userId);
        }

        const rateLimit = checkEnhanceRateLimits(auth, clientIp);
        if (!rateLimit.ok) {
          setRequestError(requestContext, "rate_limited", rateLimit.error, rateLimit.status);
          writeWebSocketError(ws, {
            message: rateLimit.error,
            status: rateLimit.status,
            code: "rate_limited",
            retryAfterSeconds: rateLimit.retryAfterSeconds,
          });
          closeWebSocket(ws, 1008, "rate_limited");
          return;
        }

        const preparedRequest = buildEnhanceStreamRequest(payload || {});
        if (!preparedRequest.ok) {
          setRequestError(
            requestContext,
            inferErrorCodeFromStatus(preparedRequest.status),
            preparedRequest.detail,
            preparedRequest.status,
          );
          writeWebSocketError(ws, {
            message: preparedRequest.detail,
            status: preparedRequest.status,
            code: "bad_response",
          });
          closeWebSocket(ws, 1008, "invalid_request");
          return;
        }

        await runEnhanceTurnStream(preparedRequest.requestData, {
          signal: controller.signal,
          emit: (eventPayload) => writeWebSocketEvent(ws, eventPayload),
          isClosed: () => !isWebSocketOpen(ws),
          requestContext,
        });

        if (!controller.signal.aborted && isWebSocketOpen(ws)) {
          writeWebSocketEvent(ws, {
            event: "stream.done",
            type: "stream.done",
          });
          closeWebSocket(ws, 1000, "done");
        }
      })();
    });
  } catch (error) {
    setRequestError(requestContext, "service_error", toErrorMessage(error), 500);
    writeWebSocketError(ws, {
      message: toErrorMessage(error),
      status: 500,
      code: "service_error",
    });
    closeWebSocket(ws, 1011, "internal_error");
    releaseConnectionSlot();
    completeRequestContext(requestContext, 500);
  }
}

function enforceRateLimit(res, corsHeaders, options, failureMessage, requestContext) {
  const result = applyRateLimit(options);
  if (result.ok) return true;
  setRequestError(requestContext, "rate_limited", failureMessage, 429);
  json(
    res,
    429,
    { error: failureMessage },
    {
      ...corsHeaders,
      "Retry-After": String(result.retryAfterSeconds),
    },
  );
  return false;
}

function checkRateLimit(options, failureMessage) {
  const result = applyRateLimit(options);
  if (result.ok) {
    return { ok: true };
  }

  return {
    ok: false,
    status: 429,
    error: failureMessage,
    retryAfterSeconds: result.retryAfterSeconds,
  };
}

function checkEnhanceRateLimits(auth, clientIp) {
  const minuteWindow = checkRateLimit({
    scope: "enhance-minute",
    key: `${auth.rateKey}:${clientIp}`,
    limit: ENHANCE_PER_MINUTE,
    windowMs: 60_000,
  }, "Rate limit exceeded. Please try again later.");
  if (!minuteWindow.ok) {
    return minuteWindow;
  }

  return checkRateLimit({
    scope: "enhance-day",
    key: auth.rateKey,
    limit: ENHANCE_PER_DAY,
    windowMs: 86_400_000,
  }, "Daily quota exceeded. Please try again tomorrow.");
}

async function authenticateRequest(req, res, corsHeaders, requestContext) {
  const auth = await authenticateRequestContext(req);
  if (!auth.ok) {
    setRequestError(
      requestContext,
      classifyHttpAuthErrorCode(auth.status, auth.error),
      auth.error,
      auth.status,
    );
    json(res, auth.status, { error: auth.error }, corsHeaders);
    return null;
  }
  if (requestContext) {
    requestContext.userIdHash = hashUserIdentifier(auth.userId);
  }
  return auth;
}

async function handleEnhance(req, res, body, corsHeaders, requestContext) {
  const auth = await authenticateRequest(req, res, corsHeaders, requestContext);
  if (!auth) return;

  const clientIp = getClientIp(req);
  const rateLimit = checkEnhanceRateLimits(auth, clientIp);
  if (!rateLimit.ok) {
    setRequestError(requestContext, "rate_limited", rateLimit.error, rateLimit.status);
    json(
      res,
      rateLimit.status,
      { error: rateLimit.error },
      {
        ...corsHeaders,
        ...(rateLimit.retryAfterSeconds
          ? { "Retry-After": String(rateLimit.retryAfterSeconds) }
          : {}),
      },
    );
    return;
  }

  await streamWithCodex(req, res, body, corsHeaders, requestContext);
}

async function handleExtractUrl(req, res, body, corsHeaders, requestContext) {
  const auth = await authenticateRequest(req, res, corsHeaders, requestContext);
  if (!auth) return;

  const clientIp = getClientIp(req);
  if (!enforceRateLimit(res, corsHeaders, {
    scope: "extract-minute",
    key: `${auth.rateKey}:${clientIp}`,
    limit: EXTRACT_PER_MINUTE,
    windowMs: 60_000,
  }, "Rate limit exceeded. Please try again later.", requestContext)) {
    return;
  }

  if (!enforceRateLimit(res, corsHeaders, {
    scope: "extract-day",
    key: auth.rateKey,
    limit: EXTRACT_PER_DAY,
    windowMs: 86_400_000,
  }, "Daily quota exceeded. Please try again tomorrow.", requestContext)) {
    return;
  }

  const rawUrl = body?.url;
  const urlInput = typeof rawUrl === "string" ? rawUrl.trim() : "";
  if (!urlInput) {
    json(res, 400, { error: "A valid URL is required." }, corsHeaders);
    return;
  }
  if (urlInput.length > MAX_URL_CHARS) {
    json(
      res,
      413,
      { error: `URL is too large. Maximum ${MAX_URL_CHARS} characters.` },
      corsHeaders,
    );
    return;
  }

  const parsedUrl = parseInputUrl(urlInput);
  if (!parsedUrl) {
    json(res, 400, { error: "Invalid URL format." }, corsHeaders);
    return;
  }

  if (isPrivateHost(parsedUrl.hostname)) {
    json(res, 400, { error: "URLs pointing to private or internal hosts are not allowed." }, corsHeaders);
    return;
  }

  let pageResponse;
  try {
    pageResponse = await fetchPageWithHeaderFallback(parsedUrl.href, FETCH_TIMEOUT_MS);
  } catch (error) {
    if (isTimeoutError(error)) {
      json(res, 504, { error: "Timed out while fetching the URL." }, corsHeaders);
      return;
    }
    throw error;
  }

  if (!pageResponse.ok) {
    json(
      res,
      422,
      {
        error: `Could not fetch URL (status ${pageResponse.status}). The target site may block automated access.`,
      },
      corsHeaders,
    );
    return;
  }

  let bodyText;
  try {
    bodyText = await readBodyWithLimit(pageResponse, MAX_RESPONSE_BYTES);
  } catch {
    json(res, 413, { error: "Response body is too large to process." }, corsHeaders);
    return;
  }

  const mimeType = responseMimeType(pageResponse);
  if (!isTextLikeContentType(mimeType) && looksLikeBinaryPayload(bodyText)) {
    json(
      res,
      422,
      {
        error:
          "The URL appears to be non-text or binary content. Provide a page URL with readable text, or paste content manually.",
      },
      corsHeaders,
    );
    return;
  }

  const title = extractTitle(bodyText, parsedUrl.href);
  let plainText = normalizeExtractableText(bodyText, mimeType);
  plainText = clampExtractText(plainText, 8000);

  if (plainText.length < 50) {
    json(
      res,
      422,
      {
        error:
          "Page had too little readable text content (often caused by script-only pages or anti-bot blocks). You can still paste text manually.",
      },
      corsHeaders,
    );
    return;
  }

  let summaryResult;
  try {
    summaryResult = await summarizeExtractedText(plainText);
  } catch (error) {
    if (isTimeoutError(error)) {
      json(res, 504, { error: "Timed out while extracting content." }, corsHeaders);
      return;
    }
    throw error;
  }

  if (!summaryResult.ok) {
    const errText = summaryResult.errorBody.trim();
    if (summaryResult.status === 429) {
      setRequestError(requestContext, "rate_limited", "Rate limit exceeded while extracting content.", 429);
      json(res, 429, { error: "Rate limit exceeded. Please try again in a moment." }, corsHeaders);
      return;
    }
    if (summaryResult.status === 402) {
      setRequestError(requestContext, "quota_exceeded", "AI credits depleted.", 402);
      json(res, 402, { error: "AI credits depleted. Please add funds to continue." }, corsHeaders);
      return;
    }
    setRequestError(
      requestContext,
      inferErrorCodeFromStatus(summaryResult.status) || "service_error",
      errText || "OpenAI extraction request failed.",
      summaryResult.status,
    );
    logEvent("error", "extract_url_openai_error", cleanLogFields({
      request_id: requestContext?.requestId,
      endpoint: requestContext?.endpoint,
      status_code: summaryResult.status,
      error_code: requestContext?.errorCode || inferErrorCodeFromStatus(summaryResult.status) || "service_error",
      error_message: errText || "OpenAI extraction request failed.",
    }));
    json(res, 500, { error: "Failed to extract content from the page." }, corsHeaders);
    return;
  }

  json(res, 200, { title, content: summaryResult.content }, corsHeaders);
}

async function handleInferBuilderFields(req, res, body, corsHeaders, requestContext) {
  const auth = await authenticateRequest(req, res, corsHeaders, requestContext);
  if (!auth) return;

  const clientIp = getClientIp(req);
  if (!enforceRateLimit(res, corsHeaders, {
    scope: "infer-minute",
    key: `${auth.rateKey}:${clientIp}`,
    limit: INFER_PER_MINUTE,
    windowMs: 60_000,
  }, "Rate limit exceeded. Please try again later.", requestContext)) {
    return;
  }

  if (!enforceRateLimit(res, corsHeaders, {
    scope: "infer-day",
    key: auth.rateKey,
    limit: INFER_PER_DAY,
    windowMs: 86_400_000,
  }, "Daily quota exceeded. Please try again tomorrow.", requestContext)) {
    return;
  }

  const promptRaw = body?.prompt;
  const prompt = typeof promptRaw === "string" ? promptRaw.trim() : "";
  if (!prompt) {
    json(res, 400, { error: "Prompt is required." }, corsHeaders);
    return;
  }
  if (prompt.length > MAX_INFERENCE_PROMPT_CHARS) {
    json(
      res,
      413,
      { error: `Prompt is too large. Maximum ${MAX_INFERENCE_PROMPT_CHARS} characters.` },
      corsHeaders,
    );
    return;
  }

  const currentFields = parseCurrentFields(body?.current_fields ?? body?.currentFields);
  const lockMetadata = parseCurrentFields(body?.lock_metadata ?? body?.lockMetadata);

  const inference = inferBuilderFieldUpdates(prompt, currentFields, lockMetadata);
  json(res, 200, inference, corsHeaders);
}

async function requestHandler(req, res) {
  const url = new URL(req.url || "/", "http://localhost");
  const rawRequestId = (headerValue(req, "x-request-id") || "").trim();
  const requestId = rawRequestId || `req_${randomUUID().replaceAll("-", "")}`;
  const method = typeof req.method === "string" ? req.method : "GET";
  const requestContext = createRequestContext(
    requestId,
    url.pathname,
    method,
    transportForEndpoint(url.pathname),
  );
  res.setHeader("x-request-id", requestId);
  attachHttpRequestLifecycleLogging(res, requestContext);
  logEvent("info", "request_start", {
    request_id: requestContext.requestId,
    endpoint: requestContext.endpoint,
    method: requestContext.method,
    transport: requestContext.transport,
  });

  if (req.method === "GET" && url.pathname === "/") {
    json(res, 200, {
      service: "ai-prompt-pro-codex-service",
      provider: "codex-sdk",
      status: "running",
      health: "/health",
    });
    return;
  }

  if (req.method === "GET" && url.pathname === "/health") {
    json(res, 200, {
      ok: true,
      provider: "codex-sdk",
      provider_source: CODEX_CONFIG_SOURCE,
      provider_name: CODEX_CONFIG?.name || "OpenAI",
      provider_base_url: OPENAI_API_BASE_URL,
      model: DEFAULT_THREAD_OPTIONS.model || null,
      sandbox_mode: DEFAULT_THREAD_OPTIONS.sandboxMode || null,
    });
    return;
  }

  const isFunctionPath = (
    url.pathname === "/enhance"
    || url.pathname === "/extract-url"
    || url.pathname === "/infer-builder-fields"
  );

  if (isFunctionPath) {
    const cors = resolveCors(req);
    if (req.method === "OPTIONS") {
      if (!cors.ok) {
        setRequestError(requestContext, inferErrorCodeFromStatus(cors.status), cors.error, cors.status);
        json(res, cors.status, { error: cors.error }, cors.headers);
        return;
      }
      res.writeHead(200, cors.headers);
      res.end("ok");
      return;
    }

    if (!cors.ok) {
      setRequestError(requestContext, inferErrorCodeFromStatus(cors.status), cors.error, cors.status);
      json(res, cors.status, { error: cors.error }, cors.headers);
      return;
    }

    if (req.method !== "POST") {
      setRequestError(requestContext, inferErrorCodeFromStatus(405), "Method not allowed.", 405);
      json(res, 405, { error: "Method not allowed." }, cors.headers);
      return;
    }

    let body;
    try {
      body = await readBodyJson(req);
    } catch (error) {
      setRequestError(requestContext, "bad_request", toErrorMessage(error), 400);
      json(res, 400, { error: toErrorMessage(error) }, cors.headers);
      return;
    }

    try {
      if (url.pathname === "/enhance") {
        await handleEnhance(req, res, body, cors.headers, requestContext);
        return;
      }
      if (url.pathname === "/extract-url") {
        await handleExtractUrl(req, res, body, cors.headers, requestContext);
        return;
      }
      if (url.pathname === "/infer-builder-fields") {
        await handleInferBuilderFields(req, res, body, cors.headers, requestContext);
        return;
      }
    } catch (error) {
      setRequestError(requestContext, "service_error", toErrorMessage(error), 500);
      logEvent("error", "request_handler_exception", cleanLogFields({
        request_id: requestContext.requestId,
        endpoint: requestContext.endpoint,
        method: requestContext.method,
        transport: requestContext.transport,
        error_code: requestContext.errorCode || "service_error",
        error_message: requestContext.errorMessage,
      }));
      json(
        res,
        500,
        { error: error instanceof Error ? error.message : "Unknown error" },
        cors.headers,
      );
      return;
    }
  }

  setRequestError(requestContext, inferErrorCodeFromStatus(404), "Not found.", 404);
  json(res, 404, { detail: "Not found." });
}

const enhanceWebSocketServer = new WebSocketServer({
  noServer: true,
  maxPayload: ENHANCE_WS_MAX_PAYLOAD_BYTES,
  handleProtocols: (protocols) => {
    if (protocols.has(ENHANCE_WS_PROTOCOL)) {
      return ENHANCE_WS_PROTOCOL;
    }
    return false;
  },
});

const websocketRequestContextByRequest = new WeakMap();

enhanceWebSocketServer.on("connection", (ws, req) => {
  const requestContext = websocketRequestContextByRequest.get(req)
    || createRequestContext(
      `req_${randomUUID().replaceAll("-", "")}`,
      ENHANCE_WS_PATH,
      "GET",
      "ws",
    );
  websocketRequestContextByRequest.delete(req);
  void handleEnhanceWebSocketConnection(ws, req, requestContext);
});

const server = createServer((req, res) => {
  void requestHandler(req, res);
});

server.on("upgrade", (req, socket, head) => {
  const url = new URL(req.url || "/", "http://localhost");
  const rawRequestId = (headerValue(req, "x-request-id") || "").trim();
  const requestId = rawRequestId || `req_${randomUUID().replaceAll("-", "")}`;
  const requestContext = createRequestContext(
    requestId,
    url.pathname || ENHANCE_WS_PATH,
    typeof req.method === "string" ? req.method : "GET",
    "ws",
  );
  logEvent("info", "request_start", {
    request_id: requestContext.requestId,
    endpoint: requestContext.endpoint,
    method: requestContext.method,
    transport: requestContext.transport,
  });
  if (url.pathname !== ENHANCE_WS_PATH) {
    socket.destroy();
    setRequestError(requestContext, "not_found", "Not found.", 404);
    completeRequestContext(requestContext, 404);
    return;
  }

  if (req.method !== "GET") {
    rejectWebSocketUpgrade(socket, 405, { error: "Method not allowed." }, requestContext);
    return;
  }

  const offeredProtocols = parseWebSocketProtocols(req);
  if (!offeredProtocols.includes(ENHANCE_WS_PROTOCOL)) {
    rejectWebSocketUpgrade(socket, 400, {
      error: `Missing websocket protocol ${ENHANCE_WS_PROTOCOL}.`,
    }, requestContext);
    return;
  }

  const cors = resolveCors(req);
  if (!cors.ok) {
    rejectWebSocketUpgrade(
      socket,
      cors.status || 403,
      { error: cors.error || "Origin is not allowed." },
      requestContext,
    );
    return;
  }

  enhanceWebSocketServer.handleUpgrade(req, socket, head, (ws) => {
    websocketRequestContextByRequest.set(req, requestContext);
    enhanceWebSocketServer.emit("connection", ws, req);
  });
});

server.listen(SERVICE_CONFIG.port, SERVICE_CONFIG.host, () => {
  logEvent("info", "service_start", {
    host: SERVICE_CONFIG.host,
    port: SERVICE_CONFIG.port,
    provider_source: CODEX_CONFIG_SOURCE,
    provider: CODEX_CONFIG?.provider || "openai",
    provider_name: CODEX_CONFIG?.name || "OpenAI",
    provider_base_url: CODEX_CONFIG?.baseUrl || "https://api.openai.com/v1",
    model: DEFAULT_THREAD_OPTIONS.model || null,
    extract_model: EXTRACT_MODEL,
    sandbox_mode: DEFAULT_THREAD_OPTIONS.sandboxMode || null,
  });
});
````

## File: src/components/AuthDialog.tsx
````typescript
import { type FormEvent, useState } from "react";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
} from "@/components/base/dialog";
import { Button } from "@/components/base/buttons/button";
import { InputBase, Input } from "@/components/base/input/input";
import { InputGroup } from "@/components/base/input/input-group";
import { AppleOAuthIcon, GitHubOAuthIcon, GoogleOAuthIcon } from "@/components/icons/oauth-icons";
import { useAuth, type AuthOAuthProvider } from "@/hooks/useAuth";
import { neon } from "@/integrations/neon/client";
import { brandCopy } from "@/lib/brand-copy";
import { Eye, EyeSlash } from "@phosphor-icons/react";

interface AuthDialogProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
}

export function AuthDialog({ open, onOpenChange }: AuthDialogProps) {
  const { signIn, signUp, signInWithOAuth } = useAuth();
  const [mode, setMode] = useState<"login" | "signup">("login");
  const [displayName, setDisplayName] = useState("");
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [showPassword, setShowPassword] = useState(false);
  const [error, setError] = useState("");
  const [loading, setLoading] = useState(false);
  const [oauthLoading, setOauthLoading] = useState<AuthOAuthProvider | null>(null);
  const [forgotPasswordLoading, setForgotPasswordLoading] = useState(false);
  const [forgotPasswordSent, setForgotPasswordSent] = useState(false);
  const [confirmationSent, setConfirmationSent] = useState(false);

  const handleSubmit = async (event: FormEvent<HTMLFormElement>) => {
    event.preventDefault();
    if (loading || oauthLoading || forgotPasswordLoading) return;

    setError("");
    setForgotPasswordSent(false);
    setLoading(true);

    const result =
      mode === "login"
        ? await signIn(email, password)
        : await signUp(email, password, displayName);

    setLoading(false);

    if (result.error) {
      setError(result.error);
      return;
    }

    if (mode === "signup") {
      if (result.session) {
        onOpenChange(false);
        resetForm();
        return;
      }
      setConfirmationSent(true);
      return;
    }

    // Login succeeded — close
    onOpenChange(false);
    resetForm();
  };

  const handleOAuth = async (provider: AuthOAuthProvider) => {
    if (loading || oauthLoading) return;

    setError("");
    setForgotPasswordSent(false);
    setOauthLoading(provider);

    try {
      const result = await signInWithOAuth(provider);
      if (result.error) {
        setError(result.error);
      }
    } finally {
      setOauthLoading(null);
    }
  };

  const handleForgotPassword = async () => {
    if (loading || oauthLoading || forgotPasswordLoading) return;

    const normalizedEmail = email.trim();
    setError("");
    setForgotPasswordSent(false);

    if (!normalizedEmail) {
      setError("Enter your email first to reset your password.");
      return;
    }

    setForgotPasswordLoading(true);
    try {
      const { error: forgotPasswordError } = await neon.auth.resetPasswordForEmail(
        normalizedEmail,
        { redirectTo: window.location.origin },
      );

      if (forgotPasswordError) {
        setError(forgotPasswordError.message || "Failed to send reset email.");
        return;
      }

      setForgotPasswordSent(true);
    } catch (forgotPasswordError) {
      setError(forgotPasswordError instanceof Error ? forgotPasswordError.message : "Failed to send reset email.");
    } finally {
      setForgotPasswordLoading(false);
    }
  };

  const resetForm = () => {
    setDisplayName("");
    setEmail("");
    setPassword("");
    setShowPassword(false);
    setError("");
    setLoading(false);
    setOauthLoading(null);
    setForgotPasswordLoading(false);
    setForgotPasswordSent(false);
    setConfirmationSent(false);
  };

  const toggleMode = () => {
    setMode((currentMode) => (currentMode === "login" ? "signup" : "login"));
    setError("");
    setPassword("");
    setShowPassword(false);
    setForgotPasswordLoading(false);
    setForgotPasswordSent(false);
    setConfirmationSent(false);
  };

  return (
    <Dialog
      open={open}
      onOpenChange={(v) => {
        onOpenChange(v);
        if (!v) resetForm();
      }}
    >
      <DialogContent className="pf-dialog-surface sm:max-w-md">
        <DialogHeader className="space-y-3">
          <div className="mx-auto inline-flex items-center rounded-md border border-border-primary bg-secondary px-2.5 py-1.5">
            <img
              src="/pf/promptforge-wordmark.png"
              alt=""
              decoding="async"
              className="h-7 w-auto object-contain"
              aria-hidden="true"
            />
          </div>
          <DialogTitle className="text-center">
            {mode === "login" ? "Sign in" : "Create account"}
          </DialogTitle>
          <DialogDescription className="text-center text-xs text-tertiary">
            Sign in or create an account to save, remix, and share prompts.
          </DialogDescription>
          <p className="text-center text-xs text-tertiary">
            {brandCopy.tagline}
          </p>
        </DialogHeader>

        {confirmationSent ? (
          <div className="text-center py-4 space-y-2">
            <p className="text-sm text-tertiary">
              Check your email, confirm your account, then sign in.
            </p>
            <Button
              color="secondary"
              onPress={() => {
                setMode("login");
                setConfirmationSent(false);
              }}
            >
              Back to sign in
            </Button>
          </div>
        ) : (
          <div className="space-y-4">
            {/* OAuth buttons */}
            <div className="grid grid-cols-1 gap-2 sm:grid-cols-3">
              <Button
                color="secondary"
                onPress={() => void handleOAuth("apple")}
                isDisabled={loading || Boolean(oauthLoading)}
                isLoading={oauthLoading === "apple"}
                showTextWhileLoading
                iconLeading={AppleOAuthIcon}
              >
                Apple
              </Button>
              <Button
                color="secondary"
                onPress={() => void handleOAuth("github")}
                isDisabled={loading || Boolean(oauthLoading)}
                isLoading={oauthLoading === "github"}
                showTextWhileLoading
                iconLeading={GitHubOAuthIcon}
              >
                GitHub
              </Button>
              <Button
                color="secondary"
                onPress={() => void handleOAuth("google")}
                isDisabled={loading || Boolean(oauthLoading)}
                isLoading={oauthLoading === "google"}
                showTextWhileLoading
                iconLeading={GoogleOAuthIcon}
              >
                Google
              </Button>
            </div>

            <div className="relative">
              <div className="absolute inset-0 flex items-center">
                <span className="w-full border-t" />
              </div>
              <div className="relative flex justify-center text-xs uppercase">
                <span className="bg-secondary px-2 text-tertiary">
                  Or continue with email
                </span>
              </div>
            </div>

            <form onSubmit={handleSubmit} className="space-y-3">
              {mode === "signup" && (
                <Input
                  label="Display name"
                  type="text"
                  value={displayName}
                  onChange={setDisplayName}
                  placeholder="Defaults to your email username"
                  autoComplete="name"
                  maxLength={80}
                />
              )}

              <Input
                label="Email"
                isRequired
                type="email"
                value={email}
                onChange={setEmail}
                placeholder="you@example.com"
                autoComplete="email"
              />

              <InputGroup
                label="Password"
                isRequired
                hint={mode === "signup" ? "Use at least 8 characters." : undefined}
                trailingAddon={
                  <InputGroup.Prefix isDisabled={loading || Boolean(oauthLoading)}>
                    <button
                      type="button"
                      aria-label={showPassword ? "Hide password" : "Show password"}
                      aria-pressed={showPassword}
                      className="inline-flex h-full items-center justify-center px-3 text-tertiary transition duration-100 ease-linear hover:text-secondary disabled:cursor-not-allowed disabled:text-disabled"
                      disabled={loading || Boolean(oauthLoading)}
                      onClick={() => setShowPassword((isVisible) => !isVisible)}
                    >
                      {showPassword ? <EyeSlash className="size-4" aria-hidden="true" /> : <Eye className="size-4" aria-hidden="true" />}
                    </button>
                  </InputGroup.Prefix>
                }
              >
                <InputBase
                  type={showPassword ? "text" : "password"}
                  value={password}
                  onChange={setPassword}
                  placeholder={mode === "signup" ? "At least 8 characters" : "Enter your password"}
                  minLength={mode === "signup" ? 8 : undefined}
                  autoComplete={mode === "login" ? "current-password" : "new-password"}
                />
              </InputGroup>

              {mode === "login" && (
                <div className="flex justify-end">
                  <Button
                    type="button"
                    color="link-color"
                    onPress={() => void handleForgotPassword()}
                    isDisabled={forgotPasswordLoading}
                    isLoading={forgotPasswordLoading}
                    showTextWhileLoading
                    className="text-sm"
                  >
                    Forgot password?
                  </Button>
                </div>
              )}

              {forgotPasswordSent && mode === "login" && (
                <p className="text-sm text-tertiary">
                  Password reset email sent. Check your inbox.
                </p>
              )}

              {error && (
                <p className="text-sm text-error-primary">{error}</p>
              )}

              <Button
                type="submit"
                className="w-full"
                isDisabled={loading || Boolean(oauthLoading)}
                isLoading={loading}
              >
                {mode === "login" ? "Sign in" : "Create account"}
              </Button>
            </form>

            <p className="text-center text-sm text-tertiary">
              {mode === "login" ? "No account? " : "Already have an account? "}
              <button
                type="button"
                className="text-brand-primary underline-offset-4 hover:underline"
                onClick={toggleMode}
              >
                {mode === "login" ? "Sign up" : "Sign in"}
              </button>
            </p>
          </div>
        )}
      </DialogContent>
    </Dialog>
  );
}
````

## File: src/pages/Library.tsx
````typescript
import { useCallback, useEffect, useMemo, useRef, useState } from "react";
import { Link, useNavigate } from "react-router-dom";
import { useVirtualizer } from "@tanstack/react-virtual";
import { PageHero, PageShell } from "@/components/PageShell";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/base/primitives/avatar";
import { Badge } from "@/components/base/badges/badges";
import { Button } from "@/components/base/buttons/button";
import { Card } from "@/components/base/primitives/card";
import { Checkbox } from "@/components/base/primitives/checkbox";
import { DropdownMenu, DropdownMenuContent, DropdownMenuItem, DropdownMenuTrigger } from "@/components/base/primitives/dropdown-menu";
import { Input } from "@/components/base/input/input";
import { StateCard } from "@/components/base/primitives/state-card";
import { Select } from "@/components/base/select/select";
import { ToastAction } from "@/components/base/primitives/toast";
import { useAuth } from "@/hooks/useAuth";
import { useIsMobile } from "@/hooks/use-mobile";
import { usePromptBuilder } from "@/hooks/usePromptBuilder";
import { useToast } from "@/hooks/use-toast";
import { brandCopy } from "@/lib/brand-copy";
import { getLibraryPromptRarity } from "@/lib/community-rarity";
import {
  getInitials,
  getUserAvatarUrl,
  getUserDisplayName,
} from "@/lib/library-pages";
import * as persistence from "@/lib/persistence";
import { PFTemplateCard } from "@/components/fantasy/PFTemplateCard";
import {
  ArrowSquareOut as ExternalLink,
  ArrowsDownUp as ArrowDownUp,
  Database,
  DotsThreeOutline as MoreHorizontal,
  GitBranch,
  Lock,
  MagnifyingGlass as Search,
  ShareNetwork as Share2,
  Sparkle as Sparkles,
} from "@phosphor-icons/react";

type SavedPromptSort = "recent" | "name" | "revision";
const LIBRARY_VIRTUALIZATION_THRESHOLD = 50;
const LIBRARY_SELECTION_STORAGE_KEY = "library-selection-ids";

function formatUpdatedAt(timestamp: number): string {
  const date = new Date(timestamp);
  return date.toLocaleDateString(undefined, {
    year: "numeric",
    month: "short",
    day: "numeric",
  });
}

function resolveShareUseCase(prompt: persistence.PromptSummary): string | undefined {
  const candidates = [prompt.useCase, prompt.description, prompt.starterPrompt];
  for (const candidate of candidates) {
    const normalized = candidate.trim();
    if (normalized) return normalized;
  }
  return undefined;
}

function normalizeSelectionIds(ids: string[]): string[] {
  return Array.from(
    new Set(
      ids
        .map((id) => id.trim())
        .filter(Boolean),
    ),
  );
}

function loadSelectionFromSession(): string[] {
  if (typeof window === "undefined") return [];
  try {
    const raw = window.sessionStorage.getItem(LIBRARY_SELECTION_STORAGE_KEY);
    const parsed = raw ? JSON.parse(raw) : [];
    if (!Array.isArray(parsed)) return [];
    return normalizeSelectionIds(parsed.filter((value): value is string => typeof value === "string"));
  } catch {
    return [];
  }
}

const Library = () => {
  const navigate = useNavigate();
  const { toast } = useToast();
  const { user } = useAuth();
  const userId = user?.id ?? null;
  const ownerName = getUserDisplayName(user);
  const ownerAvatarUrl = getUserAvatarUrl(user);
  const isMobile = useIsMobile();
  const {
    templateSummaries,
    isSignedIn,
    deleteSavedTemplate,
    deleteSavedTemplates,
    shareSavedPrompt,
    unshareSavedPrompt,
    unshareSavedPrompts,
  } = usePromptBuilder();
  const [query, setQuery] = useState("");
  const [sortBy, setSortBy] = useState<SavedPromptSort>("recent");
  const [activeCategory, setActiveCategory] = useState<string>("all");
  const [selectedIds, setSelectedIds] = useState<string[]>(() => loadSelectionFromSession());
  const [showSelectedOnly, setShowSelectedOnly] = useState(false);
  const [isBulkDeleting, setIsBulkDeleting] = useState(false);
  const [isBulkUnsharing, setIsBulkUnsharing] = useState(false);

  const normalizedQuery = query.trim().toLowerCase();
  const selectedSet = useMemo(() => new Set(selectedIds), [selectedIds]);

  const categories = useMemo(() => {
    const known = Array.from(
      new Set(
        templateSummaries
          .map((prompt) => (prompt.category || "general").trim().toLowerCase())
          .filter(Boolean),
      ),
    ).sort((a, b) => a.localeCompare(b));
    return ["all", ...known];
  }, [templateSummaries]);

  const filteredSaved = useMemo(() => {
    const matchesCategory =
      activeCategory === "all"
        ? templateSummaries
        : templateSummaries.filter((prompt) => (prompt.category || "general").toLowerCase() === activeCategory);

    const matchesQuery = matchesCategory.filter((prompt) => {
      if (!normalizedQuery) return true;
      const haystack = [prompt.name, prompt.description, prompt.tags.join(" "), prompt.starterPrompt, prompt.category]
        .join(" ")
        .toLowerCase();
      return haystack.includes(normalizedQuery);
    });

    const sorted = [...matchesQuery];
    if (sortBy === "name") {
      sorted.sort((a, b) => a.name.localeCompare(b.name));
    } else if (sortBy === "revision") {
      sorted.sort((a, b) => b.revision - a.revision);
    } else {
      sorted.sort((a, b) => b.updatedAt - a.updatedAt);
    }
    return sorted;
  }, [activeCategory, normalizedQuery, sortBy, templateSummaries]);

  const visibleSaved = useMemo(() => {
    if (!showSelectedOnly) return filteredSaved;
    return filteredSaved.filter((prompt) => selectedSet.has(prompt.id));
  }, [filteredSaved, selectedSet, showSelectedOnly]);
  const featuredPrompts = useMemo(
    () => [...templateSummaries].sort((a, b) => b.updatedAt - a.updatedAt).slice(0, 3),
    [templateSummaries],
  );

  const promptById = useMemo(() => new Map(templateSummaries.map((prompt) => [prompt.id, prompt])), [templateSummaries]);
  const selectedPrompts = useMemo(
    () => selectedIds.map((id) => promptById.get(id)).filter(Boolean),
    [promptById, selectedIds],
  );
  const selectedCount = selectedIds.length;
  const allFilteredSelected = filteredSaved.length > 0 && filteredSaved.every((prompt) => selectedSet.has(prompt.id));
  const hasActiveFilters = Boolean(normalizedQuery) || activeCategory !== "all" || showSelectedOnly;
  const shouldVirtualize = visibleSaved.length >= LIBRARY_VIRTUALIZATION_THRESHOLD;
  const isSelectionMode = selectedCount > 0;
  const listScrollRef = useRef<HTMLDivElement | null>(null);
  const rowVirtualizer = useVirtualizer({
    count: shouldVirtualize ? visibleSaved.length : 0,
    getScrollElement: () => listScrollRef.current,
    estimateSize: () => 248,
    overscan: 6,
    measureElement: (element) => element.getBoundingClientRect().height,
    enabled: shouldVirtualize,
  });

  useEffect(() => {
    if (templateSummaries.length === 0) return;
    setSelectedIds((prev) => {
      const next = prev.filter((id) => promptById.has(id));
      if (next.length === prev.length) return prev;
      if (typeof window !== "undefined") {
        if (next.length > 0) {
          window.sessionStorage.setItem(LIBRARY_SELECTION_STORAGE_KEY, JSON.stringify(next));
        } else {
          window.sessionStorage.removeItem(LIBRARY_SELECTION_STORAGE_KEY);
        }
      }
      return next;
    });
  }, [promptById, templateSummaries.length]);

  const applySelection = useCallback((ids: string[]) => {
    const next = normalizeSelectionIds(ids);
    setSelectedIds(next);
    if (typeof window !== "undefined") {
      if (next.length > 0) {
        window.sessionStorage.setItem(LIBRARY_SELECTION_STORAGE_KEY, JSON.stringify(next));
      } else {
        window.sessionStorage.removeItem(LIBRARY_SELECTION_STORAGE_KEY);
      }
    }
  }, []);

  const togglePromptSelection = useCallback(
    (id: string, checked: boolean) => {
      applySelection(checked ? [...selectedIds, id] : selectedIds.filter((value) => value !== id));
    },
    [applySelection, selectedIds],
  );

  const toggleSelectAllFiltered = useCallback(
    (checked: boolean) => {
      const filteredIds = filteredSaved.map((prompt) => prompt.id);
      if (!checked) {
        const filteredSet = new Set(filteredIds);
        applySelection(selectedIds.filter((id) => !filteredSet.has(id)));
        return;
      }
      applySelection([...selectedIds, ...filteredIds]);
    },
    [applySelection, filteredSaved, selectedIds],
  );

  const handleSelectSaved = useCallback(
    async (id: string) => {
      try {
        const loaded = await persistence.loadPromptById(userId, id);
        if (!loaded) {
          toast({ title: "Prompt not found", variant: "destructive" });
          return;
        }

        await persistence.saveDraft(userId, loaded.record.state.promptConfig);
        toast({
          title: `Prompt loaded: ${loaded.record.metadata.name}`,
          description:
            loaded.warnings.length > 0
              ? `${loaded.warnings.length} context warning(s) found.`
              : "Prompt and context restored successfully.",
        });
        navigate("/");
      } catch (error) {
        toast({
          title: "Failed to load prompt",
          description: error instanceof Error ? error.message : "Unexpected error",
          variant: "destructive",
        });
      }
    },
    [navigate, toast, userId],
  );

  const handleDeleteSaved = useCallback(
    async (id: string) => {
      try {
        const deleted = await deleteSavedTemplate(id);
        if (!deleted) {
          toast({ title: "Prompt not found", variant: "destructive" });
          return;
        }
        applySelection(selectedIds.filter((value) => value !== id));
        toast({ title: "Saved prompt deleted" });
      } catch (error) {
        toast({
          title: "Failed to delete prompt",
          description: error instanceof Error ? error.message : "Unexpected error",
          variant: "destructive",
        });
      }
    },
    [applySelection, deleteSavedTemplate, selectedIds, toast],
  );

  const handleShareSaved = useCallback(
    async (prompt: persistence.PromptSummary) => {
      if (!isSignedIn) {
        toast({ title: "Sign in required", description: "Sign in to share prompts.", variant: "destructive" });
        return;
      }
      const shareUseCase = resolveShareUseCase(prompt);
      if (!shareUseCase) {
        toast({
          title: "Missing share metadata",
          description: "Load this prompt, add a use case context, then try sharing again.",
          variant: "destructive",
        });
        return;
      }
      try {
        const result = await shareSavedPrompt(prompt.id, { useCase: shareUseCase });
        if (!result.shared) {
          toast({ title: "Prompt not found", variant: "destructive" });
          return;
        }
        toast({
          title: "Prompt shared to community remix feed",
          action: result.postId ? (
            <ToastAction altText="View post" asChild>
              <Link to={`/community/${result.postId}`}>View</Link>
            </ToastAction>
          ) : undefined,
        });
      } catch (error) {
        toast({
          title: "Failed to share prompt",
          description: error instanceof Error ? error.message : "Unexpected error",
          variant: "destructive",
        });
      }
    },
    [isSignedIn, shareSavedPrompt, toast],
  );

  const handleUnshareSaved = useCallback(
    async (id: string) => {
      try {
        const unshared = await unshareSavedPrompt(id);
        if (!unshared) {
          toast({ title: "Prompt not found", variant: "destructive" });
          return;
        }
        toast({ title: "Prompt removed from community" });
      } catch (error) {
        toast({
          title: "Failed to unshare prompt",
          description: error instanceof Error ? error.message : "Unexpected error",
          variant: "destructive",
        });
      }
    },
    [toast, unshareSavedPrompt],
  );

  const handleLoadFirstSelected = useCallback(() => {
    const first = selectedPrompts[0];
    if (!first) return;
    void handleSelectSaved(first.id);
  }, [handleSelectSaved, selectedPrompts]);

  const handleBulkSetPrivate = useCallback(async () => {
    if (selectedIds.length === 0 || isBulkUnsharing) return;
    setIsBulkUnsharing(true);
    try {
      const updatedIds = await unshareSavedPrompts(selectedIds);
      if (updatedIds.length === 0) {
        toast({ title: "No shared prompts selected" });
      } else if (updatedIds.length === selectedIds.length) {
        toast({
          title:
            updatedIds.length === 1 ? "1 prompt set to private" : `${updatedIds.length} prompts set to private`,
        });
      } else {
        const unchangedCount = selectedIds.length - updatedIds.length;
        toast({
          title: `${updatedIds.length} prompts set to private`,
          description:
            unchangedCount === 1
              ? "1 prompt was already private."
              : `${unchangedCount} prompts were already private.`,
        });
      }
    } catch (error) {
      toast({
        title: "Failed to update visibility",
        description: error instanceof Error ? error.message : "Unexpected error",
        variant: "destructive",
      });
    } finally {
      setIsBulkUnsharing(false);
    }
  }, [isBulkUnsharing, selectedIds, toast, unshareSavedPrompts]);

  const handleBulkDelete = useCallback(async () => {
    if (selectedIds.length === 0 || isBulkDeleting) return;
    const confirmed = window.confirm(
      selectedIds.length === 1
        ? "Delete 1 selected prompt?"
        : `Delete ${selectedIds.length} selected prompts?`,
    );
    if (!confirmed) return;

    setIsBulkDeleting(true);
    try {
      const deletedIds = await deleteSavedTemplates(selectedIds);
      if (deletedIds.length === 0) {
        toast({ title: "No prompts were deleted", variant: "destructive" });
        return;
      }
      const deletedSet = new Set(deletedIds);
      applySelection(selectedIds.filter((id) => !deletedSet.has(id)));
      if (deletedIds.length === selectedIds.length) {
        toast({
          title: deletedIds.length === 1 ? "Deleted 1 prompt" : `Deleted ${deletedIds.length} prompts`,
        });
      } else {
        const skippedCount = selectedIds.length - deletedIds.length;
        toast({
          title: `Deleted ${deletedIds.length} prompts`,
          description:
            skippedCount === 1 ? "1 prompt could not be deleted." : `${skippedCount} prompts could not be deleted.`,
        });
      }
    } catch (error) {
      toast({
        title: "Failed to delete selected prompts",
        description: error instanceof Error ? error.message : "Unexpected error",
        variant: "destructive",
      });
    } finally {
      setIsBulkDeleting(false);
    }
  }, [applySelection, deleteSavedTemplates, isBulkDeleting, selectedIds, toast]);

  const resetFilters = useCallback(() => {
    setQuery("");
    setActiveCategory("all");
    setShowSelectedOnly(false);
  }, []);

  const renderPromptCard = useCallback(
    (prompt: persistence.PromptSummary) => {
      const isSelected = selectedSet.has(prompt.id);
      const shareUseCase = resolveShareUseCase(prompt);
      const shareDisabledReason = !isSignedIn
        ? "Sign in to share."
        : !shareUseCase
          ? "Add a use case in Builder before sharing."
          : null;

      return (
        <Card
          key={prompt.id}
          className={`interactive-card p-3 transition-colors ${isSelected ? "border-primary/45 bg-primary/5" : "hover:border-primary/40"
            }`}
        >
          <div className="flex items-start gap-3">
            <Checkbox
              checked={isSelected}
              onCheckedChange={(checked) => togglePromptSelection(prompt.id, checked === true)}
              aria-label={`Select ${prompt.name}`}
              className="mt-1"
            />
            <div className="min-w-0 flex-1 space-y-1.5">
              <div className="flex min-w-0 items-center gap-2">
                <Avatar className="h-7 w-7 border border-border/60">
                  <AvatarImage src={ownerAvatarUrl ?? undefined} alt={ownerName} />
                  <AvatarFallback className="text-xs">{getInitials(ownerName)}</AvatarFallback>
                </Avatar>
                <div className="min-w-0 flex-1">
                  <div className="flex flex-wrap items-center gap-2">
                    <h3 className="type-wrap-safe text-sm font-medium text-foreground">{prompt.name}</h3>
                    <Badge type="modern" className="border border-border bg-background text-foreground text-xs">
                      r{prompt.revision}
                    </Badge>
                    {prompt.isShared ? (
                      <Badge type="modern" className="text-xs gap-1">
                        <Share2 className="h-3 w-3" />
                        Shared
                      </Badge>
                    ) : (
                      <Badge type="modern" className="border border-border bg-background text-foreground text-xs gap-1">
                        <Lock className="h-3 w-3" />
                        Private
                      </Badge>
                    )}
                    {!isSelectionMode && prompt.remixedFrom && (
                      <Badge type="modern" className="text-xs gap-1">
                        <GitBranch className="h-3 w-3" />
                        Remixed
                      </Badge>
                    )}
                  </div>
                  <p className="text-xs text-muted-foreground">{ownerName}</p>
                </div>
              </div>

              {isSelectionMode ? (
                <div className="flex flex-wrap items-center gap-1.5 text-xs text-muted-foreground">
                  <span className="capitalize">{prompt.category || "general"}</span>
                  <span>•</span>
                  <span>{formatUpdatedAt(prompt.updatedAt)}</span>
                  <span>•</span>
                  <span>{prompt.isShared ? "Shared" : "Private"}</span>
                </div>
              ) : (
                <>
                  {prompt.description && (
                    <p className="line-clamp-2 text-xs text-muted-foreground">{prompt.description}</p>
                  )}
                  <p className="line-clamp-2 text-xs text-muted-foreground/90">
                    <span className="font-medium text-foreground/80">Start:</span> {prompt.starterPrompt}
                  </p>
                  <div className="flex flex-wrap items-center gap-1.5 text-xs text-muted-foreground">
                    <span className="capitalize">{prompt.category || "general"}</span>
                    <span>•</span>
                    <span>{formatUpdatedAt(prompt.updatedAt)}</span>
                    <span>•</span>
                    <span className="inline-flex items-center gap-1">
                      <Database className="h-3.5 w-3.5" />
                      {prompt.sourceCount} context src / {prompt.databaseCount} db
                    </span>
                  </div>
                  {prompt.tags.length > 0 && (
                    <div className="flex flex-wrap gap-1">
                      {prompt.tags.slice(0, 5).map((tag) => (
                        <Badge key={`${prompt.id}-${tag}`} type="modern" className="border border-border bg-background text-foreground text-xs">
                          #{tag}
                        </Badge>
                      ))}
                    </div>
                  )}
                </>
              )}
            </div>

            {!isMobile && !isSelectionMode && (
              <div className="flex shrink-0 flex-col items-end gap-1">
                <Button
                  type="button"
                  color="primary"
                  size="sm"
                  className="h-11 px-2.5 text-sm sm:h-9 sm:text-sm"
                  onClick={() => void handleSelectSaved(prompt.id)}
                >
                  Load
                </Button>
                {prompt.isShared && prompt.communityPostId && (
                  <Button
                    color="tertiary"
                    size="sm"
                    className="h-11 px-2.5 text-sm sm:h-9 sm:text-sm"
                    onClick={() => navigate(`/community/${prompt.communityPostId}`)}
                  >
                    Open
                    <ExternalLink className="h-3 w-3" />
                  </Button>
                )}
                {prompt.isShared ? (
                  <Button
                    type="button"
                    color="secondary"
                    size="sm"
                    className="h-11 px-2.5 text-sm sm:h-9 sm:text-sm"
                    onClick={() => void handleUnshareSaved(prompt.id)}
                  >
                    Unshare
                  </Button>
                ) : (
                  <Button
                    type="button"
                    color="secondary"
                    size="sm"
                    className="h-11 px-2.5 text-sm sm:h-9 sm:text-sm"
                    isDisabled={Boolean(shareDisabledReason)}
                    onClick={() => void handleShareSaved(prompt)}
                  >
                    Share
                  </Button>
                )}
                {shareDisabledReason && !prompt.isShared && (
                  <p className="max-w-40 text-right text-xs text-muted-foreground">
                    {shareDisabledReason}
                  </p>
                )}
                <Button
                  type="button"
                  color="tertiary"
                  size="sm"
                  className="h-11 px-2.5 text-sm text-destructive hover:text-destructive sm:h-9 sm:text-sm"
                  onClick={() => void handleDeleteSaved(prompt.id)}
                >
                  Delete
                </Button>
              </div>
            )}
          </div>

          {isMobile && !isSelectionMode && (
            <div className="mt-2 flex items-center justify-end gap-2 border-t border-border/60 pt-2">
              {shareDisabledReason && !prompt.isShared && (
                <p className="mr-auto text-xs text-muted-foreground">{shareDisabledReason}</p>
              )}
              <Button
                type="button"
                color="primary"
                size="sm"
                className="h-11 px-3 text-sm"
                onClick={() => void handleSelectSaved(prompt.id)}
              >
                Load
              </Button>
              <DropdownMenu>
                <DropdownMenuTrigger asChild>
                  <Button
                    type="button"
                    color="secondary"
                    size="sm"
                    className="h-11 px-3 text-sm"
                    aria-label={`More actions for ${prompt.name}`}
                  >
                    <MoreHorizontal className="h-3.5 w-3.5" />
                    More
                  </Button>
                </DropdownMenuTrigger>
                <DropdownMenuContent align="end">
                  {prompt.isShared && prompt.communityPostId && (
                    <DropdownMenuItem
                      onSelect={() => navigate(`/community/${prompt.communityPostId}`)}
                    >
                      Open
                    </DropdownMenuItem>
                  )}
                  {prompt.isShared ? (
                    <DropdownMenuItem onSelect={() => void handleUnshareSaved(prompt.id)}>
                      Unshare
                    </DropdownMenuItem>
                  ) : (
                    <DropdownMenuItem
                      disabled={Boolean(shareDisabledReason)}
                      onSelect={() => void handleShareSaved(prompt)}
                    >
                      Share
                    </DropdownMenuItem>
                  )}
                  <DropdownMenuItem
                    className="text-destructive focus:text-destructive"
                    onSelect={() => void handleDeleteSaved(prompt.id)}
                  >
                    Delete
                  </DropdownMenuItem>
                </DropdownMenuContent>
              </DropdownMenu>
            </div>
          )}
        </Card>
      );
    },
    [
      handleDeleteSaved,
      handleSelectSaved,
      handleShareSaved,
      handleUnshareSaved,
      isMobile,
      isSignedIn,
      isSelectionMode,
      navigate,
      ownerAvatarUrl,
      ownerName,
      selectedSet,
      togglePromptSelection,
    ],
  );

  return (
    <PageShell>
      <PageHero
        eyebrow={brandCopy.brandLine}
        title="Prompt Library"
        subtitle="Track quality, context sources, and remix history for every saved prompt."
        className="pf-gilded-frame pf-hero-surface"
      />

      {featuredPrompts.length > 0 && (
        <Card className="pf-panel mb-4 border-[rgba(214,166,64,.32)] p-3 sm:p-4">
          <div className="flex flex-col gap-2 sm:flex-row sm:items-end sm:justify-between">
            <div>
              <p className="pf-text-display text-xl text-[rgba(230,225,213,.95)]">Featured Artifacts</p>
              <p className="text-sm text-[rgba(230,225,213,.72)]">
                Latest prompt builds mapped to Fantasy Forge rarity frames.
              </p>
            </div>
            <Button
              color="secondary"
              size="sm"
              className="h-11 text-sm sm:h-9 sm:text-sm"
              onClick={() => navigate("/")}
            >
              <Sparkles className="h-3.5 w-3.5" />
              Forge new prompt
            </Button>
          </div>

          <div className="mt-3 grid gap-3 md:grid-cols-3">
            {featuredPrompts.map((prompt) => (
              <PFTemplateCard
                key={`featured-${prompt.id}`}
                title={`✦ ${prompt.name}`}
                description={prompt.description || prompt.starterPrompt}
                rarity={getLibraryPromptRarity(prompt)}
                author={prompt.isShared ? "Community Artifact" : ownerName}
                tags={prompt.tags}
                footerLeft={formatUpdatedAt(prompt.updatedAt)}
                footerRight={`r${prompt.revision}`}
                onClick={() => {
                  void handleSelectSaved(prompt.id);
                }}
              />
            ))}
          </div>
        </Card>
      )}

      <div className="ui-density space-y-4" data-density="comfortable">
        <Card className="border-border/80 bg-card/85 p-3 sm:p-4">
          <div className="flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between">
            <div className="space-y-1">
              <p className="ui-section-label text-primary">Quality + context + remix</p>
              <p className="text-sm text-muted-foreground">
                Keep your saved prompts production-ready without changing baseline templates.
              </p>
            </div>
            <Button color="secondary" size="sm" className="h-11 gap-1 text-sm sm:h-9 sm:text-sm" onClick={() => navigate("/")}>
              <Sparkles className="h-3.5 w-3.5" />
              Open Builder
            </Button>
          </div>
        </Card>

        <Card className="border-border/80 bg-card/85 p-3 sm:p-4">
          <div className="grid grid-cols-1 gap-2 border-b border-border/60 pb-3 sm:grid-cols-[1fr_auto_auto] sm:items-center">
            <div className="relative">
              <label htmlFor="library-page-search" className="sr-only">
                Search saved prompts
              </label>
              <Search className="absolute left-2.5 top-1/2 h-3.5 w-3.5 -translate-y-1/2 text-muted-foreground" />
              <Input
                id="library-page-search"
                value={query}
                onChange={setQuery}
                placeholder="Search by name, tag, context, or remix note"
                wrapperClassName="h-11 bg-background sm:h-10"
                inputClassName="pl-8"
              />
            </div>

            <Select
              selectedKey={activeCategory}
              onSelectionChange={(value) => {
                if (value !== null) {
                  setActiveCategory(String(value));
                }
              }}
              className="min-w-35 capitalize"
              aria-label="Filter category"
              size="md"
            >
              {categories.map((category) => (
                <Select.Item key={category} id={category} className="capitalize">
                  {category}
                </Select.Item>
              ))}
            </Select>

            <div className="flex items-center gap-1.5">
              <ArrowDownUp className="h-3.5 w-3.5 text-muted-foreground" />
              <Select
                selectedKey={sortBy}
                onSelectionChange={(value) => {
                  if (value !== null) {
                    setSortBy(String(value) as SavedPromptSort);
                  }
                }}
                className="min-w-34.5"
                aria-label="Sort saved prompts"
                size="md"
              >
                <Select.Item id="recent">Most Recent</Select.Item>
                <Select.Item id="name">Name (A-Z)</Select.Item>
                <Select.Item id="revision">Revision (High)</Select.Item>
              </Select>
            </div>
          </div>

          <div className="mt-3 space-y-3">
            <div className="rounded-md border border-primary/20 bg-primary/5 p-2">
              <div className="flex flex-wrap items-center justify-between gap-2">
                <div className="flex items-center gap-2 text-xs text-muted-foreground">
                  <Checkbox
                    checked={allFilteredSelected}
                    onCheckedChange={(checked) => toggleSelectAllFiltered(checked === true)}
                    aria-label="Select all filtered prompts"
                  />
                  <span>{selectedCount} selected</span>
                  <Badge type="modern" className="text-xs">
                    {visibleSaved.length} shown
                  </Badge>
                  {showSelectedOnly && (
                    <Badge type="modern" className="border border-border bg-background text-foreground text-xs">
                      Selected only
                    </Badge>
                  )}
                </div>
                <div className="flex flex-wrap items-center justify-end gap-2">
                  <Button
                    type="button"
                    color="secondary"
                    size="sm"
                    className="h-11 text-sm sm:h-9 sm:text-sm"
                    isDisabled={selectedCount === 0 && !showSelectedOnly}
                    onClick={() => setShowSelectedOnly((prev) => !prev)}
                  >
                    Selected only
                  </Button>
                  {selectedCount > 0 && (
                    <>
                      <Button
                        type="button"
                        color="primary"
                        size="sm"
                        className="h-11 text-sm sm:h-9 sm:text-sm"
                        onClick={handleLoadFirstSelected}
                      >
                        Load first
                      </Button>
                      <Button
                        type="button"
                        color="secondary"
                        size="sm"
                        className="h-11 text-sm sm:h-9 sm:text-sm"
                        isDisabled={isBulkUnsharing}
                        onClick={() => void handleBulkSetPrivate()}
                      >
                        {isBulkUnsharing ? "Setting private..." : "Set private"}
                      </Button>
                      <Button
                        type="button"
                        color="secondary"
                        size="sm"
                        className="h-11 border-destructive/40 text-sm text-destructive hover:text-destructive sm:h-9 sm:text-sm"
                        isDisabled={isBulkDeleting}
                        onClick={() => void handleBulkDelete()}
                      >
                        {isBulkDeleting ? "Deleting..." : "Delete selected"}
                      </Button>
                      <Button
                        type="button"
                        color="tertiary"
                        size="sm"
                        className="h-11 text-sm sm:h-9 sm:text-sm"
                        onClick={() => {
                          applySelection([]);
                          setShowSelectedOnly(false);
                        }}
                      >
                        Clear
                      </Button>
                    </>
                  )}
                </div>
              </div>
            </div>

            {templateSummaries.length === 0 && (
              <StateCard
                variant="empty"
                title="No saved prompts yet"
                description="Create a prompt in Builder, run a quality pass, and save it here."
                primaryAction={{ label: "Go to Builder", to: "/" }}
              />
            )}

            {templateSummaries.length > 0 && visibleSaved.length === 0 && (
              <StateCard
                variant="empty"
                title={showSelectedOnly ? "No selected prompts in this view." : "No prompts match this filter."}
                description={
                  showSelectedOnly
                    ? "Select prompts, or switch off Selected only to browse everything."
                    : "Try a different search term, category, or context keyword."
                }
                primaryAction={
                  hasActiveFilters
                    ? { label: "Reset filters", onClick: resetFilters }
                    : { label: "Go to Builder", to: "/" }
                }
                secondaryAction={{ label: "Go to Builder", to: "/" }}
              />
            )}

            {shouldVirtualize ? (
              <div
                ref={listScrollRef}
                className="max-h-[72vh] overflow-y-auto pr-1"
                data-testid="library-virtualized-list"
              >
                <div
                  className="relative w-full"
                  style={{ height: `${rowVirtualizer.getTotalSize()}px` }}
                >
                  {rowVirtualizer.getVirtualItems().map((virtualItem) => {
                    const prompt = visibleSaved[virtualItem.index];
                    if (!prompt) return null;

                    return (
                      <div
                        key={prompt.id}
                        data-index={virtualItem.index}
                        ref={rowVirtualizer.measureElement}
                        className="absolute left-0 top-0 w-full pb-2"
                        style={{ transform: `translateY(${virtualItem.start}px)` }}
                      >
                        {renderPromptCard(prompt)}
                      </div>
                    );
                  })}
                </div>
              </div>
            ) : (
              <div className="space-y-2">
                {visibleSaved.map((prompt) => renderPromptCard(prompt))}
              </div>
            )}
          </div>
        </Card>
      </div>
    </PageShell>
  );
};

export default Library;
````

## File: src/pages/CommunityPost.tsx
````typescript
import { useCallback, useEffect, useRef, useState } from "react";
import { useNavigate, useParams } from "react-router-dom";
import { CommunityPostDetail } from "@/components/community/CommunityPostDetail";
import { CommunityReportDialog } from "@/components/community/CommunityReportDialog";
import { PageShell } from "@/components/PageShell";
import { Button } from "@/components/base/buttons/button";
import { Card } from "@/components/base/primitives/card";
import { Skeleton } from "@/components/base/primitives/skeleton";
import { StateCard } from "@/components/base/primitives/state-card";
import { useCommunityMobileTelemetry } from "@/hooks/useCommunityMobileTelemetry";
import { useIsMobile } from "@/hooks/use-mobile";
import { useToast } from "@/hooks/use-toast";
import { useAuth } from "@/hooks/useAuth";
import {
  type CommunityPost as CommunityPostType,
  type CommunityProfile,
  computeNextPromptRatingSummary,
  loadPost,
  loadMyRatings,
  loadProfilesByIds,
  loadRemixes,
  remixToLibrary,
  loadMyVotes,
  setPromptRating,
  toggleVote,
  type VoteState,
  type VoteType,
} from "@/lib/community";
import { toCommunityErrorState, type CommunityErrorState } from "@/lib/community-errors";
import { communityFeatureFlags } from "@/lib/feature-flags";
import { copyTextToClipboard } from "@/lib/clipboard";
import {
  blockCommunityUser,
  loadBlockedUserIds,
  submitCommunityReport,
  unblockCommunityUser,
} from "@/lib/community-moderation";
import { toProfileMap } from "@/lib/community-utils";
import { ArrowLeft } from "@phosphor-icons/react";

function isUuid(value: string): boolean {
  return /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(value);
}

interface CommunityReportTarget {
  targetType: "post" | "comment";
  postId: string;
  commentId?: string;
  reportedUserId: string | null;
}

const CommunityPost = () => {
  const { postId } = useParams<{ postId: string }>();
  const navigate = useNavigate();
  const requestToken = useRef(0);
  const voteInFlightByPost = useRef<Set<string>>(new Set());
  const ratingInFlightByPost = useRef<Set<string>>(new Set());
  const { toast } = useToast();
  const { user } = useAuth();
  const isMobile = useIsMobile();
  const mobileEnhancementsEnabled = isMobile && communityFeatureFlags.communityMobileEnhancements;
  const { trackInteraction } = useCommunityMobileTelemetry({
    enabled: mobileEnhancementsEnabled,
    surface: "community_post",
  });
  const [post, setPost] = useState<CommunityPostType | null>(null);
  const [parentPost, setParentPost] = useState<CommunityPostType | null>(null);
  const [remixes, setRemixes] = useState<CommunityPostType[]>([]);
  const [authorById, setAuthorById] = useState<Record<string, CommunityProfile>>({});
  const [voteState, setVoteState] = useState<VoteState | null>(null);
  const [ratingValue, setRatingValue] = useState<number | null>(null);
  const [loading, setLoading] = useState(true);
  const [errorState, setErrorState] = useState<CommunityErrorState | null>(null);
  const [retryNonce, setRetryNonce] = useState(0);
  const [blockedUserIds, setBlockedUserIds] = useState<string[]>([]);
  const [reportTarget, setReportTarget] = useState<CommunityReportTarget | null>(null);
  const [reportSubmitting, setReportSubmitting] = useState(false);

  useEffect(() => {
    if (!user?.id) {
      setBlockedUserIds([]);
      return;
    }

    let cancelled = false;
    void loadBlockedUserIds()
      .then((ids) => {
        if (!cancelled) {
          setBlockedUserIds(ids);
        }
      })
      .catch((error) => {
        if (!cancelled) {
          console.error("Failed to load blocked users:", error);
        }
      });

    return () => {
      cancelled = true;
    };
  }, [user?.id]);

  useEffect(() => {
    const resetPostState = () => {
      setPost(null);
      setParentPost(null);
      setRemixes([]);
      setAuthorById({});
      setVoteState(null);
      setRatingValue(null);
    };

    if (!postId || !isUuid(postId)) {
      resetPostState();
      setLoading(false);
      setErrorState({
        kind: "not_found",
        message: "This link is invalid or expired.",
      });
      return;
    }

    const token = ++requestToken.current;
    setLoading(true);
    setErrorState(null);

    void (async () => {
      try {
        const loadedPost = await loadPost(postId);
        if (token !== requestToken.current) return;

        if (!loadedPost) {
          resetPostState();
          setErrorState({
            kind: "not_found",
            message: "This community post is unavailable.",
          });
          return;
        }

        const [loadedParentResult, loadedRemixesResult, voteStatesResult, ratingsResult] = await Promise.allSettled([
          loadedPost.remixedFrom ? loadPost(loadedPost.remixedFrom) : Promise.resolve(null),
          loadRemixes(loadedPost.id),
          loadMyVotes([loadedPost.id]),
          loadMyRatings([loadedPost.id]),
        ]);

        if (token !== requestToken.current) return;

        const loadedParent = loadedParentResult.status === "fulfilled" ? loadedParentResult.value : null;
        const loadedRemixes = loadedRemixesResult.status === "fulfilled" ? loadedRemixesResult.value : [];
        const voteStates = voteStatesResult.status === "fulfilled" ? voteStatesResult.value : {};
        const ratings = ratingsResult.status === "fulfilled" ? ratingsResult.value : {};
        const authorIds = Array.from(
          new Set([
            loadedPost.authorId,
            ...(loadedParent ? [loadedParent.authorId] : []),
            ...loadedRemixes.map((remix) => remix.authorId),
          ]),
        );
        const profilesResult = await Promise.allSettled([loadProfilesByIds(authorIds)]);
        if (token !== requestToken.current) return;
        const profiles =
          profilesResult[0].status === "fulfilled"
            ? profilesResult[0].value
            : [];

        setPost(loadedPost);
        setParentPost(loadedParent);
        setRemixes(loadedRemixes);
        setAuthorById(toProfileMap(profiles));
        setVoteState(voteStates[loadedPost.id] ?? { upvote: false, verified: false });
        setRatingValue(ratings[loadedPost.id] ?? null);
      } catch (error) {
        if (token !== requestToken.current) return;
        resetPostState();
        setErrorState(toCommunityErrorState(error, "Failed to load this post right now. Please try again."));
      } finally {
        if (token === requestToken.current) {
          setLoading(false);
        }
      }
    })();
  }, [postId, user?.id, retryNonce]);

  const handleCopyPrompt = useCallback(
    async (target: CommunityPostType) => {
      try {
        await copyTextToClipboard(target.enhancedPrompt || target.starterPrompt);
        toast({
          title: "Prompt copied",
          description: "Prompt text copied with context-ready formatting.",
        });
      } catch {
        toast({
          title: "Copy failed",
          description: "Could not access clipboard in this browser context.",
          variant: "destructive",
        });
      }
    },
    [toast],
  );

  const handleToggleVote = useCallback(
    async (targetId: string, voteType: VoteType) => {
      if (!user) {
        toast({ title: "Sign in required", description: "Create an account to vote." });
        return;
      }
      if (voteInFlightByPost.current.has(targetId)) return;
      trackInteraction("reaction", `vote_${voteType}`, {
        postId: targetId,
      });
      voteInFlightByPost.current.add(targetId);
      try {
        const result = await toggleVote(targetId, voteType);
        setVoteState((prev) => ({
          upvote: voteType === "upvote" ? result.active : prev?.upvote ?? false,
          verified: voteType === "verified" ? result.active : prev?.verified ?? false,
        }));
        setPost((prev) => {
          if (!prev) return prev;
          const delta = result.active ? 1 : -1;
          if (voteType === "upvote") {
            return { ...prev, upvoteCount: Math.max(0, prev.upvoteCount + delta) };
          }
          return { ...prev, verifiedCount: Math.max(0, prev.verifiedCount + delta) };
        });
      } catch (error) {
        toast({
          title: "Vote failed",
          description: error instanceof Error ? error.message : "Unexpected error",
          variant: "destructive",
        });
      } finally {
        voteInFlightByPost.current.delete(targetId);
      }
    },
    [toast, trackInteraction, user],
  );

  const handleRatePrompt = useCallback(
    async (targetId: string, rating: number | null) => {
      if (!user) {
        toast({ title: "Sign in required", description: "Create an account to rate prompts." });
        return;
      }
      if (ratingInFlightByPost.current.has(targetId)) return;
      ratingInFlightByPost.current.add(targetId);

      const previousRating = ratingValue;

      try {
        const result = await setPromptRating(targetId, rating);
        setRatingValue(result.rating);
        setPost((prev) => {
          if (!prev || prev.id !== targetId) return prev;
          const summary = computeNextPromptRatingSummary({
            currentCount: prev.ratingCount ?? 0,
            currentAverage: prev.ratingAverage ?? 0,
            previousRating,
            nextRating: result.rating,
          });
          return {
            ...prev,
            ratingCount: summary.ratingCount,
            ratingAverage: summary.ratingAverage,
          };
        });
      } catch (error) {
        toast({
          title: "Rating failed",
          description: error instanceof Error ? error.message : "Unexpected error",
          variant: "destructive",
        });
      } finally {
        ratingInFlightByPost.current.delete(targetId);
      }
    },
    [ratingValue, toast, user],
  );

  const handleCommentAdded = useCallback((targetId: string) => {
    trackInteraction("comment", "comment_added", { postId: targetId });
    setPost((prev) => {
      if (!prev || prev.id !== targetId) return prev;
      return { ...prev, commentCount: prev.commentCount + 1 };
    });
  }, [trackInteraction]);

  const handleCommentThreadOpen = useCallback((targetId: string) => {
    trackInteraction("comment", "thread_opened", { postId: targetId });
  }, [trackInteraction]);

  const handleSaveToLibrary = useCallback(
    async (targetId: string) => {
      if (!user) {
        toast({ title: "Sign in required", description: "Create an account to save remixes." });
        return;
      }

      try {
        const saved = await remixToLibrary(targetId);
        toast({
          title: "Saved to Library",
          description: `“${saved.title}” is now in your private prompts.`,
        });
      } catch (error) {
        toast({
          title: "Failed to save remix",
          description: error instanceof Error ? error.message : "Unexpected error",
          variant: "destructive",
        });
      }
    },
    [toast, user],
  );

  const handleReportPost = useCallback((targetPost: CommunityPostType) => {
    if (!user) {
      toast({ title: "Sign in required", description: "Sign in to report content." });
      return;
    }

    setReportTarget({
      targetType: "post",
      postId: targetPost.id,
      reportedUserId: targetPost.authorId,
    });
  }, [toast, user]);

  const handleReportComment = useCallback((commentId: string, userId: string, postId: string) => {
    if (!user) {
      toast({ title: "Sign in required", description: "Sign in to report content." });
      return;
    }

    setReportTarget({
      targetType: "comment",
      postId,
      commentId,
      reportedUserId: userId,
    });
  }, [toast, user]);

  const handleBlockUser = useCallback(async (targetUserId: string) => {
    if (!user) {
      toast({ title: "Sign in required", description: "Sign in to block users." });
      return;
    }
    if (targetUserId === user.id) return;

    try {
      await blockCommunityUser(targetUserId);
      setBlockedUserIds((previous) => (
        previous.includes(targetUserId) ? previous : [...previous, targetUserId]
      ));
      toast({ title: "User blocked", description: "Posts and comments from this user are hidden." });
    } catch (error) {
      toast({
        title: "Could not block user",
        description: error instanceof Error ? error.message : "Unexpected moderation error.",
        variant: "destructive",
      });
    }
  }, [toast, user]);

  const handleUnblockUser = useCallback(async (targetUserId: string) => {
    if (!user) {
      toast({ title: "Sign in required", description: "Sign in to manage blocked users." });
      return;
    }

    try {
      await unblockCommunityUser(targetUserId);
      setBlockedUserIds((previous) => previous.filter((id) => id !== targetUserId));
      toast({ title: "User unblocked" });
    } catch (error) {
      toast({
        title: "Could not unblock user",
        description: error instanceof Error ? error.message : "Unexpected moderation error.",
        variant: "destructive",
      });
    }
  }, [toast, user]);

  const handleSubmitReport = useCallback(async (payload: { reason: string; details: string }) => {
    if (!reportTarget) return;

    setReportSubmitting(true);
    try {
      await submitCommunityReport({
        targetType: reportTarget.targetType,
        postId: reportTarget.postId,
        commentId: reportTarget.commentId ?? null,
        reportedUserId: reportTarget.reportedUserId,
        reason: payload.reason,
        details: payload.details,
      });
      setReportTarget(null);
      toast({ title: "Report submitted", description: "Thanks. Our team will review this content." });
    } catch (error) {
      toast({
        title: "Could not submit report",
        description: error instanceof Error ? error.message : "Unexpected moderation error.",
        variant: "destructive",
      });
    } finally {
      setReportSubmitting(false);
    }
  }, [reportTarget, toast]);

  const postAuthor = post ? authorById[post.authorId] : null;
  const postAuthorName = postAuthor?.displayName || "Community member";
  const postAuthorBlocked = post ? blockedUserIds.includes(post.authorId) : false;
  const handleRetry = useCallback(() => {
    setRetryNonce((prev) => prev + 1);
  }, []);
  const errorTitle =
    errorState?.kind === "auth"
      ? "Sign in to access this community post"
      : errorState?.kind === "network"
        ? "Couldn’t reach this community post"
        : errorState?.kind === "backend_unconfigured"
          ? "Community backend is not configured"
          : "This post is unavailable";
  const errorSecondaryAction =
    errorState?.kind === "auth"
      ? { label: "Go to Builder and sign in", to: "/" }
      : { label: "Return to community feed", to: "/community" };

  return (
    <PageShell>
      <div className="community-typography pf-community-page" data-density="comfortable">
        <div className="mb-4 flex flex-wrap items-center gap-2">
          <Button
            type="button"
            color="secondary"
            size="sm"
            className="type-button-label h-11 px-4 sm:h-8 sm:px-3"
            onClick={() => navigate("/community")}
          >
            <ArrowLeft className="h-3.5 w-3.5" />
            Back to feed
          </Button>
        </div>

        {loading && (
          <div className="space-y-3">
            <Card className="pf-card space-y-3 p-4">
              <Skeleton className="h-5 w-2/3" />
              <Skeleton className="h-3 w-1/3" />
              <Skeleton className="h-44 w-full rounded-md" />
            </Card>
            <Card className="pf-card space-y-2 p-4">
              <Skeleton className="h-4 w-28" />
              <Skeleton className="h-12 w-full" />
              <Skeleton className="h-12 w-full" />
            </Card>
          </div>
        )}

        {!loading && errorState && (
          <StateCard
            variant="error"
            title={errorTitle}
            description={errorState.message}
            primaryAction={{ label: "Retry", onClick: handleRetry }}
            secondaryAction={errorSecondaryAction}
          />
        )}

        {!loading && !errorState && post && postAuthorBlocked && (
          <StateCard
            variant="empty"
            title="You blocked this user"
            description="Posts and comments from blocked users are hidden until you unblock them."
            primaryAction={{ label: "Unblock user", onClick: () => void handleUnblockUser(post.authorId) }}
            secondaryAction={{ label: "Return to community feed", to: "/community" }}
          />
        )}

        {!loading && !errorState && post && !postAuthorBlocked && (
          <CommunityPostDetail
            post={post}
            authorName={postAuthorName}
            authorAvatarUrl={postAuthor?.avatarUrl}
            parentPost={parentPost}
            remixes={remixes}
            authorById={authorById}
            onCopyPrompt={handleCopyPrompt}
            onToggleVote={handleToggleVote}
            voteState={voteState ?? undefined}
            onCommentAdded={handleCommentAdded}
            onCommentThreadOpen={handleCommentThreadOpen}
            canVote={Boolean(user)}
            canRate={Boolean(user)}
            ratingValue={ratingValue}
            onRatePrompt={handleRatePrompt}
            canSaveToLibrary={Boolean(user)}
            onSaveToLibrary={handleSaveToLibrary}
            canModerate={Boolean(user)}
            canBlockAuthor={Boolean(user?.id && user.id !== post.authorId)}
            isAuthorBlocked={blockedUserIds.includes(post.authorId)}
            blockedUserIds={blockedUserIds}
            onReportPost={handleReportPost}
            onReportComment={handleReportComment}
            onBlockUser={handleBlockUser}
            onUnblockUser={handleUnblockUser}
          />
        )}

        <CommunityReportDialog
          open={reportTarget !== null}
          targetLabel={reportTarget?.targetType ?? "content"}
          submitting={reportSubmitting}
          onOpenChange={(open) => {
            if (!open && !reportSubmitting) {
              setReportTarget(null);
            }
          }}
          onSubmit={handleSubmitReport}
        />
      </div>
    </PageShell>
  );
};

export default CommunityPost;
````

## File: src/components/community/CommunityComments.tsx
````typescript
import { useCallback, useEffect, useMemo, useRef, useState } from "react";
import { formatDistanceToNow } from "date-fns";
import { Link } from "react-router-dom";
import { useVirtualizer } from "@tanstack/react-virtual";
import type { CommunityComment, CommunityProfile } from "@/lib/community";
import { addComment, loadComments, loadProfilesByIds } from "@/lib/community";
import { getInitials, toProfileMap } from "@/lib/community-utils";
import { useAuth } from "@/hooks/useAuth";
import { useToast } from "@/hooks/use-toast";
import { Badge } from "@/components/base/badges/badges";
import { Button } from "@/components/base/buttons/button";
import { Card } from "@/components/base/primitives/card";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/base/primitives/avatar";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/base/primitives/dropdown-menu";
import { Skeleton } from "@/components/base/primitives/skeleton";
import { Textarea } from "@/components/base/textarea";
import { cn } from "@/lib/utils";
import {
  ChatCircle as MessageCircle,
  DotsThreeOutline as MoreHorizontal,
  Flag,
  PaperPlaneTilt as Send,
  SignIn as LogIn,
  UserCheck,
  UserMinus as UserX,
} from "@phosphor-icons/react";

const COMMENTS_VIRTUALIZATION_THRESHOLD = 30;

interface CommunityCommentsProps {
  postId: string;
  totalCount: number;
  compact?: boolean;
  autoFocusComposer?: boolean;
  onCommentAdded?: (postId: string) => void;
  blockedUserIds?: string[];
  onReportComment?: (commentId: string, userId: string, postId: string) => void;
  onBlockUser?: (userId: string) => void;
  onUnblockUser?: (userId: string) => void;
  className?: string;
}


export function CommunityComments({
  postId,
  totalCount,
  compact = false,
  autoFocusComposer = false,
  onCommentAdded,
  blockedUserIds = [],
  onReportComment,
  onBlockUser,
  onUnblockUser,
  className,
}: CommunityCommentsProps) {
  const { user } = useAuth();
  const { toast } = useToast();
  const [comments, setComments] = useState<CommunityComment[]>([]);
  const [authorById, setAuthorById] = useState<Record<string, CommunityProfile>>({});
  const [loading, setLoading] = useState(true);
  const [submitting, setSubmitting] = useState(false);
  const [draft, setDraft] = useState("");
  const composerRef = useRef<HTMLTextAreaElement | null>(null);

  const limit = compact ? 2 : 120;
  const commentsScrollRef = useRef<HTMLDivElement | null>(null);

  const loadThread = useCallback(async () => {
    setLoading(true);
    try {
      const nextComments = await loadComments(postId, { limit });
      setComments(nextComments);
      const authorIds = Array.from(new Set(nextComments.map((comment) => comment.userId)));
      const profiles = await loadProfilesByIds(authorIds);
      setAuthorById(toProfileMap(profiles));
    } catch (error) {
      toast({
        title: "Failed to load comments",
        description: error instanceof Error ? error.message : "Unexpected error",
        variant: "destructive",
      });
    } finally {
      setLoading(false);
    }
  }, [limit, postId, toast]);

  useEffect(() => {
    void loadThread();
  }, [loadThread]);

  useEffect(() => {
    if (autoFocusComposer && composerRef.current) {
      const timer = setTimeout(() => composerRef.current?.focus(), 150);
      return () => clearTimeout(timer);
    }
  }, [autoFocusComposer]);

  const handleSubmit = useCallback(async () => {
    if (!user) {
      toast({
        title: "Sign in required",
        description: "Sign in to post comments.",
      });
      return;
    }

    const content = draft.trim();
    if (!content) return;
    setSubmitting(true);
    try {
      const created = await addComment(postId, content);
      if (user && !(user.id in authorById)) {
        const displayName =
          user.user_metadata?.display_name ||
          user.user_metadata?.full_name ||
          user.email ||
          "You";
        setAuthorById((prev) => ({
          ...prev,
          [user.id]: {
            id: user.id,
            displayName,
            avatarUrl: user.user_metadata?.avatar_url || null,
          },
        }));
      }
      setComments((prev) => [created, ...prev].slice(0, limit));
      setDraft("");
      onCommentAdded?.(postId);
    } catch (error) {
      toast({
        title: "Failed to post comment",
        description: error instanceof Error ? error.message : "Unexpected error",
        variant: "destructive",
      });
    } finally {
      setSubmitting(false);
    }
  }, [authorById, draft, limit, onCommentAdded, postId, toast, user]);

  const commentItems = useMemo(
    () =>
      comments.map((comment) => {
        const author = authorById[comment.userId];
        const displayName = author?.displayName || "Community member";
        const createdAt = formatDistanceToNow(new Date(comment.createdAt), { addSuffix: true });
        return {
          comment,
          author,
          displayName,
          createdAt,
        };
      }),
    [authorById, comments],
  );

  const blockedSet = useMemo(() => new Set(blockedUserIds), [blockedUserIds]);
  const visibleCommentItems = useMemo(
    () => commentItems.filter((item) => !blockedSet.has(item.comment.userId)),
    [blockedSet, commentItems],
  );
  const hiddenCommentCount = commentItems.length - visibleCommentItems.length;
  const shouldVirtualize = !compact && visibleCommentItems.length >= COMMENTS_VIRTUALIZATION_THRESHOLD;
  const commentVirtualizer = useVirtualizer({
    count: shouldVirtualize ? visibleCommentItems.length : 0,
    getScrollElement: () => commentsScrollRef.current,
    estimateSize: () => 108,
    overscan: 8,
    measureElement: (element) => element.getBoundingClientRect().height,
    enabled: shouldVirtualize,
  });

  const canComment = Boolean(user);
  const hasCommentActions = Boolean(user?.id && (onReportComment || onBlockUser || onUnblockUser));
  const submitDisabled = submitting || (canComment && !draft.trim());
  const submitLabel = canComment ? "Post comment" : "Sign in to comment";

  function renderCommentRow(item: (typeof visibleCommentItems)[number]) {
    const canToggleBlock = Boolean(user?.id && user.id !== item.comment.userId);
    const isBlocked = blockedSet.has(item.comment.userId);

    return (
      <div className="rounded-lg border border-border/60 bg-background/70 px-2.5 py-2 sm:p-2.5">
        <div className="flex items-start gap-2">
          <Avatar className="h-7 w-7 border border-border/60">
            <AvatarImage src={item.author?.avatarUrl ?? undefined} alt={item.displayName} />
            <AvatarFallback className="type-reply-label">{getInitials(item.displayName)}</AvatarFallback>
          </Avatar>
          <div className="min-w-0 flex-1">
            <div className="type-meta flex flex-wrap items-center gap-1.5 text-muted-foreground sm:gap-2">
              <Link to={`/profile/${item.comment.userId}`} className="type-author type-link-inline type-wrap-inline text-foreground">
                {item.displayName}
              </Link>
              <span className="type-timestamp">{item.createdAt}</span>
              {hasCommentActions && (
                <DropdownMenu>
                  <DropdownMenuTrigger asChild>
                    <Button
                      type="button"
                      color="tertiary"
                      size="sm"
                      className="ml-auto h-7 w-7"
                      aria-label="Open comment moderation actions"
                    >
                      <MoreHorizontal className="h-4 w-4" />
                    </Button>
                  </DropdownMenuTrigger>
                  <DropdownMenuContent align="end">
                    <DropdownMenuItem
                      onSelect={(event) => {
                        event.preventDefault();
                        onReportComment?.(item.comment.id, item.comment.userId, postId);
                      }}
                    >
                      <Flag className="mr-2 h-4 w-4" />
                      Report comment
                    </DropdownMenuItem>
                    {canToggleBlock && (
                      isBlocked ? (
                        <DropdownMenuItem
                          onSelect={(event) => {
                            event.preventDefault();
                            onUnblockUser?.(item.comment.userId);
                          }}
                        >
                          <UserCheck className="mr-2 h-4 w-4" />
                          Unblock user
                        </DropdownMenuItem>
                      ) : (
                        <DropdownMenuItem
                          onSelect={(event) => {
                            event.preventDefault();
                            onBlockUser?.(item.comment.userId);
                          }}
                        >
                          <UserX className="mr-2 h-4 w-4" />
                          Block user
                        </DropdownMenuItem>
                      )
                    )}
                  </DropdownMenuContent>
                </DropdownMenu>
              )}
            </div>
            <p className="type-comment-body type-prose-measure type-wrap-safe mt-0.5 whitespace-pre-wrap text-foreground sm:mt-1">
              {item.comment.body}
            </p>
          </div>
        </div>
      </div>
    );
  }

  return (
    <Card className={cn("space-y-2.5 border-border/75 bg-card/90 p-2.5 sm:space-y-3 sm:p-3", className)}>
      <div className="flex items-center justify-between gap-2">
        <div className="type-tab-label flex items-center gap-1.5 text-foreground sm:gap-2">
          <MessageCircle className="h-3.5 w-3.5" />
          Comments
        </div>
        <Badge type="modern" className="type-chip type-numeric h-5 min-w-5 px-1.5">
          {totalCount}
        </Badge>
      </div>

      {loading && (
        <div className="space-y-2">
          <Skeleton className="h-11 w-full" />
          <Skeleton className="h-11 w-full" />
        </div>
      )}

      {!loading && comments.length === 0 && (
        <div className="rounded-lg border border-border/60 bg-background/60 px-3 py-5 text-center">
          <span className="mx-auto inline-flex h-9 w-9 items-center justify-center rounded-full border border-border/60 bg-background/80 text-muted-foreground">
            <MessageCircle className="h-4 w-4" />
          </span>
          <p className="type-post-title mt-2 text-foreground">No comments yet</p>
          <p className="type-help mt-1 text-muted-foreground">Be the first to share your thoughts.</p>
        </div>
      )}

      {!loading && hiddenCommentCount > 0 && (
        <p className="type-help text-muted-foreground">
          {hiddenCommentCount} comment{hiddenCommentCount === 1 ? "" : "s"} hidden from blocked users.
        </p>
      )}

      {!loading && visibleCommentItems.length > 0 && (
        <>
          {shouldVirtualize ? (
            <div
              ref={commentsScrollRef}
              className="max-h-[48vh] overflow-y-auto pr-1 sm:max-h-[52vh]"
              data-testid="community-comments-virtualized-list"
            >
              <div className="relative w-full" style={{ height: `${commentVirtualizer.getTotalSize()}px` }}>
                {commentVirtualizer.getVirtualItems().map((virtualItem) => {
                  const item = visibleCommentItems[virtualItem.index];
                  if (!item) return null;

                  return (
                    <div
                      key={item.comment.id}
                      ref={commentVirtualizer.measureElement}
                      className="absolute left-0 top-0 w-full pb-1.5 sm:pb-2"
                      style={{ transform: `translateY(${virtualItem.start}px)` }}
                    >
                      {renderCommentRow(item)}
                    </div>
                  );
                })}
              </div>
            </div>
          ) : (
            <div
              data-testid="community-comments-list"
              className={cn(
                "space-y-1.5 sm:space-y-2",
                !compact && "max-h-[42vh] overflow-y-auto pr-1 sm:max-h-[52vh] sm:pr-1",
              )}
            >
              {visibleCommentItems.map((item) => (
                <div key={item.comment.id}>
                  {renderCommentRow(item)}
                </div>
              ))}
            </div>
          )}
        </>
      )}

      {compact && totalCount > comments.length && (
        <Link
          to={`/community/${postId}`}
          className="type-button-label type-link-inline inline-flex min-h-11 items-center text-primary sm:min-h-0"
        >
          View all comments
        </Link>
      )}

      {canComment ? (
        <div className="space-y-1.5 sm:space-y-2">
          <Textarea
            ref={composerRef}
            value={draft}
            onChange={(event) => setDraft(event.target.value)}
            onKeyDown={(event) => {
              if ((event.metaKey || event.ctrlKey) && event.key === "Enter") {
                event.preventDefault();
                void handleSubmit();
              }
            }}
            placeholder="Write a comment..."
            disabled={submitting}
            className="type-input type-wrap-safe min-h-19 rounded-lg border-border/70 bg-background/95 sm:min-h-22"
            enterKeyHint="send"
            maxLength={2000}
          />
          <div className="flex items-center justify-between">
            <span className="type-meta text-muted-foreground">{draft.length}/2000</span>
            <Button
              type="button"
              size="sm"
              color="primary"
              onClick={handleSubmit}
              disabled={submitDisabled}
              className="type-button-label h-11 gap-1.5 px-4 sm:h-9 sm:px-3"
              data-testid="community-comment-submit"
            >
              <Send className="h-3.5 w-3.5" />
              {submitLabel}
            </Button>
          </div>
        </div>
      ) : (
        <div className="rounded-lg border border-border/60 bg-background/70 p-3">
          <div className="flex items-start gap-2.5">
            <span className="inline-flex h-9 w-9 shrink-0 items-center justify-center rounded-full border border-border/60 bg-background/80 text-muted-foreground">
              <MessageCircle className="h-4 w-4" />
            </span>
            <div className="min-w-0">
              <p className="type-post-title text-foreground">Sign in to join the conversation</p>
              <p className="type-help mt-1 text-muted-foreground">
                Share feedback and remix tips with other creators.
              </p>
            </div>
          </div>
          <Button
            href="/"
            size="sm"
            color="primary"
            className="type-button-label mt-3 h-11 gap-1.5 px-4 sm:h-9 sm:px-3"
            data-testid="community-comment-submit"
          >
            <LogIn className="h-3.5 w-3.5" />
            Sign in to comment
          </Button>
        </div>
      )}
    </Card>
  );
}
````

## File: src/components/community/CommunityPostDetail.tsx
````typescript
import { useState } from "react";
import { formatDistanceToNow } from "date-fns";
import { Link, useNavigate } from "react-router-dom";
import type { CommunityPost, CommunityProfile, VoteState, VoteType } from "@/lib/community";
import { getInitials } from "@/lib/community-utils";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/base/primitives/avatar";
import { Badge } from "@/components/base/badges/badges";
import { Button } from "@/components/base/buttons/button";
import { Card } from "@/components/base/primitives/card";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/base/primitives/dropdown-menu";
import { PromptPreviewPanel } from "@/components/community/PromptPreviewPanel";
import { CommunityComments } from "@/components/community/CommunityComments";
import { Drawer, DrawerContent, DrawerDescription, DrawerHeader, DrawerTitle } from "@/components/base/drawer";
import { useIsMobile } from "@/hooks/use-mobile";
import { getCommunityPostRarityClass } from "@/lib/community-rarity";
import { communityFeatureFlags } from "@/lib/feature-flags";
import { UI_STATUS_ROW_CLASSES, UI_STATUS_SURFACE_CLASSES } from "@/lib/ui-status";
import { cn } from "@/lib/utils";
import {
  ArrowSquareOut as ExternalLink,
  ArrowUp,
  BookmarkSimple as BookmarkPlus,
  ChatCircle as MessageCircle,
  CheckCircle as CheckCircle2,
  DotsThreeOutline as MoreHorizontal,
  Flag,
  GitBranch,
  Star,
  UserCheck,
  UserMinus as UserX,
} from "@phosphor-icons/react";

interface CommunityPostDetailProps {
  post: CommunityPost;
  authorName: string;
  authorAvatarUrl?: string | null;
  parentPost: CommunityPost | null;
  remixes: CommunityPost[];
  authorById: Record<string, CommunityProfile>;
  onCopyPrompt: (post: CommunityPost) => void;
  onToggleVote: (postId: string, voteType: VoteType) => void;
  voteState?: VoteState;
  onCommentAdded: (postId: string) => void;
  onCommentThreadOpen?: (postId: string) => void;
  canVote: boolean;
  canRate?: boolean;
  ratingValue?: number | null;
  onRatePrompt?: (postId: string, rating: number | null) => void;
  canSaveToLibrary: boolean;
  onSaveToLibrary: (postId: string) => void;
  canModerate?: boolean;
  canBlockAuthor?: boolean;
  isAuthorBlocked?: boolean;
  blockedUserIds?: string[];
  onReportPost?: (post: CommunityPost) => void;
  onReportComment?: (commentId: string, userId: string, postId: string) => void;
  onBlockUser?: (userId: string) => void;
  onUnblockUser?: (userId: string) => void;
}

function renderAuthor(authorById: Record<string, CommunityProfile>, authorId: string): string {
  return authorById[authorId]?.displayName || "Community member";
}

interface RemixDiffDisplay {
  changes: Array<{
    field: string;
    from: string | string[];
    to: string | string[];
  }>;
  added_tags: string[];
  removed_tags: string[];
  category_changed: boolean;
}

function parseRemixDiff(value: unknown): RemixDiffDisplay | null {
  if (!value || typeof value !== "object") return null;
  const candidate = value as Record<string, unknown>;

  const rawChanges = Array.isArray(candidate.changes) ? candidate.changes : [];
  const changes = rawChanges
    .map((entry) => {
      if (!entry || typeof entry !== "object") return null;
      const row = entry as Record<string, unknown>;
      const field = typeof row.field === "string" ? row.field : null;
      const fromValue = row.from;
      const toValue = row.to;
      if (!field) return null;
      const from = Array.isArray(fromValue)
        ? fromValue.map((item) => String(item))
        : String(fromValue ?? "");
      const to = Array.isArray(toValue)
        ? toValue.map((item) => String(item))
        : String(toValue ?? "");
      return { field, from, to };
    })
    .filter((entry): entry is RemixDiffDisplay["changes"][number] => !!entry);

  const addedTags = Array.isArray(candidate.added_tags)
    ? candidate.added_tags.map((tag) => String(tag))
    : [];
  const removedTags = Array.isArray(candidate.removed_tags)
    ? candidate.removed_tags.map((tag) => String(tag))
    : [];
  const categoryChanged = Boolean(candidate.category_changed);

  if (!changes.length && !addedTags.length && !removedTags.length && !categoryChanged) {
    return null;
  }

  return {
    changes,
    added_tags: addedTags,
    removed_tags: removedTags,
    category_changed: categoryChanged,
  };
}

function stringifyDiffValue(value: string | string[]): string {
  if (Array.isArray(value)) return value.join(", ");
  return value;
}

function renderDiffValue(value: string | string[]): string {
  const normalized = stringifyDiffValue(value).trim();
  return normalized || "∅";
}

export function CommunityPostDetail({
  post,
  authorName,
  authorAvatarUrl,
  parentPost,
  remixes,
  authorById,
  onCopyPrompt,
  onToggleVote,
  voteState,
  onCommentAdded,
  onCommentThreadOpen,
  canVote,
  canRate = false,
  ratingValue = null,
  onRatePrompt,
  canSaveToLibrary,
  onSaveToLibrary,
  canModerate = false,
  canBlockAuthor = true,
  isAuthorBlocked = false,
  blockedUserIds = [],
  onReportPost,
  onReportComment,
  onBlockUser,
  onUnblockUser,
}: CommunityPostDetailProps) {
  const navigate = useNavigate();
  const isMobile = useIsMobile();
  const useMobileCommentsDrawer = isMobile && communityFeatureFlags.communityMobileEnhancements;
  const [commentsOpen, setCommentsOpen] = useState(false);
  const createdAgo = formatDistanceToNow(new Date(post.createdAt), { addSuffix: true });
  const remixDiff = parseRemixDiff(post.remixDiff);
  const promptBody = (post.enhancedPrompt || post.starterPrompt || "").trim();
  const ratingAverage = post.ratingAverage ?? 0;
  const ratingCount = post.ratingCount ?? 0;
  const ratingSummaryAriaLabel = `Average rating ${ratingAverage.toFixed(1)} from ${ratingCount} rating${ratingCount === 1 ? "" : "s"}`;

  return (
    <div className="space-y-4">
      <Card className={cn("pf-card space-y-4 border-border/80 bg-card/85 p-4 sm:p-5", getCommunityPostRarityClass(post))}>
        <div className="flex flex-wrap items-start justify-between gap-3">
          <div className="flex min-w-0 items-center gap-2">
            <Avatar className="h-9 w-9 border border-border/60">
              <AvatarImage src={authorAvatarUrl ?? undefined} alt={authorName} />
              <AvatarFallback className="type-reply-label">{getInitials(authorName)}</AvatarFallback>
            </Avatar>
            <div className="min-w-0">
              <Link to={`/profile/${post.authorId}`} className="type-author type-link-inline type-wrap-inline text-foreground">
                {authorName}
              </Link>
              <p className="type-timestamp text-muted-foreground">{createdAgo}</p>
            </div>
          </div>
          <div className="flex flex-wrap items-center gap-2 sm:justify-end">
            <Button
              type="button"
              color="tertiary"
              size="sm"
              className="type-button-label utility-action-button w-full sm:w-auto"
              onClick={() => navigate(`/?remix=${post.id}`)}
            >
              Remix
            </Button>
            <Button
              type="button"
              color="tertiary"
              size="sm"
              className="type-button-label h-11 w-full gap-1.5 sm:h-9 sm:w-auto"
              disabled={!canSaveToLibrary}
              onClick={() => onSaveToLibrary(post.id)}
            >
              <BookmarkPlus className="h-3.5 w-3.5" />
              Save to Library
            </Button>
            {canModerate && (
              <DropdownMenu>
                <DropdownMenuTrigger asChild>
                  <Button
                    type="button"
                    color="secondary"
                    size="sm"
                    className="h-11 w-11 sm:h-9 sm:w-9"
                    aria-label="Open moderation actions"
                  >
                    <MoreHorizontal className="h-4 w-4" />
                  </Button>
                </DropdownMenuTrigger>
                <DropdownMenuContent align="end">
                  <DropdownMenuItem
                    onSelect={(event) => {
                      event.preventDefault();
                      onReportPost?.(post);
                    }}
                  >
                    <Flag className="mr-2 h-4 w-4" />
                    Report post
                  </DropdownMenuItem>
                  {canBlockAuthor && (isAuthorBlocked ? (
                    <DropdownMenuItem
                      onSelect={(event) => {
                        event.preventDefault();
                        onUnblockUser?.(post.authorId);
                      }}
                    >
                      <UserCheck className="mr-2 h-4 w-4" />
                      Unblock user
                    </DropdownMenuItem>
                  ) : (
                    <DropdownMenuItem
                      onSelect={(event) => {
                        event.preventDefault();
                        onBlockUser?.(post.authorId);
                      }}
                    >
                      <UserX className="mr-2 h-4 w-4" />
                      Block user
                    </DropdownMenuItem>
                  ))}
                </DropdownMenuContent>
              </DropdownMenu>
            )}
          </div>
        </div>

        <div className="space-y-1">
          <h1 className="type-post-title text-foreground">{post.title}</h1>
          {post.useCase && (
            <p className="type-post-body type-prose-measure type-wrap-safe text-muted-foreground">{post.useCase}</p>
          )}
        </div>

        {parentPost && (
          <div className="type-meta rounded-md border border-primary/25 bg-primary/10 px-3 py-2 text-primary">
            <span className="font-medium">Remixed from:</span>{" "}
            <Link to={`/community/${parentPost.id}`} className="type-link-inline type-wrap-safe">
              {parentPost.title}
            </Link>
          </div>
        )}

        {post.remixNote && (
          <div className="type-meta type-wrap-safe rounded-md border border-border/70 bg-background/60 px-3 py-2 text-muted-foreground">
            <span className="font-medium text-foreground">Remix note:</span> {post.remixNote}
          </div>
        )}

        {remixDiff && (
          <div className="space-y-3 rounded-lg border border-primary/25 bg-primary/5 p-3">
            <div className="flex flex-wrap items-center justify-between gap-2">
              <p className="type-reply-label type-label-caps text-primary">Prompt diff</p>
              <Badge type="modern" className="type-chip h-5 px-1.5 font-mono">
                Unified
              </Badge>
            </div>

            {remixDiff.changes.length > 0 ? (
              <div className="type-code overflow-hidden rounded-md border border-border/80 bg-background/65 font-mono">
                {remixDiff.changes.map((change) => (
                  <div key={`${post.id}-${change.field}`} className="border-b border-border/70 last:border-b-0">
                    <div className="type-reply-label type-label-caps border-b border-border/70 px-3 py-1.5 text-muted-foreground">
                      {change.field}
                    </div>
                    <div className={`flex items-start gap-2 px-3 py-1.5 ${UI_STATUS_ROW_CLASSES.danger}`}>
                      <span className="mt-0.5 w-3 shrink-0 text-center font-semibold">-</span>
                      <span className="whitespace-pre-wrap wrap-break-word">{renderDiffValue(change.from)}</span>
                    </div>
                    <div className={`flex items-start gap-2 px-3 py-1.5 ${UI_STATUS_ROW_CLASSES.success}`}>
                      <span className="mt-0.5 w-3 shrink-0 text-center font-semibold">+</span>
                      <span className="whitespace-pre-wrap wrap-break-word">{renderDiffValue(change.to)}</span>
                    </div>
                  </div>
                ))}
              </div>
            ) : (
              <p className="type-help text-muted-foreground">No field-level text changes captured.</p>
            )}

            {(remixDiff.added_tags.length > 0 ||
              remixDiff.removed_tags.length > 0 ||
              remixDiff.category_changed) && (
                <div className="grid gap-2 sm:grid-cols-2">
                  {remixDiff.added_tags.length > 0 && (
                    <div className={`type-meta rounded-md px-3 py-2 ${UI_STATUS_SURFACE_CLASSES.success}`}>
                      <span className="font-semibold">Added tags</span>
                      <p className="type-code mt-1 font-mono">{remixDiff.added_tags.join(", ")}</p>
                    </div>
                  )}
                  {remixDiff.removed_tags.length > 0 && (
                    <div className={`type-meta rounded-md px-3 py-2 ${UI_STATUS_SURFACE_CLASSES.danger}`}>
                      <span className="font-semibold">Removed tags</span>
                      <p className="type-code mt-1 font-mono">{remixDiff.removed_tags.join(", ")}</p>
                    </div>
                  )}
                  {remixDiff.category_changed && (
                    <div className="type-meta rounded-md border border-border/70 bg-background/60 px-3 py-2 text-muted-foreground sm:col-span-2">
                      <span className="font-semibold text-foreground">Category changed</span>
                      <p className="type-wrap-safe mt-1">This remix is published under a different category than the parent prompt.</p>
                    </div>
                  )}
                </div>
              )}
          </div>
        )}

        <div className="flex flex-wrap items-center gap-1.5">
          <Badge type="modern" className="type-chip border border-border bg-background text-foreground capitalize">
            {post.category}
          </Badge>
          {post.targetModel && <Badge type="modern" className="type-chip">{post.targetModel}</Badge>}
          {post.tags.slice(0, 8).map((tag) => (
            <Badge
              key={`${post.id}-${tag}`}
              type="modern"
              className="type-chip border border-border bg-background text-foreground"
            >
              #{tag}
            </Badge>
          ))}
        </div>

        <PromptPreviewPanel
          text={promptBody}
          mode="full"
          className="pf-community-preview"
          onCopy={() => onCopyPrompt(post)}
        />

        <div className="type-meta flex flex-wrap items-center gap-2 text-muted-foreground">
          <Button
            type="button"
            size="sm"
            color={voteState?.upvote ? "primary" : "secondary"}
            className="type-button-label interactive-chip h-11 min-w-11 gap-1.5 px-3 sm:h-9 sm:min-w-9 sm:gap-1 sm:px-2.5"
            disabled={!canVote}
            onClick={() => onToggleVote(post.id, "upvote")}
            data-testid="community-vote-upvote"
          >
            <ArrowUp className="h-3.5 w-3.5" />
            <span className="type-numeric">{post.upvoteCount}</span>
          </Button>
          <Button
            type="button"
            size="sm"
            color={voteState?.verified ? "primary" : "secondary"}
            className="type-button-label interactive-chip h-11 min-w-11 gap-1.5 px-3 sm:h-9 sm:min-w-9 sm:gap-1 sm:px-2.5"
            disabled={!canVote}
            onClick={() => onToggleVote(post.id, "verified")}
            data-testid="community-vote-verified"
          >
            <CheckCircle2 className="h-3.5 w-3.5" />
            <span className="type-numeric">{post.verifiedCount}</span>
          </Button>
          <span className="type-numeric inline-flex items-center gap-1">
            <GitBranch className="h-3.5 w-3.5" />
            {post.remixCount}
          </span>
          {useMobileCommentsDrawer ? (
            <Button
              type="button"
              size="sm"
              color="primary"
              className="type-button-label h-11 gap-1.5 px-3 sm:h-9 sm:px-2.5"
              aria-label={`Comments ${post.commentCount}`}
              onClick={() => {
                setCommentsOpen(true);
                onCommentThreadOpen?.(post.id);
              }}
              data-testid="community-comments-thread-trigger"
            >
              <MessageCircle className="h-3.5 w-3.5" />
              Comments
              <Badge
                type="modern"
                className="type-reply-label type-numeric ml-0.5 h-4 min-w-4 px-1 leading-none"
                aria-hidden="true"
              >
                {post.commentCount}
              </Badge>
            </Button>
          ) : (
            <span className="type-numeric inline-flex items-center gap-1">
              <MessageCircle className="h-3.5 w-3.5" />
              {post.commentCount}
            </span>
          )}
          <span
            aria-label={ratingSummaryAriaLabel}
            className="type-numeric inline-flex items-center gap-1.5 rounded-full border border-border/65 bg-background/65 px-2 py-1"
          >
            <Star
              className={cn(
                "h-3.5 w-3.5",
                ratingCount > 0 ? "fill-primary text-primary" : "text-muted-foreground",
              )}
            />
            {ratingAverage.toFixed(1)}
            <span className="text-muted-foreground/80">({ratingCount})</span>
          </span>
          {canRate && onRatePrompt && (
            <div className="inline-flex items-center gap-0.5 rounded-full border border-border/65 bg-background/65 p-0.5">
              {[1, 2, 3, 4, 5].map((value) => {
                const isActive = (ratingValue ?? 0) >= value;
                return (
                  <Button
                    key={`${post.id}-detail-rate-${value}`}
                    type="button"
                    color="tertiary"
                    size="sm"
                    className="h-10 w-10 rounded-full p-0 sm:h-7 sm:w-7"
                    aria-label={`Rate ${value} star${value === 1 ? "" : "s"}`}
                    onClick={() => onRatePrompt(post.id, ratingValue === value ? null : value)}
                  >
                    <Star
                      className={cn(
                        "h-5 w-5 transition-colors sm:h-4 sm:w-4",
                        isActive ? "fill-primary text-primary" : "text-muted-foreground",
                      )}
                    />
                  </Button>
                );
              })}
            </div>
          )}
        </div>
      </Card>

      {!useMobileCommentsDrawer && (
        <CommunityComments
          postId={post.id}
          totalCount={post.commentCount}
          onCommentAdded={onCommentAdded}
          blockedUserIds={blockedUserIds}
          onReportComment={onReportComment}
          onBlockUser={onBlockUser}
          onUnblockUser={onUnblockUser}
          className="border-border/80 bg-card/85 p-4 sm:p-5"
        />
      )}

      {useMobileCommentsDrawer && (
        <Drawer open={commentsOpen} onOpenChange={setCommentsOpen}>
          <DrawerContent
            className="max-h-[86vh] gap-0 border-border/80 pb-[max(0.75rem,env(safe-area-inset-bottom))]"
            data-testid="community-comments-sheet"
          >
            <DrawerHeader className="border-b border-border/60 px-4 pb-2 pt-2.5">
              <DrawerTitle className="type-post-title">Comments</DrawerTitle>
              <DrawerDescription className="sr-only">
                Read and add comments for this prompt.
              </DrawerDescription>
            </DrawerHeader>
            <div className="px-3 pb-[max(0.75rem,env(safe-area-inset-bottom))] pt-2 sm:px-4">
              <CommunityComments
                postId={post.id}
                totalCount={post.commentCount}
                onCommentAdded={onCommentAdded}
                autoFocusComposer
                blockedUserIds={blockedUserIds}
                onReportComment={onReportComment}
                onBlockUser={onBlockUser}
                onUnblockUser={onUnblockUser}
                className="space-y-2 border-0 bg-transparent p-0 shadow-none"
              />
            </div>
          </DrawerContent>
        </Drawer>
      )}

      <Card className="pf-card space-y-3 border-border/80 bg-card/85 p-4 sm:p-5">
        <div className="flex items-center justify-between gap-2">
          <h2 className="type-tab-label text-foreground">Remixes</h2>
          <Badge type="modern" className="type-chip type-numeric">{remixes.length}</Badge>
        </div>

        {remixes.length === 0 && (
          <p className="type-help text-muted-foreground">No remixes yet.</p>
        )}

        {remixes.map((remix) => {
          const remixAuthor = renderAuthor(authorById, remix.authorId);
          const created = formatDistanceToNow(new Date(remix.createdAt), { addSuffix: true });
          return (
            <div
              key={remix.id}
              className="rounded-md border border-border/70 bg-background/50 px-3 py-2"
            >
              <div className="flex flex-wrap items-center justify-between gap-2">
                <div className="min-w-0">
                  <p className="type-author type-wrap-safe text-foreground">{remix.title}</p>
                  <p className="type-meta text-muted-foreground">
                    by {remixAuthor} • {created}
                  </p>
                </div>
                <Button
                  type="button"
                  color="tertiary"
                  size="sm"
                  className="type-button-label h-11 px-3 sm:h-9 sm:px-2"
                  onClick={() => navigate(`/community/${remix.id}`)}
                >
                  Open
                  <ExternalLink className="h-3 w-3" />
                </Button>
              </div>
            </div>
          );
        })}
      </Card>
    </div>
  );
}
````

## File: src/components/OutputPanel.tsx
````typescript
import { useEffect, useMemo, useState } from "react";
import ReactMarkdown from "react-markdown";
import remarkGfm from "remark-gfm";
import { Card } from "@/components/base/primitives/card";
import { Button } from "@/components/base/buttons/button";
import { Input } from "@/components/base/input/input";
import { Label } from "@/components/base/label";
import { Textarea } from "@/components/base/textarea";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/base/dialog";
import { Select } from "@/components/base/select/select";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuTrigger,
} from "@/components/base/primitives/dropdown-menu";
import { useIsMobile } from "@/hooks/use-mobile";
import { useToast } from "@/hooks/use-toast";
import { PROMPT_CATEGORY_OPTIONS } from "@/lib/prompt-categories";
import { copyTextToClipboard } from "@/lib/clipboard";
import {
  validateSaveDialogInput,
} from "@/lib/output-panel-validation";
import { trackBuilderEvent } from "@/lib/telemetry";
import { buildLineDiff, type DiffLine } from "@/lib/text-diff";
import {
  UI_STATUS_ROW_CLASSES,
  UI_STATUS_SURFACE_CLASSES,
  UI_STATUS_TEXT_CLASSES,
} from "@/lib/ui-status";
import { cn } from "@/lib/utils";
import { normalizeHttpUrl } from "@/lib/url-utils";
import { Checkbox } from "@/components/base/primitives/checkbox";
import { Switch } from "@/components/base/primitives/switch";
import {
  Check,
  Copy,
  DotsThreeOutline as MoreHorizontal,
  FloppyDisk as Save,
  Globe,
  Sparkle as Sparkles,
  SpinnerGap as Loader2,
} from "@phosphor-icons/react";

export type EnhancePhase = "idle" | "starting" | "streaming" | "settling" | "done";
const REASONING_SUMMARY_FADE_MS = 900;

interface SavePromptInput {
  name: string;
  description?: string;
  tags?: string[];
  category?: string;
  remixNote?: string;
}

interface SaveAndSharePromptInput extends SavePromptInput {
  useCase: string;
  targetModel?: string;
}

interface OutputPanelProps {
  builtPrompt: string;
  enhancedPrompt: string;
  isEnhancing: boolean;
  onEnhance: () => void;
  onSaveVersion: () => void;
  onSavePrompt: (input: SavePromptInput) => void;
  onSaveAndSharePrompt: (input: SaveAndSharePromptInput) => void;
  canSavePrompt: boolean;
  canSharePrompt: boolean;
  hideEnhanceButton?: boolean;
  enhancePhase?: EnhancePhase;
  enhanceIdleLabel?: string;
  phase2Enabled?: boolean;
  remixContext?: { title: string; authorName: string };
  webSearchEnabled?: boolean;
  onWebSearchToggle?: (enabled: boolean) => void;
  webSearchSources?: string[];
  reasoningSummary?: string;
}

type CodexExportModule = typeof import("@/lib/codex-export");

async function loadCodexExport(): Promise<CodexExportModule> {
  return import("@/lib/codex-export");
}

function parseTags(value: string): string[] | undefined {
  const tags = Array.from(
    new Set(
      value
        .split(",")
        .map((tag) => tag.trim().toLowerCase())
        .filter(Boolean),
    ),
  ).slice(0, 8);

  return tags.length > 0 ? tags : undefined;
}

function parseWebSourceLink(value: string): { title: string; href: string } | null {
  const mdLink = value.match(/^\[(.+?)]\((.+?)\)$/);
  if (!mdLink) return null;

  const normalizedHref = normalizeHttpUrl(mdLink[2]);
  if (!normalizedHref) return null;

  return {
    title: mdLink[1],
    href: normalizedHref,
  };
}

export function OutputPanel({
  builtPrompt,
  enhancedPrompt,
  isEnhancing,
  onEnhance,
  onSaveVersion,
  onSavePrompt,
  onSaveAndSharePrompt,
  canSavePrompt,
  canSharePrompt,
  hideEnhanceButton = false,
  enhancePhase = "idle",
  enhanceIdleLabel = "Enhance with AI",
  phase2Enabled = true,
  remixContext,
  webSearchEnabled = false,
  onWebSearchToggle,
  webSearchSources = [],
  reasoningSummary = "",
}: OutputPanelProps) {
  const [copied, setCopied] = useState(false);
  const [saveDialogOpen, setSaveDialogOpen] = useState(false);
  const [shareEnabled, setShareEnabled] = useState(false);
  const [compareDialogOpen, setCompareDialogOpen] = useState(false);

  const [saveName, setSaveName] = useState("");
  const [saveDescription, setSaveDescription] = useState("");
  const [saveTags, setSaveTags] = useState("");
  const [saveCategory, setSaveCategory] = useState("general");
  const [saveUseCase, setSaveUseCase] = useState("");
  const [saveTargetModel, setSaveTargetModel] = useState("");
  const [saveConfirmedSafe, setSaveConfirmedSafe] = useState(false);
  const [saveRemixNote, setSaveRemixNote] = useState("");
  const [saveNameTouched, setSaveNameTouched] = useState(false);
  const [saveUseCaseTouched, setSaveUseCaseTouched] = useState(false);
  const [saveConfirmedSafeTouched, setSaveConfirmedSafeTouched] = useState(false);
  const [saveSubmitAttempted, setSaveSubmitAttempted] = useState(false);

  const { toast } = useToast();
  const isMobile = useIsMobile();
  const displayPrompt = enhancedPrompt || builtPrompt;
  const trimmedReasoningSummary = reasoningSummary.trim();
  const [displayedReasoningSummary, setDisplayedReasoningSummary] = useState(trimmedReasoningSummary);
  const [isReasoningSummaryFading, setIsReasoningSummaryFading] = useState(false);
  const shareEnabledForUi = shareEnabled && canSharePrompt;

  useEffect(() => {
    if (trimmedReasoningSummary) {
      setDisplayedReasoningSummary(trimmedReasoningSummary);
      setIsReasoningSummaryFading(false);
      return;
    }

    if (!displayedReasoningSummary) {
      setIsReasoningSummaryFading(false);
      return;
    }

    setIsReasoningSummaryFading(true);
    const fadeTimer = window.setTimeout(() => {
      setDisplayedReasoningSummary("");
      setIsReasoningSummaryFading(false);
    }, REASONING_SUMMARY_FADE_MS);

    return () => window.clearTimeout(fadeTimer);
  }, [displayedReasoningSummary, trimmedReasoningSummary]);

  const downloadTextFile = (filename: string, content: string) => {
    const blob = new Blob([content], { type: "text/markdown;charset=utf-8" });
    const url = URL.createObjectURL(blob);
    const link = document.createElement("a");
    link.href = url;
    link.download = filename;
    document.body.appendChild(link);
    link.click();
    link.remove();
    setTimeout(() => URL.revokeObjectURL(url), 1000);
  };

  const handleCopyCodex = async (variant: "exec" | "tui" | "appServer") => {
    if (!displayPrompt) return;

    try {
      const codexExport = await loadCodexExport();
      const command =
        variant === "exec"
          ? codexExport.generateCodexExecCommandBash(displayPrompt)
          : variant === "tui"
            ? codexExport.generateCodexTuiCommandBash(displayPrompt)
            : codexExport.generateCodexAppServerSendMessageV2CommandBash(displayPrompt);
      await copyTextToClipboard(command);
      toast({
        title: "Copied for Codex",
        description:
          variant === "exec"
            ? "Copied `codex exec` stdin command."
            : variant === "tui"
              ? "Copied `codex` TUI command."
              : "Copied app-server debug command.",
      });
      trackBuilderEvent("builder_dev_export_used", {
        action: "copy_codex",
        variant,
      });
    } catch (error) {
      toast({
        title: "Copy failed",
        description: error instanceof Error ? error.message : "Codex command generation is unavailable.",
        variant: "destructive",
      });
    }
  };

  const handleDownloadAgents = async (variant: "agents" | "override") => {
    if (!displayPrompt) return;

    try {
      const codexExport = await loadCodexExport();
      const content =
        variant === "override"
          ? codexExport.generateAgentsOverrideMdFromPrompt(displayPrompt)
          : codexExport.generateAgentsMdFromPrompt(displayPrompt);
      const filename = variant === "override" ? "AGENTS.override.md" : "AGENTS.md";
      downloadTextFile(filename, content);
      toast({
        title: "Downloaded",
        description: `${filename} generated from the current output.`,
      });
      trackBuilderEvent("builder_dev_export_used", {
        action: "download_agents",
        variant,
      });
    } catch (error) {
      toast({
        title: "Download failed",
        description: error instanceof Error ? error.message : "AGENTS file generation is unavailable.",
        variant: "destructive",
      });
    }
  };

  const handleCopyCodexSkillScaffold = async () => {
    if (!displayPrompt) return;

    try {
      const codexExport = await loadCodexExport();
      const command = codexExport.generateCodexSkillScaffoldCommandBash(displayPrompt, {
        skillName: codexExport.CODEX_DEFAULT_SKILL_NAME,
      });
      await copyTextToClipboard(command);
      toast({
        title: "Copied for Codex",
        description: `Copied command to scaffold .agents/skills/${codexExport.CODEX_DEFAULT_SKILL_NAME}/SKILL.md.`,
      });
      trackBuilderEvent("builder_dev_export_used", {
        action: "copy_skill_scaffold",
      });
    } catch (error) {
      toast({
        title: "Copy failed",
        description: error instanceof Error ? error.message : "Codex scaffold generation is unavailable.",
        variant: "destructive",
      });
    }
  };

  const handleDownloadSkill = async () => {
    if (!displayPrompt) return;

    try {
      const codexExport = await loadCodexExport();
      const content = codexExport.generateSkillMdFromPrompt(displayPrompt, {
        skillName: codexExport.CODEX_DEFAULT_SKILL_NAME,
      });
      downloadTextFile("SKILL.md", content);
      toast({
        title: "Downloaded",
        description: `SKILL.md generated for skill name "${codexExport.CODEX_DEFAULT_SKILL_NAME}".`,
      });
      trackBuilderEvent("builder_dev_export_used", {
        action: "download_skill",
      });
    } catch (error) {
      toast({
        title: "Download failed",
        description: error instanceof Error ? error.message : "SKILL.md generation is unavailable.",
        variant: "destructive",
      });
    }
  };

  const developerToolItems = (
    <>
      <DropdownMenuItem disabled={!displayPrompt} onSelect={() => void handleCopyCodex("exec")}>
        Copy Codex exec command
      </DropdownMenuItem>
      <DropdownMenuItem disabled={!displayPrompt} onSelect={() => void handleCopyCodex("tui")}>
        Copy Codex TUI command
      </DropdownMenuItem>
      <DropdownMenuItem disabled={!displayPrompt} onSelect={() => void handleCopyCodex("appServer")}>
        Copy app server command
      </DropdownMenuItem>
      <DropdownMenuItem disabled={!displayPrompt} onSelect={() => void handleCopyCodexSkillScaffold()}>
        Copy skill scaffold
      </DropdownMenuItem>
      <DropdownMenuItem disabled={!displayPrompt} onSelect={() => void handleDownloadSkill()}>
        Download SKILL.md
      </DropdownMenuItem>
      <DropdownMenuItem disabled={!displayPrompt} onSelect={() => void handleDownloadAgents("agents")}>
        Download AGENTS.md
      </DropdownMenuItem>
      <DropdownMenuItem disabled={!displayPrompt} onSelect={() => void handleDownloadAgents("override")}>
        Download AGENTS.override.md
      </DropdownMenuItem>
    </>
  );

  const isStreamingVisual = enhancePhase === "starting" || enhancePhase === "streaming";
  const isSettledVisual = enhancePhase === "settling" || enhancePhase === "done";
  const statusLabel =
    enhancePhase === "starting"
      ? "Starting"
      : enhancePhase === "streaming"
        ? "Streaming"
        : enhancePhase === "settling"
          ? "Finalizing"
          : enhancePhase === "done"
            ? "Ready"
            : null;
  const enhanceLabel = isEnhancing
    ? enhancePhase === "starting"
      ? "Priming..."
      : enhancePhase === "settling"
        ? "Finalizing..."
        : "Enhancing..."
    : enhancePhase === "done"
      ? "Enhanced"
      : enhanceIdleLabel;
  const enhanceAssistiveStatus =
    enhancePhase === "starting"
      ? "Enhancement started."
      : enhancePhase === "streaming"
        ? "Enhancement in progress."
        : enhancePhase === "settling"
          ? "Enhancement finalizing."
          : enhancePhase === "done"
            ? "Enhancement complete."
            : "";
  const hasCompare = Boolean(
    builtPrompt.trim() && enhancedPrompt.trim() && builtPrompt.trim() !== enhancedPrompt.trim()
  );
  const canUseSaveMenu = canSavePrompt || canSharePrompt || Boolean(displayPrompt);
  const saveValidationErrors = validateSaveDialogInput({
    name: saveName,
    shareEnabled: shareEnabledForUi,
    useCase: saveUseCase,
    confirmedSafe: saveConfirmedSafe,
  });
  const saveNameError = saveValidationErrors.name ?? null;
  const showSaveNameError = Boolean(saveNameError && (saveNameTouched || saveSubmitAttempted));
  const saveUseCaseError = saveValidationErrors.useCase ?? null;
  const showSaveUseCaseError = Boolean(saveUseCaseError && (saveUseCaseTouched || saveSubmitAttempted));
  const saveConfirmedSafeError = saveValidationErrors.confirmedSafe ?? null;
  const showSaveConfirmedSafeError = Boolean(
    saveConfirmedSafeError && (saveConfirmedSafeTouched || saveSubmitAttempted),
  );

  const diff = useMemo(() => {
    if (!compareDialogOpen || !hasCompare) return null;
    return buildLineDiff(builtPrompt, enhancedPrompt);
  }, [compareDialogOpen, hasCompare, builtPrompt, enhancedPrompt]);

  const handleCopy = async () => {
    if (!displayPrompt) return;
    try {
      await copyTextToClipboard(displayPrompt);
      setCopied(true);
      toast({ title: "Copied to clipboard!", description: "Paste it into your favorite AI tool." });
      setTimeout(() => setCopied(false), 2000);
    } catch {
      toast({
        title: "Copy failed",
        description: "Clipboard access is blocked. Copy manually from the preview.",
        variant: "destructive",
      });
    }
  };

  const resetSaveDialogState = () => {
    setSaveName("");
    setSaveDescription("");
    setSaveTags("");
    setSaveCategory("general");
    setSaveUseCase("");
    setSaveTargetModel("");
    setSaveConfirmedSafe(false);
    setSaveRemixNote("");
    setShareEnabled(false);
    setSaveNameTouched(false);
    setSaveUseCaseTouched(false);
    setSaveConfirmedSafeTouched(false);
    setSaveSubmitAttempted(false);
  };

  const handleSaveSubmit = () => {
    setSaveSubmitAttempted(true);

    const canShareNow = shareEnabled && canSharePrompt;
    if (shareEnabled && !canSharePrompt) {
      setShareEnabled(false);
    }

    const effectiveErrors = canShareNow
      ? { nameErr: saveNameError, useCaseErr: saveUseCaseError, safeErr: saveConfirmedSafeError }
      : { nameErr: saveNameError, useCaseErr: null, safeErr: null };
    if (effectiveErrors.nameErr || effectiveErrors.useCaseErr || effectiveErrors.safeErr) {
      setSaveNameTouched(true);
      if (canShareNow) {
        setSaveUseCaseTouched(true);
        setSaveConfirmedSafeTouched(true);
      }
      return;
    }

    if (canShareNow) {
      onSaveAndSharePrompt({
        name: saveName.trim(),
        description: saveDescription.trim() || undefined,
        tags: parseTags(saveTags),
        category: saveCategory,
        useCase: saveUseCase.trim(),
        targetModel: saveTargetModel.trim() || undefined,
        remixNote: remixContext ? saveRemixNote.trim() || undefined : undefined,
      });
    } else {
      onSavePrompt({
        name: saveName.trim(),
        description: saveDescription.trim() || undefined,
        tags: parseTags(saveTags),
        category: saveCategory,
        remixNote: remixContext ? saveRemixNote.trim() || undefined : undefined,
      });
    }

    setSaveDialogOpen(false);
    resetSaveDialogState();
  };

  const handleSaveDialogOpenChange = (open: boolean) => {
    setSaveDialogOpen(open);
    if (open) return;
    setSaveNameTouched(false);
    setSaveUseCaseTouched(false);
    setSaveConfirmedSafeTouched(false);
    setSaveSubmitAttempted(false);
  };

  const handleShareToggleChange = (enabled: boolean) => {
    if (enabled && !canSharePrompt) return;
    setShareEnabled(enabled);
    trackBuilderEvent("builder_share_toggled", { enabled });
    if (!enabled) {
      setSaveUseCaseTouched(false);
      setSaveConfirmedSafeTouched(false);
    }
  };

  const openSaveDialog = (share: boolean) => {
    if (share && !canSharePrompt) return;
    if (remixContext) {
      if (!saveName.trim()) {
        setSaveName(`Remix of ${remixContext.title}`);
      }
    } else {
      setSaveRemixNote("");
    }
    setShareEnabled(share);
    trackBuilderEvent("builder_save_clicked", { shareEnabled: share });
    setSaveDialogOpen(true);
  };

  return (
    <div className="ui-density space-y-4 h-full flex flex-col" data-density="comfortable">
      <p className="sr-only" role="status" aria-live="polite" aria-atomic="true">
        {enhanceAssistiveStatus}
      </p>
      <div className="flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between">
        <div className="flex items-center gap-2">
          <h2 className="text-sm font-medium text-foreground">
            {enhancedPrompt ? "✨ Enhanced Prompt" : "📝 Preview"}
          </h2>
          {statusLabel && (
            <span className="interactive-chip inline-flex items-center rounded-full border border-primary/30 bg-primary/10 px-2 py-0.5 text-xs font-medium text-primary">
              {statusLabel}
            </span>
          )}
          {hasCompare && (
            <Button
              type="button"
              color="secondary"
              size="sm"
              className="ui-toolbar-button px-2"
              onClick={() => setCompareDialogOpen(true)}
            >
              Show changes
            </Button>
          )}
        </div>
        <div className="flex flex-wrap items-center gap-2 sm:justify-end">
          <Button
            color="primary"
            size="sm"
            onClick={handleCopy}
            isDisabled={!displayPrompt}
            className="ui-toolbar-button utility-action-button min-w-[84px]"
          >
            {copied ? <Check /> : <Copy />}
            {copied ? "Copied!" : "Copy"}
          </Button>

          <DropdownMenu>
            <DropdownMenuTrigger asChild>
              <Button color="secondary" size="sm" isDisabled={!canUseSaveMenu} className="ui-toolbar-button gap-1.5">
                <Save className="w-3 h-3" />
                Save
              </Button>
            </DropdownMenuTrigger>
            <DropdownMenuContent align="end">
              {phase2Enabled ? (
                <DropdownMenuItem
                  disabled={!canSavePrompt}
                  onSelect={() => openSaveDialog(false)}
                >
                  Save Prompt
                </DropdownMenuItem>
              ) : (
                <>
                  <DropdownMenuItem
                    disabled={!canSavePrompt}
                    onSelect={() => openSaveDialog(false)}
                  >
                    Save Prompt
                  </DropdownMenuItem>
                  <DropdownMenuItem
                    disabled={!canSharePrompt}
                    onSelect={() => openSaveDialog(true)}
                  >
                    Save & Share Prompt
                  </DropdownMenuItem>
                </>
              )}
              <DropdownMenuItem disabled={!displayPrompt} onSelect={() => onSaveVersion()}>
                Save Version
              </DropdownMenuItem>
            </DropdownMenuContent>
          </DropdownMenu>

          <DropdownMenu>
            <DropdownMenuTrigger asChild>
              <Button color="tertiary" size="sm" className="ui-toolbar-button gap-1.5">
                <MoreHorizontal className="w-3 h-3" />
                More
              </Button>
            </DropdownMenuTrigger>
            <DropdownMenuContent align="end">
              {isMobile ? (
                <>
                  <DropdownMenuLabel>Developer tools</DropdownMenuLabel>
                  <DropdownMenuSeparator />
                  {developerToolItems}
                </>
              ) : (
                <DropdownMenuSub>
                  <DropdownMenuSubTrigger>Developer tools</DropdownMenuSubTrigger>
                  <DropdownMenuSubContent>
                    {developerToolItems}
                  </DropdownMenuSubContent>
                </DropdownMenuSub>
              )}
            </DropdownMenuContent>
          </DropdownMenu>
        </div>
      </div>

      <Dialog open={compareDialogOpen} onOpenChange={setCompareDialogOpen}>
        <DialogContent className="sm:max-w-4xl max-h-[85vh] overflow-hidden flex flex-col">
          <DialogHeader>
            <DialogTitle>Before vs After</DialogTitle>
            <DialogDescription>
              {diff
                ? `${diff.added} added, ${diff.removed} removed`
                : "Generate an enhanced prompt to compare changes."}
            </DialogDescription>
          </DialogHeader>
          <div className="rounded-md border border-border bg-card overflow-auto flex-1 min-h-[280px]">
            <div className="font-mono text-xs leading-relaxed">
              <div className="px-3 py-1.5 border-b border-border text-muted-foreground">
                --- before
              </div>
              <div className="px-3 py-1.5 border-b border-border text-muted-foreground">
                +++ after
              </div>
              {diff?.lines.map((line, index) => (
                <DiffRow key={`${line.type}-${index}`} line={line} />
              ))}
            </div>
          </div>
        </DialogContent>
      </Dialog>

      <Dialog open={saveDialogOpen} onOpenChange={handleSaveDialogOpenChange}>
        <DialogContent className="sm:max-w-md max-h-[85vh] overflow-auto">
          <DialogHeader>
            <DialogTitle>{shareEnabledForUi ? "Save & Share Prompt" : "Save Prompt"}</DialogTitle>
            <DialogDescription>
              {shareEnabledForUi
                ? "Publish this prompt recipe to the community feed."
                : "Save a private prompt snapshot to your library."}
            </DialogDescription>
          </DialogHeader>
          <div className="space-y-3">
            {remixContext && (
              <div className="rounded-md border border-primary/25 bg-primary/10 px-3 py-2 text-sm text-primary">
                Remixing {remixContext.authorName}’s “{remixContext.title}”
              </div>
            )}
            <div className="space-y-1">
              <Label htmlFor="save-dialog-name" className="text-sm font-medium">
                Prompt title
              </Label>
              <Input
                id="save-dialog-name"
                value={saveName}
                onChange={setSaveName}
                onBlur={() => setSaveNameTouched(true)}
                placeholder="Prompt title"
                wrapperClassName="bg-background"
                inputClassName="text-base"
                aria-invalid={showSaveNameError}
                aria-describedby="save-dialog-name-help"
              />
              <p
                id="save-dialog-name-help"
                className={cn("text-sm", showSaveNameError ? "text-destructive" : "text-muted-foreground")}
              >
                {showSaveNameError ? saveNameError : "Required."}
              </p>
            </div>
            <div className="space-y-1">
              <Label className="text-sm font-medium">
                Category
              </Label>
              <Select
                selectedKey={saveCategory}
                onSelectionChange={(value) => {
                  if (value !== null) {
                    setSaveCategory(String(value));
                  }
                }}
                placeholder="Category"
                className="bg-background"
                aria-label="Category"
              >
                {PROMPT_CATEGORY_OPTIONS.map((category) => (
                  <Select.Item key={category.value} id={category.value}>
                    {category.label}
                  </Select.Item>
                ))}
              </Select>
            </div>
            <div className="space-y-1">
              <Label htmlFor="save-dialog-description" className="text-sm font-medium">
                Description
              </Label>
              <Textarea
                id="save-dialog-description"
                value={saveDescription}
                onChange={(event) => setSaveDescription(event.target.value)}
                placeholder="Description (optional)"
                className="min-h-[80px] bg-background"
              />
            </div>
            <div className="space-y-1">
              <Label htmlFor="save-dialog-tags" className="text-sm font-medium">
                Tags
              </Label>
              <Input
                id="save-dialog-tags"
                value={saveTags}
                onChange={setSaveTags}
                placeholder="Tags (comma-separated, optional)"
                wrapperClassName="bg-background"
                inputClassName="text-base"
              />
            </div>
            {remixContext && (
              <div className="space-y-1">
                <Label htmlFor="save-dialog-remix-note" className="text-sm font-medium">
                  Remix note
                </Label>
                <Textarea
                  id="save-dialog-remix-note"
                  value={saveRemixNote}
                  onChange={(event) => setSaveRemixNote(event.target.value)}
                  placeholder="Remix note (optional)"
                  className="min-h-[80px] bg-background"
                />
              </div>
            )}

            {phase2Enabled && (
              <div className="rounded-md border border-border/80 bg-muted/30 px-3 py-2">
                <div className="flex items-center justify-between">
                  <div>
                    <Label htmlFor="save-dialog-share-toggle" className="text-sm font-medium text-foreground">
                      Share to community
                    </Label>
                    <p className="text-sm text-muted-foreground">
                      Enable to publish after saving.
                    </p>
                  </div>
                  <Switch
                    id="save-dialog-share-toggle"
                    checked={shareEnabledForUi}
                    onCheckedChange={handleShareToggleChange}
                    disabled={!canSharePrompt}
                  />
                </div>
                {!canSharePrompt && (
                  <p className="mt-2 text-sm text-muted-foreground">
                    Sign in to enable sharing.
                  </p>
                )}
              </div>
            )}

            {shareEnabledForUi && (
              <>
                <div className="space-y-1">
                  <Label htmlFor="save-dialog-use-case" className="text-sm font-medium">
                    Use case
                  </Label>
                  <Textarea
                    id="save-dialog-use-case"
                    value={saveUseCase}
                    onChange={(event) => setSaveUseCase(event.target.value)}
                    onBlur={() => setSaveUseCaseTouched(true)}
                    placeholder="Describe how this prompt should be used"
                    className="min-h-[90px] bg-background"
                    aria-invalid={showSaveUseCaseError}
                    aria-describedby="save-dialog-use-case-help"
                  />
                  <p
                    id="save-dialog-use-case-help"
                    className={cn("text-sm", showSaveUseCaseError ? "text-destructive" : "text-muted-foreground")}
                  >
                    {showSaveUseCaseError ? saveUseCaseError : "Required when sharing."}
                  </p>
                </div>
                <div className="space-y-1">
                  <Label htmlFor="save-dialog-target-model" className="text-sm font-medium">
                    Target model
                  </Label>
                  <Input
                    id="save-dialog-target-model"
                    value={saveTargetModel}
                    onChange={setSaveTargetModel}
                    placeholder="Target model (optional)"
                    wrapperClassName="bg-background"
                    inputClassName="text-base"
                  />
                </div>
                <div className="flex items-start gap-2">
                  <Checkbox
                    id="save-dialog-confirm-safe"
                    checked={saveConfirmedSafe}
                    onCheckedChange={(checked) => {
                      setSaveConfirmedSafe(checked === true);
                      setSaveConfirmedSafeTouched(true);
                    }}
                    className="mt-0.5"
                    aria-invalid={showSaveConfirmedSafeError}
                    aria-describedby="save-dialog-confirm-safe-help"
                  />
                  <Label
                    htmlFor="save-dialog-confirm-safe"
                    className="cursor-pointer text-sm leading-snug text-muted-foreground"
                  >
                    I confirm this prompt contains no secrets or private data.
                  </Label>
                </div>
                <p
                  id="save-dialog-confirm-safe-help"
                  className={cn(
                    "text-sm",
                    showSaveConfirmedSafeError ? "text-destructive" : "text-muted-foreground",
                  )}
                >
                  {showSaveConfirmedSafeError ? saveConfirmedSafeError : "Required when sharing."}
                </p>
              </>
            )}
          </div>
          <DialogFooter>
            <Button color="secondary" onClick={() => handleSaveDialogOpenChange(false)}>
              Cancel
            </Button>
            <Button color="primary" onClick={handleSaveSubmit}>
              {shareEnabledForUi ? "Save & Share" : "Save Prompt"}
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>

      {displayedReasoningSummary && (
        <Card
          className={cn(
            "p-3 transition-opacity duration-1000 ease-out",
            UI_STATUS_SURFACE_CLASSES.warning,
            isReasoningSummaryFading && "opacity-0",
          )}
        >
          <p className={cn("ui-section-label", UI_STATUS_TEXT_CLASSES.warning)}>
            Reasoning summary
          </p>
          <div className="prose prose-sm mt-2 max-w-none whitespace-normal text-foreground/90 dark:prose-invert prose-headings:my-1 prose-p:my-1 prose-pre:my-1 prose-code:break-words prose-ul:my-1 prose-ol:my-1">
            <ReactMarkdown remarkPlugins={[remarkGfm]}>
              {displayedReasoningSummary}
            </ReactMarkdown>
          </div>
        </Card>
      )}

      <Card
        className={cn(
          "enhance-output-frame flex-1 p-4 bg-card overflow-auto",
          isStreamingVisual && "enhance-output-streaming",
          isSettledVisual && "enhance-output-complete"
        )}
      >
        {displayPrompt ? (
          <pre className="whitespace-pre-wrap text-sm font-mono text-foreground leading-relaxed">
            {displayPrompt}
          </pre>
        ) : (
          <div className="flex items-center justify-center h-full min-h-[120px] sm:min-h-[200px]">
            <p className="text-sm text-muted-foreground text-center">
              Your output appears here.
              <br />
              Enter a prompt or choose a template.
            </p>
          </div>
        )}
      </Card>

      {webSearchSources.length > 0 && (
        <div className="px-1 pt-1 pb-0">
          <p className="ui-section-label mb-1 text-muted-foreground">Sources</p>
          <ul className="space-y-0.5">
            {webSearchSources.map((source, i) => {
              const safeLink = parseWebSourceLink(source);
              return (
                <li key={i} className="text-sm text-muted-foreground">
                  {safeLink ? (
                    <a
                      href={safeLink.href}
                      target="_blank"
                      rel="noopener noreferrer"
                      className="text-primary hover:underline"
                    >
                      {safeLink.title}
                    </a>
                  ) : (
                    source
                  )}
                </li>
              );
            })}
          </ul>
        </div>
      )}

      {!hideEnhanceButton && (
        <div className="flex flex-col gap-2">
          {onWebSearchToggle && (
            <div className="flex flex-wrap items-center gap-2">
              <label className="flex cursor-pointer items-center gap-2 text-sm text-muted-foreground select-none">
                <Switch
                  checked={webSearchEnabled}
                  onCheckedChange={onWebSearchToggle}
                  disabled={isEnhancing}
                  aria-label="Enable web search during enhancement"
                />
                <Globe className="w-3.5 h-3.5" />
                <span>Use web sources</span>
              </label>
            </div>
          )}
          <Button
            color="primary"
            size="lg"
            onClick={onEnhance}
            isDisabled={isEnhancing || !builtPrompt}
            className="signature-enhance-button w-full gap-2"
            data-phase={enhancePhase}
          >
            {isEnhancing ? (
              <>
                <Loader2 className="w-4 h-4 animate-spin" />
                {enhanceLabel}
              </>
            ) : (
              <>
                {enhancePhase === "done" ? <Check className="w-4 h-4" /> : <Sparkles className="w-4 h-4" />}
                {enhanceLabel}
              </>
            )}
          </Button>
        </div>
      )}
    </div>
  );
}

function DiffRow({ line }: { line: DiffLine }) {
  const marker = line.type === "add" ? "+" : line.type === "remove" ? "-" : " ";
  const rowClass =
    line.type === "add"
      ? UI_STATUS_ROW_CLASSES.success
      : line.type === "remove"
        ? UI_STATUS_ROW_CLASSES.danger
        : "text-foreground";

  return (
    <div className={`px-3 whitespace-pre-wrap wrap-break-word ${rowClass}`}>
      <span className="inline-block w-4 select-none">{marker}</span>
      {line.value}
    </div>
  );
}
````

## File: src/pages/Community.tsx
````typescript
import { useCallback, useEffect, useMemo, useRef, useState } from "react";
import { useSearchParams } from "react-router-dom";
import { CommunityFeed } from "@/components/community/CommunityFeed";
import { CommunityReportDialog } from "@/components/community/CommunityReportDialog";
import { PageHero, PageShell } from "@/components/PageShell";
import { Button } from "@/components/base/buttons/button";
import { Drawer, DrawerContent, DrawerDescription, DrawerHeader, DrawerTitle } from "@/components/base/drawer";
import { InputBase } from "@/components/base/input/input";
import { ScrollArea } from "@/components/base/primitives/scroll-area";
import { useCommunityMobileTelemetry } from "@/hooks/useCommunityMobileTelemetry";
import { useIsMobile } from "@/hooks/use-mobile";
import { useNewPostsIndicator } from "@/hooks/useNewPostsIndicator";
import { useToast } from "@/hooks/use-toast";
import { useAuth } from "@/hooks/useAuth";
import { brandCopy } from "@/lib/brand-copy";
import {
  type CommunityPost,
  type CommunityProfile,
  type CommunitySort,
  type VoteState,
  type VoteType,
  computeNextPromptRatingSummary,
  followCommunityUser,
  loadFeed,
  loadFollowingUserIds,
  loadMyRatings,
  loadMyVotes,
  loadPersonalFeed,
  loadPostsByIds,
  loadProfilesByIds,
  remixToLibrary,
  setPromptRating,
  toggleVote,
  unfollowCommunityUser,
} from "@/lib/community";
import { communityFeatureFlags } from "@/lib/feature-flags";
import { toCommunityErrorState, type CommunityErrorState } from "@/lib/community-errors";
import { PROMPT_CATEGORY_OPTIONS } from "@/lib/prompt-categories";
import { copyTextToClipboard } from "@/lib/clipboard";
import { sharePost } from "@/lib/community-share";
import {
  blockCommunityUser,
  loadBlockedUserIds,
  submitCommunityReport,
  unblockCommunityUser,
} from "@/lib/community-moderation";
import { toParentTitleMap, toProfileMap } from "@/lib/community-utils";
import { cn } from "@/lib/utils";
import { MagnifyingGlass as Search } from "@phosphor-icons/react";

const SORT_OPTIONS: Array<{ label: string; value: CommunitySort }> = [
  { label: "Trending", value: "popular" },
  { label: "Newest", value: "new" },
  { label: "Most Remixed", value: "most_remixed" },
  { label: "Verified", value: "verified" },
];

const CATEGORY_OPTIONS = [
  { value: "all", label: "All" },
  ...PROMPT_CATEGORY_OPTIONS,
];
const FEED_PAGE_SIZE = 20;

interface CommunityReportTarget {
  targetType: "post" | "comment";
  postId: string;
  commentId?: string;
  reportedUserId: string | null;
}

const Community = () => {
  const [searchParams, setSearchParams] = useSearchParams();
  const feedMode = (searchParams.get("tab") === "following" ? "following" : "for_you") as "for_you" | "following";
  const isFollowingMode = feedMode === "following";
  const setFeedMode = useCallback(
    (mode: "for_you" | "following") => {
      setSearchParams((prev) => {
        const next = new URLSearchParams(prev);
        if (mode === "following") {
          next.set("tab", "following");
        } else {
          next.delete("tab");
        }
        return next;
      }, { replace: true });
    },
    [setSearchParams],
  );
  const [posts, setPosts] = useState<CommunityPost[]>([]);
  const [authorById, setAuthorById] = useState<Record<string, CommunityProfile>>({});
  const [parentTitleById, setParentTitleById] = useState<Record<string, string>>({});
  const [voteStateByPost, setVoteStateByPost] = useState<Record<string, VoteState>>({});
  const [ratingByPost, setRatingByPost] = useState<Record<string, number | null>>({});
  const [sort, setSort] = useState<CommunitySort>("new");
  const [category, setCategory] = useState("all");
  const [queryInput, setQueryInput] = useState("");
  const [query, setQuery] = useState("");
  const activeSort: CommunitySort = isFollowingMode ? "new" : sort;
  const activeCategory = isFollowingMode ? "all" : category;
  const activeQuery = isFollowingMode ? "" : query;
  const [isSearchFocused, setIsSearchFocused] = useState(false);
  const [mobileCategorySheetOpen, setMobileCategorySheetOpen] = useState(false);
  const [loading, setLoading] = useState(true);
  const [isLoadingMore, setIsLoadingMore] = useState(false);
  const [hasMore, setHasMore] = useState(false);
  const [page, setPage] = useState(0);
  const [errorState, setErrorState] = useState<CommunityErrorState | null>(null);
  const [retryNonce, setRetryNonce] = useState(0);
  const [blockedUserIds, setBlockedUserIds] = useState<string[]>([]);
  const [followingUserIds, setFollowingUserIds] = useState<Set<string>>(new Set());
  const [reportTarget, setReportTarget] = useState<CommunityReportTarget | null>(null);
  const [reportSubmitting, setReportSubmitting] = useState(false);
  const requestToken = useRef(0);
  const voteInFlightByPost = useRef<Set<string>>(new Set());
  const ratingInFlightByPost = useRef<Set<string>>(new Set());
  const { toast } = useToast();
  const { user } = useAuth();
  const isMobile = useIsMobile();
  const mobileEnhancementsEnabled = isMobile && communityFeatureFlags.communityMobileEnhancements;
  const showCategorySuggestions = !isFollowingMode && isSearchFocused && (!isMobile || !mobileEnhancementsEnabled);
  const { trackFirstMeaningfulAction, trackInteraction } = useCommunityMobileTelemetry({
    enabled: mobileEnhancementsEnabled,
    surface: "community_feed",
  });
  const categoryPanelId = "community-search-categories";
  const selectedCategoryLabel =
    CATEGORY_OPTIONS.find((option) => option.value === category)?.label ?? "All";

  const { newCount: newPostCount, dismiss: dismissNewPosts } = useNewPostsIndicator({
    enabled: Boolean(user) && !isFollowingMode,
  });

  useEffect(() => {
    const timer = window.setTimeout(() => {
      setQuery(queryInput.trim());
    }, 250);
    return () => window.clearTimeout(timer);
  }, [queryInput]);

  useEffect(() => {
    if (!isFollowingMode) return;
    setIsSearchFocused(false);
    setMobileCategorySheetOpen(false);
  }, [isFollowingMode]);

  useEffect(() => {
    if (!user?.id) {
      setBlockedUserIds([]);
      return;
    }

    let cancelled = false;
    void loadBlockedUserIds()
      .then((ids) => {
        if (!cancelled) {
          setBlockedUserIds(ids);
        }
      })
      .catch((error) => {
        if (!cancelled) {
          console.error("Failed to load blocked users:", error);
        }
      });

    void loadFollowingUserIds()
      .then((ids) => {
        if (!cancelled) {
          setFollowingUserIds(new Set(ids));
        }
      })
      .catch((error) => {
        if (!cancelled) {
          console.error("Failed to load following users:", error);
        }
      });

    return () => {
      cancelled = true;
    };
  }, [user?.id]);

  const hydrateFeedContext = useCallback(
    async (
      targetPosts: CommunityPost[],
      token: number,
      mode: "replace" | "merge" = "replace",
    ) => {
      const authorIds = Array.from(new Set(targetPosts.map((post) => post.authorId)));
      const parentIds = Array.from(
        new Set(targetPosts.map((post) => post.remixedFrom).filter((value): value is string => !!value)),
      );

      const [authorProfilesResult, parentPostsResult, voteStatesResult, ratingsResult] = await Promise.allSettled([
        loadProfilesByIds(authorIds),
        loadPostsByIds(parentIds),
        loadMyVotes(targetPosts.map((post) => post.id)),
        loadMyRatings(targetPosts.map((post) => post.id)),
      ]);

      if (token !== requestToken.current) return;

      const authorProfiles = authorProfilesResult.status === "fulfilled" ? authorProfilesResult.value : [];
      const parentPosts = parentPostsResult.status === "fulfilled" ? parentPostsResult.value : [];
      const voteStates = voteStatesResult.status === "fulfilled" ? voteStatesResult.value : {};
      const ratings = ratingsResult.status === "fulfilled" ? ratingsResult.value : {};
      const nextAuthors = toProfileMap(authorProfiles);
      const nextParentTitles = toParentTitleMap(parentPosts);
      if (mode === "merge") {
        setAuthorById((previous) => ({ ...previous, ...nextAuthors }));
        setParentTitleById((previous) => ({ ...previous, ...nextParentTitles }));
        setVoteStateByPost((previous) => ({ ...previous, ...voteStates }));
        setRatingByPost((previous) => ({ ...previous, ...ratings }));
        return;
      }

      setAuthorById(nextAuthors);
      setParentTitleById(nextParentTitles);
      setVoteStateByPost(voteStates);
      setRatingByPost(ratings);
    },
    [],
  );

  useEffect(() => {
    const token = ++requestToken.current;
    setLoading(true);
    setIsLoadingMore(false);
    setErrorState(null);

    void (async () => {
      try {
        const firstPage = feedMode === "following"
          ? await loadPersonalFeed({ limit: FEED_PAGE_SIZE, page: 0 })
          : await loadFeed({
              sort: activeSort,
              category: activeCategory,
              search: activeQuery || undefined,
              limit: FEED_PAGE_SIZE,
              page: 0,
            });
        if (token !== requestToken.current) return;

        setPosts(firstPage);
        setPage(0);
        setHasMore(firstPage.length === FEED_PAGE_SIZE);
        await hydrateFeedContext(firstPage, token);
      } catch (error) {
        if (token !== requestToken.current) return;
        setPosts([]);
        setPage(0);
        setHasMore(false);
        setAuthorById({});
        setParentTitleById({});
        setVoteStateByPost({});
        setRatingByPost({});
        setErrorState(toCommunityErrorState(error, "Failed to load community feed."));
      } finally {
        if (token === requestToken.current) {
          setLoading(false);
        }
      }
    })();
  }, [activeCategory, activeQuery, activeSort, feedMode, user?.id, hydrateFeedContext, retryNonce]);

  const handleLoadMore = useCallback(() => {
    if (loading || isLoadingMore || !hasMore) return;
    const token = requestToken.current;
    const nextPage = page + 1;
    setIsLoadingMore(true);

    void (async () => {
      try {
        const nextPagePosts = feedMode === "following"
          ? await loadPersonalFeed({ limit: FEED_PAGE_SIZE, page: nextPage })
          : await loadFeed({
              sort: activeSort,
              category: activeCategory,
              search: activeQuery || undefined,
              limit: FEED_PAGE_SIZE,
              page: nextPage,
            });
        if (token !== requestToken.current) return;

        const seenIds = new Set(posts.map((post) => post.id));
        const dedupedNewPosts = nextPagePosts.filter((post) => !seenIds.has(post.id));

        setPosts((previous) => {
          const previousIds = new Set(previous.map((post) => post.id));
          const dedupedAgainstPrevious = nextPagePosts.filter((post) => !previousIds.has(post.id));
          return [...previous, ...dedupedAgainstPrevious];
        });
        setPage(nextPage);
        setHasMore(nextPagePosts.length === FEED_PAGE_SIZE);
        if (dedupedNewPosts.length > 0) {
          await hydrateFeedContext(dedupedNewPosts, token, "merge");
        }
      } catch (error) {
        if (token !== requestToken.current) return;
        toast({
          title: "Could not load more posts",
          description: error instanceof Error ? error.message : "Unexpected error while loading remix feed.",
          variant: "destructive",
        });
      } finally {
        if (token === requestToken.current) {
          setIsLoadingMore(false);
        }
      }
    })();
  }, [
    loading,
    isLoadingMore,
    hasMore,
    page,
    activeSort,
    activeCategory,
    activeQuery,
    feedMode,
    posts,
    hydrateFeedContext,
    toast,
  ]);

  const handleCopyPrompt = useCallback(
    async (post: CommunityPost) => {
      try {
        await copyTextToClipboard(post.enhancedPrompt || post.starterPrompt);
        toast({
          title: "Prompt copied",
          description: "Prompt text copied with context-ready formatting.",
        });
      } catch {
        toast({
          title: "Copy failed",
          description: "Could not access clipboard in this browser context.",
          variant: "destructive",
        });
      }
    },
    [toast],
  );

  const handleSharePost = useCallback(
    async (post: CommunityPost) => {
      const result = await sharePost(post);
      if (result === "clipboard") {
        toast({ title: "Link copied", description: "Post link copied to clipboard." });
      } else if (result === "failed") {
        toast({ title: "Share failed", description: "Could not share this post.", variant: "destructive" });
      }
      trackInteraction("share", result);
    },
    [toast, trackInteraction],
  );

  const handleSaveToLibrary = useCallback(
    async (postId: string) => {
      if (!user) {
        toast({ title: "Sign in required", description: "Create an account to save prompts." });
        return;
      }
      try {
        await remixToLibrary(postId);
        toast({ title: "Saved to Library", description: "Prompt saved to your library." });
        trackInteraction("save", "library");
      } catch {
        toast({ title: "Save failed", description: "Could not save this prompt.", variant: "destructive" });
      }
    },
    [user, toast, trackInteraction],
  );

  const handleToggleFollow = useCallback(
    async (targetUserId: string, isFollowing: boolean) => {
      if (!user) {
        toast({ title: "Sign in required", description: "Create an account to follow users." });
        return;
      }
      // Optimistic update
      setFollowingUserIds((prev) => {
        const next = new Set(prev);
        if (isFollowing) {
          next.delete(targetUserId);
        } else {
          next.add(targetUserId);
        }
        return next;
      });
      try {
        if (isFollowing) {
          await unfollowCommunityUser(targetUserId);
        } else {
          await followCommunityUser(targetUserId);
        }
      } catch {
        // Revert
        setFollowingUserIds((prev) => {
          const next = new Set(prev);
          if (isFollowing) {
            next.add(targetUserId);
          } else {
            next.delete(targetUserId);
          }
          return next;
        });
        toast({ title: "Action failed", description: "Could not update follow status.", variant: "destructive" });
      }
    },
    [user, toast],
  );

  const handleToggleVote = useCallback(
    async (postId: string, voteType: VoteType) => {
      if (!user) {
        toast({ title: "Sign in required", description: "Create an account to vote." });
        return;
      }
      if (voteInFlightByPost.current.has(postId)) return;
      trackInteraction("reaction", `vote_${voteType}`, {
        postId,
      });
      voteInFlightByPost.current.add(postId);
      try {
        const result = await toggleVote(postId, voteType);
        setVoteStateByPost((prev) => ({
          ...prev,
          [postId]: {
            upvote: voteType === "upvote" ? result.active : prev[postId]?.upvote ?? false,
            verified: voteType === "verified" ? result.active : prev[postId]?.verified ?? false,
          },
        }));
        setPosts((prev) =>
          prev.map((post) => {
            if (post.id !== postId) return post;
            const delta = result.active ? 1 : -1;
            if (voteType === "upvote") {
              return { ...post, upvoteCount: Math.max(0, post.upvoteCount + delta) };
            }
            return { ...post, verifiedCount: Math.max(0, post.verifiedCount + delta) };
          }),
        );
      } catch (error) {
        toast({
          title: "Vote failed",
          description: error instanceof Error ? error.message : "Unexpected error",
          variant: "destructive",
        });
      } finally {
        voteInFlightByPost.current.delete(postId);
      }
    },
    [toast, trackInteraction, user],
  );

  const handleRatePrompt = useCallback(
    async (postId: string, rating: number | null) => {
      if (!user) {
        toast({ title: "Sign in required", description: "Create an account to rate prompts." });
        return;
      }
      if (ratingInFlightByPost.current.has(postId)) return;
      ratingInFlightByPost.current.add(postId);

      const previousRating = ratingByPost[postId] ?? null;

      try {
        const result = await setPromptRating(postId, rating);
        setRatingByPost((prev) => ({
          ...prev,
          [postId]: result.rating,
        }));
        setPosts((prev) =>
          prev.map((post) => {
            if (post.id !== postId) return post;
            const summary = computeNextPromptRatingSummary({
              currentCount: post.ratingCount ?? 0,
              currentAverage: post.ratingAverage ?? 0,
              previousRating,
              nextRating: result.rating,
            });
            return {
              ...post,
              ratingCount: summary.ratingCount,
              ratingAverage: summary.ratingAverage,
            };
          }),
        );
      } catch (error) {
        toast({
          title: "Rating failed",
          description: error instanceof Error ? error.message : "Unexpected error",
          variant: "destructive",
        });
      } finally {
        ratingInFlightByPost.current.delete(postId);
      }
    },
    [ratingByPost, toast, user],
  );

  const handleCommentAdded = useCallback((postId: string) => {
    trackInteraction("comment", "comment_added", { postId });
    setPosts((prev) =>
      prev.map((post) =>
        post.id === postId ? { ...post, commentCount: post.commentCount + 1 } : post,
      ),
    );
  }, [trackInteraction]);

  const handleCommentThreadOpen = useCallback((postId: string) => {
    trackFirstMeaningfulAction("comment_thread_opened", { postId });
    trackInteraction("comment", "thread_opened", { postId });
  }, [trackFirstMeaningfulAction, trackInteraction]);

  const handleTagClick = useCallback((tag: string) => {
    const normalizedTag = tag.trim();
    if (!normalizedTag) return;
    if (isFollowingMode) {
      setFeedMode("for_you");
    }
    setQueryInput(normalizedTag);
    setQuery(normalizedTag);
    setIsSearchFocused(false);
    setMobileCategorySheetOpen(false);
    window.scrollTo({ top: 0, behavior: "smooth" });
  }, [isFollowingMode, setFeedMode]);

  const visiblePosts = useMemo(
    () => posts.filter((post) => !blockedUserIds.includes(post.authorId)),
    [blockedUserIds, posts],
  );

  const handleBlockUser = useCallback(async (targetUserId: string) => {
    if (!user) {
      toast({ title: "Sign in required", description: "Sign in to block users." });
      return;
    }
    if (!targetUserId || targetUserId === user.id) {
      return;
    }

    try {
      await blockCommunityUser(targetUserId);
      setBlockedUserIds((previous) => (
        previous.includes(targetUserId) ? previous : [...previous, targetUserId]
      ));
      toast({
        title: "User blocked",
        description: "Posts and comments from this user are now hidden.",
      });
    } catch (error) {
      toast({
        title: "Unable to block user",
        description: error instanceof Error ? error.message : "Unexpected error",
        variant: "destructive",
      });
    }
  }, [toast, user]);

  const handleUnblockUser = useCallback(async (targetUserId: string) => {
    if (!user) {
      toast({ title: "Sign in required", description: "Sign in to manage blocked users." });
      return;
    }

    try {
      await unblockCommunityUser(targetUserId);
      setBlockedUserIds((previous) => previous.filter((id) => id !== targetUserId));
      toast({ title: "User unblocked" });
    } catch (error) {
      toast({
        title: "Unable to unblock user",
        description: error instanceof Error ? error.message : "Unexpected error",
        variant: "destructive",
      });
    }
  }, [toast, user]);

  const handleReportPost = useCallback((post: CommunityPost) => {
    if (!user) {
      toast({ title: "Sign in required", description: "Sign in to submit reports." });
      return;
    }

    setReportTarget({
      targetType: "post",
      postId: post.id,
      reportedUserId: post.authorId,
    });
  }, [toast, user]);

  const handleReportComment = useCallback((commentId: string, userId: string, postId: string) => {
    if (!user) {
      toast({ title: "Sign in required", description: "Sign in to submit reports." });
      return;
    }

    setReportTarget({
      targetType: "comment",
      postId,
      commentId,
      reportedUserId: userId,
    });
  }, [toast, user]);

  const handleSubmitReport = useCallback(async ({ reason, details }: { reason: string; details: string }) => {
    if (!reportTarget) return;

    setReportSubmitting(true);
    try {
      await submitCommunityReport({
        targetType: reportTarget.targetType,
        postId: reportTarget.postId,
        commentId: reportTarget.commentId ?? null,
        reportedUserId: reportTarget.reportedUserId,
        reason,
        details,
      });
      setReportTarget(null);
      toast({
        title: "Thanks for the report",
        description: "We review reports and take action when needed.",
      });
    } catch (error) {
      toast({
        title: "Failed to submit report",
        description: error instanceof Error ? error.message : "Unexpected error",
        variant: "destructive",
      });
    } finally {
      setReportSubmitting(false);
    }
  }, [reportTarget, toast]);

  const handleRetry = useCallback(() => {
    setRetryNonce((prev) => prev + 1);
  }, []);

  return (
    <PageShell>
      <div className="community-typography pf-community-page" data-density="comfortable">
        <PageHero
          eyebrow={brandCopy.brandLine}
          title="Community Remix Feed"
          subtitle="Browse proven prompts, review context, and remix with clear attribution."
          className="pf-gilded-frame pf-hero-surface"
        />

        <div
          className="pf-panel pf-panel-overflow-visible relative mb-3 rounded-xl border border-border bg-card/85 shadow-sm focus-within:ring-2 focus-within:ring-ring focus-within:ring-offset-2"
          data-testid="community-search-shell"
        >
          <div className="p-2 sm:p-0">
            <div className="relative">
              <label htmlFor="community-feed-search" className="sr-only">
                Search community posts
              </label>
              <Search className="pointer-events-none absolute left-3 top-1/2 h-4 w-4 -translate-y-1/2 text-muted-foreground" />
              <InputBase
                id="community-feed-search"
                value={queryInput}
                onChange={setQueryInput}
                onFocus={() => {
                  if (!mobileEnhancementsEnabled) setIsSearchFocused(true);
                }}
                onBlur={() => {
                  if (!mobileEnhancementsEnabled) setIsSearchFocused(false);
                }}
                onKeyDown={(event) => {
                  if (event.key === "Escape") {
                    setIsSearchFocused(false);
                    (event.target as HTMLInputElement).blur();
                  }
                }}
                placeholder={
                  isFollowingMode
                    ? "Search is available in the For You tab"
                    : "Search by title, use case, or context keyword"
                }
                inputClassName="type-input h-11 border-0 bg-transparent pl-9 shadow-none"
                wrapperClassName="bg-transparent shadow-none ring-0"
                isDisabled={isFollowingMode}
                aria-expanded={showCategorySuggestions}
                aria-controls={showCategorySuggestions ? categoryPanelId : undefined}
              />
            </div>
            {mobileEnhancementsEnabled && !isFollowingMode && (
              <Button
                type="button"
                color="secondary"
                size="sm"
                className="type-button-label mt-2 h-11 w-full items-center justify-between px-3"
                onClick={() => {
                  trackFirstMeaningfulAction("filter_drawer_opened");
                  setMobileCategorySheetOpen(true);
                }}
                data-testid="community-filter-trigger"
              >
                <span>Filter</span>
                <span className="type-meta type-wrap-safe max-w-[65%] text-right text-muted-foreground">
                  {selectedCategoryLabel}
                </span>
              </Button>
            )}
          </div>

          {showCategorySuggestions && (
            <div
              id={categoryPanelId}
              className="pf-community-popover type-post-body absolute left-0 right-0 top-full z-20 mt-2 rounded-xl border border-border/70 bg-popover p-2 shadow-lg"
              role="group"
              aria-label="Category filters"
            >
              <div className="type-label-caps type-reply-label flex items-center justify-between px-2 py-1 text-muted-foreground">
                <span>Categories</span>
                <span>Action</span>
              </div>
              <div className="mt-1 flex flex-col gap-1">
                {CATEGORY_OPTIONS.map((option) => {
                  const isSelected = category === option.value;
                  return (
                    <button
                      key={option.value}
                      type="button"
                      aria-pressed={isSelected}
                      onMouseDown={(event) => event.preventDefault()}
                      onClick={() => setCategory(option.value)}
                      className={cn(
                        "type-tab-label flex min-h-11 items-center justify-between rounded-md px-2 py-2 transition-colors sm:min-h-10",
                        isSelected
                          ? "bg-accent text-accent-foreground"
                          : "text-foreground hover:bg-muted",
                      )}
                    >
                      <span>{option.label}</span>
                      <span className="type-meta text-muted-foreground">
                        {isSelected ? "Selected" : "Filter"}
                      </span>
                    </button>
                  );
                })}
              </div>
              <div className="type-help px-2 pt-2 text-muted-foreground">
                Current: <span className="font-medium text-foreground">{selectedCategoryLabel}</span>
              </div>
            </div>
          )}
        </div>

        <div className="mb-3 flex rounded-lg bg-muted p-1">
          <button
            type="button"
            onClick={() => setFeedMode("for_you")}
            aria-pressed={feedMode === "for_you"}
            className={cn(
              "type-tab-label flex-1 rounded-md px-3 py-2 transition-all",
              feedMode === "for_you"
                ? "bg-background text-foreground shadow-sm"
                : "text-muted-foreground hover:text-foreground",
            )}
          >
            For You
          </button>
          <button
            type="button"
            onClick={() => setFeedMode("following")}
            aria-pressed={feedMode === "following"}
            className={cn(
              "type-tab-label flex-1 rounded-md px-3 py-2 transition-all",
              feedMode === "following"
                ? "bg-background text-foreground shadow-sm"
                : "text-muted-foreground hover:text-foreground",
            )}
          >
            Following
          </button>
        </div>
        {isFollowingMode && (
          <p className="type-help mb-3 text-muted-foreground">
            Search, sort, and category filters apply to the For You tab.
          </p>
        )}

        <div className="pf-community-toolbar mb-4 grid grid-cols-2 gap-2 sm:flex sm:rounded-lg sm:bg-muted sm:p-1">
          {SORT_OPTIONS.map((option) => (
            <button
              key={option.value}
              type="button"
              disabled={isFollowingMode}
              onClick={() => {
                setSort(option.value);
                trackFirstMeaningfulAction("sort_changed", { sort: option.value });
              }}
              aria-pressed={sort === option.value}
              data-testid="community-sort-button"
              className={cn(
                "type-tab-label h-11 rounded-md px-3 transition-all sm:h-10 sm:flex-1 sm:px-2",
                isFollowingMode && "cursor-not-allowed opacity-60",
                sort === option.value
                  ? "bg-background text-foreground shadow-sm"
                  : "bg-muted text-muted-foreground hover:text-foreground sm:bg-transparent",
              )}
            >
              {option.label}
            </button>
          ))}
        </div>

        {mobileEnhancementsEnabled && !isFollowingMode && (
          <Drawer open={mobileCategorySheetOpen} onOpenChange={setMobileCategorySheetOpen}>
            <DrawerContent
              className="pf-dialog-surface max-h-[80vh] pb-[max(0.75rem,env(safe-area-inset-bottom))]"
              data-testid="community-filter-sheet"
            >
              <DrawerHeader className="pb-1">
                <DrawerTitle className="type-post-title">Filter Categories</DrawerTitle>
                <DrawerDescription className="sr-only">
                  Choose a community category to filter visible prompts.
                </DrawerDescription>
              </DrawerHeader>
              <div className="px-4 pb-[max(0.75rem,env(safe-area-inset-bottom))]">
                <p className="type-help mb-2 text-muted-foreground">
                  Current: <span className="font-medium text-foreground">{selectedCategoryLabel}</span>
                </p>
                <ScrollArea className="max-h-[52vh] pr-2">
                  <div className="space-y-1.5 pb-1">
                    {CATEGORY_OPTIONS.map((option) => {
                      const isSelected = category === option.value;
                      return (
                        <button
                          key={option.value}
                          type="button"
                          className={cn(
                            "type-tab-label flex h-11 w-full items-center justify-between rounded-md border px-3 text-left",
                            isSelected
                              ? "border-primary/35 bg-primary/10 text-foreground"
                              : "border-border/70 bg-background text-foreground",
                          )}
                          onClick={() => {
                            trackFirstMeaningfulAction("filter_selected", { category: option.value });
                            setCategory(option.value);
                            setMobileCategorySheetOpen(false);
                          }}
                        >
                          <span>{option.label}</span>
                          <span className="type-meta text-muted-foreground">
                            {isSelected ? "Selected" : "Filter"}
                          </span>
                        </button>
                      );
                    })}
                  </div>
                </ScrollArea>
              </div>
            </DrawerContent>
          </Drawer>
        )}

        {!isFollowingMode && newPostCount > 0 && (
          <div className="sticky top-16 z-30 flex justify-center py-2">
            <button
              type="button"
              className="animate-in slide-in-from-top-2 rounded-full bg-brand-solid px-4 py-1.5 text-sm font-medium text-white shadow-md transition-transform hover:scale-105"
              onClick={() => {
                dismissNewPosts();
                setPage(0);
                setRetryNonce((n) => n + 1);
                window.scrollTo({ top: 0, behavior: "smooth" });
              }}
            >
              ↑ {newPostCount} new {newPostCount === 1 ? "post" : "posts"}
            </button>
          </div>
        )}

        <CommunityFeed
          posts={visiblePosts}
          loading={loading}
          errorMessage={errorState?.message}
          errorType={errorState?.kind}
          authorById={authorById}
          parentTitleById={parentTitleById}
          onCopyPrompt={handleCopyPrompt}
          onToggleVote={handleToggleVote}
          voteStateByPost={voteStateByPost}
          onCommentAdded={handleCommentAdded}
          onCommentThreadOpen={handleCommentThreadOpen}
          onSharePost={handleSharePost}
          onSaveToLibrary={handleSaveToLibrary}
          followingUserIds={followingUserIds}
          onToggleFollow={handleToggleFollow}
          canVote={Boolean(user)}
          canRate={Boolean(user)}
          ratingByPost={ratingByPost}
          onRatePrompt={handleRatePrompt}
          currentUserId={user?.id ?? null}
          blockedUserIds={blockedUserIds}
          onReportPost={handleReportPost}
          onReportComment={handleReportComment}
          onBlockUser={handleBlockUser}
          onUnblockUser={handleUnblockUser}
          onTagClick={handleTagClick}
          hasMore={hasMore}
          isLoadingMore={isLoadingMore}
          onLoadMore={handleLoadMore}
          onRetry={handleRetry}
        />

        <CommunityReportDialog
          open={reportTarget !== null}
          targetLabel={reportTarget?.targetType ?? "content"}
          submitting={reportSubmitting}
          onOpenChange={(open) => {
            if (!open && !reportSubmitting) {
              setReportTarget(null);
            }
          }}
          onSubmit={handleSubmitReport}
        />
      </div>
    </PageShell>
  );
};

export default Community;
````

## File: src/index.css
````css
/* Definition of the design system. All colors, gradients, fonts, etc should be defined here. 
All colors MUST be HSL.
*/

@layer base {
  :root {
    --background: 213 29% 6%;
    --foreground: 42 25% 87%;

    --card: 212 25% 15%;
    --card-foreground: 42 25% 87%;

    --popover: 212 25% 15%;
    --popover-foreground: 42 25% 87%;

    --primary: 174 83% 43%;
    --primary-foreground: 213 29% 6%;

    --secondary: 210 21% 23%;
    --secondary-foreground: 42 25% 87%;

    --muted: 210 21% 18%;
    --muted-foreground: 37 11% 68%;

    --accent: 41 65% 55%;
    --accent-foreground: 213 29% 6%;

    --destructive: 25 100% 55%;
    --destructive-foreground: 213 29% 6%;

    --border: 210 21% 23%;
    --input: 210 21% 23%;
    --ring: 174 83% 43%;

    /* Align Tailwind v4 semantic utility variables with shadcn-style tokens. */
    --background-color-primary: hsl(var(--primary));
    --background-color-primary-solid: hsl(var(--primary));
    --background-color-primary_hover: hsl(var(--primary) / 0.92);
    --text-color-primary: hsl(var(--primary));
    --border-color-primary: hsl(var(--primary));
    --ring-color-primary: hsl(var(--primary));

    --radius: 0.75rem;

    --sidebar-background: 212 25% 13%;

    --sidebar-foreground: 42 25% 87%;

    --sidebar-primary: 174 83% 43%;

    --sidebar-primary-foreground: 213 29% 6%;

    --sidebar-accent: 210 21% 20%;

    --sidebar-accent-foreground: 42 25% 87%;

    --sidebar-border: 210 21% 23%;

    --sidebar-ring: 174 83% 43%;

    --chart-1: 174 83% 43%;

    --chart-2: 41 65% 55%;

    --chart-3: 25 100% 55%;

    --chart-4: 176 83% 23%;

    --chart-5: 39 62% 45%;

    --font-sans: var(--pf-font-body);

    --font-serif: var(--pf-font-display);

    --font-mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;

    --type-2xs-size: 0.6875rem;
    --type-2xs-line: 1rem;
    --type-xs-size: 0.75rem;
    --type-xs-line: 1.125rem;
    --type-sm-size: 0.875rem;
    --type-sm-line: 1.375rem;
    --type-base-size: 1rem;
    --type-base-line: 1.5rem;
    --type-lg-size: 1.125rem;
    --type-lg-line: 1.625rem;
    --type-xl-size: 1.25rem;
    --type-xl-line: 1.75rem;
    --type-2xl-size: 1.5rem;
    --type-2xl-line: 2rem;
    --type-3xl-size: 1.875rem;
    --type-3xl-line: 2.25rem;
    --type-4xl-size: 2.25rem;
    --type-4xl-line: 2.625rem;
    --type-5xl-size: 3rem;
    --type-5xl-line: 1.1;
    --type-label-caps-tracking: 0.04em;
    --type-label-shortcut-tracking: 0.08em;

    --shadow-2xs: 0 1px 2px 0px hsl(0 0% 0% / 0.05);

    --shadow-xs: 0 1px 3px 0px hsl(0 0% 0% / 0.05);

    --shadow-sm: 0 1px 3px 0px hsl(0 0% 0% / 0.1), 0 1px 2px -1px hsl(0 0% 0% / 0.1);

    --shadow-md: 0 1px 3px 0px hsl(0 0% 0% / 0.1), 0 2px 4px -1px hsl(0 0% 0% / 0.1);

    --shadow-lg: 0 1px 3px 0px hsl(0 0% 0% / 0.1), 0 4px 6px -1px hsl(0 0% 0% / 0.1);

    --shadow-xl: 0 1px 3px 0px hsl(0 0% 0% / 0.1), 0 8px 10px -1px hsl(0 0% 0% / 0.1);

    --shadow-2xl: 0 1px 3px 0px hsl(0 0% 0% / 0.25);

    --tracking-normal: 0em;

    --spacing: 0.25rem;

    --delight-warm: 41 65% 55%;
    --delight-cool: 174 83% 43%;
    --delight-glow: 25 100% 55%;
    --delight-surface: 212 25% 15%;
    --motion-snap: cubic-bezier(0.2, 0.8, 0.2, 1);
  }

  .dark {
    --background: 213 32% 4%;
    --foreground: 42 25% 90%;

    --card: 212 28% 12%;
    --card-foreground: 42 25% 90%;

    --popover: 212 28% 12%;
    --popover-foreground: 42 25% 90%;

    --primary: 174 83% 48%;
    --primary-foreground: 213 29% 6%;

    --secondary: 210 22% 20%;
    --secondary-foreground: 42 25% 90%;

    --muted: 210 21% 16%;
    --muted-foreground: 37 11% 70%;

    --accent: 41 65% 52%;
    --accent-foreground: 213 29% 6%;

    --destructive: 25 100% 52%;
    --destructive-foreground: 213 29% 6%;

    --border: 210 21% 20%;
    --input: 210 21% 20%;
    --ring: 174 83% 48%;

    /* Keep primary utility mappings consistent in dark mode. */
    --background-color-primary: hsl(var(--primary));
    --background-color-primary-solid: hsl(var(--primary));
    --background-color-primary_hover: hsl(var(--primary) / 0.9);
    --text-color-primary: hsl(var(--primary));
    --border-color-primary: hsl(var(--primary));
    --ring-color-primary: hsl(var(--primary));
    --sidebar-background: 212 28% 10%;
    --sidebar-foreground: 42 25% 90%;
    --sidebar-primary: 174 83% 48%;
    --sidebar-primary-foreground: 213 29% 6%;
    --sidebar-accent: 210 21% 16%;
    --sidebar-accent-foreground: 42 25% 90%;
    --sidebar-border: 210 21% 20%;
    --sidebar-ring: 174 83% 48%;
    --chart-1: 174 83% 48%;
    --chart-2: 41 65% 52%;
    --chart-3: 25 100% 52%;
    --chart-4: 176 83% 23%;
    --chart-5: 39 62% 45%;
    --shadow-2xs: 0 1px 2px 0px hsl(0 0% 0% / 0.05);
    --shadow-xs: 0 1px 3px 0px hsl(0 0% 0% / 0.05);
    --shadow-sm: 0 1px 3px 0px hsl(0 0% 0% / 0.1), 0 1px 2px -1px hsl(0 0% 0% / 0.1);
    --shadow-md: 0 1px 3px 0px hsl(0 0% 0% / 0.1), 0 2px 4px -1px hsl(0 0% 0% / 0.1);
    --shadow-lg: 0 1px 3px 0px hsl(0 0% 0% / 0.1), 0 4px 6px -1px hsl(0 0% 0% / 0.1);
    --shadow-xl: 0 1px 3px 0px hsl(0 0% 0% / 0.1), 0 8px 10px -1px hsl(0 0% 0% / 0.1);
    --shadow-2xl: 0 1px 3px 0px hsl(0 0% 0% / 0.25);
    --delight-warm: 41 65% 52%;
    --delight-cool: 174 83% 48%;
    --delight-glow: 25 100% 52%;
    --delight-surface: 212 28% 12%;
  }
}

@layer base {
  * {
    @apply border-border;
  }

  body {
    @apply bg-background font-sans text-foreground antialiased;
    font-size: var(--type-sm-size);
    line-height: var(--type-sm-line);
    background-image:
      radial-gradient(1100px 520px at -6% -12%, hsl(var(--delight-warm) / 0.17), transparent 58%),
      radial-gradient(900px 500px at 102% -8%, hsl(var(--delight-cool) / 0.12), transparent 56%),
      linear-gradient(180deg, hsl(var(--background)), hsl(var(--background)));
    background-attachment: fixed;
  }

  @media (max-width: 767px) {
    body {
      background-attachment: scroll;
    }
  }

  h1,
  h2,
  h3,
  h4,
  h5,
  h6 {
    font-family: var(--pf-font-display), var(--font-serif);
    color: hsl(var(--foreground));
  }

  h1 {
    font-size: var(--type-3xl-size);
    line-height: var(--type-3xl-line);
    font-weight: 700;
    letter-spacing: -0.015em;
    text-wrap: balance;
  }

  h2 {
    font-size: var(--type-2xl-size);
    line-height: var(--type-2xl-line);
    font-weight: 700;
    letter-spacing: -0.01em;
    text-wrap: balance;
  }

  h3 {
    font-size: var(--type-xl-size);
    line-height: var(--type-xl-line);
    font-weight: 600;
  }

  h4 {
    font-size: var(--type-lg-size);
    line-height: var(--type-lg-line);
    font-weight: 600;
  }

  h5,
  h6 {
    font-size: var(--type-base-size);
    line-height: var(--type-base-line);
    font-weight: 600;
  }

  p,
  li,
  dt,
  dd,
  blockquote,
  label,
  input,
  textarea,
  select,
  button {
    font-size: var(--type-sm-size);
    line-height: var(--type-sm-line);
  }

  small {
    font-size: var(--type-xs-size);
    line-height: var(--type-xs-line);
  }

  code,
  pre,
  kbd,
  samp {
    font-family: var(--font-mono);
    font-size: var(--type-xs-size);
    line-height: var(--type-xs-line);
    font-variant-numeric: tabular-nums;
  }

  @media (min-width: 640px) {
    body {
      font-size: var(--type-base-size);
      line-height: var(--type-base-line);
    }

    h1 {
      font-size: var(--type-4xl-size);
      line-height: var(--type-4xl-line);
    }

    h2 {
      font-size: var(--type-3xl-size);
      line-height: var(--type-3xl-line);
    }

    p,
    li,
    dt,
    dd,
    blockquote,
    label,
    input,
    textarea,
    select,
    button {
      font-size: var(--type-base-size);
      line-height: var(--type-base-line);
    }
  }

  :where(a,
    button,
    input,
    textarea,
    select,
    [role="button"],
    [role="tab"],
    [role="menuitem"],
    [tabindex]):focus-visible {
    outline: 2px solid hsl(var(--ring) / 0.85);
    outline-offset: 2px;
  }
}

@keyframes delight-hero-drift {

  0%,
  100% {
    background-position: 0% 0%, 100% 0%;
  }

  50% {
    background-position: 6% 12%, 94% -8%;
  }
}

@keyframes delight-enhance-pulse {

  0%,
  100% {
    box-shadow: 0 0 0 0 hsl(var(--delight-glow) / 0.3), 0 16px 36px -24px hsl(var(--delight-glow) / 0.55);
  }

  50% {
    box-shadow: 0 0 0 8px hsl(var(--delight-glow) / 0), 0 20px 42px -22px hsl(var(--delight-glow) / 0.78);
  }
}

@keyframes delight-enhance-ignite {
  0% {
    transform: translateY(0) scale(0.995);
    box-shadow: 0 10px 24px -20px hsl(var(--delight-glow) / 0.38);
  }

  55% {
    transform: translateY(-1px) scale(1.016);
    box-shadow: 0 18px 38px -20px hsl(var(--delight-glow) / 0.86);
  }

  100% {
    transform: translateY(0) scale(1);
    box-shadow: 0 14px 30px -20px hsl(var(--delight-glow) / 0.65);
  }
}

@keyframes delight-enhance-stream {

  0%,
  100% {
    transform: translateY(0);
    box-shadow: 0 13px 30px -22px hsl(var(--delight-glow) / 0.58);
  }

  50% {
    transform: translateY(-1px);
    box-shadow: 0 18px 36px -18px hsl(var(--delight-glow) / 0.82);
  }
}

@keyframes delight-enhance-settle-button {
  0% {
    transform: translateY(0) scale(1);
    box-shadow: 0 14px 30px -20px hsl(var(--delight-glow) / 0.68);
  }

  60% {
    transform: translateY(-1px) scale(1.01);
    box-shadow: 0 20px 38px -18px hsl(var(--delight-glow) / 0.85);
  }

  100% {
    transform: translateY(0) scale(1);
    box-shadow: 0 14px 30px -20px hsl(var(--delight-glow) / 0.62);
  }
}

@keyframes delight-enhance-success-wave {
  from {
    transform: scale(0.5);
    opacity: 0.62;
  }

  to {
    transform: scale(1.55);
    opacity: 0;
  }
}

@keyframes delight-enhance-sheen {
  from {
    transform: translateX(-130%);
  }

  to {
    transform: translateX(130%);
  }
}

@keyframes delight-settle {
  0% {
    transform: translateY(2px) scale(0.995);
    box-shadow: 0 0 0 0 hsl(var(--delight-glow) / 0);
  }

  60% {
    transform: translateY(-1px) scale(1.003);
    box-shadow: 0 0 0 6px hsl(var(--delight-glow) / 0.08);
  }

  100% {
    transform: translateY(0) scale(1);
    box-shadow: 0 10px 26px -18px hsl(var(--delight-glow) / 0.4);
  }
}

@keyframes community-feed-enter {
  from {
    opacity: 0;
    transform: translateY(10px) scale(0.995);
  }

  to {
    opacity: 1;
    transform: translateY(0) scale(1);
  }
}

@layer components {
  .brand-gradient-hero {
    background-image:
      radial-gradient(520px 220px at 8% -12%, hsl(var(--delight-warm) / 0.2), transparent 58%),
      radial-gradient(460px 220px at 92% -14%, hsl(var(--delight-cool) / 0.16), transparent 56%),
      linear-gradient(180deg, hsl(var(--delight-surface) / 0.55), hsl(var(--card) / 0.9));
  }

  .brand-gradient-surface {
    background-image: linear-gradient(140deg,
        hsl(var(--card)),
        hsl(var(--delight-surface) / 0.72));
  }

  .brand-border-gradient {
    border: 1px solid transparent;
    background:
      linear-gradient(hsl(var(--card)), hsl(var(--card))) padding-box,
      linear-gradient(120deg, hsl(var(--delight-cool) / 0.6), hsl(var(--delight-warm) / 0.7)) border-box;
  }

  .brand-input-surface {
    border: 1px solid transparent;
    background:
      linear-gradient(140deg,
        hsl(var(--card)),
        hsl(var(--delight-surface) / 0.72)) padding-box,
      linear-gradient(120deg, hsl(var(--delight-cool) / 0.6), hsl(var(--delight-warm) / 0.7)) border-box;
  }

  .brand-input-segment {
    border-style: solid;
    border-color: transparent;
    background:
      linear-gradient(140deg,
        hsl(var(--card)),
        hsl(var(--delight-surface) / 0.72)) padding-box,
      linear-gradient(120deg, hsl(var(--delight-cool) / 0.6), hsl(var(--delight-warm) / 0.7)) border-box;
  }

  .delight-hero,
  .delight-hero-static {
    @apply rounded-2xl border border-border/70 px-4 py-5 sm:px-6 sm:py-7 shadow-sm;
    background-image:
      radial-gradient(480px 180px at 8% -12%, hsl(var(--delight-warm) / 0.2), transparent 58%),
      radial-gradient(420px 180px at 90% -20%, hsl(var(--delight-cool) / 0.16), transparent 54%),
      linear-gradient(180deg, hsl(var(--delight-surface) / 0.55), hsl(var(--card) / 0.85));
    backdrop-filter: blur(8px);
    position: relative;
    overflow: hidden;
  }

  .delight-hero {
    animation: delight-hero-drift 18s ease-in-out 1;
  }

  @media (min-width: 768px) {

    .delight-hero::before,
    .delight-hero-static::before {
      content: "";
      position: absolute;
      inset: 0;
      background-image: url("/brand/pf-gradient-hero-light.png");
      background-position: center;
      background-size: cover;
      opacity: 0.22;
      pointer-events: none;
      z-index: 0;
    }

    .dark .delight-hero::before,
    .dark .delight-hero-static::before {
      background-image: url("/brand/pf-gradient-hero-dark.png");
    }

    .delight-hero::after,
    .delight-hero-static::after {
      content: "";
      position: absolute;
      inset: 0;
      background-image: url("/brand/pf-border-frame-thin-v2.png");
      background-position: center;
      background-repeat: no-repeat;
      background-size: 100% 100%;
      opacity: 0.16;
      pointer-events: none;
      z-index: 0;
    }

    .dark .delight-hero::after,
    .dark .delight-hero-static::after {
      opacity: 0.24;
    }

    .delight-hero>*,
    .delight-hero-static>* {
      position: relative;
      z-index: 1;
    }
  }

  .interactive-chip {
    transition:
      transform 180ms var(--motion-snap),
      box-shadow 180ms var(--motion-snap),
      background-color 180ms var(--motion-snap),
      border-color 180ms var(--motion-snap),
      color 180ms var(--motion-snap);
    box-shadow: 0 4px 14px -14px hsl(var(--foreground) / 0.65);
  }

  .interactive-chip:hover {
    transform: translateY(-1px);
    box-shadow: 0 9px 20px -16px hsl(var(--foreground) / 0.78);
  }

  .interactive-chip:active {
    transform: translateY(0) scale(0.98);
  }

  .interactive-card {
    transition:
      transform 220ms var(--motion-snap),
      box-shadow 220ms var(--motion-snap),
      border-color 220ms var(--motion-snap);
    box-shadow: 0 8px 22px -24px hsl(var(--foreground) / 0.86);
  }

  .interactive-card:hover {
    transform: translateY(-2px);
    box-shadow: 0 16px 40px -30px hsl(var(--foreground) / 0.8);
  }

  .interactive-card:active {
    transform: translateY(0) scale(0.995);
  }

  .page-hero-title {
    letter-spacing: -0.015em;
    text-wrap: balance;
  }

  .page-hero-subtitle {
    text-wrap: pretty;
  }

  .type-label-caps {
    text-transform: uppercase;
    letter-spacing: var(--type-label-caps-tracking);
  }

  .ui-density {
    --ui-density-section-label-size: var(--type-xs-size);
    --ui-density-section-label-line: var(--type-xs-line);
    --ui-density-toolbar-size: var(--type-xs-size);
    --ui-density-toolbar-line: var(--type-xs-line);
    --ui-density-toolbar-height-mobile: 2.75rem;
    --ui-density-toolbar-height-desktop: 2.25rem;
    --ui-density-state-title-size: var(--type-base-size);
    --ui-density-state-title-line: var(--type-base-line);
    --ui-density-state-body-size: var(--type-sm-size);
    --ui-density-state-body-line: var(--type-sm-line);
  }

  .ui-density[data-density="compact"] {
    --ui-density-section-label-size: var(--type-xs-size);
    --ui-density-section-label-line: var(--type-xs-line);
    --ui-density-toolbar-size: var(--type-xs-size);
    --ui-density-toolbar-line: var(--type-xs-line);
    --ui-density-toolbar-height-mobile: 2.5rem;
    --ui-density-toolbar-height-desktop: 2rem;
    --ui-density-state-title-size: var(--type-sm-size);
    --ui-density-state-title-line: var(--type-sm-line);
    --ui-density-state-body-size: var(--type-sm-size);
    --ui-density-state-body-line: var(--type-sm-line);
  }

  .ui-section-label {
    font-size: var(--ui-density-section-label-size, var(--type-sm-size));
    line-height: var(--ui-density-section-label-line, var(--type-sm-line));
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: var(--type-label-caps-tracking);
  }

  .ui-toolbar-button {
    min-height: var(--ui-density-toolbar-height-mobile);
    font-size: var(--ui-density-toolbar-size, var(--type-xs-size));
    line-height: var(--ui-density-toolbar-line, var(--type-xs-line));
  }

  .utility-action-button {
    min-height: 2.5rem;
    border-radius: 0.625rem;
    padding-inline: 0.75rem;
    gap: 0.375rem;
    font-size: var(--type-xs-size);
    line-height: var(--type-xs-line);
    font-weight: 600;
    letter-spacing: 0;
    white-space: nowrap;
  }

  .utility-action-button svg {
    width: 0.875rem;
    height: 0.875rem;
    flex-shrink: 0;
  }

  .utility-action-button--floating {
    background-color: hsl(var(--background) / 0.86);
    box-shadow: 0 10px 22px -18px hsl(var(--foreground) / 0.75);
    backdrop-filter: blur(6px);
  }

  @media (min-width: 640px) {
    .ui-toolbar-button {
      min-height: var(--ui-density-toolbar-height-desktop);
    }

    .utility-action-button {
      min-height: 2.125rem;
      padding-inline: 0.625rem;
      gap: 0.3125rem;
    }
  }

  .ui-state-card-title {
    font-size: var(--ui-density-state-title-size, var(--type-base-size));
    line-height: var(--ui-density-state-title-line, var(--type-base-line));
    font-weight: 600;
  }

  .ui-state-card-body {
    font-size: var(--ui-density-state-body-size, var(--type-sm-size));
    line-height: var(--ui-density-state-body-line, var(--type-sm-line));
  }

  .type-label-shortcut {
    letter-spacing: var(--type-label-shortcut-tracking);
    font-variant-numeric: tabular-nums;
  }

  .type-wrap-safe {
    overflow-wrap: anywhere;
    word-break: break-word;
    hyphens: auto;
  }

  .type-prose-measure {
    max-inline-size: 62ch;
  }

  .community-feed-card {
    animation: community-feed-enter 420ms var(--motion-snap) both;
  }

  .category-scroll-fade::after {
    content: "";
    position: absolute;
    right: 0;
    top: 0;
    bottom: 0;
    width: 2rem;
    background: linear-gradient(to right, transparent, hsl(var(--card)));
    pointer-events: none;
    z-index: 1;
  }

  .enhance-output-frame {
    @apply border-border/90;
    transition:
      border-color 220ms var(--motion-snap),
      box-shadow 220ms var(--motion-snap),
      background-color 220ms var(--motion-snap);
  }

  .enhance-output-streaming {
    position: relative;
    isolation: isolate;
    box-shadow: 0 20px 34px -32px hsl(var(--delight-glow) / 0.62);
    border-color: hsl(var(--delight-glow) / 0.45);
  }

  .enhance-output-streaming::after {
    content: "";
    position: absolute;
    inset: -1px;
    z-index: -1;
    background: linear-gradient(110deg,
        transparent 34%,
        hsl(var(--delight-glow) / 0.12) 49%,
        transparent 64%);
    animation: delight-enhance-sheen 1700ms linear infinite;
    pointer-events: none;
  }

  .enhance-output-complete {
    animation: delight-settle 420ms var(--motion-snap) both;
    border-color: hsl(var(--delight-glow) / 0.55);
  }

  .signature-enhance-button {
    position: relative;
    isolation: isolate;
    overflow: hidden;
    box-shadow: 0 14px 30px -20px hsl(var(--delight-glow) / 0.62);
  }

  .signature-enhance-button::after {
    content: "";
    position: absolute;
    inset: -12%;
    border-radius: inherit;
    background: radial-gradient(circle, hsl(var(--delight-glow) / 0.32) 0%, transparent 68%);
    opacity: 0;
    pointer-events: none;
    transform: scale(0.5);
  }

  .signature-enhance-button[data-phase="starting"] {
    animation: delight-enhance-ignite 520ms var(--motion-snap) both;
  }

  .signature-enhance-button[data-phase="streaming"] {
    animation:
      delight-enhance-stream 960ms ease-in-out infinite,
      delight-enhance-pulse 1200ms ease-in-out infinite;
  }

  .signature-enhance-button[data-phase="settling"] {
    animation: delight-enhance-settle-button 480ms var(--motion-snap) both;
  }

  .signature-enhance-button[data-phase="done"] {
    border-color: hsl(var(--delight-glow) / 0.62);
    box-shadow: 0 14px 34px -22px hsl(var(--delight-glow) / 0.72);
  }

  .signature-enhance-button[data-phase="done"]::after {
    opacity: 1;
    animation: delight-enhance-success-wave 620ms var(--motion-snap) 1;
  }

  .community-typography {
    --community-type-screen-title-size: 1.75rem;
    --community-type-screen-title-line: 2.125rem;
    --community-type-screen-subtitle-size: 0.9375rem;
    --community-type-screen-subtitle-line: 1.5rem;
    --community-type-tab-size: 0.8125rem;
    --community-type-tab-line: 1.125rem;
    --community-type-post-title-size: 1.125rem;
    --community-type-post-title-line: 1.625rem;
    --community-type-post-body-size: 0.9375rem;
    --community-type-post-body-line: 1.5rem;
    --community-type-author-size: 0.8125rem;
    --community-type-author-line: 1.125rem;
    --community-type-time-size: 0.75rem;
    --community-type-time-line: 1rem;
    --community-type-meta-size: 0.75rem;
    --community-type-meta-line: 1rem;
    --community-type-button-size: 0.875rem;
    --community-type-button-line: 1.25rem;
    --community-type-chip-size: 0.75rem;
    --community-type-chip-line: 1rem;
    --community-type-comment-size: 0.9375rem;
    --community-type-comment-line: 1.5rem;
    --community-type-reply-size: 0.6875rem;
    --community-type-reply-line: 0.875rem;
    --community-type-input-size: var(--type-base-size);
    --community-type-input-line: var(--type-base-line);
    --community-type-help-size: 0.75rem;
    --community-type-help-line: 1.125rem;
    --community-type-code-size: 0.8125rem;
    --community-type-code-line: 1.25rem;
    --community-type-letter-caps: 0.03em;
  }

  .community-typography[data-density="compact"] {
    --community-type-screen-title-size: 1.5rem;
    --community-type-screen-title-line: 1.875rem;
    --community-type-screen-subtitle-size: 0.875rem;
    --community-type-screen-subtitle-line: 1.25rem;
    --community-type-tab-size: 0.75rem;
    --community-type-tab-line: 1rem;
    --community-type-post-title-size: 1rem;
    --community-type-post-title-line: 1.375rem;
    --community-type-post-body-size: 0.875rem;
    --community-type-post-body-line: 1.3125rem;
    --community-type-button-size: 0.8125rem;
    --community-type-button-line: 1.125rem;
    --community-type-comment-size: 0.875rem;
    --community-type-comment-line: 1.3125rem;
    --community-type-help-line: 1rem;
    --community-type-code-size: 0.75rem;
    --community-type-code-line: 1.125rem;
  }

  .community-typography .type-screen-title {
    font-size: var(--community-type-screen-title-size);
    line-height: var(--community-type-screen-title-line);
    font-weight: 700;
    letter-spacing: -0.01em;
  }

  .community-typography .type-screen-subtitle {
    font-size: var(--community-type-screen-subtitle-size);
    line-height: var(--community-type-screen-subtitle-line);
    font-weight: 400;
  }

  .community-typography .type-tab-label {
    font-size: var(--community-type-tab-size);
    line-height: var(--community-type-tab-line);
    font-weight: 600;
  }

  .community-typography .type-post-title {
    font-size: var(--community-type-post-title-size);
    line-height: var(--community-type-post-title-line);
    font-weight: 600;
    letter-spacing: -0.005em;
  }

  .community-typography .type-post-body {
    font-size: var(--community-type-post-body-size);
    line-height: var(--community-type-post-body-line);
    font-weight: 400;
  }

  .community-typography .type-author {
    font-size: var(--community-type-author-size);
    line-height: var(--community-type-author-line);
    font-weight: 600;
  }

  .community-typography .type-timestamp {
    font-size: var(--community-type-time-size);
    line-height: var(--community-type-time-line);
    font-weight: 400;
  }

  .community-typography .type-meta {
    font-size: var(--community-type-meta-size);
    line-height: var(--community-type-meta-line);
    font-weight: 400;
  }

  .community-typography .type-button-label {
    font-size: var(--community-type-button-size);
    line-height: var(--community-type-button-line);
    font-weight: 600;
    letter-spacing: 0;
  }

  .community-typography .type-chip {
    font-size: var(--community-type-chip-size);
    line-height: var(--community-type-chip-line);
    font-weight: 500;
  }

  .community-typography .type-comment-body {
    font-size: var(--community-type-comment-size);
    line-height: var(--community-type-comment-line);
    font-weight: 400;
  }

  .community-typography .type-reply-label {
    font-size: var(--community-type-reply-size);
    line-height: var(--community-type-reply-line);
    font-weight: 600;
  }

  .community-typography .type-input {
    font-size: var(--community-type-input-size);
    line-height: var(--community-type-input-line);
    font-weight: 400;
  }

  .community-typography .type-help {
    font-size: var(--community-type-help-size);
    line-height: var(--community-type-help-line);
    font-weight: 400;
  }

  .community-typography .type-code {
    font-size: var(--community-type-code-size);
    line-height: var(--community-type-code-line);
    font-weight: 400;
  }

  .community-typography .type-label-caps {
    text-transform: uppercase;
    letter-spacing: var(--community-type-letter-caps);
  }

  .community-typography .type-link-inline {
    text-decoration-line: underline;
    text-underline-offset: 0.16em;
    text-decoration-thickness: 1px;
  }

  .community-typography .type-link-inline:hover {
    text-decoration-thickness: 2px;
  }

  .community-typography .type-link-inline:focus-visible {
    border-radius: 0.125rem;
    outline: 2px solid hsl(var(--ring));
    outline-offset: 2px;
    text-decoration-thickness: 2px;
  }

  .community-typography .type-link-inline:visited {
    text-decoration-thickness: 1.25px;
  }

  .community-typography .type-numeric {
    font-variant-numeric: tabular-nums;
    font-feature-settings: "tnum" 1, "lnum" 1;
  }

  .community-typography .type-wrap-safe {
    overflow-wrap: anywhere;
    word-break: break-word;
    hyphens: auto;
  }

  .community-typography .type-wrap-inline {
    overflow-wrap: break-word;
    word-break: normal;
    hyphens: auto;
  }

  .community-typography .type-emoji-inline {
    font-size: 1.1em;
    line-height: 1;
    vertical-align: -0.1em;
  }

  .community-typography .type-prose-measure {
    max-inline-size: 58ch;
  }

  .community-typography .delight-hero h1 {
    font-size: var(--community-type-screen-title-size);
    line-height: var(--community-type-screen-title-line);
    font-weight: 700;
    letter-spacing: -0.01em;
  }

  .community-typography .delight-hero p {
    font-size: var(--community-type-screen-subtitle-size);
    line-height: var(--community-type-screen-subtitle-line);
    font-weight: 400;
  }
}

@media (prefers-reduced-motion: reduce) {

  .delight-hero,
  .community-feed-card,
  .enhance-output-streaming::after,
  .signature-enhance-button[data-phase="starting"],
  .signature-enhance-button[data-phase="streaming"],
  .signature-enhance-button[data-phase="settling"],
  .signature-enhance-button[data-phase="done"]::after,
  .enhance-output-complete {
    animation: none !important;
  }

  .signature-enhance-button::after {
    opacity: 0 !important;
  }

  .interactive-chip:hover,
  .interactive-chip:active,
  .interactive-card:hover,
  .interactive-card:active {
    transform: none !important;
  }
}
````

## File: src/components/community/CommunityPostCard.tsx
````typescript
import { memo, useMemo, useState } from "react";
import { formatDistanceToNow } from "date-fns";
import { Link, useNavigate } from "react-router-dom";
import type { CommunityPost, VoteState, VoteType } from "@/lib/community";
import { estimateTokens, getInitials } from "@/lib/community-utils";
import { Badge } from "@/components/base/badges/badges";
import { Button } from "@/components/base/buttons/button";
import { Card } from "@/components/base/primitives/card";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/base/primitives/avatar";
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/base/primitives/tooltip";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/base/primitives/dropdown-menu";
import { PromptPreviewPanel } from "@/components/community/PromptPreviewPanel";
import { CommunityComments } from "@/components/community/CommunityComments";
import { Drawer, DrawerContent, DrawerDescription, DrawerHeader, DrawerTitle } from "@/components/base/drawer";
import { useIsMobile } from "@/hooks/use-mobile";
import { getCommunityPostRarityClass } from "@/lib/community-rarity";
import { communityFeatureFlags } from "@/lib/feature-flags";
import { cn } from "@/lib/utils";
import {
  ArrowUp,
  BookmarkSimple as BookmarkPlus,
  ChatCircle as MessageCircle,
  CheckCircle as CheckCircle2,
  Database,
  DotsThreeOutline as MoreHorizontal,
  Flag,
  GitBranch,
  ShareNetwork as Share2,
  Star,
  UserCheck,
  UserMinus as UserX,
} from "@phosphor-icons/react";

interface CommunityPostCardProps {
  post: CommunityPost;
  isFeatured?: boolean;
  animationDelayMs?: number;
  authorName: string;
  authorAvatarUrl?: string | null;
  parentPostTitle?: string;
  onCopyPrompt: (post: CommunityPost) => void;
  onToggleVote: (postId: string, voteType: VoteType) => void;
  voteState?: VoteState;
  onCommentAdded: (postId: string) => void;
  onCommentThreadOpen?: (postId: string) => void;
  onSharePost?: (post: CommunityPost) => void;
  onSaveToLibrary?: (postId: string) => void;
  followingUserIds?: Set<string>;
  currentUserId?: string | null;
  onToggleFollow?: (userId: string, isFollowing: boolean) => void;
  canVote: boolean;
  canRate?: boolean;
  ratingValue?: number | null;
  onRatePrompt?: (postId: string, rating: number | null) => void;
  canModerate?: boolean;
  canBlockAuthor?: boolean;
  isAuthorBlocked?: boolean;
  blockedUserIds?: string[];
  onReportPost?: (post: CommunityPost) => void;
  onReportComment?: (commentId: string, userId: string, postId: string) => void;
  onBlockUser?: (userId: string) => void;
  onUnblockUser?: (userId: string) => void;
  onTagClick?: (tag: string) => void;
  featuredBadgeLabel?: string;
}


function CommunityPostCardComponent({
  post,
  isFeatured = false,
  animationDelayMs = 0,
  authorName,
  authorAvatarUrl,
  parentPostTitle,
  onCopyPrompt,
  onToggleVote,
  voteState,
  onCommentAdded,
  onCommentThreadOpen,
  onSharePost,
  onSaveToLibrary,
  followingUserIds,
  currentUserId,
  onToggleFollow,
  canVote,
  canRate = false,
  ratingValue = null,
  onRatePrompt,
  canModerate = false,
  canBlockAuthor = true,
  isAuthorBlocked = false,
  blockedUserIds = [],
  onReportPost,
  onReportComment,
  onBlockUser,
  onUnblockUser,
  onTagClick,
  featuredBadgeLabel,
}: CommunityPostCardProps) {
  const navigate = useNavigate();
  const isMobile = useIsMobile();
  const useMobileCommentsDrawer = isMobile && communityFeatureFlags.communityMobileEnhancements;
  const createdAgo = useMemo(
    () => formatDistanceToNow(new Date(post.createdAt), { addSuffix: true }),
    [post.createdAt],
  );
  const [commentsOpen, setCommentsOpen] = useState(false);
  const promptBody = (post.enhancedPrompt || post.starterPrompt || "").trim();
  const tokenEstimate = useMemo(() => estimateTokens(promptBody), [promptBody]);
  const ratingAverage = post.ratingAverage ?? 0;
  const ratingCount = post.ratingCount ?? 0;
  const ratingSummaryAriaLabel = `Average rating ${ratingAverage.toFixed(1)} from ${ratingCount} rating${ratingCount === 1 ? "" : "s"}`;
  const visibleTags = useMemo(() => {
    const mobileMax = 2;
    const desktopMax = isFeatured ? 6 : 4;
    return post.tags.slice(0, isMobile ? mobileMax : desktopMax);
  }, [isFeatured, isMobile, post.tags]);
  const postPath = `/community/${post.id}`;
  const commentsLabel = useMobileCommentsDrawer ? "Comments" : commentsOpen ? "Hide comments" : "Comments";

  return (
    <Card
      className={cn(
        "community-feed-card interactive-card pf-card overflow-hidden border-border/80 bg-card/85 p-3 sm:p-4",
        getCommunityPostRarityClass(post, isFeatured),
        isFeatured && "lg:col-span-2 bg-linear-to-br from-primary/10 via-card/90 to-card/85",
      )}
      style={{
        animationDelay: `${animationDelayMs}ms`,
        ...(isFeatured ? { borderColor: "hsl(var(--primary) / 0.35)" } : {}),
      }}
    >
      <div className={cn("space-y-3", isMobile && "space-y-2.5")}>
        <div className="flex flex-col gap-2 sm:flex-row sm:items-start sm:justify-between sm:gap-3">
          <div className="flex min-w-0 items-center gap-2">
            <Avatar className="h-8 w-8 border border-border/60">
              <AvatarImage src={authorAvatarUrl ?? undefined} alt={authorName} />
              <AvatarFallback className="type-reply-label">{getInitials(authorName)}</AvatarFallback>
            </Avatar>
            <div className="min-w-0">
              <div className="flex items-center gap-1.5">
                <Link to={`/profile/${post.authorId}`} className="type-author type-link-inline type-wrap-inline text-foreground">
                  {authorName}
                </Link>
                {onToggleFollow && currentUserId && post.authorId !== currentUserId && (
                  <Button
                    type="button"
                    size="sm"
                    color={followingUserIds?.has(post.authorId) ? "secondary" : "primary"}
                    className="type-button-label h-6 px-2 text-xs leading-none sm:h-5"
                    onClick={() => onToggleFollow(post.authorId, followingUserIds?.has(post.authorId) ?? false)}
                  >
                    {followingUserIds?.has(post.authorId) ? "Following" : "Follow"}
                  </Button>
                )}
              </div>
              <p className="type-timestamp text-muted-foreground">{createdAgo}</p>
            </div>
          </div>
          <div className="flex flex-wrap items-center gap-1 self-start sm:self-auto sm:justify-end">
            {post.targetModel && (
              <Badge type="modern" className="type-chip h-6 px-2 font-mono sm:h-5 sm:px-1.5">
                {post.targetModel}
              </Badge>
            )}
            <Badge
              type="modern"
              className="type-chip h-6 border border-border bg-background px-2 text-foreground capitalize sm:h-5 sm:px-1.5"
            >
              {post.category}
            </Badge>
            {canModerate && (
              <DropdownMenu>
                <DropdownMenuTrigger asChild>
                  <Button
                    type="button"
                    color="tertiary"
                    size="sm"
                    className="h-8 w-8"
                    aria-label="Open moderation actions"
                  >
                    <MoreHorizontal className="h-4 w-4" />
                  </Button>
                </DropdownMenuTrigger>
                <DropdownMenuContent align="end">
                  <DropdownMenuItem
                    onSelect={(event) => {
                      event.preventDefault();
                      onReportPost?.(post);
                    }}
                  >
                    <Flag className="mr-2 h-4 w-4" />
                    Report post
                  </DropdownMenuItem>
                  {canBlockAuthor && (isAuthorBlocked ? (
                    <DropdownMenuItem
                      onSelect={(event) => {
                        event.preventDefault();
                        onUnblockUser?.(post.authorId);
                      }}
                    >
                      <UserCheck className="mr-2 h-4 w-4" />
                      Unblock user
                    </DropdownMenuItem>
                  ) : (
                    <DropdownMenuItem
                      onSelect={(event) => {
                        event.preventDefault();
                        onBlockUser?.(post.authorId);
                      }}
                    >
                      <UserX className="mr-2 h-4 w-4" />
                      Block user
                    </DropdownMenuItem>
                  ))}
                </DropdownMenuContent>
              </DropdownMenu>
            )}
          </div>
        </div>

        {post.remixedFrom && (
          <div className="type-meta rounded-md border border-primary/20 bg-primary/10 px-2.5 py-1.5 text-primary">
            <span className="font-medium">Remixed from:</span> {parentPostTitle || "another community prompt"}
          </div>
        )}

        <Link
          to={postPath}
          aria-label={`Open ${post.title}`}
          className="block rounded-md focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2"
        >
          {featuredBadgeLabel && (
            <Badge
              type="modern"
              className="type-chip mb-1 border border-primary/35 bg-primary/12 text-primary"
            >
              {featuredBadgeLabel}
            </Badge>
          )}
          <h3 className={cn("type-post-title text-foreground", isFeatured && "sm:text-xl sm:leading-7")}>
            {post.title}
          </h3>
          {post.useCase && (
            <p className="type-post-body type-prose-measure type-wrap-safe mt-1 line-clamp-3 text-muted-foreground">
              {post.useCase}
            </p>
          )}
        </Link>

        <PromptPreviewPanel
          text={promptBody}
          mode="compact"
          className={cn("pf-community-preview bg-background/65", isFeatured && "border-primary/25")}
          onCopy={() => onCopyPrompt(post)}
        />

        {visibleTags.length > 0 && (
          <div className="flex flex-wrap items-center gap-1.5">
            {visibleTags.map((tag) => (
              <button
                key={`${post.id}-${tag}`}
                type="button"
                disabled={!onTagClick}
                onClick={() => onTagClick?.(tag)}
                aria-label={onTagClick ? `Filter by tag ${tag}` : undefined}
                className="rounded-full focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-default"
              >
                <Badge
                  type="modern"
                  className={cn(
                    "type-chip border border-border bg-background text-foreground",
                    onTagClick && "cursor-pointer hover:bg-muted",
                  )}
                >
                  #{tag}
                </Badge>
              </button>
            ))}
          </div>
        )}

        <div className="type-meta flex flex-wrap items-center justify-between gap-2 border-t border-border/60 pt-2 text-muted-foreground">
          <div className="flex flex-wrap items-center gap-3">
            <TooltipProvider delayDuration={150}>
              <Tooltip>
                <TooltipTrigger asChild>
                  <span className="type-numeric inline-flex items-center gap-1 font-mono">
                    <Database className="h-3.5 w-3.5" />
                    {tokenEstimate}t
                  </span>
                </TooltipTrigger>
                <TooltipContent side="top">
                  Estimated token count (~1.35x word count)
                </TooltipContent>
              </Tooltip>
            </TooltipProvider>
            <span className="type-numeric inline-flex items-center gap-1">
              <GitBranch className="h-3.5 w-3.5" />
              {post.remixCount}
            </span>
          </div>
          <div className="flex items-center gap-1.5">
            {onSaveToLibrary && currentUserId && (
              <Button
                type="button"
                color="secondary"
                size="sm"
                className="type-button-label utility-action-button"
                onClick={() => onSaveToLibrary(post.id)}
                data-testid="community-save-cta"
              >
                <BookmarkPlus className="h-3.5 w-3.5" />
                Save
              </Button>
            )}
            <Button
              type="button"
              color={isMobile || isFeatured ? "primary" : "secondary"}
              size="sm"
              className="type-button-label utility-action-button min-w-[84px]"
              onClick={() => navigate(`/?remix=${post.id}`)}
              data-testid="community-remix-cta"
            >
              Remix
            </Button>
          </div>
        </div>

        <div
          className={cn(
            "type-meta gap-2 text-muted-foreground",
            isMobile ? "grid grid-cols-4" : "flex flex-wrap items-center",
          )}
        >
          <Button
            type="button"
            size="sm"
            color={voteState?.upvote ? "primary" : "secondary"}
            className="type-button-label interactive-chip h-11 min-w-11 gap-1.5 px-3 sm:h-9 sm:min-w-9 sm:gap-1 sm:px-2.5"
            disabled={!canVote}
            onClick={() => onToggleVote(post.id, "upvote")}
            data-testid="community-vote-upvote"
          >
            <ArrowUp className="h-3.5 w-3.5" />
            <span className="type-numeric">{post.upvoteCount}</span>
          </Button>
          <Button
            type="button"
            size="sm"
            color={voteState?.verified ? "primary" : "secondary"}
            className="type-button-label interactive-chip h-11 min-w-11 gap-1.5 px-3 sm:h-9 sm:min-w-9 sm:gap-1 sm:px-2.5"
            disabled={!canVote}
            onClick={() => onToggleVote(post.id, "verified")}
            data-testid="community-vote-verified"
          >
            <CheckCircle2 className="h-3.5 w-3.5" />
            <span className="type-numeric">{post.verifiedCount}</span>
          </Button>
          <Button
            type="button"
            color="tertiary"
            size="sm"
            className="type-button-label interactive-chip h-11 gap-1.5 px-3 sm:h-9 sm:px-2.5"
            aria-label={post.commentCount > 0 ? `${commentsLabel} ${post.commentCount}` : commentsLabel}
            onClick={() => {
              if (useMobileCommentsDrawer) {
                setCommentsOpen(true);
                onCommentThreadOpen?.(post.id);
                return;
              }
              setCommentsOpen((prev) => !prev);
            }}
            data-testid="community-comment-toggle"
          >
            <MessageCircle className="h-3.5 w-3.5" />
            {commentsLabel}
            {post.commentCount > 0 && (
              <Badge
                type="modern"
                className="type-reply-label type-numeric ml-0.5 h-4 min-w-4 px-1 leading-none"
                aria-hidden="true"
              >
                {post.commentCount}
              </Badge>
            )}
          </Button>
          {onSharePost && (
            <Button
              type="button"
              color="tertiary"
              size="sm"
              className="type-button-label interactive-chip h-11 min-w-11 gap-1.5 px-3 sm:h-9 sm:min-w-9 sm:gap-1 sm:px-2.5"
              aria-label="Share post"
              onClick={() => onSharePost(post)}
              data-testid="community-share"
            >
              <Share2 className="h-3.5 w-3.5" />
            </Button>
          )}
        </div>

        <div className="space-y-2">
          <div className="type-meta flex flex-wrap items-center gap-2 text-muted-foreground">
            <span className="type-meta text-muted-foreground">Community rating</span>
            <span
              aria-label={ratingSummaryAriaLabel}
              className="inline-flex items-center gap-1.5 rounded-full border border-border/65 bg-background/65 px-2 py-1"
            >
              <Star
                className={cn(
                  "h-3.5 w-3.5",
                  ratingCount > 0 ? "fill-primary text-primary" : "text-muted-foreground",
                )}
              />
              <span className="type-numeric">{ratingAverage.toFixed(1)}</span>
              <span className="type-numeric text-muted-foreground/80">({ratingCount})</span>
            </span>
          </div>
          {canRate && onRatePrompt && (
            <div className="type-meta flex flex-wrap items-center gap-2 border-t border-border/40 pt-2 text-muted-foreground">
              <span className="type-meta text-muted-foreground">Your rating</span>
              <div className="inline-flex items-center gap-0.5 rounded-full border border-border/65 bg-background/65 p-0.5">
                {[1, 2, 3, 4, 5].map((value) => {
                  const isActive = (ratingValue ?? 0) >= value;
                  return (
                    <Button
                      key={`${post.id}-rate-${value}`}
                      type="button"
                      color="tertiary"
                      size="sm"
                      className="h-10 w-10 rounded-full p-0 sm:h-7 sm:w-7"
                      aria-label={`Rate ${value} star${value === 1 ? "" : "s"}`}
                      onClick={() => onRatePrompt(post.id, ratingValue === value ? null : value)}
                    >
                      <Star
                        className={cn(
                          "h-5 w-5 transition-colors sm:h-4 sm:w-4",
                          isActive ? "fill-primary text-primary" : "text-muted-foreground",
                        )}
                      />
                    </Button>
                  );
                })}
              </div>
            </div>
          )}
        </div>

        {!useMobileCommentsDrawer && commentsOpen && (
          <CommunityComments
            postId={post.id}
            totalCount={post.commentCount}
            compact
            onCommentAdded={onCommentAdded}
            blockedUserIds={blockedUserIds}
            onReportComment={onReportComment}
            onBlockUser={onBlockUser}
            onUnblockUser={onUnblockUser}
          />
        )}

        {useMobileCommentsDrawer && (
          <Drawer open={commentsOpen} onOpenChange={setCommentsOpen}>
            <DrawerContent
              className="max-h-[84vh] gap-0 border-border/80 pb-[max(0.75rem,env(safe-area-inset-bottom))]"
              data-testid="community-comments-sheet"
            >
              <DrawerHeader className="border-b border-border/60 px-4 pb-2 pt-2.5">
                <DrawerTitle className="type-post-title">Comments</DrawerTitle>
                <DrawerDescription className="sr-only">
                  Read and add comments for this prompt.
                </DrawerDescription>
              </DrawerHeader>
              <div className="px-3 pb-[max(0.75rem,env(safe-area-inset-bottom))] pt-2 sm:px-4">
                <CommunityComments
                  postId={post.id}
                  totalCount={post.commentCount}
                  onCommentAdded={onCommentAdded}
                  autoFocusComposer
                  blockedUserIds={blockedUserIds}
                  onReportComment={onReportComment}
                  onBlockUser={onBlockUser}
                  onUnblockUser={onUnblockUser}
                  className="space-y-2 border-0 bg-transparent p-0 shadow-none"
                />
              </div>
            </DrawerContent>
          </Drawer>
        )}
      </div>
    </Card>
  );
}

function areVoteStatesEqual(previous?: VoteState, next?: VoteState): boolean {
  return (previous?.upvote ?? false) === (next?.upvote ?? false) &&
    (previous?.verified ?? false) === (next?.verified ?? false);
}

function areRatingsEqual(previous: number | null | undefined, next: number | null | undefined): boolean {
  return (previous ?? null) === (next ?? null);
}

function arePropsEqual(previous: CommunityPostCardProps, next: CommunityPostCardProps): boolean {
  return (
    previous.post === next.post &&
    previous.isFeatured === next.isFeatured &&
    previous.animationDelayMs === next.animationDelayMs &&
    previous.authorName === next.authorName &&
    previous.authorAvatarUrl === next.authorAvatarUrl &&
    previous.parentPostTitle === next.parentPostTitle &&
    previous.onCopyPrompt === next.onCopyPrompt &&
    previous.onToggleVote === next.onToggleVote &&
    previous.onCommentAdded === next.onCommentAdded &&
    previous.onCommentThreadOpen === next.onCommentThreadOpen &&
    previous.onSharePost === next.onSharePost &&
    previous.onSaveToLibrary === next.onSaveToLibrary &&
    previous.followingUserIds === next.followingUserIds &&
    previous.currentUserId === next.currentUserId &&
    previous.onToggleFollow === next.onToggleFollow &&
    previous.canVote === next.canVote &&
    previous.canRate === next.canRate &&
    areRatingsEqual(previous.ratingValue, next.ratingValue) &&
    previous.onRatePrompt === next.onRatePrompt &&
    previous.canModerate === next.canModerate &&
    previous.canBlockAuthor === next.canBlockAuthor &&
    previous.isAuthorBlocked === next.isAuthorBlocked &&
    previous.onReportPost === next.onReportPost &&
    previous.onReportComment === next.onReportComment &&
    previous.onBlockUser === next.onBlockUser &&
    previous.onUnblockUser === next.onUnblockUser &&
    previous.onTagClick === next.onTagClick &&
    previous.featuredBadgeLabel === next.featuredBadgeLabel &&
    previous.blockedUserIds === next.blockedUserIds &&
    areVoteStatesEqual(previous.voteState, next.voteState)
  );
}

export const CommunityPostCard = memo(CommunityPostCardComponent, arePropsEqual);
CommunityPostCard.displayName = "CommunityPostCard";
````

## File: src/pages/Index.tsx
````typescript
import { useState, useEffect, useCallback, useRef, useMemo } from "react";
import { Link, useSearchParams } from "react-router-dom";
import { PageShell } from "@/components/PageShell";
import { PromptInput } from "@/components/PromptInput";
import { BuilderHeroInput } from "@/components/BuilderHeroInput";
import { BuilderAdjustDetails } from "@/components/BuilderAdjustDetails";
import { BuilderSourcesAdvanced } from "@/components/BuilderSourcesAdvanced";
import { BuilderTabs } from "@/components/BuilderTabs";
import { ContextPanel } from "@/components/ContextPanel";
import { ToneControls } from "@/components/ToneControls";
import { QualityScore } from "@/components/QualityScore";
import { OutputPanel, type EnhancePhase } from "@/components/OutputPanel";
import { usePromptBuilder } from "@/hooks/usePromptBuilder";
import {
  inferBuilderFields,
  streamEnhance,
  type AIClientError,
  type EnhanceThreadOptions,
} from "@/lib/ai-client";
import {
  applyInferenceUpdates,
  clearAiOwnedFields,
  createFieldOwnershipFromConfig,
  inferBuilderFieldsLocally,
  listInferenceFieldsFromUpdates,
  markOwnershipFields,
  type BuilderFieldOwnershipMap,
  type BuilderSuggestionChip,
} from "@/lib/builder-inference";
import { getSectionHealth, type SectionHealthState } from "@/lib/section-health";
import { buildPrompt, defaultConfig, hasPromptInput } from "@/lib/prompt-builder";
import { useToast } from "@/hooks/use-toast";
import { useIsMobile } from "@/hooks/use-mobile";
import { loadPost, loadProfilesByIds } from "@/lib/community";
import { consumeRestoredVersionPrompt } from "@/lib/history-restore";
import { builderRedesignFlags, launchExperimentFlags } from "@/lib/feature-flags";
import { trackBuilderEvent } from "@/lib/telemetry";
import { templates } from "@/lib/templates";
import { getUserPreferences, setUserPreference } from "@/lib/user-preferences";
import { brandCopy } from "@/lib/brand-copy";
import {
  getHeroCopyVariant,
  getLaunchExperimentAssignments,
  getPrimaryCtaVariantLabel,
} from "@/lib/launch-experiments";
import {
  Accordion,
  AccordionContent,
  AccordionItem,
  AccordionTrigger,
} from "@/components/base/primitives/accordion";
import {
  Drawer,
  DrawerContent,
  DrawerDescription,
  DrawerHeader,
  DrawerTitle,
} from "@/components/base/drawer";
import { Button } from "@/components/base/buttons/button";
import { Badge } from "@/components/base/badges/badges";
import { Card } from "@/components/base/primitives/card";
import { ToastAction } from "@/components/base/primitives/toast";
import { Switch } from "@/components/base/primitives/switch";
import type { Icon as IconType } from "@phosphor-icons/react";
import { UI_STATUS_SURFACE_CLASSES } from "@/lib/ui-status";
import { PFQualityGauge } from "@/components/fantasy/PFQualityGauge";
import {
  ChartBar as BarChart3,
  Chat as MessageSquare,
  Check,
  CheckCircle as CheckCircle2,
  CircleDashed,
  Crosshair as Target,
  Eye,
  Gauge,
  Globe,
  Layout as LayoutIcon,
  Sparkle as Sparkles,
  SpinnerGap as Loader2,
  X,
} from "@phosphor-icons/react";

const healthBadgeStyles: Record<
  SectionHealthState,
  { label: string; className: string; icon: IconType }
> = {
  empty: {
    label: "Empty",
    className: "border-border/80 bg-muted/50 text-muted-foreground",
    icon: CircleDashed,
  },
  in_progress: {
    label: "In progress",
    className: UI_STATUS_SURFACE_CLASSES.info,
    icon: Gauge,
  },
  complete: {
    label: "Complete",
    className: UI_STATUS_SURFACE_CLASSES.success,
    icon: CheckCircle2,
  },
};

function SectionHealthBadge({ state }: { state: SectionHealthState }) {
  const meta = healthBadgeStyles[state];
  const Icon = meta.icon;

  return (
    <span
      className={`inline-flex items-center gap-1 rounded-full border px-2 py-0.5 text-xs font-medium ${meta.className}`}
      title={meta.label}
    >
      <Icon className="h-3 w-3" />
      <span className="hidden sm:inline">{meta.label}</span>
    </span>
  );
}

type BuilderSection = "builder" | "context" | "tone" | "quality";

const ENHANCE_THREAD_OPTIONS_BASE: Omit<EnhanceThreadOptions, "webSearchEnabled"> = {
  modelReasoningEffort: "medium",
};

const DEBUG_ENHANCE_EVENTS_KEY = "promptforge:debug-enhance-events";
const DEBUG_ENHANCE_EVENTS_MAX = 200;
const DEBUG_ENHANCE_PAYLOAD_PREVIEW_CHARS = 1200;
const ENHANCED_PROMPT_SOURCES_SEPARATOR = /\n---\n\s*Sources:\s*\n/i;
const REASONING_ITEM_TYPES = new Set([
  "reasoning",
  "reasoning_summary",
  "reasoning-summary",
  "reasoning.summary",
  "reasoningsummary",
]);
const REASONING_SEGMENT_PATTERN = /(^|[./_-])reasoning([./_-]|$)/;

type EnhanceStreamEvent = {
  eventType: string | null;
  responseType: string | null;
  threadId: string | null;
  turnId: string | null;
  itemId: string | null;
  itemType: string | null;
  payload: unknown;
};

type EnhanceDebugEventSnapshot = {
  at: number;
  eventType: string | null;
  responseType: string | null;
  threadId: string | null;
  turnId: string | null;
  itemId: string | null;
  itemType: string | null;
  payloadPreview: string;
};

function normalizeEventToken(value: string | null | undefined): string {
  return typeof value === "string" ? value.trim().toLowerCase() : "";
}

function hasReasoningSegment(value: string | null | undefined): boolean {
  const normalized = normalizeEventToken(value);
  if (!normalized) return false;
  return REASONING_SEGMENT_PATTERN.test(normalized);
}

function isReasoningItemType(value: string | null | undefined): boolean {
  const normalized = normalizeEventToken(value);
  if (!normalized) return false;
  return REASONING_ITEM_TYPES.has(normalized) || hasReasoningSegment(normalized);
}

function extractTextValue(value: unknown): string | null {
  if (typeof value === "string" && value) return value;
  if (!value || typeof value !== "object") return null;
  const obj = value as { text?: unknown; content?: unknown; output_text?: unknown; delta?: unknown };
  if (typeof obj.text === "string" && obj.text) return obj.text;
  if (typeof obj.content === "string" && obj.content) return obj.content;
  if (typeof obj.output_text === "string" && obj.output_text) return obj.output_text;
  if (typeof obj.delta === "string" && obj.delta) return obj.delta;
  return null;
}

function extractTextFromContent(value: unknown): string | null {
  if (typeof value === "string" && value) return value;
  if (!value) return null;
  if (Array.isArray(value)) {
    const parts = value
      .map((entry) => extractTextFromContent(entry))
      .filter((entry): entry is string => Boolean(entry));
    return parts.length > 0 ? parts.join("") : null;
  }
  if (typeof value === "object") {
    const obj = value as {
      content?: unknown;
      text?: unknown;
      summary?: unknown;
      reasoning_summary?: unknown;
      reasoningSummary?: unknown;
      parts?: unknown;
    };
    return (
      extractTextValue(obj) ||
      extractTextFromContent(obj.content) ||
      extractTextFromContent(obj.summary) ||
      extractTextFromContent(obj.reasoning_summary) ||
      extractTextFromContent(obj.reasoningSummary) ||
      extractTextFromContent(obj.parts)
    );
  }
  return null;
}

function isReasoningSummaryEvent(meta: EnhanceStreamEvent, payload: unknown): boolean {
  if (isReasoningItemType(meta.itemType)) return true;

  if (hasReasoningSegment(meta.eventType)) return true;

  if (hasReasoningSegment(meta.responseType)) return true;

  if (payload && typeof payload === "object") {
    const payloadItemType = (payload as { item?: { type?: unknown } }).item?.type;
    if (isReasoningItemType(typeof payloadItemType === "string" ? payloadItemType : null)) return true;
  }

  return false;
}

function extractReasoningSummaryChunk(
  meta: EnhanceStreamEvent,
  payload: unknown,
): { text: string; isDelta: boolean; itemId: string | null } | null {
  if (!isReasoningSummaryEvent(meta, payload)) return null;
  if (!payload || typeof payload !== "object") return null;

  const data = payload as {
    delta?: unknown;
    text?: unknown;
    output_text?: unknown;
    content?: unknown;
    summary?: unknown;
    reasoning_summary?: unknown;
    reasoningSummary?: unknown;
    payload?: unknown;
    item?: unknown;
  };
  const item = (data.item ?? {}) as {
    delta?: unknown;
    text?: unknown;
    output_text?: unknown;
    content?: unknown;
    summary?: unknown;
    reasoning_summary?: unknown;
    reasoningSummary?: unknown;
  };

  const deltaText =
    extractTextValue(data.delta) ||
    extractTextFromContent(data.delta) ||
    extractTextValue(item.delta) ||
    extractTextFromContent(item.delta) ||
    extractTextValue((data.payload as { delta?: unknown } | undefined)?.delta);
  if (deltaText) return { text: deltaText, isDelta: true, itemId: meta.itemId };

  const directText =
    extractTextValue(data.reasoning_summary) ||
    extractTextFromContent(data.reasoning_summary) ||
    extractTextValue(data.reasoningSummary) ||
    extractTextFromContent(data.reasoningSummary) ||
    extractTextValue(data.summary) ||
    extractTextFromContent(data.summary) ||
    extractTextValue(item.reasoning_summary) ||
    extractTextFromContent(item.reasoning_summary) ||
    extractTextValue(item.reasoningSummary) ||
    extractTextFromContent(item.reasoningSummary) ||
    extractTextValue(item.summary) ||
    extractTextFromContent(item.summary) ||
    extractTextValue(data.text) ||
    extractTextFromContent(data.text) ||
    extractTextValue(data.output_text) ||
    extractTextFromContent(data.output_text) ||
    extractTextValue(data.content) ||
    extractTextFromContent(data.content) ||
    extractTextValue(item.text) ||
    extractTextFromContent(item.text) ||
    extractTextValue(item.output_text) ||
    extractTextFromContent(item.output_text) ||
    extractTextValue(item.content) ||
    extractTextFromContent(item.content) ||
    extractTextValue((data.payload as { text?: unknown; output_text?: unknown } | undefined)?.text) ||
    extractTextFromContent((data.payload as { text?: unknown; output_text?: unknown } | undefined)?.text) ||
    extractTextValue((data.payload as { output_text?: unknown } | undefined)?.output_text) ||
    extractTextFromContent((data.payload as { output_text?: unknown } | undefined)?.output_text) ||
    extractTextFromContent(item.content);

  if (!directText) return null;

  const eventToken = `${meta.eventType ?? ""} ${meta.responseType ?? ""}`.toLowerCase();
  const isDelta = eventToken.includes("delta");
  return { text: directText, isDelta, itemId: meta.itemId };
}

function splitEnhancedPromptAndSources(input: string): { promptText: string; sources: string[] } {
  const separatorIdx = input.search(ENHANCED_PROMPT_SOURCES_SEPARATOR);
  if (separatorIdx === -1) {
    return {
      promptText: input,
      sources: [],
    };
  }

  const promptText = input.slice(0, separatorIdx).trimEnd();
  const sourcesBlock = input.slice(separatorIdx);
  const sources = sourcesBlock
    .split("\n")
    .map((line) => line.trim())
    .filter((line) => line.startsWith("- "))
    .map((line) => line.slice(2));

  return {
    promptText,
    sources,
  };
}

function extractEnhancedPromptFromMetadataEvent(payload: unknown): string | null {
  if (!payload || typeof payload !== "object") return null;
  const data = payload as {
    event?: unknown;
    type?: unknown;
    payload?: unknown;
  };
  const eventType = normalizeEventToken(typeof data.event === "string" ? data.event : null);
  const responseType = normalizeEventToken(typeof data.type === "string" ? data.type : null);
  if (eventType !== "enhance/metadata" && responseType !== "enhance.metadata") return null;

  const metadata = data.payload;
  if (!metadata || typeof metadata !== "object") return null;

  const enhancedPrompt = (metadata as { enhanced_prompt?: unknown }).enhanced_prompt;
  if (typeof enhancedPrompt !== "string") return null;
  const normalized = enhancedPrompt.trim();
  return normalized || null;
}

function previewEnhancePayload(payload: unknown): string {
  if (payload === null || payload === undefined) return "";
  try {
    const serialized = JSON.stringify(payload);
    if (!serialized) return "";
    if (serialized.length <= DEBUG_ENHANCE_PAYLOAD_PREVIEW_CHARS) return serialized;
    return `${serialized.slice(0, DEBUG_ENHANCE_PAYLOAD_PREVIEW_CHARS)}...`;
  } catch {
    return "[unserializable payload]";
  }
}

function toEnhanceDebugEventSnapshot(event: EnhanceStreamEvent): EnhanceDebugEventSnapshot {
  return {
    at: Date.now(),
    eventType: event.eventType,
    responseType: event.responseType,
    threadId: event.threadId,
    turnId: event.turnId,
    itemId: event.itemId,
    itemType: event.itemType,
    payloadPreview: previewEnhancePayload(event.payload),
  };
}

function isEnhanceDebugEnabled(): boolean {
  if (typeof window === "undefined") return false;
  try {
    return window.localStorage.getItem(DEBUG_ENHANCE_EVENTS_KEY) === "1";
  } catch {
    return false;
  }
}

function hasFieldOwnershipValue(
  ownership: BuilderFieldOwnershipMap,
  value: "ai" | "user" | "empty",
): boolean {
  return Object.values(ownership).some((entry) => entry === value);
}

function normalizeRemoteInferenceResult(
  response: Awaited<ReturnType<typeof inferBuilderFields>>,
): ReturnType<typeof inferBuilderFieldsLocally> {
  const inferredUpdatesRaw = response.inferredUpdates;
  const inferredFieldsRaw = response.inferredFields;
  const suggestionChipsRaw = response.suggestionChips;

  const inferredUpdates: {
    role?: string;
    tone?: string;
    lengthPreference?: string;
    format?: string[];
    constraints?: string[];
  } = {};
  if (typeof inferredUpdatesRaw?.role === "string") {
    inferredUpdates.role = inferredUpdatesRaw.role;
  }
  if (typeof inferredUpdatesRaw?.tone === "string") {
    inferredUpdates.tone = inferredUpdatesRaw.tone;
  }
  if (typeof inferredUpdatesRaw?.lengthPreference === "string") {
    inferredUpdates.lengthPreference = inferredUpdatesRaw.lengthPreference;
  }
  if (Array.isArray(inferredUpdatesRaw?.format)) {
    inferredUpdates.format = inferredUpdatesRaw.format.filter(
      (entry): entry is string => typeof entry === "string",
    );
  }
  if (Array.isArray(inferredUpdatesRaw?.constraints)) {
    inferredUpdates.constraints = inferredUpdatesRaw.constraints.filter(
      (entry): entry is string => typeof entry === "string",
    );
  }

  const inferredFields = Array.isArray(inferredFieldsRaw)
    ? inferredFieldsRaw.filter(
      (field): field is "role" | "tone" | "lengthPreference" | "format" | "constraints" =>
        field === "role" ||
        field === "tone" ||
        field === "lengthPreference" ||
        field === "format" ||
        field === "constraints",
    )
    : [];
  if (inferredFields.length === 0) {
    if (typeof inferredUpdates.role === "string") inferredFields.push("role");
    if (typeof inferredUpdates.tone === "string") inferredFields.push("tone");
    if (typeof inferredUpdates.lengthPreference === "string") inferredFields.push("lengthPreference");
    if (Array.isArray(inferredUpdates.format)) inferredFields.push("format");
    if (Array.isArray(inferredUpdates.constraints)) inferredFields.push("constraints");
  }

  const suggestionChips = Array.isArray(suggestionChipsRaw)
    ? suggestionChipsRaw
      .map((chip): BuilderSuggestionChip | null => {
        if (!chip || typeof chip !== "object") return null;
        const id = typeof chip.id === "string" ? chip.id : null;
        const label = typeof chip.label === "string" ? chip.label : null;
        const description = typeof chip.description === "string" ? chip.description : "";
        const action = chip.action;
        if (!id || !label || !action || typeof action !== "object") return null;

        const actionType = action.type;
        if (actionType === "append_prompt" && typeof action.text === "string") {
          return {
            id,
            label,
            description,
            action: {
              type: "append_prompt",
              text: action.text,
            },
          };
        }

        if (actionType === "set_fields" && action.updates && typeof action.updates === "object") {
          const updates = action.updates as Record<string, unknown>;
          const fields = Array.isArray(action.fields)
            ? action.fields.filter(
              (field): field is "role" | "tone" | "lengthPreference" | "format" | "constraints" =>
                field === "role" ||
                field === "tone" ||
                field === "lengthPreference" ||
                field === "format" ||
                field === "constraints",
            )
            : [];

          return {
            id,
            label,
            description,
            action: {
              type: "set_fields",
              updates: (() => {
                const normalizedUpdates: {
                  role?: string;
                  tone?: string;
                  lengthPreference?: string;
                  format?: string[];
                  constraints?: string[];
                  customRole?: string;
                  customFormat?: string;
                  customConstraint?: string;
                } = {};
                if (typeof updates.role === "string") {
                  normalizedUpdates.role = updates.role;
                  normalizedUpdates.customRole = "";
                }
                if (typeof updates.tone === "string") {
                  normalizedUpdates.tone = updates.tone;
                }
                if (typeof updates.lengthPreference === "string") {
                  normalizedUpdates.lengthPreference = updates.lengthPreference;
                }
                if (Array.isArray(updates.format)) {
                  normalizedUpdates.format = updates.format.filter(
                    (entry): entry is string => typeof entry === "string",
                  );
                  normalizedUpdates.customFormat = "";
                }
                if (Array.isArray(updates.constraints)) {
                  normalizedUpdates.constraints = updates.constraints.filter(
                    (entry): entry is string => typeof entry === "string",
                  );
                  normalizedUpdates.customConstraint = "";
                }
                return normalizedUpdates;
              })(),
              fields,
            },
          };
        }

        return null;
      })
      .filter((chip): chip is BuilderSuggestionChip => chip !== null)
    : [];

  return {
    inferredUpdates,
    inferredFields,
    suggestionChips,
    confidence: response.confidence,
  };
}

const buildInferenceCurrentFields = (config: typeof defaultConfig) => {
  const currentFields: {
    role?: string;
    tone?: string;
    lengthPreference?: string;
    format?: string[];
    constraints?: string[];
  } = {
    role: config.customRole.trim() || config.role.trim(),
    format: config.format,
    constraints: config.constraints,
  };

  if (config.tone && config.tone !== defaultConfig.tone) {
    currentFields.tone = config.tone;
  }
  if (config.lengthPreference && config.lengthPreference !== defaultConfig.lengthPreference) {
    currentFields.lengthPreference = config.lengthPreference;
  }

  return currentFields;
};

const Index = () => {
  const isBuilderRedesignPhase1 = builderRedesignFlags.builderRedesignPhase1;
  const isBuilderRedesignPhase2 =
    isBuilderRedesignPhase1 && builderRedesignFlags.builderRedesignPhase2;
  const isBuilderRedesignPhase3 =
    isBuilderRedesignPhase1 && builderRedesignFlags.builderRedesignPhase3;
  const [searchParams, setSearchParams] = useSearchParams();
  const remixId = searchParams.get("remix");
  const presetId = searchParams.get("preset");
  const remixLoadToken = useRef(0);
  const [drawerOpen, setDrawerOpen] = useState(false);
  const [openSections, setOpenSections] = useState<BuilderSection[]>(["builder"]);
  const [isAdjustDetailsOpen, setIsAdjustDetailsOpen] = useState(false);
  const [isSourcesAdvancedOpen, setIsSourcesAdvancedOpen] = useState(false);
  const [showAdvancedControls, setShowAdvancedControls] = useState(() => getUserPreferences().showAdvancedControls);
  const [enhancePhase, setEnhancePhase] = useState<EnhancePhase>("idle");
  const enhancePhaseTimers = useRef<number[]>([]);
  const hasTrackedBuilderLoaded = useRef(false);
  const hasTrackedFirstInput = useRef(false);
  const hasTrackedZone2Opened = useRef(false);
  const hasTrackedZone3Opened = useRef(false);
  const suggestionLoadToken = useRef(0);
  const enhanceStartedAt = useRef<number | null>(null);
  const enhancePending = useRef(false);
  const enhanceAbortController = useRef<AbortController | null>(null);
  const enhanceStreamToken = useRef(0);
  const [suggestionChips, setSuggestionChips] = useState<BuilderSuggestionChip[]>([]);
  const [isInferringSuggestions, setIsInferringSuggestions] = useState(false);
  const [hasInferenceError, setHasInferenceError] = useState(false);
  const [webSearchEnabled, setWebSearchEnabled] = useState(() => getUserPreferences().webSearchEnabled);
  const [webSearchSources, setWebSearchSources] = useState<string[]>([]);
  const [reasoningSummary, setReasoningSummary] = useState("");
  const [fieldOwnership, setFieldOwnership] = useState<BuilderFieldOwnershipMap>(() =>
    createFieldOwnershipFromConfig(defaultConfig),
  );
  const { toast } = useToast();
  const isMobile = useIsMobile();

  const persistedSetWebSearchEnabled = useCallback((value: boolean | ((prev: boolean) => boolean)) => {
    setWebSearchEnabled((prev) => {
      const next = typeof value === "function" ? value(prev) : value;
      setUserPreference("webSearchEnabled", next);
      return next;
    });
  }, []);

  const persistedSetShowAdvancedControls = useCallback((value: boolean | ((prev: boolean) => boolean)) => {
    setShowAdvancedControls((prev) => {
      const next = typeof value === "function" ? value(prev) : value;
      setUserPreference("showAdvancedControls", next);
      return next;
    });
  }, []);

  const {
    config,
    updateConfig,
    clearOriginalPrompt,
    builtPrompt,
    score,
    enhancedPrompt,
    setEnhancedPrompt,
    isEnhancing,
    setIsEnhancing,
    isSignedIn,
    saveVersion,
    savePrompt,
    saveAndSharePrompt,
    loadTemplate,
    remixContext,
    startRemix,
    clearRemix,
    updateContextSources,
    updateDatabaseConnections,
    updateRagParameters,
    updateContextStructured,
    updateContextInterview,
    updateProjectNotes,
    toggleDelimiters,
  } = usePromptBuilder();

  const launchAssignments = useMemo(() => getLaunchExperimentAssignments(), []);
  const heroCopyVariant = launchExperimentFlags.launchHeroCopyExperiment
    ? launchAssignments.heroCopy
    : "control";
  const primaryCtaVariant = launchExperimentFlags.launchPrimaryCtaExperiment
    ? launchAssignments.primaryCta
    : "control";
  const heroCopy = useMemo(() => getHeroCopyVariant(heroCopyVariant), [heroCopyVariant]);
  const primaryCtaLabel = useMemo(
    () => getPrimaryCtaVariantLabel(primaryCtaVariant),
    [primaryCtaVariant],
  );

  useEffect(() => {
    if (hasTrackedBuilderLoaded.current) return;
    hasTrackedBuilderLoaded.current = true;
    trackBuilderEvent("builder_loaded", {
      isMobile,
      isSignedIn,
      redesignPhase1: isBuilderRedesignPhase1,
      redesignPhase2: isBuilderRedesignPhase2,
      redesignPhase3: isBuilderRedesignPhase3,
      hasRemixParam: Boolean(remixId),
      hasPresetParam: Boolean(presetId),
      heroCopyExperimentEnabled: launchExperimentFlags.launchHeroCopyExperiment,
      primaryCtaExperimentEnabled: launchExperimentFlags.launchPrimaryCtaExperiment,
      heroCopyVariant,
      primaryCtaVariant,
    });
  }, [
    isMobile,
    isSignedIn,
    isBuilderRedesignPhase1,
    isBuilderRedesignPhase2,
    isBuilderRedesignPhase3,
    remixId,
    presetId,
    heroCopyVariant,
    primaryCtaVariant,
  ]);

  useEffect(() => {
    const restoredPrompt = consumeRestoredVersionPrompt();
    if (!restoredPrompt) return;
    setEnhancedPrompt(restoredPrompt);
    setReasoningSummary("");
    toast({ title: "Version restored", description: "Restored from History." });
    if (isMobile) {
      setDrawerOpen(true);
    }
  }, [isMobile, setEnhancedPrompt, toast]);

  useEffect(() => {
    if (!presetId) return;
    const preset = templates.find((t) => t.id === presetId);
    if (!preset) {
      toast({ title: "Preset not found", description: `No preset with id "${presetId}".` });
      setSearchParams((prev) => { prev.delete("preset"); return prev; }, { replace: true });
      return;
    }
    loadTemplate(preset);
    toast({ title: "Preset loaded", description: `"${preset.name}" applied to the builder.` });
    setSearchParams((prev) => { prev.delete("preset"); return prev; }, { replace: true });
  }, [presetId, loadTemplate, toast, setSearchParams]);

  useEffect(() => {
    if (!remixId) return;
    if (remixContext?.postId === remixId) return;
    const token = ++remixLoadToken.current;

    void (async () => {
      try {
        const post = await loadPost(remixId);
        if (token !== remixLoadToken.current) return;
        if (!post) {
          toast({ title: "Remix unavailable", description: "That community prompt could not be loaded." });
          return;
        }
        const [author] = await loadProfilesByIds([post.authorId]);
        if (token !== remixLoadToken.current) return;

        startRemix({
          postId: post.id,
          title: post.title,
          authorName: author?.displayName,
          publicConfig: post.publicConfig,
          parentTags: post.tags,
          parentCategory: post.category,
        });
        toast({
          title: "Remix ready",
          description: `Loaded “${post.title}” into Builder with context preserved.`,
        });
      } catch (error) {
        if (token !== remixLoadToken.current) return;
        toast({
          title: "Failed to load remix",
          description: error instanceof Error ? error.message : "Unexpected error",
          variant: "destructive",
        });
      }
    })();
  }, [remixId, remixContext?.postId, startRemix, toast]);

  const handleClearRemix = useCallback(() => {
    clearRemix();
    if (!remixId) return;
    const next = new URLSearchParams(searchParams);
    next.delete("remix");
    setSearchParams(next, { replace: true });
  }, [clearRemix, remixId, searchParams, setSearchParams]);

  const clearEnhanceTimers = useCallback(() => {
    enhancePhaseTimers.current.forEach((timer) => window.clearTimeout(timer));
    enhancePhaseTimers.current = [];
  }, []);

  useEffect(() => {
    return () => clearEnhanceTimers();
  }, [clearEnhanceTimers]);

  const handleAdjustDetailsUpdate = useCallback(
    (updates: Partial<typeof config>) => {
      if (isBuilderRedesignPhase3) {
        const fields = listInferenceFieldsFromUpdates(updates);
        if (fields.length > 0) {
          setFieldOwnership((previous) => markOwnershipFields(previous, fields, "user"));
          trackBuilderEvent("builder_field_manual_override", {
            fields: fields.join(","),
          });
        }
      }

      updateConfig(updates);
    },
    [isBuilderRedesignPhase3, updateConfig],
  );

  const handleApplySuggestionChip = useCallback(
    (chip: BuilderSuggestionChip) => {
      if (chip.action.type === "append_prompt") {
        updateConfig({
          originalPrompt: `${config.originalPrompt}${chip.action.text}`,
        });
        return;
      }

      const fields = chip.action.fields.length > 0
        ? chip.action.fields
        : listInferenceFieldsFromUpdates(chip.action.updates);
      updateConfig(chip.action.updates);
      setFieldOwnership((previous) => markOwnershipFields(previous, fields, "ai"));
      setIsAdjustDetailsOpen(true);
      trackBuilderEvent("builder_inference_applied", {
        source: "chip",
        fields: fields.join(","),
      });
    },
    [config.originalPrompt, updateConfig],
  );

  const handleResetInferredDetails = useCallback(() => {
    const { updates, clearedFields, nextOwnership } = clearAiOwnedFields(fieldOwnership);
    if (clearedFields.length === 0) return;
    updateConfig(updates);
    setFieldOwnership(nextOwnership);
    setSuggestionChips([]);
    setHasInferenceError(false);
    trackBuilderEvent("builder_inference_applied", {
      source: "reset",
      clearedFields: clearedFields.join(","),
    });
  }, [fieldOwnership, updateConfig]);

  const handleEnhance = useCallback(() => {
    if (isEnhancing || enhancePending.current) return;
    enhancePending.current = true;

    void (async () => {
      let configForEnhance = config;
      let promptForEnhance = buildPrompt(configForEnhance);
      if (!promptForEnhance) {
        enhancePending.current = false;
        return;
      }

      if (isBuilderRedesignPhase3) {
        clearEnhanceTimers();
        setEnhancePhase("starting");
        setIsEnhancing(true);
        enhancePending.current = false;
        const applyInferenceResult = (
          inference: ReturnType<typeof inferBuilderFieldsLocally>,
          source: "enhance_remote" | "enhance_local",
        ) => {
          if (inference.suggestionChips.length > 0) {
            setSuggestionChips(inference.suggestionChips);
          }

          const { updates, appliedFields } = applyInferenceUpdates(configForEnhance, fieldOwnership, inference);
          if (appliedFields.length === 0) return;

          updateConfig(updates);
          setFieldOwnership((previous) => markOwnershipFields(previous, appliedFields, "ai"));
          setIsAdjustDetailsOpen(true);
          configForEnhance = { ...configForEnhance, ...updates };
          promptForEnhance = buildPrompt(configForEnhance);
          trackBuilderEvent("builder_inference_applied", {
            source,
            fields: appliedFields.join(","),
          });
        };

        try {
          const remote = await inferBuilderFields({
            prompt: config.originalPrompt,
            currentFields: buildInferenceCurrentFields(configForEnhance),
            lockMetadata: fieldOwnership,
          });

          const normalized = normalizeRemoteInferenceResult(remote);
          if (normalized.inferredFields.length > 0 || normalized.suggestionChips.length > 0) {
            applyInferenceResult(normalized, "enhance_remote");
          } else {
            applyInferenceResult(inferBuilderFieldsLocally(config.originalPrompt, config), "enhance_local");
          }
          setHasInferenceError(false);
        } catch {
          setHasInferenceError(true);
          applyInferenceResult(inferBuilderFieldsLocally(config.originalPrompt, config), "enhance_local");
        }
      }

      if (!promptForEnhance) {
        if (isBuilderRedesignPhase3) {
          setIsEnhancing(false);
          setEnhancePhase("idle");
        }
        enhancePending.current = false;
        return;
      }

      enhanceStartedAt.current = Date.now();
      trackBuilderEvent("builder_enhance_clicked", {
        promptChars: promptForEnhance.length,
        redesignPhase1: isBuilderRedesignPhase1,
        hasExistingEnhancedPrompt: Boolean(enhancedPrompt.trim()),
      });
      clearEnhanceTimers();
      setEnhancePhase("starting");
      setIsEnhancing(true);
      enhancePending.current = false;
      setEnhancedPrompt("");
      setReasoningSummary("");
      setWebSearchSources([]);

      if (isMobile) setDrawerOpen(true);

      enhanceStreamToken.current += 1;
      enhanceAbortController.current?.abort();
      const streamToken = enhanceStreamToken.current;
      const streamAbortController = new AbortController();
      enhanceAbortController.current = streamAbortController;

      let accumulated = "";
      let hasReceivedDelta = false;
      const reasoningByItemId = new Map<string, string>();
      const reasoningItemOrder: string[] = [];
      const REASONING_FALLBACK_ITEM_ID = "__reasoning_summary__";
      const debugEnhanceEvents = isEnhanceDebugEnabled();
      const debugEventStore =
        debugEnhanceEvents && typeof window !== "undefined"
          ? ((window as typeof window & { __promptforgeEnhanceEvents?: EnhanceDebugEventSnapshot[] })
            .__promptforgeEnhanceEvents ??= [])
          : null;
      const outputFormats = [
        ...configForEnhance.format,
        configForEnhance.customFormat.trim(),
      ].filter((value) => value.length > 0);
      const outputFormatField = [
        outputFormats.join(", "),
        configForEnhance.lengthPreference ? `Length: ${configForEnhance.lengthPreference}` : "",
      ]
        .filter((value) => value.length > 0)
        .join(" | ");
      const guardrailItems = [
        ...configForEnhance.constraints,
        configForEnhance.customConstraint.trim(),
        configForEnhance.tone ? `Tone: ${configForEnhance.tone}` : "",
        configForEnhance.complexity ? `Complexity: ${configForEnhance.complexity}` : "",
      ].filter((value) => value.length > 0);
      const applyEnhancedOutput = (nextOutput: string, clearSourcesWhenMissing = false) => {
        const { promptText, sources } = splitEnhancedPromptAndSources(nextOutput);
        if (sources.length > 0) {
          setEnhancedPrompt(promptText);
          setWebSearchSources(sources);
          return;
        }

        setEnhancedPrompt(nextOutput);
        if (clearSourcesWhenMissing) {
          setWebSearchSources([]);
        }
      };
      streamEnhance({
        prompt: promptForEnhance,
        threadOptions: { ...ENHANCE_THREAD_OPTIONS_BASE, webSearchEnabled },
        builderFields: {
          role: (configForEnhance.customRole || configForEnhance.role || "").trim(),
          context: configForEnhance.context.trim(),
          task: (configForEnhance.originalPrompt || configForEnhance.task || "").trim(),
          outputFormat: outputFormatField,
          examples: configForEnhance.examples.trim(),
          guardrails: guardrailItems.join("; "),
        },
        signal: streamAbortController.signal,
        onDelta: (text) => {
          if (streamToken !== enhanceStreamToken.current) return;
          if (!hasReceivedDelta) {
            hasReceivedDelta = true;
            setEnhancePhase("streaming");
          }
          accumulated += text;
          applyEnhancedOutput(accumulated);
        },
        onEvent: (event) => {
          if (streamToken !== enhanceStreamToken.current) return;
          if (debugEventStore) {
            debugEventStore.push(toEnhanceDebugEventSnapshot(event));
            if (debugEventStore.length > DEBUG_ENHANCE_EVENTS_MAX) {
              debugEventStore.splice(0, debugEventStore.length - DEBUG_ENHANCE_EVENTS_MAX);
            }
          }

          const metadataPrompt = extractEnhancedPromptFromMetadataEvent(event.payload);
          if (metadataPrompt) {
            accumulated = metadataPrompt;
            applyEnhancedOutput(metadataPrompt, true);
            return;
          }

          const chunk = extractReasoningSummaryChunk(event, event.payload);
          if (!chunk?.text) return;

          const reasoningItemId = chunk.itemId || REASONING_FALLBACK_ITEM_ID;
          if (!reasoningByItemId.has(reasoningItemId)) {
            reasoningItemOrder.push(reasoningItemId);
          }

          const previous = reasoningByItemId.get(reasoningItemId) || "";
          const next = chunk.isDelta ? `${previous}${chunk.text}` : chunk.text;

          reasoningByItemId.set(reasoningItemId, next);
          const merged = reasoningItemOrder
            .map((itemId) => reasoningByItemId.get(itemId) || "")
            .filter((text) => text.length > 0)
            .join("\n\n")
            .trim();
          setReasoningSummary(merged);
        },
        onDone: () => {
          if (streamToken !== enhanceStreamToken.current) return;
          if (enhanceAbortController.current === streamAbortController) {
            enhanceAbortController.current = null;
          }
          const startedAt = enhanceStartedAt.current;
          const durationMs = startedAt ? Math.max(Date.now() - startedAt, 0) : -1;
          enhanceStartedAt.current = null;
          trackBuilderEvent("builder_enhance_completed", {
            success: true,
            durationMs,
            outputChars: accumulated.length,
          });
          setIsEnhancing(false);
          setEnhancePhase("settling");
          const doneTimer = window.setTimeout(() => {
            setEnhancePhase("done");
          }, 260);
          const idleTimer = window.setTimeout(() => {
            setEnhancePhase("idle");
          }, 1800);
          enhancePhaseTimers.current.push(doneTimer, idleTimer);
          toast({
            title: "Quality pass complete",
            description: "Prompt updated with clearer structure, context, and constraints.",
          });
        },
        onError: (error: AIClientError) => {
          if (streamToken !== enhanceStreamToken.current) return;
          if (enhanceAbortController.current === streamAbortController) {
            enhanceAbortController.current = null;
          }
          if (error.code === "request_aborted") return;

          const errorMessage = error.message;
          const startedAt = enhanceStartedAt.current;
          const durationMs = startedAt ? Math.max(Date.now() - startedAt, 0) : -1;
          enhanceStartedAt.current = null;
          trackBuilderEvent("builder_enhance_completed", {
            success: false,
            durationMs,
            error: errorMessage,
            errorCode: error.code,
          });
          clearEnhanceTimers();
          setIsEnhancing(false);
          setEnhancePhase("idle");
          toast({ title: "Enhancement failed", description: errorMessage, variant: "destructive" });
        },
      });
    })();
  }, [
    clearEnhanceTimers,
    config,
    enhancedPrompt,
    fieldOwnership,
    isBuilderRedesignPhase1,
    isBuilderRedesignPhase3,
    isEnhancing,
    isMobile,
    setEnhancedPrompt,
    setIsEnhancing,
    setReasoningSummary,
    toast,
    updateConfig,
    webSearchEnabled,
  ]);

  useEffect(() => {
    if (isEnhancing) return;
    clearEnhanceTimers();
    setEnhancePhase("idle");
  }, [builtPrompt, clearEnhanceTimers, isEnhancing]);

  useEffect(() => {
    if (isEnhancing) return;
    if (enhancedPrompt.trim()) return;
    setReasoningSummary((prev) => (prev ? "" : prev));
  }, [enhancedPrompt, isEnhancing]);

  useEffect(() => {
    return () => {
      clearEnhanceTimers();
      enhanceStreamToken.current += 1;
      enhanceAbortController.current?.abort();
      enhanceAbortController.current = null;
    };
  }, [clearEnhanceTimers]);

  const handleSavePrompt = useCallback(
    async (input: { name: string; description?: string; tags?: string[]; category?: string; remixNote?: string }) => {
      try {
        const result = await savePrompt({
          title: input.name,
          description: input.description,
          tags: input.tags,
          category: input.category,
          remixNote: input.remixNote,
        });
        const warningText =
          result.warnings.length > 0
            ? ` ${result.warnings.length} validation warning(s) were recorded.`
            : "";
        const verb =
          result.outcome === "created"
            ? "saved"
            : result.outcome === "updated"
              ? "updated"
              : "unchanged";
        toast({
          title: `Prompt ${verb}: ${result.record.metadata.name}`,
          description: `Revision r${result.record.metadata.revision}.${warningText}`,
        });
        if (remixContext) {
          handleClearRemix();
        }
      } catch (error) {
        toast({
          title: "Failed to save prompt",
          description: error instanceof Error ? error.message : "Unexpected error",
          variant: "destructive",
        });
      }
    },
    [savePrompt, toast, remixContext, handleClearRemix]
  );

  const handleSaveAndSharePrompt = useCallback(
    async (input: {
      name: string;
      description?: string;
      tags?: string[];
      category?: string;
      useCase: string;
      targetModel?: string;
      remixNote?: string;
    }) => {
      if (!isSignedIn) {
        toast({ title: "Sign in required", description: "Sign in to share prompts.", variant: "destructive" });
        return;
      }

      try {
        const result = await saveAndSharePrompt({
          title: input.name,
          description: input.description,
          tags: input.tags,
          category: input.category,
          useCase: input.useCase,
          targetModel: input.targetModel,
          remixNote: input.remixNote,
        });
        toast({
          title: `Prompt shared: ${result.record.metadata.name}`,
          description: `Revision r${result.record.metadata.revision}.`,
          action: result.postId ? (
            <ToastAction altText="View post" asChild>
              <Link to={`/community/${result.postId}`}>View</Link>
            </ToastAction>
          ) : undefined,
        });
        if (remixContext) {
          handleClearRemix();
        }
      } catch (error) {
        toast({
          title: "Failed to save & share prompt",
          description: error instanceof Error ? error.message : "Unexpected error",
          variant: "destructive",
        });
      }
    },
    [isSignedIn, saveAndSharePrompt, toast, remixContext, handleClearRemix]
  );

  // Keyboard shortcut: Ctrl+Enter to enhance
  useEffect(() => {
    const handler = (e: KeyboardEvent) => {
      if ((e.ctrlKey || e.metaKey) && e.key === "Enter") {
        e.preventDefault();
        handleEnhance();
      }
    };
    window.addEventListener("keydown", handler);
    return () => window.removeEventListener("keydown", handler);
  }, [handleEnhance]);

  // Status indicators for accordion triggers
  const sourceCount = config.contextConfig.sources.length;
  const sectionHealth = getSectionHealth(config, score.total);
  const selectedRole = config.customRole || config.role;
  const displayPrompt = enhancedPrompt || builtPrompt;
  const hasEnhancedOnce = enhancedPrompt.trim().length > 0;
  const allSectionsComplete =
    sectionHealth.builder === "complete" &&
    sectionHealth.context === "complete" &&
    sectionHealth.tone === "complete";
  const showEnhanceFirstCard = !hasEnhancedOnce && (isBuilderRedesignPhase1 || !allSectionsComplete);
  const hasDetailSelections = Boolean(
    selectedRole ||
    config.format.length ||
    config.customFormat.trim() ||
    config.constraints.length ||
    config.customConstraint.trim() ||
    config.examples.trim(),
  );
  const hasSourceOrAdvancedSelections = Boolean(
    config.contextConfig.sources.length ||
    config.contextConfig.projectNotes.trim() ||
    config.contextConfig.databaseConnections.length ||
    config.contextConfig.rag.enabled,
  );
  const shouldShowAdvancedControls =
    showAdvancedControls || hasEnhancedOnce || hasDetailSelections || hasSourceOrAdvancedSelections;
  const canSavePrompt = hasPromptInput(config);
  const canSharePrompt = canSavePrompt && isSignedIn;
  const mobileEnhanceLabel = isEnhancing
    ? enhancePhase === "starting"
      ? "Starting…"
      : enhancePhase === "settling"
        ? "Finalizing…"
        : "Enhancing…"
    : enhancePhase === "done"
      ? "Enhanced"
      : primaryCtaLabel;
  const enhanceLiveMessage =
    enhancePhase === "starting"
      ? "Enhancement started."
      : enhancePhase === "streaming"
        ? "Enhancement in progress."
        : enhancePhase === "settling"
          ? "Enhancement finalizing."
          : enhancePhase === "done"
            ? "Enhancement complete."
            : "";
  const mobilePreviewText = useMemo(() => {
    const trimmed = displayPrompt.trim();
    if (!trimmed) {
      return "Your prompt preview updates as you build. Tap to expand.";
    }
    return trimmed
      .split(/\r?\n/)
      .map((line) => line.trim())
      .filter(Boolean)
      .slice(0, 2)
      .join("\n");
  }, [displayPrompt]);
  const refineSuggestions = useMemo(() => {
    const suggestions: Array<{ id: BuilderSection; title: string; description: string }> = [];
    if (sectionHealth.builder !== "complete") {
      suggestions.push({
        id: "builder",
        title: selectedRole ? "Add task details" : "Add a role",
        description: "Clarify who the model should be and what outcome you need.",
      });
    }
    if (sectionHealth.context !== "complete") {
      suggestions.push({
        id: "context",
        title: "Add context",
        description: "Include sources, notes, or constraints from your environment.",
      });
    }
    if (sectionHealth.tone !== "complete") {
      suggestions.push({
        id: "tone",
        title: "Tune tone",
        description: "Set style and complexity to better match the target audience.",
      });
    }
    return suggestions.slice(0, 3);
  }, [sectionHealth.builder, sectionHealth.context, sectionHealth.tone, selectedRole]);
  const showRefineSuggestions = Boolean(enhancedPrompt.trim()) && refineSuggestions.length > 0;
  const hasAiOwnedFields = hasFieldOwnershipValue(fieldOwnership, "ai");

  useEffect(() => {
    if (hasTrackedFirstInput.current) return;
    const trimmedPrompt = config.originalPrompt.trim();
    if (!trimmedPrompt) return;

    hasTrackedFirstInput.current = true;
    trackBuilderEvent("builder_first_input", {
      promptChars: trimmedPrompt.length,
      redesignPhase1: isBuilderRedesignPhase1,
    });
  }, [config.originalPrompt, isBuilderRedesignPhase1]);

  useEffect(() => {
    if (isBuilderRedesignPhase3) return;
    setSuggestionChips([]);
    setIsInferringSuggestions(false);
    setHasInferenceError(false);
    setFieldOwnership(createFieldOwnershipFromConfig(config));
  }, [isBuilderRedesignPhase3, config]);

  useEffect(() => {
    if (!isBuilderRedesignPhase3) return;
    setFieldOwnership((previous) => {
      const baseline = createFieldOwnershipFromConfig(config);
      let changed = false;
      const next: BuilderFieldOwnershipMap = { ...previous };
      (Object.keys(next) as Array<keyof BuilderFieldOwnershipMap>).forEach((field) => {
        if (baseline[field] === "user" && previous[field] === "empty") {
          next[field] = "user";
          changed = true;
        }
        if (baseline[field] === "empty" && previous[field] === "user") {
          next[field] = "empty";
          changed = true;
        }
      });
      return changed ? next : previous;
    });
  }, [isBuilderRedesignPhase3, config]);

  useEffect(() => {
    if (!isBuilderRedesignPhase1) return;

    if (hasEnhancedOnce || hasDetailSelections || hasSourceOrAdvancedSelections) {
      persistedSetShowAdvancedControls(true);
    }
    if (hasDetailSelections || hasEnhancedOnce) {
      setIsAdjustDetailsOpen(true);
    }
    if (hasSourceOrAdvancedSelections || hasEnhancedOnce) {
      setIsSourcesAdvancedOpen(true);
    }
  }, [
    isBuilderRedesignPhase1,
    hasEnhancedOnce,
    hasDetailSelections,
    hasSourceOrAdvancedSelections,
    persistedSetShowAdvancedControls,
  ]);

  useEffect(() => {
    if (!isBuilderRedesignPhase1) return;
    if (!isAdjustDetailsOpen || hasTrackedZone2Opened.current) return;

    hasTrackedZone2Opened.current = true;
    trackBuilderEvent("builder_zone2_opened", {
      selectedRole: Boolean(selectedRole),
      formatCount: config.format.length,
      constraintCount: config.constraints.length,
      hasExamples: Boolean(config.examples.trim()),
    });
  }, [
    isBuilderRedesignPhase1,
    isAdjustDetailsOpen,
    selectedRole,
    config.format.length,
    config.constraints.length,
    config.examples,
  ]);

  useEffect(() => {
    if (!isBuilderRedesignPhase1) return;
    if (!isSourcesAdvancedOpen || hasTrackedZone3Opened.current) return;

    hasTrackedZone3Opened.current = true;
    trackBuilderEvent("builder_zone3_opened", {
      sourceCount: config.contextConfig.sources.length,
      hasProjectNotes: Boolean(config.contextConfig.projectNotes.trim()),
      databaseCount: config.contextConfig.databaseConnections.length,
      ragEnabled: config.contextConfig.rag.enabled,
    });
  }, [
    isBuilderRedesignPhase1,
    isSourcesAdvancedOpen,
    config.contextConfig.sources.length,
    config.contextConfig.projectNotes,
    config.contextConfig.databaseConnections.length,
    config.contextConfig.rag.enabled,
  ]);

  useEffect(() => {
    if (!isBuilderRedesignPhase3) {
      suggestionLoadToken.current += 1;
      return;
    }
    const prompt = config.originalPrompt.trim();
    if (prompt.length < 24) {
      suggestionLoadToken.current += 1;
      setSuggestionChips([]);
      setHasInferenceError(false);
      setIsInferringSuggestions(false);
      return;
    }

    const token = ++suggestionLoadToken.current;
    const timer = window.setTimeout(() => {
      void (async () => {
        setIsInferringSuggestions(true);
        try {
          const remote = await inferBuilderFields({
            prompt,
            currentFields: buildInferenceCurrentFields(config),
            lockMetadata: fieldOwnership,
          });

          if (token !== suggestionLoadToken.current) return;

          const normalized = normalizeRemoteInferenceResult(remote);
          if (normalized.suggestionChips.length > 0) {
            setSuggestionChips(normalized.suggestionChips);
          } else {
            setSuggestionChips(inferBuilderFieldsLocally(prompt, config).suggestionChips);
          }
          setHasInferenceError(false);
        } catch {
          if (token !== suggestionLoadToken.current) return;
          setSuggestionChips(inferBuilderFieldsLocally(prompt, config).suggestionChips);
          setHasInferenceError(true);
        } finally {
          if (token === suggestionLoadToken.current) {
            setIsInferringSuggestions(false);
          }
        }
      })();
    }, 450);

    return () => {
      window.clearTimeout(timer);
      suggestionLoadToken.current += 1;
    };
  }, [
    isBuilderRedesignPhase3,
    config,
    fieldOwnership,
  ]);

  const openAndFocusSection = useCallback((section: BuilderSection) => {
    if (isBuilderRedesignPhase1) {
      const targetId = section === "context" ? "builder-zone-3" : "builder-zone-2";
      persistedSetShowAdvancedControls(true);
      if (section === "context") {
        setIsSourcesAdvancedOpen(true);
      } else {
        setIsAdjustDetailsOpen(true);
      }
      window.requestAnimationFrame(() => {
        window.requestAnimationFrame(() => {
          document.getElementById(targetId)?.scrollIntoView({
            behavior: "smooth",
            block: "center",
          });
        });
      });
      return;
    }
    setOpenSections((prev) => (prev.includes(section) ? prev : [...prev, section]));
    window.requestAnimationFrame(() => {
      document.getElementById(`accordion-${section}`)?.scrollIntoView({
        behavior: "smooth",
        block: "center",
      });
    });
  }, [isBuilderRedesignPhase1, persistedSetShowAdvancedControls]);

  return (
    <PageShell mainClassName="py-3 sm:py-6">
      {isMobile && (
        <p className="sr-only" role="status" aria-live="polite" aria-atomic="true">
          {enhanceLiveMessage}
        </p>
      )}
      {/* Hero — compact on mobile */}
      <div
        className="pf-gilded-frame pf-hero-surface mb-4 px-4 py-5 text-center sm:mb-8 sm:px-6 sm:py-7"
        data-testid="builder-hero"
      >
        <h1 className="pf-text-display mb-1 text-2xl font-bold tracking-tight text-[rgba(230,225,213,.95)] sm:mb-2 sm:text-3xl md:text-4xl">
          {heroCopy.headline}
        </h1>
        <p className="mx-auto max-w-2xl text-sm text-[rgba(230,225,213,.82)] sm:text-base">
          {heroCopy.subhead}
        </p>
        <div className="mt-2 flex flex-wrap items-center justify-center gap-1.5">
          {brandCopy.pillars.map((pillar) => (
            <Badge
              key={pillar.title}
              type="modern"
              className="border border-[rgba(214,166,64,.35)] bg-black/35 text-xs text-[rgba(230,225,213,.9)]"
            >
              {pillar.title}
            </Badge>
          ))}
        </div>
        <div className="mx-auto mt-3 w-44 pf-divider" />
      </div>

      {remixContext && (
        <Card className="mb-4 border-primary/30 bg-primary/5 p-3 sm:p-4">
          <div className="flex flex-wrap items-center justify-between gap-2">
            <div className="space-y-1">
              <p className="type-label-caps text-xs text-primary">Remix mode</p>
              <p className="text-sm font-medium text-foreground">
                Remixing {remixContext.parentAuthor}’s “{remixContext.parentTitle}”
              </p>
              <p className="text-xs text-muted-foreground">
                Your changes will be attributed when you save or share.
              </p>
            </div>
            <Button
              color="tertiary"
              size="sm"
              onClick={handleClearRemix}
              className="utility-action-button gap-1.5 text-sm sm:text-sm"
            >
              <X className="h-3 w-3" />
              Clear remix
            </Button>
          </div>
        </Card>
      )}

      {/* Split layout */}
      <div className="grid grid-cols-1 lg:grid-cols-2 gap-4 sm:gap-6">
        {/* Left: Input & Builder */}
        <div className="space-y-3 sm:space-y-4">
          {isBuilderRedesignPhase1 ? (
            <>
              <BuilderHeroInput
                value={config.originalPrompt}
                onChange={(value) => updateConfig({ originalPrompt: value })}
                onClear={clearOriginalPrompt}
                phase3Enabled={isBuilderRedesignPhase3}
                suggestionChips={suggestionChips}
                isInferringSuggestions={isInferringSuggestions}
                hasInferenceError={hasInferenceError}
                onApplySuggestion={handleApplySuggestionChip}
                onResetInferred={handleResetInferredDetails}
                canResetInferred={hasAiOwnedFields}
              />

              {showEnhanceFirstCard && (
                <Card className="border-border/70 bg-card/80 p-3">
                  <div className="space-y-2">
                    <p className="text-sm font-medium text-foreground">Start in 3 steps</p>
                    <ol className="grid gap-1 text-xs text-muted-foreground sm:grid-cols-3">
                      <li>1. Add your rough prompt</li>
                      <li>2. Tap {primaryCtaLabel}</li>
                      <li>3. Refine details</li>
                    </ol>
                    <p className="text-xs text-muted-foreground">
                      Keep the first pass simple, then strengthen quality, context, and remix readiness.
                    </p>
                  </div>
                </Card>
              )}

              {showRefineSuggestions && (
                <Card className="border-primary/25 bg-primary/5 p-3">
                  <p className="text-xs font-medium text-primary">Improve this result</p>
                  <div className="mt-2 flex flex-wrap gap-2">
                    {refineSuggestions.map((suggestion) => (
                      <Button
                        key={suggestion.id}
                        type="button"
                        size="sm"
                        color="secondary"
                        className="h-11 text-sm sm:h-9 sm:text-sm"
                        onClick={() => openAndFocusSection(suggestion.id)}
                      >
                        {suggestion.title}
                      </Button>
                    ))}
                  </div>
                  <p className="mt-2 text-xs text-muted-foreground">
                    {refineSuggestions[0]?.description}
                  </p>
                </Card>
              )}

              {!shouldShowAdvancedControls && (
                <Card className="border-border/70 bg-card/80 p-3">
                  <div className="flex flex-col gap-2 sm:flex-row sm:items-center sm:justify-between">
                    <div>
                      <p className="text-sm font-medium text-foreground">Need more control?</p>
                      <p className="text-xs text-muted-foreground">
                        Reveal advanced settings when you are ready to refine.
                      </p>
                    </div>
                    <Button
                      type="button"
                      size="sm"
                      color="secondary"
                      className="h-11 text-sm sm:h-9 sm:text-sm"
                      onClick={() => persistedSetShowAdvancedControls(true)}
                    >
                      Show advanced controls
                    </Button>
                  </div>
                </Card>
              )}

              {shouldShowAdvancedControls && (
                <>
                  <BuilderAdjustDetails
                    config={config}
                    isOpen={isAdjustDetailsOpen}
                    onOpenChange={setIsAdjustDetailsOpen}
                    onUpdate={handleAdjustDetailsUpdate}
                  />

                  <BuilderSourcesAdvanced
                    contextConfig={config.contextConfig}
                    isOpen={isSourcesAdvancedOpen}
                    onOpenChange={setIsSourcesAdvancedOpen}
                    onUpdateSources={updateContextSources}
                    onUpdateDatabaseConnections={updateDatabaseConnections}
                    onUpdateRag={updateRagParameters}
                    onUpdateProjectNotes={updateProjectNotes}
                    onToggleDelimiters={toggleDelimiters}
                  />
                </>
              )}
            </>
          ) : (
            <>
              <PromptInput
                value={config.originalPrompt}
                onChange={(v) => updateConfig({ originalPrompt: v })}
                onClear={clearOriginalPrompt}
              />

              {showEnhanceFirstCard && (
                <Card className="border-border/70 bg-card/80 p-3">
                  <div className="space-y-2">
                    <p className="text-sm font-medium text-foreground">Start in 3 steps</p>
                    <ol className="grid gap-1 text-xs text-muted-foreground sm:grid-cols-3">
                      <li>1. Add your rough prompt</li>
                      <li>2. Tap {primaryCtaLabel}</li>
                      <li>3. Refine details</li>
                    </ol>
                    <p className="text-xs text-muted-foreground">
                      Keep the first pass simple, then strengthen quality, context, and remix readiness.
                    </p>
                  </div>
                </Card>
              )}

              {showRefineSuggestions && (
                <Card className="border-primary/25 bg-primary/5 p-3">
                  <p className="text-xs font-medium text-primary">Improve this result</p>
                  <div className="mt-2 flex flex-wrap gap-2">
                    {refineSuggestions.map((suggestion) => (
                      <Button
                        key={suggestion.id}
                        type="button"
                        size="sm"
                        color="secondary"
                        className="h-11 text-sm sm:h-9 sm:text-sm"
                        onClick={() => openAndFocusSection(suggestion.id)}
                      >
                        {suggestion.title}
                      </Button>
                    ))}
                  </div>
                  <p className="mt-2 text-xs text-muted-foreground">
                    {refineSuggestions[0]?.description}
                  </p>
                </Card>
              )}

              <Accordion
                type="multiple"
                value={openSections}
                onValueChange={(value) => setOpenSections(value as BuilderSection[])}
                className="space-y-1"
              >
                <AccordionItem id="accordion-builder" value="builder" className="border rounded-lg px-3">
                  <AccordionTrigger className="py-3 text-sm hover:no-underline gap-2">
                    <span className="flex items-center gap-2">
                      <Target className="w-3.5 h-3.5 text-muted-foreground" />
                      Builder
                    </span>
                    <span className="ml-auto mr-2 flex items-center gap-1.5">
                      {selectedRole && (
                        <Badge type="modern" className="max-w-45 text-xs">
                          <span className="type-wrap-safe">{selectedRole}</span>
                        </Badge>
                      )}
                      <SectionHealthBadge state={sectionHealth.builder} />
                    </span>
                  </AccordionTrigger>
                  <AccordionContent>
                    <BuilderTabs config={config} onUpdate={updateConfig} />
                  </AccordionContent>
                </AccordionItem>

                <AccordionItem id="accordion-context" value="context" className="border rounded-lg px-3">
                  <AccordionTrigger className="py-3 text-sm hover:no-underline gap-2">
                    <span className="flex items-center gap-2">
                      <LayoutIcon className="w-3.5 h-3.5 text-muted-foreground" />
                      Context & Sources
                    </span>
                    <span className="ml-auto mr-2 flex items-center gap-1.5">
                      {sourceCount > 0 && (
                        <Badge type="modern" className="text-xs">
                          {sourceCount} src
                        </Badge>
                      )}
                      <SectionHealthBadge state={sectionHealth.context} />
                    </span>
                  </AccordionTrigger>
                  <AccordionContent>
                    <ContextPanel
                      contextConfig={config.contextConfig}
                      onUpdateSources={updateContextSources}
                      onUpdateDatabaseConnections={updateDatabaseConnections}
                      onUpdateRag={updateRagParameters}
                      onUpdateStructured={updateContextStructured}
                      onUpdateInterview={updateContextInterview}
                      onUpdateProjectNotes={updateProjectNotes}
                      onToggleDelimiters={toggleDelimiters}
                    />
                  </AccordionContent>
                </AccordionItem>

                <AccordionItem id="accordion-tone" value="tone" className="border rounded-lg px-3">
                  <AccordionTrigger className="py-3 text-sm hover:no-underline gap-2">
                    <span className="flex items-center gap-2">
                      <MessageSquare className="w-3.5 h-3.5 text-muted-foreground" />
                      Tone & Style
                    </span>
                    <span className="ml-auto mr-2 flex items-center gap-1.5">
                      {config.tone && (
                        <Badge type="modern" className="text-xs">
                          {config.tone}
                        </Badge>
                      )}
                      <SectionHealthBadge state={sectionHealth.tone} />
                    </span>
                  </AccordionTrigger>
                  <AccordionContent>
                    <ToneControls
                      tone={config.tone}
                      complexity={config.complexity}
                      onUpdate={updateConfig}
                    />
                  </AccordionContent>
                </AccordionItem>

                <AccordionItem id="accordion-quality" value="quality" className="border rounded-lg px-3">
                  <AccordionTrigger className="py-3 text-sm hover:no-underline gap-2">
                    <span className="flex items-center gap-2">
                      <BarChart3 className="w-3.5 h-3.5 text-muted-foreground" />
                      Quality Score
                    </span>
                    <span className="ml-auto mr-2 flex items-center gap-1.5">
                      <Badge
                        type="pill-color"
                        color={score.total >= 75 ? "brand" : "gray"}
                        className="text-xs"
                      >
                        {score.total}/100
                      </Badge>
                      <SectionHealthBadge state={sectionHealth.quality} />
                    </span>
                  </AccordionTrigger>
                  <AccordionContent>
                    <QualityScore score={score} />
                  </AccordionContent>
                </AccordionItem>
              </Accordion>
            </>
          )}
        </div>

        {/* Right: Output — inline on desktop, drawer on mobile */}
        {!isMobile && (
          <div className="lg:sticky lg:top-20 lg:self-start">
            {isBuilderRedesignPhase1 && (
              <Card className="pf-panel mb-3 border-[rgba(214,166,64,.32)] bg-card/80 p-3">
                <div className="flex items-start justify-between gap-3">
                  <div>
                    <p className="text-xs font-medium text-[rgba(230,225,213,.92)]">Quality signal</p>
                    <p className="mt-0.5 text-xs text-[rgba(230,225,213,.72)]">
                      {score.tips[0]}
                    </p>
                  </div>
                  <div className="flex flex-col items-end gap-1">
                    <Badge type="pill-color" color={score.total >= 75 ? "brand" : "gray"} className="text-xs">
                      {score.total}/100
                    </Badge>
                    <span className="text-[11px] text-[rgba(230,225,213,.72)]">
                      {score.total >= 90 ? "Legendary" : score.total >= 70 ? "Epic" : score.total >= 40 ? "Rare" : "Common"}
                    </span>
                  </div>
                </div>
                <div className="mt-3 rounded-2xl border border-white/10 bg-black/20 p-2">
                  <PFQualityGauge value={score.total} size={92} showLabel={false} />
                </div>
              </Card>
            )}
            <OutputPanel
              builtPrompt={builtPrompt}
              enhancedPrompt={enhancedPrompt}
              reasoningSummary={reasoningSummary}
              isEnhancing={isEnhancing}
              enhancePhase={enhancePhase}
              onEnhance={handleEnhance}
              onSaveVersion={saveVersion}
              onSavePrompt={handleSavePrompt}
              onSaveAndSharePrompt={handleSaveAndSharePrompt}
              canSavePrompt={canSavePrompt}
              canSharePrompt={canSharePrompt}
              phase2Enabled={isBuilderRedesignPhase2}
              webSearchEnabled={webSearchEnabled}
              onWebSearchToggle={persistedSetWebSearchEnabled}
              webSearchSources={webSearchSources}
              enhanceIdleLabel={primaryCtaLabel}
              remixContext={
                remixContext
                  ? { title: remixContext.parentTitle, authorName: remixContext.parentAuthor }
                  : undefined
              }
            />
            <p className="text-xs text-muted-foreground text-center mt-3">
              Press <kbd className="px-1.5 py-0.5 text-xs bg-muted rounded border border-border font-mono">Ctrl+Enter</kbd> to enhance
            </p>
          </div>
        )}
      </div>

      {/* Mobile: sticky bottom bar */}
      {isMobile && (
        <div
          className="fixed inset-x-0 bottom-[calc(4.375rem+env(safe-area-inset-bottom)+1px)] sm:bottom-0 z-30 border-t border-border bg-card/95 px-3 pt-2 pb-[max(0.75rem,env(safe-area-inset-bottom))] backdrop-blur-sm"
          data-testid="builder-mobile-sticky-bar"
        >
          <button
            type="button"
            onClick={() => setDrawerOpen(true)}
            className="interactive-chip mb-2 w-full rounded-lg border border-border/80 bg-background/70 px-3 py-2 text-left"
            aria-label="Open output preview"
            data-testid="builder-mobile-preview-trigger"
          >
            <div className="type-label-caps flex items-center gap-1.5 text-xs font-medium text-muted-foreground">
              <Eye className="h-3.5 w-3.5" />
              Live preview
            </div>
            <p className="mt-1 max-h-10 overflow-hidden whitespace-pre-line font-mono text-xs leading-5 text-foreground/90">
              {mobilePreviewText}
            </p>
          </button>

          <div className="flex items-center gap-2 max-[360px]:grid max-[360px]:grid-cols-2">
            <label
              className="flex min-h-11 min-w-23 items-center justify-center gap-2 rounded-md border border-border/70 bg-background/70 px-2 text-sm text-muted-foreground cursor-pointer select-none max-[360px]:min-w-0"
              data-testid="builder-mobile-web-toggle"
            >
              <Switch
                checked={webSearchEnabled}
                onCheckedChange={persistedSetWebSearchEnabled}
                disabled={isEnhancing}
                aria-label="Enable web search during enhancement"
              />
              <Globe className="h-3.5 w-3.5" />
              <span>Web</span>
            </label>
            <Badge
              type="pill-color"
              color={score.total >= 75 ? "brand" : "gray"}
              className="h-11 min-w-16 justify-center rounded-md px-2 text-sm font-semibold max-[360px]:min-w-0 max-[360px]:justify-self-end sm:h-10 sm:text-base"
            >
              {score.total}/100
            </Badge>
            <Button
              color="primary"
              size="md"
              onClick={handleEnhance}
              disabled={isEnhancing || !builtPrompt}
              className="signature-enhance-button h-11 min-w-0 flex-1 gap-2 max-[360px]:col-span-2 max-[360px]:w-full max-[360px]:gap-1 max-[360px]:px-2 max-[360px]:text-xs sm:h-10"
              data-phase={enhancePhase}
              data-testid="builder-mobile-enhance-button"
            >
              {isEnhancing ? (
                <>
                  <Loader2 className="w-4 h-4 animate-spin" />
                  {mobileEnhanceLabel}
                </>
              ) : (
                <>
                  {enhancePhase === "done" ? <Check className="w-4 h-4" /> : <Sparkles className="w-4 h-4" />}
                  {mobileEnhanceLabel}
                </>
              )}
            </Button>
          </div>
        </div>
      )}

      {/* Mobile: output drawer */}
      {isMobile && (
        <Drawer open={drawerOpen} onOpenChange={setDrawerOpen}>
          <DrawerContent className="max-h-[85vh]">
            <DrawerHeader>
              <DrawerTitle>
                {enhancedPrompt ? "✨ Enhanced Prompt" : "📝 Preview"}
              </DrawerTitle>
              <DrawerDescription className="sr-only">
                Review, copy, and save your current prompt output.
              </DrawerDescription>
            </DrawerHeader>
            <div className="px-4 pb-6 overflow-auto flex-1">
              <OutputPanel
                builtPrompt={builtPrompt}
                enhancedPrompt={enhancedPrompt}
                reasoningSummary={reasoningSummary}
                isEnhancing={isEnhancing}
                enhancePhase={enhancePhase}
                onEnhance={handleEnhance}
                onSaveVersion={saveVersion}
                onSavePrompt={handleSavePrompt}
                onSaveAndSharePrompt={handleSaveAndSharePrompt}
                canSavePrompt={canSavePrompt}
                canSharePrompt={canSharePrompt}
                phase2Enabled={isBuilderRedesignPhase2}
                enhanceIdleLabel={primaryCtaLabel}
                hideEnhanceButton
                remixContext={
                  remixContext
                    ? { title: remixContext.parentTitle, authorName: remixContext.parentAuthor }
                    : undefined
                }
              />
            </div>
          </DrawerContent>
        </Drawer>
      )}

      {/* Add bottom padding on mobile for sticky bar */}
      {isMobile && <div className="h-44 sm:h-32" />}
    </PageShell>
  );
};

export default Index;
````

## File: src/components/Header.tsx
````typescript
import { useCallback, useEffect, useState, type FormEvent } from "react";
import { Button } from "@/components/base/buttons/button";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/base/primitives/avatar";
import { Dialog, DialogContent, DialogDescription, DialogHeader, DialogTitle } from "@/components/base/dialog";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/base/primitives/alert-dialog";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuSeparator,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuTrigger,
} from "@/components/base/primitives/dropdown-menu";
import { Input } from "@/components/base/input/input";
import { Label } from "@/components/base/label";
import { Popover, PopoverContent, PopoverTrigger } from "@/components/base/primitives/popover";
import { Drawer, DrawerContent, DrawerDescription, DrawerHeader, DrawerTitle } from "@/components/base/drawer";
import { Link, useLocation, useNavigate } from "react-router-dom";
import { useAuth } from "@/hooks/useAuth";
import { useNotifications } from "@/hooks/useNotifications";
import { useToast } from "@/hooks/use-toast";
import { AuthDialog } from "@/components/AuthDialog";
import { NotificationPanel } from "@/components/NotificationPanel";
import { communityFeatureFlags } from "@/lib/feature-flags";
import { APP_ROUTE_NAV_ITEMS, isRouteActive } from "@/lib/navigation";
import { getGravatarUrl } from "@/lib/gravatar";
import { brandCopy } from "@/lib/brand-copy";
import { DISPLAY_NAME_MAX_LENGTH, validateDisplayName } from "@/lib/profile";
import {
  Bell,
  List as Menu,
  Moon,
  SignIn as LogIn,
  SignOut as LogOut,
  SpinnerGap as Loader2,
  Sun,
  Trash as Trash2,
  User,
  Users,
} from "@phosphor-icons/react";

interface HeaderProps {
  isDark: boolean;
  onToggleTheme: () => void;
}

export function Header({ isDark, onToggleTheme }: HeaderProps) {
  const { user, signOut, updateDisplayName, deleteAccount } = useAuth();
  const { toast } = useToast();
  const {
    notifications,
    unreadCount,
    loading: notificationsLoading,
    refresh: refreshNotifications,
    markAsRead: markNotificationAsRead,
    markAllAsRead: markAllNotificationsAsRead,
  } = useNotifications();
  const location = useLocation();
  const navigate = useNavigate();
  const [authOpen, setAuthOpen] = useState(false);
  const [desktopNotificationsOpen, setDesktopNotificationsOpen] = useState(false);
  const [mobileNotificationsOpen, setMobileNotificationsOpen] = useState(false);
  const [gravatarData, setGravatarData] = useState<{ email: string; url: string } | null>(null);
  const [displayNameOpen, setDisplayNameOpen] = useState(false);
  const [displayNameDraft, setDisplayNameDraft] = useState("");
  const [displayNameError, setDisplayNameError] = useState("");
  const [savingDisplayName, setSavingDisplayName] = useState(false);
  const [deleteAccountOpen, setDeleteAccountOpen] = useState(false);
  const [deleteAccountConfirmText, setDeleteAccountConfirmText] = useState("");
  const [deletingAccount, setDeletingAccount] = useState(false);
  const mobileNotificationsEnabled = communityFeatureFlags.communityMobileEnhancements;
  const canDeleteAccount = deleteAccountConfirmText.trim().toUpperCase() === "DELETE";

  const unreadCountLabel = unreadCount > 99 ? "99+" : String(unreadCount);

  const oauthAvatar = user?.user_metadata?.avatar_url as string | undefined;

  useEffect(() => {
    if (oauthAvatar || !user?.email) {
      return;
    }
    let cancelled = false;
    const email = user.email;
    getGravatarUrl(email, 80).then((url) => {
      if (cancelled) return;
      setGravatarData({ email, url });
    });
    return () => { cancelled = true; };
  }, [oauthAvatar, user?.email]);

  const resolvedGravatarUrl =
    user?.email && gravatarData?.email === user.email ? gravatarData.url : null;
  const avatarSrc = oauthAvatar || resolvedGravatarUrl || undefined;

  const metadataDisplayName =
    typeof user?.user_metadata?.display_name === "string"
      ? user.user_metadata.display_name.trim()
      : "";
  const metadataFullName =
    typeof user?.user_metadata?.full_name === "string"
      ? user.user_metadata.full_name.trim()
      : "";
  const initialsSource = metadataDisplayName || metadataFullName || user?.email || "";
  const initials = initialsSource
    ? initialsSource
      .split(" ")
      .map((value) => value.trim())
      .filter(Boolean)
      .map((value) => value[0] || "")
      .join("")
      .slice(0, 2)
      .toUpperCase() || initialsSource[0]?.toUpperCase() || "?"
    : "?";

  const openDisplayNameDialog = () => {
    setDisplayNameDraft(metadataDisplayName);
    setDisplayNameError("");
    setDisplayNameOpen(true);
  };

  const openMobileNotifications = useCallback(() => {
    setMobileNotificationsOpen(true);
    void refreshNotifications();
  }, [refreshNotifications]);

  // Auto-close drawer if viewport crosses sm breakpoint (e.g. device rotation)
  useEffect(() => {
    if (!mobileNotificationsOpen) return;
    const mq = window.matchMedia("(min-width: 640px)");
    const closeIfDesktop = (matches: boolean) => {
      if (matches) setMobileNotificationsOpen(false);
    };
    const handler = (e: MediaQueryListEvent) => closeIfDesktop(e.matches);
    mq.addEventListener("change", handler);
    closeIfDesktop(mq.matches);
    return () => mq.removeEventListener("change", handler);
  }, [mobileNotificationsOpen]);

  const handleDisplayNameSubmit = async (event: FormEvent) => {
    event.preventDefault();
    const normalized = displayNameDraft.trim();
    const validationError = validateDisplayName(normalized);
    if (validationError) {
      setDisplayNameError(validationError);
      return;
    }

    setSavingDisplayName(true);
    const result = await updateDisplayName(normalized);
    setSavingDisplayName(false);
    if (result.error) {
      setDisplayNameError(result.error);
      return;
    }

    setDisplayNameOpen(false);
    setDisplayNameError("");
    toast({ title: "Display name updated" });
  };

  const openDeleteAccountDialog = () => {
    setDeleteAccountConfirmText("");
    setDeleteAccountOpen(true);
  };

  const handleDeleteAccount = async () => {
    if (!canDeleteAccount || deletingAccount) return;
    setDeletingAccount(true);
    const result = await deleteAccount();
    setDeletingAccount(false);
    if (result.error) {
      toast({ title: "Failed to delete account", description: result.error, variant: "destructive" });
      return;
    }
    setDeleteAccountOpen(false);
    setDeleteAccountConfirmText("");
    toast({ title: "Account deleted" });
  };

  return (
    <>
      <header className="pf-nav-header border-b border-border/80 bg-card/75 backdrop-blur-md sticky top-0 z-50">
        <div className="container mx-auto flex items-center justify-between h-12 sm:h-14 px-3 sm:px-4">
          <Link
            to="/"
            className="flex items-center rounded-md focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring"
            aria-label={brandCopy.appName}
          >
            <img
              src="/pf/newlogo.png"
              alt=""
              decoding="async"
              className="h-8 w-auto object-contain sm:h-9"
              aria-hidden="true"
            />
          </Link>

          <nav className="flex items-center gap-0.5 sm:gap-1">
            {user && mobileNotificationsEnabled && (
              <Button
                color="tertiary"
                size="icon"
                aria-label="Open notifications"
                className="interactive-chip relative w-11 h-11 sm:hidden"
                data-testid="mobile-notifications-trigger"
                onClick={openMobileNotifications}
              >
                <Bell className="w-4 h-4" />
                {unreadCount > 0 && (
                  <span className="absolute -right-0.5 -top-0.5 inline-flex min-w-4 items-center justify-center rounded-full bg-destructive px-1 py-0.5 text-xs font-semibold leading-none text-destructive-foreground">
                    {unreadCountLabel}
                  </span>
                )}
              </Button>
            )}
            <DropdownMenu>
              <DropdownMenuTrigger asChild>
                <Button
                  color="tertiary"
                  size="icon"
                  aria-label="Open utilities menu"
                  className="interactive-chip w-11 h-11 sm:hidden"
                >
                  <Menu className="w-4 h-4" />
                </Button>
              </DropdownMenuTrigger>
              <DropdownMenuContent align="end" className="sm:hidden min-w-[220px]">
                <DropdownMenuItem
                  onSelect={(event) => {
                    event.preventDefault();
                    onToggleTheme();
                  }}
                >
                  {isDark ? <Sun className="w-4 h-4 mr-2" /> : <Moon className="w-4 h-4 mr-2" />}
                  {isDark ? "Switch to light mode" : "Switch to dark mode"}
                </DropdownMenuItem>
                <DropdownMenuItem
                  onSelect={(event) => {
                    event.preventDefault();
                    navigate("/community?tab=following");
                  }}
                >
                  <Users className="w-4 h-4 mr-2" />
                  Following
                </DropdownMenuItem>
                <DropdownMenuSeparator />
                {user ? (
                  <>
                    {!mobileNotificationsEnabled && (
                      <>
                        <DropdownMenuSub>
                          <DropdownMenuSubTrigger
                            className="gap-2"
                            data-testid="mobile-notifications-menu-item"
                          >
                            <Bell className="w-4 h-4" />
                            Notifications
                            {unreadCount > 0 && (
                              <span className="ml-auto inline-flex min-w-5 items-center justify-center rounded-full bg-primary px-1.5 py-0.5 text-xs font-semibold leading-none text-primary-foreground">
                                {unreadCountLabel}
                              </span>
                            )}
                          </DropdownMenuSubTrigger>
                          <DropdownMenuSubContent className="border-none bg-transparent p-0 shadow-none">
                            <NotificationPanel
                              notifications={notifications}
                              unreadCount={unreadCount}
                              loading={notificationsLoading}
                              onMarkAsRead={markNotificationAsRead}
                              onMarkAllAsRead={markAllNotificationsAsRead}
                              onRefresh={refreshNotifications}
                              onNavigate={() => setMobileNotificationsOpen(false)}
                            />
                          </DropdownMenuSubContent>
                        </DropdownMenuSub>
                        <DropdownMenuSeparator />
                      </>
                    )}
                    <DropdownMenuItem disabled className="text-xs text-muted-foreground">
                      {user.email}
                    </DropdownMenuItem>
                    <DropdownMenuItem
                      onSelect={(event) => {
                        event.preventDefault();
                        navigate(`/profile/${user.id}`);
                      }}
                    >
                      <User className="w-4 h-4 mr-2" />
                      View profile
                    </DropdownMenuItem>
                    <DropdownMenuItem
                      onSelect={(event) => {
                        event.preventDefault();
                        openDisplayNameDialog();
                      }}
                    >
                      Edit display name
                    </DropdownMenuItem>
                    <DropdownMenuItem
                      className="text-destructive focus:text-destructive"
                      onSelect={(event) => {
                        event.preventDefault();
                        openDeleteAccountDialog();
                      }}
                    >
                      <Trash2 className="w-4 h-4 mr-2" />
                      Delete account
                    </DropdownMenuItem>
                    <DropdownMenuItem
                      onSelect={(event) => {
                        event.preventDefault();
                        void signOut();
                      }}
                    >
                      <LogOut className="w-4 h-4 mr-2" />
                      Sign out
                    </DropdownMenuItem>
                  </>
                ) : (
                  <DropdownMenuItem
                    onSelect={(event) => {
                      event.preventDefault();
                      setAuthOpen(true);
                    }}
                  >
                    <LogIn className="w-4 h-4 mr-2" />
                    Sign in
                  </DropdownMenuItem>
                )}
                <DropdownMenuSeparator />
                <DropdownMenuItem
                  onSelect={(event) => {
                    event.preventDefault();
                    navigate("/privacy");
                  }}
                >
                  Privacy Policy
                </DropdownMenuItem>
                <DropdownMenuItem
                  onSelect={(event) => {
                    event.preventDefault();
                    navigate("/terms");
                  }}
                >
                  Terms of Use
                </DropdownMenuItem>
                <DropdownMenuItem
                  onSelect={(event) => {
                    event.preventDefault();
                    navigate("/contact");
                  }}
                >
                  Contact Support
                </DropdownMenuItem>
              </DropdownMenuContent>
            </DropdownMenu>
            {APP_ROUTE_NAV_ITEMS.map(({ to, label, icon: Icon, ariaLabel }) => (
              <Button
                key={to}
                type="button"
                color={isRouteActive(location.pathname, to) ? "secondary" : "tertiary"}
                size="sm"
                className="pf-nav-button interactive-chip hidden sm:inline-flex gap-1.5 sm:gap-2 h-11 sm:h-9 px-2 sm:px-3"
                aria-label={ariaLabel}
                onClick={() => navigate(to)}
              >
                <Icon className="w-4 h-4" />
                <span className="hidden sm:inline text-sm">{label}</span>
              </Button>
            ))}
            {user && (
              <Popover
                open={desktopNotificationsOpen}
                onOpenChange={(open) => {
                  setDesktopNotificationsOpen(open);
                  if (open) {
                    void refreshNotifications();
                  }
                }}
              >
                <PopoverTrigger asChild>
                  <Button
                    color="tertiary"
                    size="icon"
                    aria-label="Open notifications"
                    className="interactive-chip hidden sm:inline-flex relative w-11 h-11 sm:w-9 sm:h-9"
                  >
                    <Bell className="w-4 h-4" />
                    {unreadCount > 0 && (
                      <span className="absolute -right-0.5 -top-0.5 inline-flex min-w-4 items-center justify-center rounded-full bg-destructive px-1 py-0.5 text-xs font-semibold leading-none text-destructive-foreground">
                        {unreadCountLabel}
                      </span>
                    )}
                  </Button>
                </PopoverTrigger>
                <PopoverContent
                  align="end"
                  sideOffset={8}
                  className="w-auto border-none bg-transparent p-0 shadow-none"
                >
                  <NotificationPanel
                    notifications={notifications}
                    unreadCount={unreadCount}
                    loading={notificationsLoading}
                    onMarkAsRead={markNotificationAsRead}
                    onMarkAllAsRead={markAllNotificationsAsRead}
                    onRefresh={refreshNotifications}
                    onNavigate={() => setDesktopNotificationsOpen(false)}
                  />
                </PopoverContent>
              </Popover>
            )}
            <Button
              color="tertiary"
              size="icon"
              onClick={onToggleTheme}
              aria-label="Toggle theme"
              className="interactive-chip hidden sm:inline-flex w-11 h-11 sm:w-9 sm:h-9"
            >
              {isDark ? <Sun className="w-4 h-4" /> : <Moon className="w-4 h-4" />}
            </Button>

            {user ? (
              <DropdownMenu>
                <DropdownMenuTrigger asChild>
                  <Button
                    color="tertiary"
                    size="icon"
                    aria-label="Open account menu"
                    className="interactive-chip hidden sm:inline-flex w-11 h-11 sm:w-9 sm:h-9 rounded-full p-0"
                  >
                    <Avatar className="w-7 h-7 sm:w-8 sm:h-8">
                      <AvatarImage src={avatarSrc} />
                      <AvatarFallback className="text-xs">{initials}</AvatarFallback>
                    </Avatar>
                  </Button>
                </DropdownMenuTrigger>
                <DropdownMenuContent align="end">
                  <DropdownMenuItem disabled className="text-xs text-muted-foreground">
                    {user.email}
                  </DropdownMenuItem>
                  <DropdownMenuItem onClick={() => navigate(`/profile/${user.id}`)}>
                    <User className="w-4 h-4 mr-2" />
                    View profile
                  </DropdownMenuItem>
                  <DropdownMenuItem onClick={openDisplayNameDialog}>
                    Edit display name
                  </DropdownMenuItem>
                  <DropdownMenuItem
                    className="text-destructive focus:text-destructive"
                    onClick={openDeleteAccountDialog}
                  >
                    <Trash2 className="w-4 h-4 mr-2" />
                    Delete account
                  </DropdownMenuItem>
                  <DropdownMenuItem onClick={() => signOut()}>
                    <LogOut className="w-4 h-4 mr-2" />
                    Sign out
                  </DropdownMenuItem>
                </DropdownMenuContent>
              </DropdownMenu>
            ) : (
              <Button
                color="tertiary"
                size="sm"
                onClick={() => setAuthOpen(true)}
                aria-label="Sign in"
                className="pf-nav-button interactive-chip hidden sm:inline-flex gap-1.5 sm:gap-2 h-11 sm:h-9 px-2 sm:px-3"
              >
                <LogIn className="w-4 h-4" />
                <span className="sr-only sm:not-sr-only sm:inline text-sm">Sign in</span>
              </Button>
            )}
          </nav>
        </div>
      </header>

      {user && mobileNotificationsEnabled && (
        <Drawer
          open={mobileNotificationsOpen}
          onOpenChange={(open) => {
            setMobileNotificationsOpen(open);
            if (open) {
              void refreshNotifications();
            }
          }}
        >
          <DrawerContent
            className="max-h-[82vh] pb-[max(0.75rem,env(safe-area-inset-bottom))] sm:hidden"
            data-testid="mobile-notifications-sheet"
          >
            <DrawerHeader className="pb-1">
              <DrawerTitle className="text-base">Notifications</DrawerTitle>
              <DrawerDescription className="sr-only">
                Community activity updates including comments, upvotes, verifications, and remixes.
              </DrawerDescription>
            </DrawerHeader>
            <div className="px-4 pb-[max(0.75rem,env(safe-area-inset-bottom))]">
              <NotificationPanel
                notifications={notifications}
                unreadCount={unreadCount}
                loading={notificationsLoading}
                onMarkAsRead={markNotificationAsRead}
                onMarkAllAsRead={markAllNotificationsAsRead}
                onRefresh={refreshNotifications}
                onNavigate={() => setMobileNotificationsOpen(false)}
                className="w-full border-none bg-transparent shadow-none"
              />
            </div>
          </DrawerContent>
        </Drawer>
      )}

      <AuthDialog open={authOpen} onOpenChange={setAuthOpen} />
      <Dialog
        open={displayNameOpen}
        onOpenChange={(open) => {
          setDisplayNameOpen(open);
          if (!open) {
            setDisplayNameError("");
          }
        }}
      >
        <DialogContent className="sm:max-w-sm">
          <DialogHeader>
            <DialogTitle>Edit display name</DialogTitle>
            <DialogDescription>
              Update the public name shown on your profile and community posts.
            </DialogDescription>
          </DialogHeader>
          <form className="space-y-3" onSubmit={handleDisplayNameSubmit}>
            <div className="space-y-1.5">
              <Label htmlFor="display-name">Display name</Label>
              <Input
                id="display-name"
                value={displayNameDraft}
                onChange={(event) => {
                  setDisplayNameDraft(event.target.value);
                  if (displayNameError) {
                    setDisplayNameError("");
                  }
                }}
                autoComplete="nickname"
                maxLength={DISPLAY_NAME_MAX_LENGTH}
                placeholder="Letters and numbers only"
                aria-invalid={displayNameError ? true : undefined}
              />
              <p className="text-xs text-muted-foreground">
                Use letters and numbers only. Max {DISPLAY_NAME_MAX_LENGTH} characters.
              </p>
            </div>
            {displayNameError && (
              <p className="text-sm text-destructive">{displayNameError}</p>
            )}
            <div className="flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2">
              <Button
                type="button"
                color="secondary"
                onClick={() => setDisplayNameOpen(false)}
                disabled={savingDisplayName}
              >
                Cancel
              </Button>
              <Button type="submit" disabled={savingDisplayName}>
                {savingDisplayName && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
                Save
              </Button>
            </div>
          </form>
        </DialogContent>
      </Dialog>

      <AlertDialog
        open={deleteAccountOpen}
        onOpenChange={(open) => {
          if (!deletingAccount) {
            setDeleteAccountOpen(open);
            if (!open) {
              setDeleteAccountConfirmText("");
            }
          }
        }}
      >
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Delete account?</AlertDialogTitle>
            <AlertDialogDescription>
              This permanently removes your profile and saved content. Type DELETE to confirm.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <div className="space-y-1.5">
            <Label htmlFor="delete-account-confirm">Type DELETE</Label>
            <Input
              id="delete-account-confirm"
              value={deleteAccountConfirmText}
              onChange={(event) => setDeleteAccountConfirmText(event.target.value)}
              placeholder="DELETE"
              autoComplete="off"
              disabled={deletingAccount}
            />
          </div>
          <AlertDialogFooter>
            <AlertDialogCancel disabled={deletingAccount}>Cancel</AlertDialogCancel>
            <AlertDialogAction
              variant="brandDestructive"
              disabled={!canDeleteAccount || deletingAccount}
              onClick={(event) => {
                event.preventDefault();
                void handleDeleteAccount();
              }}
            >
              {deletingAccount && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
              Delete account
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </>
  );
}
````

## File: package.json
````json
{
  "name": "vite_react_shadcn_ts",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "engines": {
    "node": "^20.19.0 || >=22.12.0"
  },
  "scripts": {
    "dev": "vite",
    "agent:codex": "dotenv -- node agent_service/codex_service.mjs",
    "build": "vite build",
    "build:dev": "vite build --mode development",
    "lint": "eslint .",
    "check:no-legacy-ui-imports": "node scripts/check-no-legacy-ui-imports.mjs",
    "check:no-legacy-ds-props": "node scripts/check-no-legacy-ds-props.mjs",
    "check:no-primitive-ds-imports": "node scripts/check-no-primitive-ds-imports.mjs",
    "check:no-new-phosphor-imports": "node scripts/check-no-new-phosphor-imports.mjs",
    "check:token-runtime": "node scripts/check-token-runtime-drift.mjs",
    "check:design-system": "npm run build && npm run check:token-runtime && npm run check:no-legacy-ui-imports && npm run check:no-legacy-ds-props && STRICT_PRIMITIVE_IMPORTS=1 npm run check:no-primitive-ds-imports && npm run check:no-new-phosphor-imports",
    "check:prod": "npm run check:no-legacy-ui-imports && npm run check:no-legacy-ds-props && STRICT_PRIMITIVE_IMPORTS=1 npm run check:no-primitive-ds-imports && npm run check:no-new-phosphor-imports && npm run lint && npm run test:unit && npm run build && npm run check:token-runtime",
    "preview": "vite preview",
    "swa:init": "swa init",
    "swa:start": "swa start",
    "swa:build": "swa build",
    "swa:deploy:dry-run": "swa deploy --env production --dry-run",
    "swa:deploy": "swa deploy --env production",
    "test": "vitest run",
    "test:unit": "vitest run --exclude 'src/test/rls-community-*.test.ts'",
    "test:mobile": "playwright test",
    "test:mobile:headed": "playwright test --headed",
    "test:rls": "dotenv -- vitest run src/test/rls-community-*.test.ts",
    "test:watch": "vitest"
  },
  "dependencies": {
    "@hookform/resolvers": "^3.10.0",
    "@neondatabase/neon-js": "^0.2.0-beta.1",
    "@openai/codex-sdk": "^0.104.0",
    "@phosphor-icons/react": "^2.1.10",
    "@radix-ui/react-accordion": "^1.2.12",
    "@radix-ui/react-alert-dialog": "^1.1.15",
    "@radix-ui/react-aspect-ratio": "^1.1.8",
    "@radix-ui/react-avatar": "^1.1.11",
    "@radix-ui/react-checkbox": "^1.3.3",
    "@radix-ui/react-collapsible": "^1.1.12",
    "@radix-ui/react-context-menu": "^2.2.16",
    "@radix-ui/react-dialog": "^1.1.15",
    "@radix-ui/react-dropdown-menu": "^2.1.16",
    "@radix-ui/react-hover-card": "^1.1.15",
    "@radix-ui/react-label": "^2.1.8",
    "@radix-ui/react-menubar": "^1.1.16",
    "@radix-ui/react-navigation-menu": "^1.2.14",
    "@radix-ui/react-popover": "^1.1.15",
    "@radix-ui/react-progress": "^1.1.8",
    "@radix-ui/react-radio-group": "^1.3.8",
    "@radix-ui/react-scroll-area": "^1.2.10",
    "@radix-ui/react-select": "^2.2.6",
    "@radix-ui/react-separator": "^1.1.8",
    "@radix-ui/react-slider": "^1.3.6",
    "@radix-ui/react-slot": "^1.2.4",
    "@radix-ui/react-switch": "^1.2.6",
    "@radix-ui/react-tabs": "^1.1.13",
    "@radix-ui/react-toast": "^1.2.15",
    "@radix-ui/react-toggle": "^1.1.10",
    "@radix-ui/react-toggle-group": "^1.1.11",
    "@radix-ui/react-tooltip": "^1.2.8",
    "@react-stately/utils": "^3.11.0",
    "@tanstack/react-query": "^5.83.0",
    "@tanstack/react-virtual": "^3.13.18",
    "@testing-library/dom": "^10.4.1",
    "baseline-browser-mapping": "^2.9.19",
    "caniuse-lite": "^1.0.30001769",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "cmdk": "^1.1.1",
    "date-fns": "^3.0.0",
    "embla-carousel-react": "^8.6.0",
    "input-otp": "^1.4.2",
    "jose": "^6.1.3",
    "next-themes": "^0.4.6",
    "react": "^19.2.4",
    "react-aria": "^3.46.0",
    "react-aria-components": "^1.15.1",
    "react-day-picker": "^9.13.2",
    "react-dom": "^19.2.4",
    "react-hook-form": "^7.71.1",
    "react-markdown": "^10.1.0",
    "react-resizable-panels": "^2.1.9",
    "react-router-dom": "^6.30.3",
    "recharts": "^2.15.4",
    "remark-gfm": "^4.0.1",
    "repomix": "^1.11.1",
    "smol-toml": "^1.6.0",
    "sonner": "^2.0.7",
    "tailwind-merge": "^3.5.0",
    "tailwindcss-animate": "^1.0.7",
    "tailwindcss-react-aria-components": "^2.0.1",
    "vaul": "^1.1.2",
    "ws": "^8.19.0",
    "zod": "^3.25.76"
  },
  "devDependencies": {
    "@azure/static-web-apps-cli": "^2.0.8",
    "@eslint/js": "^9.32.0",
    "@playwright/test": "^1.58.2",
    "@tailwindcss/postcss": "^4.2.0",
    "@tailwindcss/typography": "^0.5.19",
    "@tailwindcss/vite": "^4.2.0",
    "@testing-library/jest-dom": "^6.6.0",
    "@testing-library/react": "^16.0.0",
    "@types/node": "^25.3.0",
    "@types/react": "^19.2.14",
    "@types/react-dom": "^19.2.3",
    "@vitejs/plugin-react-swc": "^4.2.3",
    "autoprefixer": "^10.4.21",
    "axe-core": "^4.11.1",
    "dotenv-cli": "^11.0.0",
    "eslint": "^9.39.2",
    "eslint-plugin-react-hooks": "^5.2.0",
    "eslint-plugin-react-refresh": "^0.4.26",
    "globals": "^15.15.0",
    "jsdom": "^28.1.0",
    "lovable-tagger": "^1.1.13",
    "postcss": "^8.5.6",
    "tailwindcss": "^4.2.0",
    "typescript": "^5.9.3",
    "typescript-eslint": "^8.55.0",
    "vite": "^7.3.1",
    "vitest": "^4.0.18",
    "vitest-axe": "^0.1.0"
  }
}
````
